

--NOTE WHEN UPDATING SQL 2005 MANY OF THE OBJECTS CREATED HERE WILL NOT WORK, THIS VERSION WORKS ON 2008 R2 AND GREATED
--ON OLDER YOU MAY NEED TO MANUALLY OVERRIDE THE LICENSE CHECK FUNCTIO NWITH THE CODE BELOW, JUST CHANGE THE DATE
/*
alter function Licensing.fn_ValidateLicense() returns @Lic table(IsValid bit, LicensingExpirationDate dateTIME)
--WITH ENCRYPTION
as
begin
    insert into @Lic(IsValid, LicensingExpirationDate)
    SELECT  1, CAST('2019-07-04' AS dateTIME)
    

    return
end
*/

/****************************************************************************************************
 FORTIFIED DATA DBA DATABASE SETUP AND PROCEDURES USED BY US
 Created: 4/1/2015
	By: Keith Buck
Purpose: Used to set up FDDBA database
****************************************************************************************************
		VERSION HISTORY - Please put version informtaion in here and update it below in PROC FDDBA_Get_Version
****************************************************************************************************
11/30/2018 ver: 1.2.0000 Keith Buck
	--Updated many procs to call the validate licensing procedure
	--Updated sp_whoisActive to v11.32, Added Proc dbo.pGet_AvailabilityGroupInfo
	--adding compression to table WaitStatistics
	--Fixed bug when inserting intial row into fddba_config2 table '@OnCleanRecipients=Null' was changed to remove the null as it causes errors.
	--validation report: Fixed bug with SQL Express showing SQL Agent as not running, also added SQL Version to report
	--Fixed bug in pWaitStatistics_delete, it now works and added logging and batching.
	--commented out lines 27798 and 27799 so it does not execute the procedure pMigrateTraceFlags to updatea trace flags settings in the database


12/26/2018  ver 1.2.01 Keith Buck
	--BackupException_AG: Added @DebugOverride parameter. Updated comments header and changed parameter delimters for@NamesList and @InstanceNames list as the move to have them all in one entry in a table 
		causes a parsing issue. Full changes documented in procedure header
	-- BackupException fixed a bug where it only ran the code to get db list excluding those in an AG if version was 12 or higher, but it should have been version 11.
	-- Procedure pGet_AvailabilityGroupInfo, added in listener name and changed proc name from pGet_AvailabilityGroupInfo to pGetAvailabilityGroupInfo
	--Procedure BackupException, fixed issue with Log Backup validation having issues if there was an old backup done with Copy Only, it would not recognize the newer ones and report it as missing
	-- Backup Exclusion fix, added columns to table BackupReportExclusion for excluding specific types of backups, Full log or Diff
	--table Licensing.LicensingKey changed data type from datetime(2) to datetime and updated insert statetment to use getdate() for backward compatibility.
	
	
	2019-01-17 Keith Buck : Proc pStartUpValidation: changed select for  getting @sname  to use server property if @@servername is null
							Proc pDatabaseRefresh - Added @DriverName so we could specify what provider to use in the OPENROWSET call.
	2019-01-21	Keith Buck: Added table for Benign WaitStats		


2/5/2019 VER 1.2.02		Keith Buck
	Added proc Process_Monitor_Adhoc_Purge
	procedure Process_Monitor_Adhoc, Added optional parameter for capturing plan, defaulted to off, to save space
	Created view vWaitStats_Benign, this will be created once and never updated so customized versions of the view will not be overwritten
	procedure BackupException - changed param DebugIOverride to default of 0, updated device type to split on caret ^, updated db select list to exclude Log Shipped standbys is_in_standby=1
	procedure usp_UpdateVersionStatics -  added with Encryption
	Licensing.fn_ValidateLicense - added date return to license function

3/8/2019 VER 1.2.03
	Added Proc pCurrentActivity
	Did a slight update to BackupException proc to trim the values read from the exclusion table when joining them to the backups
	updated pMigrateTraceFlag to keep it from overwriting existing trace flags and suggested trace flags column. Will  throw an error/warning but not change the actual trace_flags row.

03/13/2019  VER 1.2.04
	*Keith Buck  - 	Updated insert into mon.dm_exec_query_memory_grants to use expicit column names as new columns added in 2017  --usp_Load_Process_Monitor_Adhoc
		-- Fixed bugs in backup exception AG	
		
05/20/2019	VER 1.2.05
		--Fixed issue with SQL 2005 for Creation of table Infra.Numbers. May need to fix issues with Infra.fnSplit not being created in 2005
		-- updated code in Licensing.fnValidateLicense to work with 2005
		-- pCPU_Insert added an error handler for trouble shotting purposes, had to create a seperate version for 2008R2 and earlier as THROW not available
		-- pRefreshDatabase -Updated to check for differenital backups too
		-- Updated job update for FD - Backup Validation to not update it if the AG Replica Check is already there.
		-- Updated proc pWaitStats_Report, added section to update waitstattype CanIgnore column based on data in the WaitStats_Benign table
		-- Added removal of CXCONSUMER from WaitStats_Benign table
		* Adi Cohen -- Changed deadlock collection frequency from 10 to 90 minutes as it's a heavy process
		-- Updated pPerfExecRequests added more parameters to reduce the data coming back
		
		-- added procedures 
			dbo.pGetRestoreInfo	
			dbo.pStatistics2014Plus
			dbo.pGetServiceAccounts
			dbo.pGetResotoreInfo
			dbo.pGetIndexCompressionEstimate
			dbo.pGetBackupHistory
			dbo.pPerfWhatsRunning  : This is Adi's Whats Running Query
			dbo.pGetIndexUsageDetail
			dbo.pGetIndexInformation

00/00/2019  ver 1.2.06
		FIXES:
			dbo.BackupException_AG: 6/6/2019 Keith BUck - Fixed bug, email profile was hard coded, change to accept paramter @EmailProfile.
			Licensing.LicensingKey updated to 3rd quarter date
			Reomved all code in section with title "TEMPORARY FIX SECTION "



		ADDITIONS:
			Views
				vAgentjob_history  : view on top of table agentjob_history

			Jobs:
				FD - Monitor Agent Job History				:job will be installed and active but schedule is disabled
				FD - Monitor Agent Job History Purge		:job will be installed and active but no schedule created

****************************************************************************************************/


USE master
SET NOCOUNT ON
IF OBJECT_ID('tempdb..#FDVER') IS NOT NULL
	DROP TABLE #FDVER
CREATE TABLE #FDVER (VerDec	DECIMAL(18,2) NOT NULL)
INSERT INTO #FDVER(VerDec)
select Ver1
	from (select cast(serverproperty('ProductVersion') as varchar(100)) Ver) s
		cross apply (select cast(parsename(Ver, 4) + '.' + parsename(Ver, 3) as decimal(10, 2)) Ver1) v

declare @bintest	tinyint
set @bintest = 0 --for case sensitivity testing, default should be 0, this will cause three 468 errors on 2 stored procedures

DECLARE @DefaultDestDataLoc		VARCHAR(256)
		,@DefaultDestLogLoc		VARCHAR(256)
		,@NewestDB				SYSNAME

IF (select VerDec from #FDVER) >= 11
BEGIN 
	SELECT @DefaultDestDataLoc = CAST(SERVERPROPERTY('InstanceDefaultDataPath') AS VARCHAR(256)), 
		@DefaultDestLogLoc = CAST(SERVERPROPERTY('InstanceDefaultLogPath') AS VARCHAR(256))
END
ELSE
BEGIN
	exec master.dbo.xp_instance_regread
		N'HKEY_LOCAL_MACHINE',
		N'Software\Microsoft\MSSQLServer\MSSQLServer',
		N'DefaultData', 
		@DefaultDestDataLoc output

	exec master.dbo.xp_instance_regread
		N'HKEY_LOCAL_MACHINE',
		N'Software\Microsoft\MSSQLServer\MSSQLServer',
		N'DefaultLog', 
		@DefaultDestLogLoc output
END

--If we still do not have it, get it from model
IF @DefaultDestDataLoc IS NULL
BEGIN  -- get the location of MODEL
	SELECT 
		@DefaultDestDataLoc = left(physical_name,(len(physical_name)-(charindex('\',REVERSE(physical_name)))+1))
	FROM 
		sys.master_files mf 
	where 
		DB_NAME(mf.database_id) = 'model'
		AND type_desc = 'ROWS'
END
IF @DefaultDestLogLoc IS NULL
BEGIN
	SELECT 
		@DefaultDestLogLoc = left(physical_name,(len(physical_name)-(charindex('\',REVERSE(physical_name)))+1))
		FROM 
		sys.master_files mf 
		WHERE DB_NAME(mf.database_id) = 'model'
		AND type_desc = 'LOG'
END
SELECT @DefaultDestDataLoc AS '@DefaultDestDataLoc', @DefaultDestLogLoc AS '@DefaultDestLogLoc'
RAISERROR ('',10,1) WITH NOWAIT;
RAISERROR ('	------------ FDDBA Database and Object Creation ---------------',10,1) WITH NOWAIT;

IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = N'FDDBA')
BEGIN
	-- Be sure we have a trailing backslash
	IF SUBSTRING(@DefaultDestDataLoc, LEN(@DefaultDestDataLoc),1) != '\'
		SET @DefaultDestDataLoc = @DefaultDestDataLoc +'\'
	IF SUBSTRING(@DefaultDestLogLoc, LEN(@DefaultDestLogLoc),1) != '\'
		SET @DefaultDestLogLoc = @DefaultDestLogLoc +'\'

	RAISERROR ('CREATING DATABASE [FDDBA]',10,1) WITH NOWAIT;
	--CREATE DATABASE [FDDBA];
	DECLARE @datafile1		VARCHAR(256)
	DECLARE @datafile2		VARCHAR(256)
	DECLARE @logfile		VARCHAR(256)
	DECLARE @sql			NVARCHAR(MAX)

	SET @datafile1 = @DefaultDestDataLoc + 'FDDBA_01.mdf'
	SET @datafile2 = @DefaultDestDataLoc + 'FDDBA_02.ndf'
	SET @logfile = @DefaultDestLogLoc + 'FDDBA.ldf'

	SELECT @sql = N'CREATE DATABASE [FDDBA]
	 ON  PRIMARY 
	( NAME = N''FDDBA_01'', FILENAME = ''' + @datafile1 + N''', SIZE = 524288KB , FILEGROWTH = 262144KB ),
	( NAME = N''FDDBA_02'', FILENAME = ''' + @datafile2 + N''', SIZE = 524288KB , FILEGROWTH = 262144KB )
	 LOG ON 
	( NAME = N''FDDBA_log'', FILENAME = ''' + @logfile +  N''', SIZE = 524288KB , FILEGROWTH = 524288KB)'

	IF @bintest = 1
	BEGIN
		SET @sql = @sql + N' COLLATE SQL_Latin1_General_CP850_BIN'
	END

	RAISERROR( 'Here is the create statment for FDDBA database.',10,1) WITH NOWAIT;
	RAISERROR( @sql,10,1) WITH NOWAIT;
	RAISERROR( '',10,1) WITH NOWAIT;
	RAISERROR( '',10,1) WITH NOWAIT;
	execute sp_executesql  @sql;
	ALTER DATABASE [FDDBA] SET RECOVERY SIMPLE;
end
IF NOT EXISTS(Select 1 from sys.databases where name = 'FDDBA')
BEGIN
	RAISERROR('FDDBA does not exist, exiting script, please fix and run again.',20,1) with LOG
	RETURN
END
GO
use FDDBA


/****************************************************************************************************
JOB SETUP SECTION. INPUT EVERY JOB IN THIS SCRIPT INTO THE TEMP TABLE WITH A DEFAULT INSTALL VALUE
AND ADJUST THE INSTALL BIT FOR EACH RUN TO INCLUDE OR EXCLUDE JOBS YOU WANT CREATED
****************************************************************************************************/
IF OBJECT_ID('tempdb..#joblist') IS NOT NULL
	DROP TABLE #joblist 
CREATE TABLE #joblist (JobName sysname, Install bit, IsEnabled bit)

IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Gather Database Size Information')	
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
		VALUES(N'FD - Gather Database Size Information', 1, 1)
END
---IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Capture Perfmon Data')
--changed this job to be created when run as there is an update to it. Adding code to drop the job if it exists and does not have the SCHEDULER ste
IF EXISTS(SELECT TOP 1 1 FROM msdb.dbo.sysjobs j WHERE j.name = N'FD - Capture Perfmon Data')
BEGIN
	IF NOT EXISTS(SELECT TOP 1 1 FROM msdb.dbo.sysjobs j INNER JOIN msdb.dbo.sysjobsteps s on j.job_id = s.job_id  WHERE name = N'FD - Capture Perfmon Data' AND s.step_name = N'Check Scheduler Pressure')
	BEGIN
		BEGIN TRY
			RAISERROR('Attempting to drop job ''FD - Capture Perfmon Data''',10,1) WITH NOWAIT;
			exec msdb.dbo.sp_delete_job @job_name =N'FD - Capture Perfmon Data'
		END TRY
		BEGIN CATCH
			DECLARE @msg VARCHAR(2048)
			SELECT @msg = 'Failed to delete job FD - Capture Perfmon Data. Error IS: ' + ERROR_MESSAGE()
			RAISERROR(@msg,10,1) WITH NOWAIT;
		END CATCH
	END
END
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
		VALUES(N'FD - Capture Perfmon Data', 1,1)
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Gather File IO Stats')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
		VALUES(N'FD - Gather File IO Stats', 1,1)
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - WhoIsActive Purge')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - WhoIsActive Purge', 1,1)
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - WhoIsActive Load')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - WhoIsActive Load', 1,0)
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Gather Configuration Settings')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Gather Configuration Settings', 1,1)
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Process_Monitor - Capture Active Running Processes')
BEGIN
	--THIS JOB NEEDS TO ALWAYS BE ENABLED OR ELSE THE CALL TO IT FROM Agent Alerts will fail, the code will enable this anyway regardless of the IsEnabled parameter
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Process_Monitor - Capture Active Running Processes', 1,1)
END

IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Process_Monitor_Adhoc Purge')
BEGIN --REGARDLESS OF THIS ENTRY THIS JOB WILL ALWAYS BE CREATED AND ENABLED
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Process_Monitor_Adhoc Purge', 1,1)
END


IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Gather Index Usage Stats')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Gather Index Usage Stats', 1,1)
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Monitor Statistics')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Monitor Statistics', 1,0) --yes should be disabled to start as setting up tracking will enable
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Monitor Plan Statistics')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Monitor Plan Statistics', 1,0) --yes should be disabled to start as setting up tracking will enable
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Monitor Plan Results')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Monitor Plan Results', 1,0) --yes should be disabled to start as setting up tracking will enable
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - GatherWaitStatistics')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - GatherWaitStatistics', 1,1) 
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Monitor Statistics')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - FD - Monitor Statistics', 1,0) 
END


IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - ExecRequest Load')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - ExecRequest Load', 1,0) 
END

IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - ExecRequestes Purge')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - ExecRequestes Purge', 1,1) 
END

IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Backup Validation')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Backup Validation', 1,0) 
END
IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Run Operations')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Run Operations', 1,1)
END

IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Monitor Agent Job History')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Monitor Agent Job History', 1,0)
END

IF NOT EXISTS(SELECT 1 from msdb.dbo.sysjobs WHERE name = N'FD - Monitor Agent Job History Purge')
BEGIN
	INSERT INTO #joblist(JobName, Install, IsEnabled)
	VALUES(N'FD - Monitor Agent Job History Purge', 1,0)
END

--RUN THIS UPDATE TO ENSURE ALL THE OLD JOBS ARE NOT DELETED
--THIS IS EASIER THAT UPDATING INSTALL TO 0 FOR THE ABOVE JOBS
--UPDATE #joblist set Install = 0;

--INSERT INTO #joblist(JobName, Install, IsEnabled)
--VALUES(N'InsertNameHere', 0,0)
--INSERT INTO #joblist(JobName, Install, IsEnabled)
--VALUES(N'InsertNameHere', 0,0)
--INSERT INTO #joblist(JobName, Install, IsEnabled)
--VALUES(N'InsertNameHere', 0,0)
--------------  END OF JOB SETUP SECTION	----------------------------------------------------------
/****************************************************************************************************
	GET THE CURRENT VERSION OF SQL AND STORE IT IN A TEMP TABLE FOR USE BY VARIOUS PARTS OF THIS SCRIPT
****************************************************************************************************/
if cast(serverproperty('ProductMajorVersion') as int) < 10
begin
	update #joblist set Install =0, IsEnabled = 0
end


--this code is used to determine if initial install or upgrade and needs to preceed creation of dbo.FDDBA_Get_Version stored procedure
IF OBJECT_ID('tempdb..#fddba_version') IS NOT NULL
	DROP TABLE #fddba_version
GO
CREATE TABLE #fddba_version (a varchar(20) NULL)
GO
IF OBJECT_ID('tempdb..#fddba_script_time') IS NOT NULL
	DROP TABLE #fddba_script_time
GO
CREATE TABLE #fddba_script_time (ldt datetime NOT NULL, utcdt datetime NOT NULL)
GO
INSERT #fddba_script_time VALUES (GETDATE(), GETUTCDATE())
GO
IF OBJECT_ID(N'[dbo].[FDDBA_Get_Version]', 'P') IS NOT NULL
BEGIN
	DECLARE @err int
	DECLARE @sev int
	DECLARE @state int
	DECLARE @msg varchar(200)
	BEGIN TRY
		INSERT #fddba_version EXEC ('exec dbo.FDDBA_Get_Version')
	END TRY
	BEGIN CATCH
		SET @err = ERROR_NUMBER()
		SET @sev = ERROR_SEVERITY()
		SET @state = ERROR_STATE()
		SET @msg = ERROR_MESSAGE()
		IF @err != 201 
		BEGIN
			RAISERROR(@err, @sev, @state)
			PRINT 'Original Message=' + @msg
		END
		--(error= 201) ignore case of new version of FDDBA_Get_Version which uses output parameter as work below would already be done in prior upgrade
	END CATCH
END
GO
IF OBJECT_ID('dbo.config_fddba2','U') IS NOT NULL
BEGIN
	DECLARE @utcdt datetime
	DECLARE @ldt datetime
	DECLARE @dbdt datetime
	DECLARE @version varchar(20)
	DECLARE @upgrade_count int = 0
	DECLARE @offset_minutes int 
	DECLARE @minutes int 
	SELECT @ldt = ldt, @utcdt = utcdt FROM #fddba_script_time
	SELECT TOP 1 @version = a FROM #fddba_version

	IF @version IS NOT NULL
	BEGIN
		SELECT @dbdt = create_date FROM sys.databases WHERE database_id = DB_ID()
		SET @offset_minutes = DATEDIFF(MINUTE, @ldt, @utcdt) * -1

		--update any old
		DECLARE fddba_setup_old_cur CURSOR FOR
			SELECT [domain] FROM dbo.config_fddba2 WHERE [name] = 'fddba setup'  ORDER BY CreatedOn
		OPEN fddba_setup_old_cur
		FETCH NEXT FROM fddba_setup_old_cur INTO @utcdt

		WHILE @@FETCH_STATUS != -1
		BEGIN
			IF @upgrade_count = 0 AND ABS(DATEDIFF(MINUTE, DATEADD(MINUTE, @offset_minutes, @utcdt), @dbdt)) < 61
			BEGIN
				--possible with 1.1.0045 thru 1.1.0057
				UPDATE dbo.config_fddba2
					SET [name] = 'fddba\setup'
					WHERE [name] = 'fddba setup' AND [domain] = CONVERT(VARCHAR(23), @utcdt, 126)
			END
			ELSE
			BEGIN
				SET @upgrade_count = @upgrade_count + 1

				UPDATE dbo.config_fddba2
					SET [name] = 'fddba\upgrade\' + LTRIM(STR(@upgrade_count))
					WHERE [name] = 'fddba setup' AND [domain] = CONVERT(VARCHAR(23), @utcdt, 126)
			END
			FETCH NEXT FROM fddba_setup_old_cur INTO @utcdt
		END
		DEALLOCATE fddba_setup_old_cur
	END
END
GO


if schema_id('Auditing') is null
begin
RAISERROR('	CREATING schema [Auditing].',10,1) WITH NOWAIT
exec('CREATE SCHEMA [Auditing]')
end
else
RAISERROR('	Schema [Auditing] already exists, skipping add.',10,1) WITH NOWAIT
GO


if schema_id('Infra') is null
begin
RAISERROR('	CREATING schema [Infra].',10,1) WITH NOWAIT
exec('CREATE SCHEMA [Infra]')
end
else
RAISERROR('	Schema [Infra] already exists, skipping add.',10,1) WITH NOWAIT
GO


if schema_id('Licensing') is null
begin
RAISERROR('	CREATING schema [Licensing].',10,1) WITH NOWAIT
exec('CREATE SCHEMA [Licensing]')
end
else
RAISERROR('	Schema [Licensing] already exists, skipping add.',10,1) WITH NOWAIT
GO


if schema_id('mon') is null
begin
RAISERROR('	CREATING schema [mon].',10,1) WITH NOWAIT
exec('CREATE SCHEMA [mon]')
end
else
RAISERROR('	Schema [mon] already exists, skipping add.',10,1) WITH NOWAIT
GO


if schema_id('Monitoring') is null
begin
RAISERROR('	CREATING schema [Monitoring].',10,1) WITH NOWAIT
exec('CREATE SCHEMA [Monitoring]')
end
else
RAISERROR('	Schema [Monitoring] already exists, skipping add.',10,1) WITH NOWAIT
GO


if schema_id('OpsControl') is null
begin
RAISERROR('	CREATING schema [OpsControl].',10,1) WITH NOWAIT
exec('CREATE SCHEMA [OpsControl]')
end
else
RAISERROR('	Schema [OpsControl] already exists, skipping add.',10,1) WITH NOWAIT
GO


if schema_id('perf') is null
begin
RAISERROR('	CREATING schema [perf].',10,1) WITH NOWAIT
exec('CREATE SCHEMA [perf]')
end
else
RAISERROR('	Schema [perf] already exists, skipping add.',10,1) WITH NOWAIT
GO


if object_id('dbo.exec_plan_tracked') is null
begin
RAISERROR('	CREATING table [dbo].[exec_plan_tracked]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[exec_plan_tracked](
	[exec_plan_tracked_ID] [int] IDENTITY(1,1) NOT NULL,
	[runtime] [datetime] NOT NULL,
	[plan_handle] [varbinary](64) NOT NULL,
	[len_query_plan] [int] NOT NULL,
	[query_plan] [xml] NULL,
 CONSTRAINT [exec_plan_tracked_PK] PRIMARY KEY CLUSTERED 
(
	[exec_plan_tracked_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [exec_plan_tracked_UC] UNIQUE NONCLUSTERED 
(
	[plan_handle] ASC,
	[len_query_plan] ASC,
	[runtime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[exec_plan_tracked] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Auditing.AuditSessions') is null
begin
RAISERROR('	CREATING table [Auditing].[AuditSessions]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Auditing].[AuditSessions](
	[ASE_ID] [int] IDENTITY(1,1) NOT NULL,
	[ASE_AUT_ID] [int] NOT NULL,
	[ASE_StoragePath] [varchar](1000) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[ASE_IsActive] [bit] NOT NULL,
 CONSTRAINT [PK_AuditSessions] PRIMARY KEY CLUSTERED 
(
	[ASE_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 CREATE UNIQUE NONCLUSTERED INDEX [IX_AuditSessions_ASE_AUT_ID] ON [Auditing].[AuditSessions]
(
	[ASE_AUT_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Auditing].[AuditSessions] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Auditing.AuditTemplateEvents') is null
begin
RAISERROR('	CREATING table [Auditing].[AuditTemplateEvents]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Auditing].[AuditTemplateEvents](
	[ATE_ID] [int] IDENTITY(1,1) NOT NULL,
	[ATE_AUT_ID] [int] NOT NULL,
	[ATE_AET_ID] [int] NOT NULL,
	[ATE_Description] [varchar](200) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[ATE_AddedColumns] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[ATE_Filter] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[ATE_IsActive] [bit] NOT NULL,
 CONSTRAINT [PK_AuditTemplateEvents] PRIMARY KEY CLUSTERED 
(
	[ATE_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 CREATE UNIQUE NONCLUSTERED INDEX [IX_AuditTemplateEvents_ATE_AUT_ID#ATE_AET_ID#ATE_Description] ON [Auditing].[AuditTemplateEvents]
(
	[ATE_AUT_ID] ASC,
	[ATE_AET_ID] ASC,
	[ATE_Description] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Auditing].[AuditTemplateEvents] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Auditing.AuditTemplates') is null
begin
RAISERROR('	CREATING table [Auditing].[AuditTemplates]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Auditing].[AuditTemplates](
	[AUT_ID] [int] NOT NULL,
	[AUT_Name] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [PK_AuditTemplates] PRIMARY KEY CLUSTERED 
(
	[AUT_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 SET ANSI_PADDING ON
 CREATE UNIQUE NONCLUSTERED INDEX [IX_AuditTemplates_AUT_Name] ON [Auditing].[AuditTemplates]
(
	[AUT_Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Auditing].[AuditTemplates] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Auditing.AuditTrail') is null
begin
RAISERROR('	CREATING table [Auditing].[AuditTrail]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Auditing].[AuditTrail](
	[ATL_ID] [int] IDENTITY(1,1) NOT NULL,
	[ATL_ASE_ID] [int] NOT NULL,
	[ATL_AES_ID] [tinyint] NOT NULL,
	[ATL_ImportDateTime] [datetime2](3) NOT NULL,
	[ATL_EventDateTime] [datetime2](3) NOT NULL,
	[ATL_EventType_AVM_ID] [int] NULL,
	[ATL_ServerInstanceName_AVM_ID] [int] NULL,
	[ATL_ObjectType_AVM_ID] [int] NULL,
	[ATL_ObjectName] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[ATL_DatabaseName_AVM_ID] [int] NULL,
	[ATL_IndexID] [int] NULL,
	[ATL_PermissionBitmask] [varbinary](16) NULL,
	[ATL_Succeeded] [bit] NULL,
	[ATL_SessionID] [int] NULL,
	[ATL_ServerLoginName_AVM_ID] [int] NULL,
	[ATL_SessionLoginName_AVM_ID] [int] NULL,
	[ATL_Username_AVM_ID] [int] NULL,
	[ATL_HostName_AVM_ID] [int] NULL,
	[ATL_ApplicationName_AVM_ID] [int] NULL,
	[ATL_IsSystem] [bit] NULL,
	[ATL_SQLStatement] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[ATL_AdditionalInformation] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[ATL_DurationMS] [bigint] NULL,
 CONSTRAINT [PK_AuditTrail] PRIMARY KEY NONCLUSTERED 
(
	[ATL_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 CREATE UNIQUE CLUSTERED INDEX [IX_AuditTrail_ATL_EventDateTime#ATL_ASE_ID#ATL_ID] ON [Auditing].[AuditTrail]
(
	[ATL_EventDateTime] ASC,
	[ATL_ASE_ID] ASC,
	[ATL_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ALTER TABLE [Auditing].[AuditTrail] ADD  CONSTRAINT [DF_AuditTrail_ATL_InsertDate]  DEFAULT (sysdatetime()) FOR [ATL_ImportDateTime]
end
else
RAISERROR ('	Table [Auditing].[AuditTrail] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Auditing.AuditTrailValueMap') is null
begin
RAISERROR('	CREATING table [Auditing].[AuditTrailValueMap]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Auditing].[AuditTrailValueMap](
	[AVM_ID] [int] IDENTITY(1,1) NOT NULL,
	[AVM_AVT_ID] [tinyint] NOT NULL,
	[AVM_Name] [nvarchar](255) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [PK_AuditTrailEventTypes] PRIMARY KEY CLUSTERED 
(
	[AVM_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 SET ANSI_PADDING ON
 CREATE UNIQUE NONCLUSTERED INDEX [IX_AuditTrailValueMap_AVM_AVT_ID#AVM_Name] ON [Auditing].[AuditTrailValueMap]
(
	[AVM_AVT_ID] ASC,
	[AVM_Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Auditing].[AuditTrailValueMap] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Auditing.AuditTrailValueTypes') is null
begin
RAISERROR('	CREATING table [Auditing].[AuditTrailValueTypes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Auditing].[AuditTrailValueTypes](
	[AVT_ID] [tinyint] NOT NULL,
	[AVT_Name] [varchar](255) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [PK_AuditTrailValueTypes] PRIMARY KEY CLUSTERED 
(
	[AVT_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 CREATE UNIQUE NONCLUSTERED INDEX [IX_AuditTrailValueTypes_AVT_Name] ON [Auditing].[AuditTrailValueTypes]
(
	[AVT_Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Auditing].[AuditTrailValueTypes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Auditing.EventSourceTypes') is null
begin
RAISERROR('	CREATING table [Auditing].[EventSourceTypes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Auditing].[EventSourceTypes](
	[AES_ID] [tinyint] NOT NULL,
	[AES_Name] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [PK_EventSourceTypes] PRIMARY KEY CLUSTERED 
(
	[AES_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [Auditing].[EventSourceTypes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Auditing.EventTypes') is null
begin
RAISERROR('	CREATING table [Auditing].[EventTypes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Auditing].[EventTypes](
	[AET_ID] [int] NOT NULL,
	[AET_AES_ID] [int] NOT NULL,
	[AET_Name] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [PK_EventTypes] PRIMARY KEY CLUSTERED 
(
	[AET_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 SET ANSI_PADDING ON
 CREATE UNIQUE NONCLUSTERED INDEX [IX_EventTypes_AET_AES_ID#AET_Name] ON [Auditing].[EventTypes]
(
	[AET_AES_ID] ASC,
	[AET_Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Auditing].[EventTypes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.agentjob_history') is null
begin
RAISERROR('	CREATING table [dbo].[agentjob_history]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[agentjob_history](
	[instance_id] [int] NOT NULL,
	[job_id] [uniqueidentifier] NOT NULL,
	[step_id] [int] NOT NULL,
	[sql_message_id] [int] NOT NULL,
	[sql_severity] [int] NOT NULL,
	[run_status] [tinyint] NOT NULL,
	[run_date] [int] NOT NULL,
	[run_time] [int] NOT NULL,
	[run_duration] [int] NOT NULL,
	[message] [nvarchar](4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [agentjob_history_PK] PRIMARY KEY CLUSTERED 
(
	[instance_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 CREATE NONCLUSTERED INDEX [agentjob_history_run_date] ON [dbo].[agentjob_history]
(
	[run_date] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[agentjob_history] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.agentjob_monitor') is null
begin
RAISERROR('	CREATING table [dbo].[agentjob_monitor]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[agentjob_monitor](
	[job_id] [uniqueidentifier] NOT NULL,
	[is_enabled] [bit] NOT NULL,
	[report_success] [bit] NOT NULL,
	[job_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[retention_days] [smallint] NOT NULL,
	[insert_date] [datetime] NULL,
 CONSTRAINT [agentjob_monitor_U] UNIQUE CLUSTERED 
(
	[job_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 ALTER TABLE [dbo].[agentjob_monitor] ADD  DEFAULT ((30)) FOR [retention_days] ALTER TABLE [dbo].[agentjob_monitor] ADD  DEFAULT (getdate()) FOR [insert_date]
end
else
RAISERROR ('	Table [dbo].[agentjob_monitor] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.agentjob_search_history') is null
begin
RAISERROR('	CREATING table [dbo].[agentjob_search_history]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[agentjob_search_history](
	[is_gap_before] [bit] NOT NULL,
	[min_instance_id] [int] NOT NULL,
	[max_instance_id] [int] NOT NULL,
	[runtime] [datetime] NOT NULL,
 CONSTRAINT [agentjob_search_history_PK] PRIMARY KEY CLUSTERED 
(
	[runtime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[agentjob_search_history] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.AvailabiltyGroupTracking') is null
begin
RAISERROR('	CREATING table [dbo].[AvailabiltyGroupTracking]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[AvailabiltyGroupTracking](
	[CreatedOn] [datetime] NOT NULL,
	[InstanceName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[AGName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[FailureConditionLevel] [int] NOT NULL,
	[PrimaryReplica] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[Note] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [PK_AvailabiltyGroupTracking] PRIMARY KEY CLUSTERED 
(
	[CreatedOn] ASC,
	[InstanceName] ASC,
	[AGName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 ALTER TABLE [dbo].[AvailabiltyGroupTracking] ADD  CONSTRAINT [DF_AG_Tracking_CreatedOn]  DEFAULT (getdate()) FOR [CreatedOn] ALTER TABLE [dbo].[AvailabiltyGroupTracking] ADD  CONSTRAINT [DF_AG_Tracking_InstanceName]  DEFAULT (@@servername) FOR [InstanceName]
end
else
RAISERROR ('	Table [dbo].[AvailabiltyGroupTracking] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.BackupReportExclusion') is null
begin
RAISERROR('	CREATING table [dbo].[BackupReportExclusion]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[BackupReportExclusion](
	[DatabaseName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[CreatedOn] [datetime] NULL,
	[ExcludeFull] [bit] NOT NULL,
	[ExcludeDiff] [bit] NOT NULL,
	[ExcludeLog] [bit] NOT NULL,
 CONSTRAINT [PK_BackupReportExclusion] PRIMARY KEY CLUSTERED 
(
	[DatabaseName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 ALTER TABLE [dbo].[BackupReportExclusion] ADD  CONSTRAINT [DF_BackupReportExclusion_CreatedOn]  DEFAULT (getdate()) FOR [CreatedOn] ALTER TABLE [dbo].[BackupReportExclusion] ADD  CONSTRAINT [DF_BackupReportExclusion_ExcludeFull]  DEFAULT ((0)) FOR [ExcludeFull] ALTER TABLE [dbo].[BackupReportExclusion] ADD  CONSTRAINT [DF_BackupReportExclusion_ExcludeDiff]  DEFAULT ((0)) FOR [ExcludeDiff] ALTER TABLE [dbo].[BackupReportExclusion] ADD  CONSTRAINT [DF_BackupReportExclusion_ExcludeLog]  DEFAULT ((0)) FOR [ExcludeLog]
end
else
RAISERROR ('	Table [dbo].[BackupReportExclusion] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.collection_session') is null
begin
RAISERROR('	CREATING table [dbo].[collection_session]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[collection_session](
	[collection_session_id] [int] IDENTITY(1,1) NOT NULL,
	[runtime] [datetime] NOT NULL,
	[servername] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[durationS] [int] NULL,
 CONSTRAINT [collection_session_pk] PRIMARY KEY CLUSTERED 
(
	[collection_session_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[collection_session] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.collection_session_perf') is null
begin
RAISERROR('	CREATING table [dbo].[collection_session_perf]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[collection_session_perf](
	[collection_session_perf_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[collection_type] [tinyint] NOT NULL,
	[durationSEC] [smallint] NOT NULL,
	[result_message] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [collection_session_perf_pk] PRIMARY KEY CLUSTERED 
(
	[collection_session_perf_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[collection_session_perf] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.config_fddba2') is null
begin
RAISERROR('	CREATING table [dbo].[config_fddba2]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[config_fddba2](
	[name] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[domain] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[CreatedOn] [datetime] NOT NULL,
	[UpdatedOn] [datetime] NOT NULL,
	[value] [nvarchar](3950) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[valuebig] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[comment] [varchar](2000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [config_fddba2_PK] PRIMARY KEY CLUSTERED 
(
	[name] ASC,
	[domain] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 ALTER TABLE [dbo].[config_fddba2] ADD  DEFAULT (getdate()) FOR [CreatedOn] ALTER TABLE [dbo].[config_fddba2] ADD  DEFAULT (getdate()) FOR [UpdatedOn]
end
else
RAISERROR ('	Table [dbo].[config_fddba2] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.config_fddba2_history') is null
begin
RAISERROR('	CREATING table [dbo].[config_fddba2_history]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[config_fddba2_history](
	[name] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[domain] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[CreatedOn] [datetime] NOT NULL,
	[UpdatedOn] [datetime] NOT NULL,
	[value] [nvarchar](3950) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[valuebig] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[comment] [varchar](2000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [config_fddba2_history_PK] PRIMARY KEY CLUSTERED 
(
	[name] ASC,
	[domain] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 ALTER TABLE [dbo].[config_fddba2_history] ADD  DEFAULT (getdate()) FOR [CreatedOn] ALTER TABLE [dbo].[config_fddba2_history] ADD  DEFAULT (getdate()) FOR [UpdatedOn]
end
else
RAISERROR ('	Table [dbo].[config_fddba2_history] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.ConfigurationHistory') is null
begin
RAISERROR('	CREATING table [dbo].[ConfigurationHistory]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[ConfigurationHistory](
	[CreatedOn] [datetime] NOT NULL,
	[name] [nvarchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[value_in_use] [sql_variant] NOT NULL
) ON [PRIMARY]
 CREATE CLUSTERED INDEX [CIX_ConfigurationHistory] ON [dbo].[ConfigurationHistory]
(
	[CreatedOn] DESC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[ConfigurationHistory] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.database_mirroring_changes') is null
begin
RAISERROR('	CREATING table [dbo].[database_mirroring_changes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[database_mirroring_changes](
	[dt] [datetime] NOT NULL,
	[dbid] [int] NOT NULL,
	[state] [tinyint] NOT NULL,
	[role] [tinyint] NOT NULL,
	[safety] [tinyint] NOT NULL,
	[timeout] [int] NOT NULL,
	[database_mirroring_changes_id] [int] IDENTITY(1,1) NOT NULL,
 CONSTRAINT [database_mirroring_changes_pk] PRIMARY KEY CLUSTERED 
(
	[database_mirroring_changes_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[database_mirroring_changes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.database_mirroring_connect_changes') is null
begin
RAISERROR('	CREATING table [dbo].[database_mirroring_connect_changes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[database_mirroring_connect_changes](
	[dt] [datetime] NOT NULL,
	[is_accept] [bit] NOT NULL,
	[state] [smallint] NOT NULL,
	[login_state] [smallint] NOT NULL,
	[connect_time] [datetime] NOT NULL,
	[database_mirroring_connect_changes_id] [int] IDENTITY(1,1) NOT NULL,
 CONSTRAINT [database_mirroring_connect_changes_pk] PRIMARY KEY CLUSTERED 
(
	[database_mirroring_connect_changes_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[database_mirroring_connect_changes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.database_mirroring_connect_performance') is null
begin
RAISERROR('	CREATING table [dbo].[database_mirroring_connect_performance]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[database_mirroring_connect_performance](
	[dt] [datetime] NOT NULL,
	[is_accept] [bit] NOT NULL,
	[state] [smallint] NOT NULL,
	[is_receive_fc] [bit] NOT NULL,
	[is_send_fc] [bit] NOT NULL,
	[total_bytes_sent] [bigint] NOT NULL,
	[total_bytes_received] [bigint] NOT NULL,
	[last_activity_time] [datetime] NOT NULL,
	[active_bytes] [bigint] NOT NULL,
 CONSTRAINT [database_mirroring_connect_performance_pk] PRIMARY KEY CLUSTERED 
(
	[dt] ASC,
	[is_accept] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[database_mirroring_connect_performance] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.database_mirroring_lsns') is null
begin
RAISERROR('	CREATING table [dbo].[database_mirroring_lsns]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[database_mirroring_lsns](
	[dt] [datetime] NOT NULL,
	[dbid] [int] NOT NULL,
	[end_of_log_lsn] [decimal](25, 0) NOT NULL,
	[failover_lsn] [decimal](25, 0) NOT NULL,
 CONSTRAINT [database_mirroring_lsns_pk] PRIMARY KEY CLUSTERED 
(
	[dt] ASC,
	[dbid] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[database_mirroring_lsns] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.DatabaseFileStorage') is null
begin
RAISERROR('	CREATING table [dbo].[DatabaseFileStorage]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[DatabaseFileStorage](
	[InstanceName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[CreatedOn] [datetime] NOT NULL,
	[DatabaseName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[LogicalName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[PhysicalName] [nvarchar](260) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[TYPE] [tinyint] NOT NULL,
	[TotalSize_Mb] [int] NOT NULL,
	[AvailableSpace_Mb] [int] NOT NULL,
 CONSTRAINT [PK_DatabaseFileStorage] PRIMARY KEY CLUSTERED 
(
	[CreatedOn] DESC,
	[DatabaseName] ASC,
	[LogicalName] ASC
)WITH (PAD_INDEX = ON, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 ALTER TABLE [dbo].[DatabaseFileStorage] ADD  CONSTRAINT [DF_DatabaseFileStorage_InstanceName]  DEFAULT (@@servername) FOR [InstanceName] ALTER TABLE [dbo].[DatabaseFileStorage] ADD  CONSTRAINT [DF_DatabaseFileStorage_CreatedOn]  DEFAULT (getdate()) FOR [CreatedOn]
end
else
RAISERROR ('	Table [dbo].[DatabaseFileStorage] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.DatabaseObjectStorage') is null
begin
RAISERROR('	CREATING table [dbo].[DatabaseObjectStorage]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[DatabaseObjectStorage](
	[InstanceName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[CreatedOn] [datetime] NOT NULL,
	[DatabaseName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[SchemaName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[TableName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[IndexName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[PartitionNumber] [int] NOT NULL,
	[Index_Type] [tinyint] NULL,
	[DataCompression] [tinyint] NOT NULL,
	[RecordCount] [bigint] NOT NULL,
	[in_row_reserved_page_count] [bigint] NOT NULL,
	[lob_reserved_page_count] [bigint] NOT NULL,
	[row_overflow_reserved_page_count] [bigint] NOT NULL,
	[in_row_used_page_count] [bigint] NOT NULL,
	[lob_used_page_count] [bigint] NOT NULL,
	[row_overflow_used_page_count] [bigint] NOT NULL,
	[FileGroupName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DriveLetter] [char](1) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [PK_DatabaseObjectStorage] PRIMARY KEY CLUSTERED 
(
	[CreatedOn] DESC,
	[DatabaseName] ASC,
	[SchemaName] ASC,
	[TableName] ASC,
	[IndexName] ASC,
	[PartitionNumber] ASC
)WITH (PAD_INDEX = ON, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 ALTER TABLE [dbo].[DatabaseObjectStorage] ADD  CONSTRAINT [DF_DatabaseObjectStorage_InstanceName]  DEFAULT (@@servername) FOR [InstanceName] ALTER TABLE [dbo].[DatabaseObjectStorage] ADD  CONSTRAINT [DF_DatabaseObjectStorage_CreatedOn]  DEFAULT (getdate()) FOR [CreatedOn]
end
else
RAISERROR ('	Table [dbo].[DatabaseObjectStorage] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.DatabasePermission') is null
begin
RAISERROR('	CREATING table [dbo].[DatabasePermission]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[DatabasePermission](
	[InstanceName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[CreatedOn] [datetime] NOT NULL,
	[DatabaseName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[PermissionScript] [varchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [PK_DatabasePermission] PRIMARY KEY CLUSTERED 
(
	[DatabaseName] ASC,
	[CreatedOn] DESC
)WITH (PAD_INDEX = ON, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 ALTER TABLE [dbo].[DatabasePermission] ADD  CONSTRAINT [DF_DatabasePermission_InstanceName]  DEFAULT (@@servername) FOR [InstanceName] ALTER TABLE [dbo].[DatabasePermission] ADD  CONSTRAINT [DF_DatabasePermission_CreatedOn]  DEFAULT (getdate()) FOR [CreatedOn]
end
else
RAISERROR ('	Table [dbo].[DatabasePermission] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_allocation_units') is null
begin
RAISERROR('	CREATING table [dbo].[db_allocation_units]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_allocation_units](
	[db_allocation_units_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[type] [tinyint] NOT NULL,
	[container_id] [bigint] NOT NULL,
	[data_space_id] [int] NULL,
	[total_pages] [bigint] NOT NULL,
 CONSTRAINT [db_allocation_units_pk] PRIMARY KEY CLUSTERED 
(
	[db_allocation_units_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_allocation_units] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_columns') is null
begin
RAISERROR('	CREATING table [dbo].[db_columns]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_columns](
	[db_columns_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[column_id] [int] NOT NULL,
	[name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [db_columns_pk] PRIMARY KEY CLUSTERED 
(
	[db_columns_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_columns] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_filegroups') is null
begin
RAISERROR('	CREATING table [dbo].[db_filegroups]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_filegroups](
	[db_filegroups_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[data_space_id] [int] NOT NULL,
	[type] [char](2) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[is_default] [bit] NULL,
	[is_read_only] [bit] NULL,
	[name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [db_filegroups_pk] PRIMARY KEY CLUSTERED 
(
	[db_filegroups_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_filegroups] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_index_columns') is null
begin
RAISERROR('	CREATING table [dbo].[db_index_columns]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_index_columns](
	[db_index_columns_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[index_id] [int] NOT NULL,
	[column_id] [int] NOT NULL,
	[key_ordinal] [tinyint] NOT NULL,
	[is_descending_key] [bit] NULL,
	[is_included_column] [bit] NULL,
 CONSTRAINT [db_index_columns_pk] PRIMARY KEY CLUSTERED 
(
	[db_index_columns_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_index_columns] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_index_operational_stats') is null
begin
RAISERROR('	CREATING table [dbo].[db_index_operational_stats]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_index_operational_stats](
	[db_index_operational_stats_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [smallint] NOT NULL,
	[object_id] [int] NOT NULL,
	[index_id] [int] NOT NULL,
	[partition_number] [int] NOT NULL,
	[leaf_insert_count] [bigint] NOT NULL,
	[leaf_delete_count] [bigint] NOT NULL,
	[leaf_update_count] [bigint] NOT NULL,
	[leaf_ghost_count] [bigint] NOT NULL,
	[nonleaf_insert_count] [bigint] NOT NULL,
	[nonleaf_delete_count] [bigint] NOT NULL,
	[nonleaf_update_count] [bigint] NOT NULL,
	[leaf_page_merge_count] [bigint] NOT NULL,
	[range_scan_count] [bigint] NOT NULL,
	[singleton_lookup_count] [bigint] NOT NULL,
	[lob_fetch_in_pages] [bigint] NOT NULL,
	[row_overflow_fetch_in_pages] [bigint] NOT NULL,
	[index_lock_promotion_count] [bigint] NOT NULL,
 CONSTRAINT [db_index_operational_stats_pk] PRIMARY KEY CLUSTERED 
(
	[db_index_operational_stats_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_index_operational_stats] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_indexes') is null
begin
RAISERROR('	CREATING table [dbo].[db_indexes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_indexes](
	[db_indexes_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[index_id] [int] NOT NULL,
	[type] [tinyint] NOT NULL,
	[data_space_id] [int] NULL,
	[is_unique] [bit] NOT NULL,
	[ignore_dup_key] [bit] NOT NULL,
	[is_primary_key] [bit] NOT NULL,
	[is_unique_constraint] [bit] NOT NULL,
	[fill_factor] [tinyint] NOT NULL,
	[is_padded] [bit] NOT NULL,
	[is_disabled] [bit] NOT NULL,
	[is_hypothetical] [bit] NOT NULL,
	[allow_row_locks] [bit] NOT NULL,
	[allow_page_locks] [bit] NOT NULL,
	[has_filter] [bit] NOT NULL,
	[name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [db_indexes_pk] PRIMARY KEY CLUSTERED 
(
	[db_indexes_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_indexes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_missing_indexes') is null
begin
RAISERROR('	CREATING table [dbo].[db_missing_indexes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_missing_indexes](
	[db_missing_indexes_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [smallint] NOT NULL,
	[object_id] [int] NOT NULL,
	[avg_total_user_cost] [float] NULL,
	[avg_user_impact] [float] NULL,
	[user_seeks] [bigint] NOT NULL,
	[user_scans] [bigint] NOT NULL,
	[unique_compiles] [bigint] NOT NULL,
	[last_user_seek] [datetime] NULL,
	[equality_columns] [nvarchar](4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[inequality_columns] [nvarchar](4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[included_columns] [nvarchar](4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [db_missing_indexes_pk] PRIMARY KEY CLUSTERED 
(
	[db_missing_indexes_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_missing_indexes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_objects') is null
begin
RAISERROR('	CREATING table [dbo].[db_objects]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_objects](
	[db_objects_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[schema_id] [int] NOT NULL,
	[type] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [db_objects_pk] PRIMARY KEY CLUSTERED 
(
	[db_objects_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_objects] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_partitions') is null
begin
RAISERROR('	CREATING table [dbo].[db_partitions]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_partitions](
	[db_partitions_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[partition_id] [bigint] NOT NULL,
	[object_id] [int] NOT NULL,
	[index_id] [int] NOT NULL,
	[partition_number] [int] NOT NULL,
	[hobt_id] [bigint] NOT NULL,
	[data_compression] [tinyint] NOT NULL,
 CONSTRAINT [db_partitions_pk] PRIMARY KEY CLUSTERED 
(
	[db_partitions_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_partitions] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_schemas') is null
begin
RAISERROR('	CREATING table [dbo].[db_schemas]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_schemas](
	[db_schemas_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[schema_id] [int] NOT NULL,
	[name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [db_schemas_pk] PRIMARY KEY CLUSTERED 
(
	[db_schemas_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_schemas] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.db_sysindexes') is null
begin
RAISERROR('	CREATING table [dbo].[db_sysindexes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[db_sysindexes](
	[db_sysindexes_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[index_id] [int] NOT NULL,
	[dpages] [bigint] NOT NULL,
	[rowcnt] [bigint] NOT NULL,
	[rowmodctr] [bigint] NOT NULL,
 CONSTRAINT [db_sysindexes_pk] PRIMARY KEY CLUSTERED 
(
	[db_sysindexes_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[db_sysindexes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock](
	[deadlock_id] [int] IDENTITY(1,1) NOT NULL,
	[deadlock_file_id] [smallint] NOT NULL,
	[is_complete] [bit] NOT NULL,
	[is_database_xml] [bit] NOT NULL,
	[is_intraquery] [bit] NOT NULL,
	[spid] [int] NOT NULL,
	[start_time] [datetime] NOT NULL,
	[end_time] [datetime] NOT NULL,
	[process_count] [smallint] NOT NULL,
	[waiter_count] [smallint] NOT NULL,
	[resource_count] [smallint] NOT NULL,
	[victim] [varchar](16) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[last_process_seen] [varchar](16) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[last_node_seen] [tinyint] NULL,
	[is_processing_inputbuf] [bit] NOT NULL,
	[dl_checksum] [bigint] NULL,
	[dl_unique_checksum] [bigint] NULL,
	[dl_unique_checksum_count] [tinyint] NULL,
	[xml_parse_error] [tinyint] NULL,
	[xml_deadlock] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [deadlock_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 CREATE UNIQUE NONCLUSTERED INDEX [deadlock_2] ON [dbo].[deadlock]
(
	[deadlock_id] ASC,
	[deadlock_file_id] ASC,
	[is_complete] ASC,
	[spid] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[deadlock] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_file') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_file]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_file](
	[deadlock_file_id] [int] IDENTITY(1,1) NOT NULL,
	[is_complete] [bit] NOT NULL,
	[is_xel] [bit] NOT NULL,
	[fileid] [tinyint] NOT NULL,
	[start_time] [datetime] NOT NULL,
	[active_deadlocks] [smallint] NOT NULL,
	[file_size] [bigint] NULL,
	[errorlog_last_date] [datetime] NULL,
	[first_deadlock_id] [int] NULL,
	[last_deadlock_id] [int] NULL,
	[deadlock_count] [int] NULL,
	[xml_database_deadlock_event_count] [int] NULL,
	[max_active_deadlocks] [smallint] NULL,
	[max_active_deadlocks_dt] [datetime] NULL,
	[line_count] [bigint] NULL,
	[duration_in_sec] [int] NULL,
	[perf_comment] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[file_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [deadlock_file_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_file_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 SET ANSI_PADDING ON
 CREATE UNIQUE NONCLUSTERED INDEX [deadlock_file_2] ON [dbo].[deadlock_file]
(
	[file_name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[deadlock_file] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_iq_process') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_iq_process]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_iq_process](
	[deadlock_id] [int] NOT NULL,
	[node] [tinyint] NOT NULL,
	[spid] [int] NULL,
	[sbid] [int] NULL,
	[ecid] [int] NULL,
	[wr_type] [varchar](20) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wait_resource] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[event_type] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[proc_dbid] [int] NULL,
	[proc_id] [int] NULL,
	[proc_line] [int] NULL,
	[statement_type] [varchar](32) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[port_line] [varchar](500) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[inputbuf_line] [varchar](500) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[res_line] [varchar](500) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[spid_line] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [deadlock_iq_process_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_id] ASC,
	[node] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[deadlock_iq_process] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_message_blacklist') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_message_blacklist]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_message_blacklist](
	[deadlock_message_blacklist_id] [int] IDENTITY(1,1) NOT NULL,
	[message_id] [int] NULL,
	[message_text] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [deadlock_message_blacklist_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_message_blacklist_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[deadlock_message_blacklist] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_message_noise') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_message_noise]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_message_noise](
	[deadlock_message_noise_id] [int] IDENTITY(1,1) NOT NULL,
	[occurrences] [int] NOT NULL,
	[message_text] [varchar](200) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [deadlock_message_noise_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_message_noise_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 CREATE UNIQUE NONCLUSTERED INDEX [deadlock_message_noise_2] ON [dbo].[deadlock_message_noise]
(
	[message_text] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[deadlock_message_noise] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_parse_error') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_parse_error]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_parse_error](
	[deadlock_id] [int] NULL,
	[value1] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[value2] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[line] [varchar](8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[deadlock_parse_error] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_parse_strings') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_parse_strings]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_parse_strings](
	[deadlock_parse_strings_id] [smallint] IDENTITY(1,1) NOT NULL,
	[stype] [tinyint] NOT NULL,
	[typeid] [smallint] NOT NULL,
	[mystr] [varchar](25) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[mylen] [tinyint] NULL,
	[childstype] [tinyint] NULL,
 CONSTRAINT [deadlock_waiter_strings_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_parse_strings_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[deadlock_parse_strings] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_process') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_process]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_process](
	[deadlock_id] [int] NOT NULL,
	[process_id] [varchar](16) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[spid] [int] NULL,
	[sbid] [int] NOT NULL,
	[ecid] [int] NULL,
	[task_priority] [smallint] NULL,
	[log_used] [bigint] NULL,
	[wait_resource] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wr_type] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wr_dbid] [int] NULL,
	[wr_hobt] [bigint] NULL,
	[wr_hash] [varchar](20) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wr_fileid] [int] NULL,
	[wr_pageid] [int] NULL,
	[wr_rid] [smallint] NULL,
	[wr_objid] [int] NULL,
	[wr_indid] [smallint] NULL,
	[wr_schid] [int] NULL,
	[wait_time] [int] NULL,
	[ownerid] [varchar](20) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[transaction_name] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[last_tran_started] [datetime] NULL,
	[xdes] [varchar](20) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[lock_mode] [varchar](8) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[scheduler_id] [tinyint] NULL,
	[kpid] [int] NULL,
	[status] [varchar](32) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[priority] [smallint] NULL,
	[tran_count] [tinyint] NULL,
	[last_batch_started] [datetime] NULL,
	[last_batch_completed] [datetime] NULL,
	[last_attention] [datetime] NULL,
	[client_app] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[host_name] [varchar](32) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[host_pid] [bigint] NULL,
	[login_name] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[iso_level_val] [tinyint] NULL,
	[xactid] [bigint] NULL,
	[currentdb] [int] NULL,
	[lock_timeout] [bigint] NULL,
	[client_option1] [int] NULL,
	[client_option2] [int] NULL,
	[process_checksum] [int] NULL,
	[proc_dbid] [int] NULL,
	[proc_id] [int] NULL,
	[inputbuf] [varchar](8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[full_line] [varchar](8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [deadlock_process_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_id] ASC,
	[process_id] ASC,
	[sbid] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[deadlock_process] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_resource') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_resource]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_resource](
	[deadlock_id] [int] NOT NULL,
	[type] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[database_id] [int] NULL,
	[fileid] [int] NULL,
	[pageid] [int] NULL,
	[rid] [smallint] NULL,
	[object_id] [int] NULL,
	[hobtId] [bigint] NULL,
	[schema_id] [int] NULL,
	[lock_mode] [varchar](8) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[lock] [varchar](25) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[sub_resource] [varchar](25) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[object_name] [varchar](255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[index_name] [varchar](255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[address] [varchar](16) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wait_type] [varchar](25) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[nodeid] [tinyint] NULL,
	[deadlock_resource_id] [int] IDENTITY(1,1) NOT NULL,
 CONSTRAINT [deadlock_resource_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_resource_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[deadlock_resource] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_tsql_stack') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_tsql_stack]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_tsql_stack](
	[deadlock_id] [int] NOT NULL,
	[process_id] [varchar](16) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[sbid] [int] NOT NULL,
	[frame_id] [tinyint] NOT NULL,
	[proc_name] [varchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[line] [int] NOT NULL,
	[stmt_start] [int] NULL,
	[stmt_end] [int] NULL,
	[sql_handle] [varchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [deadlock_tsql_stack_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_id] ASC,
	[process_id] ASC,
	[sbid] ASC,
	[frame_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[deadlock_tsql_stack] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.deadlock_waiter') is null
begin
RAISERROR('	CREATING table [dbo].[deadlock_waiter]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[deadlock_waiter](
	[deadlock_id] [int] NOT NULL,
	[resource_id] [int] NOT NULL,
	[process_id] [varchar](16) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[is_waiter] [tinyint] NOT NULL,
	[lock_mode] [varchar](8) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[item_count] [tinyint] NOT NULL,
	[request_type] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [deadlock_waiter_pk] PRIMARY KEY CLUSTERED 
(
	[deadlock_id] ASC,
	[resource_id] ASC,
	[process_id] ASC,
	[lock_mode] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[deadlock_waiter] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.dm_exec_adhoc_sql') is null
begin
RAISERROR('	CREATING table [dbo].[dm_exec_adhoc_sql]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[dm_exec_adhoc_sql](
	[dm_exec_adhoc_sql_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[query_hash] [binary](8) NOT NULL,
	[stmt_text] [nvarchar](4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [dm_exec_adhoc_sql_pk] PRIMARY KEY CLUSTERED 
(
	[dm_exec_adhoc_sql_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[dm_exec_adhoc_sql] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.dm_exec_adhoc_stats') is null
begin
RAISERROR('	CREATING table [dbo].[dm_exec_adhoc_stats]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[dm_exec_adhoc_stats](
	[dm_exec_adhoc_stats_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[execution_count] [bigint] NOT NULL,
	[total_worker_timeMS] [bigint] NOT NULL,
	[total_elapsed_timeMS] [bigint] NOT NULL,
	[query_plan_hash_count] [int] NOT NULL,
	[query_hash] [binary](8) NOT NULL,
 CONSTRAINT [dm_exec_adhoc_stats_pk] PRIMARY KEY CLUSTERED 
(
	[dm_exec_adhoc_stats_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[dm_exec_adhoc_stats] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.dm_exec_code') is null
begin
RAISERROR('	CREATING table [dbo].[dm_exec_code]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[dm_exec_code](
	[dm_exec_code_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[schema_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[type] [varchar](2) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[create_date] [datetime] NOT NULL,
	[modified_date] [datetime] NOT NULL,
 CONSTRAINT [dm_exec_code_pk] PRIMARY KEY CLUSTERED 
(
	[dm_exec_code_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[dm_exec_code] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.dm_exec_code_stats') is null
begin
RAISERROR('	CREATING table [dbo].[dm_exec_code_stats]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[dm_exec_code_stats](
	[dm_exec_code_stats_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[type] [char](2) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[cached_time] [datetime] NOT NULL,
	[last_execution_time] [datetime] NOT NULL,
	[execution_count] [bigint] NOT NULL,
	[total_worker_timeMS] [bigint] NOT NULL,
	[total_elapsed_timeMS] [bigint] NOT NULL,
 CONSTRAINT [dm_exec_code_stats_pk] PRIMARY KEY CLUSTERED 
(
	[dm_exec_code_stats_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[dm_exec_code_stats] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.dm_exec_query_plan_summary') is null
begin
RAISERROR('	CREATING table [dbo].[dm_exec_query_plan_summary]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[dm_exec_query_plan_summary](
	[dm_exec_query_plan_summary_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[objtype] [varchar](16) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[entry_count] [int] NOT NULL,
	[cache_size_MB] [decimal](38, 4) NOT NULL,
 CONSTRAINT [dm_exec_query_plan_summary_pk] PRIMARY KEY CLUSTERED 
(
	[dm_exec_query_plan_summary_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[dm_exec_query_plan_summary] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.dm_exec_query_stats') is null
begin
RAISERROR('	CREATING table [dbo].[dm_exec_query_stats]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[dm_exec_query_stats](
	[dm_exec_query_stats_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NULL,
	[usecounts] [int] NOT NULL,
	[plansizeKB] [int] NOT NULL,
	[total_worker_timeMS] [bigint] NOT NULL,
	[total_elapsed_timeMS] [bigint] NOT NULL,
	[total_physical_reads] [bigint] NOT NULL,
	[total_logical_writes] [bigint] NOT NULL,
	[total_logical_reads] [bigint] NOT NULL,
	[CpuRank] [int] NOT NULL,
	[PhysicalReadsRank] [int] NOT NULL,
	[DurationRank] [int] NOT NULL,
	[query_hash] [binary](8) NULL,
	[query_plan_hash] [binary](8) NULL,
	[creation_time] [datetime] NOT NULL,
	[statement_start_offset] [int] NOT NULL,
	[statement_end_offset] [int] NOT NULL,
	[plan_generation_num] [bigint] NOT NULL,
	[min_worker_time] [bigint] NOT NULL,
	[last_worker_time] [bigint] NOT NULL,
	[max_worker_time] [bigint] NOT NULL,
	[min_elapsed_time] [bigint] NOT NULL,
	[last_elapsed_time] [bigint] NOT NULL,
	[max_elapsed_time] [bigint] NOT NULL,
	[min_physical_reads] [bigint] NOT NULL,
	[last_physical_reads] [bigint] NOT NULL,
	[max_physical_reads] [bigint] NOT NULL,
	[min_logical_writes] [bigint] NOT NULL,
	[last_logical_writes] [bigint] NOT NULL,
	[max_logical_writes] [bigint] NOT NULL,
	[min_logical_reads] [bigint] NOT NULL,
	[last_logical_reads] [bigint] NOT NULL,
	[max_logical_reads] [bigint] NOT NULL,
	[total_rows] [bigint] NOT NULL,
	[min_rows] [bigint] NOT NULL,
	[last_rows] [bigint] NOT NULL,
	[max_rows] [bigint] NOT NULL,
	[plan_handle] [varbinary](64) NOT NULL,
	[cacheobjtype] [varchar](35) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[procname] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[stmt_text] [nvarchar](512) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [dm_exec_query_stats_pk] PRIMARY KEY CLUSTERED 
(
	[dm_exec_query_stats_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[dm_exec_query_stats] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.exec_plan_hashes_tracked') is null
begin
RAISERROR('	CREATING table [dbo].[exec_plan_hashes_tracked]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[exec_plan_hashes_tracked](
	[exec_plan_tracked_ID] [int] NOT NULL,
	[statement_start_offset] [int] NOT NULL,
	[query_hash] [binary](8) NOT NULL,
	[query_plan_hash] [binary](8) NOT NULL,
 CONSTRAINT [exec_plan_hashes_tracked_PK] PRIMARY KEY CLUSTERED 
(
	[query_plan_hash] ASC,
	[statement_start_offset] ASC,
	[exec_plan_tracked_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 ALTER TABLE [dbo].[exec_plan_hashes_tracked]  WITH CHECK ADD  CONSTRAINT [exec_plan_hashes_tracked_FK] FOREIGN KEY([exec_plan_tracked_ID])
REFERENCES [dbo].[exec_plan_tracked] ([exec_plan_tracked_ID]) ALTER TABLE [dbo].[exec_plan_hashes_tracked] CHECK CONSTRAINT [exec_plan_hashes_tracked_FK]
end
else
RAISERROR ('	Table [dbo].[exec_plan_hashes_tracked] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.exec_plan_params_tracked') is null
begin
RAISERROR('	CREATING table [dbo].[exec_plan_params_tracked]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[exec_plan_params_tracked](
	[runtime] [datetime] NOT NULL,
	[plan_handle] [varbinary](64) NOT NULL,
	[plan_generation_num] [int] NOT NULL,
	[query_parameters] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [trackedplansparams_PK] PRIMARY KEY CLUSTERED 
(
	[plan_handle] ASC,
	[plan_generation_num] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [trackedplansparams_UC] UNIQUE NONCLUSTERED 
(
	[runtime] ASC,
	[plan_handle] ASC,
	[plan_generation_num] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[exec_plan_params_tracked] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.exec_plan_stats_to_track') is null
begin
RAISERROR('	CREATING table [dbo].[exec_plan_stats_to_track]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[exec_plan_stats_to_track](
	[exec_plan_stats_to_track_id] [int] IDENTITY(1,1) NOT NULL,
	[database_id] [smallint] NOT NULL,
	[schema_id] [int] NULL,
	[object_id] [int] NULL,
	[database_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[schema_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[object_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[query_hash] [binary](8) NULL,
	[adhoc_string] [nvarchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[plan_handle_filter] [varbinary](8) NOT NULL,
	[enabled] [tinyint] NOT NULL,
	[ins_date] [datetime] NOT NULL,
 CONSTRAINT [exec_plan_stats_to_track_PK] PRIMARY KEY CLUSTERED 
(
	[exec_plan_stats_to_track_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [exec_plan_stats_to_track_UK] UNIQUE NONCLUSTERED 
(
	[object_id] ASC,
	[query_hash] ASC,
	[database_id] ASC,
	[schema_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 ALTER TABLE [dbo].[exec_plan_stats_to_track] ADD  DEFAULT (getdate()) FOR [ins_date]
end
else
RAISERROR ('	Table [dbo].[exec_plan_stats_to_track] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.exec_plan_stats_tracked') is null
begin
RAISERROR('	CREATING table [dbo].[exec_plan_stats_tracked]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[exec_plan_stats_tracked](
	[runtime] [datetime] NOT NULL,
	[statement_start_offset] [int] NOT NULL,
	[plan_handle] [varbinary](64) NOT NULL,
	[query_hash] [binary](8) NOT NULL,
	[query_plan_hash] [binary](8) NOT NULL,
	[plan_generation_num] [bigint] NOT NULL,
	[creation_time] [datetime] NOT NULL,
	[last_execution_time] [datetime] NOT NULL,
	[execution_count] [bigint] NULL,
	[total_worker_time] [bigint] NULL,
	[last_worker_time] [bigint] NULL,
	[min_worker_time] [bigint] NULL,
	[max_worker_time] [bigint] NULL,
	[total_elapsed_time] [bigint] NULL,
	[last_elapsed_time] [bigint] NULL,
	[min_elapsed_time] [bigint] NULL,
	[max_elapsed_time] [bigint] NULL,
	[total_rows] [bigint] NULL,
	[last_rows] [bigint] NULL,
 CONSTRAINT [exec_plan_stats_tracked_PK] PRIMARY KEY CLUSTERED 
(
	[runtime] ASC,
	[query_hash] ASC,
	[plan_handle] ASC,
	[statement_start_offset] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [exec_plan_stats_tracked_UK] UNIQUE NONCLUSTERED 
(
	[plan_handle] ASC,
	[statement_start_offset] ASC,
	[last_execution_time] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[exec_plan_stats_tracked] already exists.',10,1) WITH NOWAIT;
GO


IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[FileStats]') AND TYPE in (N'U'))
BEGIN
	RAISERROR ('	CREATING table [dbo].[FileStats]',10,1) WITH NOWAIT;
	IF (select VerDec from #FDVER) >= 13.0
		EXEC sp_executesql N'Create table dbo.FileStats(
			InstanceName	sysname not null,
			CreatedOn	DATETIME2(3) not null,
			LastSqlStartOn DATETIME2(3) not null,
			DatabaseName	sysname not null,
			Database_Id	smallint not null,
			File_id	smallint not null,
			LogicalFileName sysname null,
			Sample_ms	bigint null,
			Num_of_reads	bigint not null,
			Num_of_bytes_read	bigint not null,
			Io_stall_read_ms	bigint not null,
			Num_of_writes	bigint not null,
			Num_of_bytes_written	bigint not null,
			Io_stall_write_ms	bigint not null,
			Io_stall	bigint not null,
			Size_on_disk_bytes	bigint not null)'
	ELSE IF (select VerDec from #FDVER) >= 10.5
		BEGIN
		EXEC sp_executesql N'Create table dbo.FileStats(
			InstanceName	sysname not null,
			CreatedOn	DATETIME2(3) not null,
			LastSqlStartOn DATETIME2(3) not null,
			DatabaseName	sysname not null,
			Database_Id	smallint not null,
			File_id	smallint not null,
			LogicalFileName sysname null,
			Sample_ms	int null,
			Num_of_reads	bigint not null,
			Num_of_bytes_read	bigint not null,
			Io_stall_read_ms	bigint not null,
			Num_of_writes	bigint not null,
			Num_of_bytes_written	bigint not null,
			Io_stall_write_ms	bigint not null,
			Io_stall	bigint not null,
			Size_on_disk_bytes	bigint not null)'
		END
	ELSE
		Create table dbo.FileStats(
			InstanceName	sysname not null,
			CreatedOn	DATETIME not null,
			LastSqlStartOn DATETIME not null,
			DatabaseName	sysname not null,
			Database_Id	smallint not null,
			File_id	smallint not null,
			LogicalFileName sysname null,
			Sample_ms	bigint null,
			Num_of_reads	bigint not null,
			Num_of_bytes_read	bigint not null,
			Io_stall_read_ms	bigint not null,
			Num_of_writes	bigint not null,
			Num_of_bytes_written	bigint not null,
			Io_stall_write_ms	bigint not null,
			Io_stall	bigint not null,
			Size_on_disk_bytes	bigint not null)
	

	CREATE CLUSTERED INDEX [IX_FilesStats] on dbo.FileStats(CreatedOn DESC)
END
ELSE
BEGIN
	RAISERROR ('	Table [dbo].[FileStats] already exists. Check version for SQL 2016 Table definition change',10,1) WITH NOWAIT;
	IF (select VerDec from #FDVER) >= 13.0
	BEGIN
		RAISERROR ('			TABLE [dbo].[FileStats] may require definition changes: ',10,1) WITH NOWAIT;
		--check if column is an int which is was in 2014 and earlier. If so change to Bigint for 2016 and greater
		IF EXISTS(SELECT 1 
					FROM 
						sys.tables t 
						INNER JOIN sys.columns c on t.object_id = c.object_id
						INNER JOIN sys.types ty on c.user_type_id = ty.user_type_id and c.system_type_id = ty.system_type_id
					WHERE 
						t.name  = 'FileStats'
						AND t.schema_id = 1
						AND c.name = N'Sample_ms'
						AND ty.name = 'int')
		BEGIN
			BEGIN TRY
				RAISERROR ('			TABLE [dbo].[FileStats] requires definition changes, about to execute change.',10,1) WITH NOWAIT;
				EXEC sp_executesql N'ALTER TABLE dbo.FileStats ALTER COLUMN Sample_ms BIGINT NULL'
				RAISERROR ('		TABLE [dbo].[FileStats] definition change completed successfully ',10,1) WITH NOWAIT;
			END TRY
			BEGIN CATCH
				DECLARE @msg VARCHAR(2048)
				SELECT @msg = 'Error occured attempting to convert FileStats.dbo.Sample_MS to a BIGINT, please check it out. Error is: ' + SUBSTRING(ERROR_MESSAGE(),1,1940)
				RAISERROR(@msg, 15,1) WITH NOWAIT;
			END CATCH
		END 
		ELSE
		RAISERROR ('			Table [dbo].[FileStats] no additional Table definition changes required',10,1) WITH NOWAIT;

	END
	ELSE
	BEGIN
		RAISERROR ('	Table [dbo].[FileStats] no additional Table definition changes required',10,1) WITH NOWAIT;
	END

END
GO


if object_id('dbo.index_analysis_compression') is null
begin
RAISERROR('	CREATING table [dbo].[index_analysis_compression]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[index_analysis_compression](
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[index_id] [int] NOT NULL,
	[partition_number] [int] NOT NULL,
	[current_size_KB] [bigint] NOT NULL,
	[est_page_compressed_KB] [bigint] NOT NULL,
	[est_row_compressed_KB] [bigint] NOT NULL,
	[current_sample_KB] [bigint] NOT NULL,
	[page_sample_KB] [bigint] NOT NULL,
	[row_sample_KB] [bigint] NOT NULL,
	[index_analysis_compression_ID] [int] IDENTITY(1,1) NOT NULL,
 CONSTRAINT [PK_index_analysis_compression] PRIMARY KEY CLUSTERED 
(
	[index_analysis_compression_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[index_analysis_compression] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.index_analysis_db_backlist') is null
begin
RAISERROR('	CREATING table [dbo].[index_analysis_db_backlist]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[index_analysis_db_backlist](
	[index_analysis_db_backlist_id] [int] IDENTITY(1,1) NOT NULL,
	[is_enabled] [tinyint] NOT NULL,
	[modified_dt] [datetime] NOT NULL,
	[database_id] [int] NOT NULL,
	[database_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [index_analysis_db_backlist_pk] PRIMARY KEY CLUSTERED 
(
	[index_analysis_db_backlist_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [index_analysis_db_backlist_u] UNIQUE NONCLUSTERED 
(
	[is_enabled] ASC,
	[database_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[index_analysis_db_backlist] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.index_analysis_duplicate_indexes') is null
begin
RAISERROR('	CREATING table [dbo].[index_analysis_duplicate_indexes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[index_analysis_duplicate_indexes](
	[index_analysis_duplicate_indexes_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[index_id] [int] NOT NULL,
	[dup_index_id] [int] NOT NULL,
	[KeyColumns] [varchar](512) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[IncludeColumns] [varchar](512) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[exact] [bit] NULL,
 CONSTRAINT [index_analysis_duplicate_indexes_pk] PRIMARY KEY CLUSTERED 
(
	[index_analysis_duplicate_indexes_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[index_analysis_duplicate_indexes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.index_analysis_expensive_indexes') is null
begin
RAISERROR('	CREATING table [dbo].[index_analysis_expensive_indexes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[index_analysis_expensive_indexes](
	[index_analysis_expensive_indexes_id] [int] IDENTITY(1,1) NOT NULL,
	[date_stamp] [datetime] NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[index_id] [int] NOT NULL,
	[data_space_id] [int] NOT NULL,
	[TotalPages] [bigint] NOT NULL,
	[InRowPages] [bigint] NOT NULL,
	[UserSeeks] [bigint] NOT NULL,
	[UserScans] [bigint] NOT NULL,
	[UserLookups] [bigint] NOT NULL,
	[UserUpdates] [bigint] NOT NULL,
	[data_compression_min] [tinyint] NOT NULL,
	[data_compression_max] [tinyint] NOT NULL,
	[IndexCount] [int] NULL,
	[PartitionCount] [int] NOT NULL,
	[Last_User_Scan] [datetime] NULL,
	[Last_User_Seek] [datetime] NULL,
	[TotalUsage]  AS ((([UserSeeks]+[UserScans])+[UserLookups])+[UserUpdates]),
 CONSTRAINT [index_analysis_expensive_indexes_pk] PRIMARY KEY CLUSTERED 
(
	[index_analysis_expensive_indexes_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[index_analysis_expensive_indexes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.IndexUsageStats') is null
begin
RAISERROR('	CREATING table [dbo].[IndexUsageStats]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[IndexUsageStats](
	[database_id] [smallint] NOT NULL,
	[object_id] [int] NOT NULL,
	[index_id] [int] NOT NULL,
	[user_seeks] [bigint] NOT NULL,
	[user_scans] [bigint] NOT NULL,
	[user_lookups] [bigint] NOT NULL,
	[user_updates] [bigint] NOT NULL,
	[last_user_seek] [datetime] NULL,
	[last_user_scan] [datetime] NULL,
	[last_user_lookup] [datetime] NULL,
	[last_user_update] [datetime] NULL,
	[system_seeks] [bigint] NOT NULL,
	[system_scans] [bigint] NOT NULL,
	[system_lookups] [bigint] NOT NULL,
	[system_updates] [bigint] NOT NULL,
	[last_system_seek] [datetime] NULL,
	[last_system_scan] [datetime] NULL,
	[last_system_lookup] [datetime] NULL,
	[last_system_update] [datetime] NULL,
	[last_poll_user_seeks] [bigint] NOT NULL,
	[last_poll_user_scans] [bigint] NOT NULL,
	[last_poll_user_lookups] [bigint] NOT NULL,
	[last_poll_user_updates] [bigint] NOT NULL,
	[last_poll_system_seeks] [bigint] NOT NULL,
	[last_poll_system_scans] [bigint] NOT NULL,
	[last_poll_system_lookups] [bigint] NOT NULL,
	[last_poll_system_updates] [bigint] NOT NULL,
	[date_stamp] [datetime] NOT NULL,
 CONSTRAINT [PK_dm_db_index_usage_stats] PRIMARY KEY CLUSTERED 
(
	[database_id] ASC,
	[object_id] ASC,
	[index_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90) ON [PRIMARY]
) ON [PRIMARY]
 CREATE NONCLUSTERED INDEX [IX_user_reads] ON [dbo].[IndexUsageStats]
(
	[user_scans] ASC,
	[user_seeks] ASC,
	[user_lookups] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 80) ON [PRIMARY] CREATE NONCLUSTERED INDEX [IX_user_writes] ON [dbo].[IndexUsageStats]
(
	[user_updates] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 80) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[IndexUsageStats] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.logshipping_performance') is null
begin
RAISERROR('	CREATING table [dbo].[logshipping_performance]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[logshipping_performance](
	[copy_start_instance_id] [int] NULL,
	[copy_end_instance_id] [int] NULL,
	[restore_history_id] [int] NULL,
	[restore_end_instance_id] [int] NULL,
	[copy_start_dt_UTC] [datetime] NULL,
	[copy_end_dt_UTC] [datetime] NULL,
	[copy_delay_seconds] [int] NULL,
	[copy_duration_msec] [int] NULL,
	[copy_KB_per_sec] [decimal](12, 2) NULL,
	[restore_start_dt_UTC] [datetime] NULL,
	[restore_end_dt_UTC] [datetime] NULL,
	[restore_delay_seconds] [int] NULL,
	[restore_duration_msec] [int] NULL,
	[backup_set_id] [int] NULL,
	[backup_size] [bigint] NULL,
	[compressed_backup_size] [bigint] NULL,
	[database_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[filename] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[source_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[lineage] [tinyint] NOT NULL,
	[logshipping_performance_id] [int] IDENTITY(1,1) NOT NULL,
 CONSTRAINT [logshipping_performance_pk] PRIMARY KEY CLUSTERED 
(
	[logshipping_performance_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [logshipping_performance_u] UNIQUE NONCLUSTERED 
(
	[filename] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[logshipping_performance] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.logshipping_performance_mesages') is null
begin
RAISERROR('	CREATING table [dbo].[logshipping_performance_mesages]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[logshipping_performance_mesages](
	[instance_id] [int] NULL,
	[type] [char](1) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[message] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[string1] [varchar](255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[string2] [varchar](255) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[dt] [datetime] NOT NULL,
	[logshipping_performance_mesages_id] [int] IDENTITY(1,1) NOT NULL,
 CONSTRAINT [logshipping_performance_mesages_PK] PRIMARY KEY CLUSTERED 
(
	[logshipping_performance_mesages_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[logshipping_performance_mesages] already exists.',10,1) WITH NOWAIT;
GO


SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
SET ANSI_PADDING ON
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Performance_Counter]') AND TYPE in (N'U'))
BEGIN
	RAISERROR ('	CREATING table [dbo].[Performance_Counter]',10,1) WITH NOWAIT;
	IF (select VerDec from #FDVER) >= 10.5
		EXEC sp_executesql N'CREATE TABLE [dbo].[Performance_Counter](
			[SQL_Server_Name] [varchar](40) NOT NULL,
			[CreatedOn] datetime2(3) NOT NULL DEFAULT (getdate()),
			[User_Connections] [int] NULL,
			[Page_Life_Expectancy] [int] NULL,
			[Batch_Requests_Sec] [int] NULL,
			[Batch_Requests_Sec_Base] [bigint] NULL,
			[Buffer_Cache_Hit_Ratio] [int] NULL,
			[Logins_Sec] [int] NULL,
			[Logins_Sec_Base] [int] NULL,
			[SQL_Compiles_Sec] [int] NULL,
			[SQL_Compiles_Sec_Base] [int] NULL,
			[Active_Temp_Tables] [int] NULL,
			[Blocked_Processes] [int] NULL,
			[Memory_Grants_Outstanding] [int] NULL,
			[Connection_Memory_KB] [int] NULL,
			[Granted_Workspace_Memory_KB] [int] NULL,
			[Optimizer_Memory_KB] [int] NULL,
			[SQL_Cache_Memory_KB] [int] NULL,
			[Target_Server_Memory_KB] [int] NULL,
			[Total_Server_Memory_KB] [int] NULL,
			[Lock_Waits_AWT] [int] NULL,
			[Memory_Grant_Queue_AWT] [int] NULL,
			[Thread_Safe_Memory_Grants_AWT] [int] NULL,
			[Log_Writes_Waits_AWT] [int] NULL,
			[Log_Buffer_Waits_AWT] [int] NULL,
			[Network_IO_Waits_AWT] [int] NULL,
			[Page_IO_Latch_Waits_AWT] [int] NULL,
			[Page_Latch_Waits_AWT] [int] NULL,
			[Non_Page_Latch_Waits_AWT] [int] NULL,
			[Wait_For_Worker_AWT] [int] NULL,
			[Workspace_Sync_Waits_AWT] [int] NULL,
			[Transaction_Owernship_Waits_AWT] [int] NULL,
			[Lock_Waits_WIP] [int] NULL,
			[Memory_Grant_Queue_WIP] [int] NULL,
			[Thread_Safe_Memory_Grants_WIP] [int] NULL,
			[Log_Writes_Waits_WIP] [int] NULL,
			[Log_Buffer_Waits_WIP] [int] NULL,
			[Network_IO_Waits_WIP] [int] NULL,
			[Page_IO_Latch_Waits_WIP] [int] NULL,
			[Page_Latch_Waits_WIP] [int] NULL,
			[Non_Page_Latch_Waits_WIP] [int] NULL,
			[Wait_For_Worker_WIP] [int] NULL,
			[Workspace_Sync_Waits_WIP] [int] NULL,
			[Transaction_Owernship_Waits_WIP] [int] NULL,
			[MemoryGrantsPending] int NULL
		 CONSTRAINT [PK_Performance_Counter] PRIMARY KEY CLUSTERED 
		(
			[SQL_Server_Name] ASC,
			[CreatedOn] ASC
		)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90) ON [PRIMARY]
		) ON [PRIMARY]'
	ELSE
		CREATE TABLE [dbo].[Performance_Counter](
			[SQL_Server_Name] [varchar](40) NOT NULL,
			[CreatedOn] datetime NOT NULL DEFAULT (getdate()),
			[User_Connections] [int] NULL,
			[Page_Life_Expectancy] [int] NULL,
			[Batch_Requests_Sec] [int] NULL,
			[Batch_Requests_Sec_Base] [bigint] NULL,
			[Buffer_Cache_Hit_Ratio] [int] NULL,
			[Logins_Sec] [int] NULL,
			[Logins_Sec_Base] [int] NULL,
			[SQL_Compiles_Sec] [int] NULL,
			[SQL_Compiles_Sec_Base] [int] NULL,
			[Active_Temp_Tables] [int] NULL,
			[Blocked_Processes] [int] NULL,
			[Memory_Grants_Outstanding] [int] NULL,
			[Connection_Memory_KB] [int] NULL,
			[Granted_Workspace_Memory_KB] [int] NULL,
			[Optimizer_Memory_KB] [int] NULL,
			[SQL_Cache_Memory_KB] [int] NULL,
			[Target_Server_Memory_KB] [int] NULL,
			[Total_Server_Memory_KB] [int] NULL,
			[Lock_Waits_AWT] [int] NULL,
			[Memory_Grant_Queue_AWT] [int] NULL,
			[Thread_Safe_Memory_Grants_AWT] [int] NULL,
			[Log_Writes_Waits_AWT] [int] NULL,
			[Log_Buffer_Waits_AWT] [int] NULL,
			[Network_IO_Waits_AWT] [int] NULL,
			[Page_IO_Latch_Waits_AWT] [int] NULL,
			[Page_Latch_Waits_AWT] [int] NULL,
			[Non_Page_Latch_Waits_AWT] [int] NULL,
			[Wait_For_Worker_AWT] [int] NULL,
			[Workspace_Sync_Waits_AWT] [int] NULL,
			[Transaction_Owernship_Waits_AWT] [int] NULL,
			[Lock_Waits_WIP] [int] NULL,
			[Memory_Grant_Queue_WIP] [int] NULL,
			[Thread_Safe_Memory_Grants_WIP] [int] NULL,
			[Log_Writes_Waits_WIP] [int] NULL,
			[Log_Buffer_Waits_WIP] [int] NULL,
			[Network_IO_Waits_WIP] [int] NULL,
			[Page_IO_Latch_Waits_WIP] [int] NULL,
			[Page_Latch_Waits_WIP] [int] NULL,
			[Non_Page_Latch_Waits_WIP] [int] NULL,
			[Wait_For_Worker_WIP] [int] NULL,
			[Workspace_Sync_Waits_WIP] [int] NULL,
			[Transaction_Owernship_Waits_WIP] [int] NULL,
			[MemoryGrantsPending] int NULL
		 CONSTRAINT [PK_Performance_Counter] PRIMARY KEY CLUSTERED 
		(
			[SQL_Server_Name] ASC,
			[CreatedOn] ASC
		)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90) ON [PRIMARY]
		) ON [PRIMARY]
END
GO


if object_id('dbo.Process_Monitor_Adhoc') is null
begin
RAISERROR('	CREATING table [dbo].[Process_Monitor_Adhoc]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[Process_Monitor_Adhoc](
	[Process_Monitor_Adhoc_id] [int] IDENTITY(1,1) NOT NULL,
	[session_id] [smallint] NOT NULL,
	[status] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[host_name] [varchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[login_name] [varchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[wait_type] [varchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wait_resource] [varchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[wait_time] [int] NOT NULL,
	[start_time] [datetime] NOT NULL,
	[totallogical_reads] [bigint] NULL,
	[totalWrites] [bigint] NULL,
	[totalCPU] [int] NULL,
	[writes_in_tempdb] [bigint] NULL,
	[parallelquery] [int] NULL,
	[blocking_session_id] [int] NULL,
	[statement_text] [varchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[blocking_text] [varchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[sql_text] [varchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[transaction_id] [bigint] NOT NULL,
	[percent_complete] [real] NOT NULL,
	[estimated_completion_time] [bigint] NOT NULL,
	[scheduler_id] [int] NULL,
	[statement_text_xml] [xml] NULL,
	[sql_text_xml] [xml] NULL,
	[blocking_text_xml] [xml] NULL,
	[inserted_dt] [datetime] NOT NULL,
	[execution_plan] [xml] NULL,
	[plan_handle] [varbinary](64) NULL,
	[granted_query_memory] [int] NULL,
 CONSTRAINT [PK_Process_Monitor_Adhoc] PRIMARY KEY CLUSTERED 
(
	[Process_Monitor_Adhoc_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 CREATE NONCLUSTERED INDEX [idx_Process_Monitor_Adhoc_host_name_login_name] ON [dbo].[Process_Monitor_Adhoc]
(
	[host_name] ASC,
	[login_name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] CREATE NONCLUSTERED INDEX [idx_Process_Monitor_Adhoc_inserted_dt] ON [dbo].[Process_Monitor_Adhoc]
(
	[inserted_dt] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] CREATE NONCLUSTERED INDEX [idx_Process_Monitor_Adhoc_start_time_session_id] ON [dbo].[Process_Monitor_Adhoc]
(
	[start_time] ASC,
	[session_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[Process_Monitor_Adhoc] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.PurgeDetail') is null
begin
RAISERROR('	CREATING table [dbo].[PurgeDetail]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[PurgeDetail](
	[Id] [int] IDENTITY(1,1) NOT NULL,
	[DBName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[SchemaName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[TableName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[RunDate] [datetime] NOT NULL,
	[BatchSize] [int] NOT NULL,
 CONSTRAINT [PK_PurgeDetail] PRIMARY KEY CLUSTERED 
(
	[Id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[PurgeDetail] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.PurgeTransaction') is null
begin
RAISERROR('	CREATING table [dbo].[PurgeTransaction]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[PurgeTransaction](
	[PurgeDetailId] [int] NOT NULL,
	[StartDate] [datetime] NOT NULL,
	[EndDate] [datetime] NOT NULL,
	[RowAffected] [int] NOT NULL,
 CONSTRAINT [PK_PurgeTransaction] PRIMARY KEY CLUSTERED 
(
	[PurgeDetailId] ASC,
	[StartDate] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 ALTER TABLE [dbo].[PurgeTransaction]  WITH CHECK ADD  CONSTRAINT [FK_PurgeTransaction_PurgeDetail] FOREIGN KEY([PurgeDetailId])
REFERENCES [dbo].[PurgeDetail] ([Id]) ALTER TABLE [dbo].[PurgeTransaction] CHECK CONSTRAINT [FK_PurgeTransaction_PurgeDetail]
end
else
RAISERROR ('	Table [dbo].[PurgeTransaction] already exists.',10,1) WITH NOWAIT;
GO


GO


IF OBJECT_ID('dbo.RefreshBackupLocations') IS NULL
BEGIN
	RAISERROR('	CREATING table [dbo].[RefreshBackupLocations]',10,1) WITH NOWAIT
	SET ANSI_NULLS ON 
	SET QUOTED_IDENTIFIER ON 

	CREATE TABLE [dbo].[RefreshBackupLocations](
		[DatabaseName] [sysname] NOT NULL,
		[FullbackupPath] [nvarchar](500) NULL,
		[DiffbackupPath] [nvarchar](500) NULL,
		[SecondaryFullbackupPath] [nvarchar](500) NULL,
		[SecondaryDiffbackupPath] [nvarchar](500) NULL

	 CONSTRAINT [PK_RefreshBackupLocations] PRIMARY KEY CLUSTERED 
	(
		[DatabaseName] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
	) ON [PRIMARY]
END
ELSE
	RAISERROR ('	Table [dbo].[RefreshBackupLocations] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.restartlog') is null
begin
RAISERROR('	CREATING table [dbo].[restartlog]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[restartlog](
	[InstanceName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[ShutdownTime] [datetime] NOT NULL,
	[StartupTime] [datetime] NOT NULL,
	[CreatedOn] [datetime] NOT NULL
) ON [PRIMARY]
 ALTER TABLE [dbo].[restartlog] ADD  CONSTRAINT [DF_restartlog_CreatedOn]  DEFAULT (getdate()) FOR [CreatedOn]
end
else
RAISERROR ('	Table [dbo].[restartlog] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.ring_buffer_connectivity') is null
begin
RAISERROR('	CREATING table [dbo].[ring_buffer_connectivity]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[ring_buffer_connectivity](
	[ts] [bigint] NOT NULL,
	[eventtime] [datetimeoffset](3) NOT NULL,
	[type] [varchar](20) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[source] [varchar](20) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[is_client] [tinyint] NULL,
	[spid] [int] NOT NULL,
	[os_error] [int] NULL,
	[sni_error] [int] NULL,
	[sni_provider] [int] NOT NULL,
	[state] [int] NULL,
	[hostname] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[remote_port] [int] NOT NULL,
	[local_port] [int] NOT NULL,
	[input_buf_error] [int] NULL,
	[output_buf_error] [int] NULL,
	[input_buf_bytes] [int] NULL,
	[phys_conn_killed] [bit] NULL,
	[disconn_due_to_read_error] [bit] NULL,
	[net_error_input_strm] [bit] NULL,
	[error_before_login] [bit] NULL,
	[session_killed] [bit] NULL,
	[routing_completed] [bit] NULL,
	[normal_disconn] [bit] NULL,
	[normal_logout] [varchar](3) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[total_ms] [int] NULL,
	[enqueue_ms] [int] NULL,
	[net_writes_ms] [int] NULL,
	[net_reads_ms] [int] NULL,
	[login_trg_res_gov_ms] [int] NULL,
	[ssl_total_ms] [int] NULL,
	[ssl_enqueue_ms] [int] NULL,
	[ssl_net_writes_ms] [int] NULL,
	[ssl_net_reads_ms] [int] NULL,
	[ssl_sec_api_ms] [int] NULL,
	[sspi_total_ms] [int] NULL,
	[sspi_enqueue_ms] [int] NULL,
	[sspi_net_writes_ms] [int] NULL,
	[sspi_net_reads_ms] [int] NULL,
	[sspi_sec_api_ms] [int] NULL
) ON [PRIMARY]
 CREATE CLUSTERED INDEX [ring_buffer_connectivity_ci] ON [dbo].[ring_buffer_connectivity]
(
	[eventtime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[ring_buffer_connectivity] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.ring_buffer_security_error') is null
begin
RAISERROR('	CREATING table [dbo].[ring_buffer_security_error]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[ring_buffer_security_error](
	[ts] [bigint] NOT NULL,
	[eventtime] [datetimeoffset](3) NOT NULL,
	[spid] [int] NOT NULL,
	[error_code] [varchar](10) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[api_name] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[calling_api_name] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL
) ON [PRIMARY]
 CREATE CLUSTERED INDEX [ring_buffer_security_error_ci] ON [dbo].[ring_buffer_security_error]
(
	[eventtime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[ring_buffer_security_error] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.sched_mon_cpu_util') is null
begin
RAISERROR('	CREATING table [dbo].[sched_mon_cpu_util]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[sched_mon_cpu_util](
	[ts] [bigint] NOT NULL,
	[eventtime] [datetimeoffset](3) NOT NULL,
	[system_idle_cpu] [tinyint] NOT NULL,
	[sql_cpu_utilization] [tinyint] NOT NULL,
	[usertime] [bigint] NOT NULL,
	[kerneltime] [bigint] NOT NULL,
 CONSTRAINT [sched_mon_cpu_util_PK] PRIMARY KEY CLUSTERED 
(
	[eventtime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[sched_mon_cpu_util] already exists.',10,1) WITH NOWAIT;
GO


IF OBJECT_ID('dbo.Security_Drop') IS NULL
BEGIN
	RAISERROR('	CREATING table [dbo].[Security_Drop]',10,1) WITH NOWAIT
	SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON 
	
	CREATE TABLE [dbo].[Security_Drop](
	[Command_ID] [int] IDENTITY(1,1) NOT NULL,
	[Command] [nvarchar](max) NULL,
	[CreatedOn] [datetime] NULL,
	[DatabaseName] [sysname] NOT NULL,
		 CONSTRAINT [PK_Security_Drop] PRIMARY KEY CLUSTERED 
		([Command_ID] ASC
		)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
		) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
END
ELSE
RAISERROR ('	Table [dbo].[Security_Drop] already exists.',10,1) WITH NOWAIT;
GO


IF OBJECT_ID('dbo.Security_Restore') IS NULL
BEGIN
	RAISERROR('	CREATING table [dbo].[Security_Restore]',10,1) WITH NOWAIT
	SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON 

	CREATE TABLE [dbo].[Security_Restore](
	[Command_ID] [int] IDENTITY(1,1) NOT NULL,
	[Command] [nvarchar](max) NULL,
	[CreatedOn] [datetime] NULL,
	[DatabaseName] [sysname] NOT NULL,
 		CONSTRAINT [PK_Security_Restore] PRIMARY KEY CLUSTERED 
		([Command_ID] ASC
		)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, 		ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
		) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
END
ELSE
RAISERROR ('	Table [dbo].[Security_Restore] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.srv_databases') is null
begin
RAISERROR('	CREATING table [dbo].[srv_databases]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[srv_databases](
	[srv_databases_id] [int] IDENTITY(1,1) NOT NULL,
	[collection_session_id] [int] NOT NULL,
	[database_id] [int] NOT NULL,
	[name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[is_read_only] [tinyint] NULL,
	[state] [tinyint] NULL,
 CONSTRAINT [srv_databases_pk] PRIMARY KEY CLUSTERED 
(
	[srv_databases_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[srv_databases] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.statistics_to_track') is null
begin
RAISERROR('	CREATING table [dbo].[statistics_to_track]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[statistics_to_track](
	[database_id] [smallint] NOT NULL,
	[schema_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[stats_id] [int] NULL,
	[database_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[schema_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[object_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[stats_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[enabled] [tinyint] NOT NULL,
	[ins_date] [datetime] NOT NULL,
 CONSTRAINT [statistics_to_track_UK] UNIQUE CLUSTERED 
(
	[object_id] ASC,
	[database_id] ASC,
	[stats_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 ALTER TABLE [dbo].[statistics_to_track] ADD  DEFAULT (getdate()) FOR [ins_date]
end
else
RAISERROR ('	Table [dbo].[statistics_to_track] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.statistics_tracked') is null
begin
RAISERROR('	CREATING table [dbo].[statistics_tracked]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[statistics_tracked](
	[runtime] [datetime] NOT NULL,
	[database_id] [smallint] NOT NULL,
	[object_id] [int] NOT NULL,
	[stats_id] [int] NOT NULL,
	[stats_date] [datetime] NULL,
	[stats_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[row_count] [bigint] NULL,
	[page_count] [bigint] NULL,
	[stats_stream] [varbinary](max) NULL,
 CONSTRAINT [statistics_tracked_PK] PRIMARY KEY CLUSTERED 
(
	[runtime] ASC,
	[database_id] ASC,
	[object_id] ASC,
	[stats_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [statistics_tracked_UK] UNIQUE NONCLUSTERED 
(
	[object_id] ASC,
	[database_id] ASC,
	[stats_id] ASC,
	[stats_date] ASC,
	[runtime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[statistics_tracked] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.statistics_tracked_size') is null
begin
RAISERROR('	CREATING table [dbo].[statistics_tracked_size]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[statistics_tracked_size](
	[runtime] [datetime] NOT NULL,
	[database_id] [smallint] NOT NULL,
	[object_id] [int] NOT NULL,
	[stats_id] [int] NOT NULL,
	[dpages] [bigint] NULL,
	[rowcnt] [bigint] NULL,
	[rowmodctr] [bigint] NULL,
 CONSTRAINT [statistics_tracked_size_PK] PRIMARY KEY CLUSTERED 
(
	[runtime] ASC,
	[database_id] ASC,
	[object_id] ASC,
	[stats_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [statistics_tracked_size_UK] UNIQUE NONCLUSTERED 
(
	[object_id] ASC,
	[database_id] ASC,
	[stats_id] ASC,
	[runtime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[statistics_tracked_size] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.WaitStatistics') is null
begin
RAISERROR('	CREATING table [dbo].[WaitStatistics]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[WaitStatistics](
	[WaitStatTypeId] [smallint] NOT NULL,
	[WaitingTaksCount] [bigint] NOT NULL,
	[WaitTime_ms] [bigint] NOT NULL,
	[MaxWaitTime_ms] [bigint] NOT NULL,
	[SignalWaitTime_ms] [bigint] NOT NULL,
	[CaptureDate] [datetime] NOT NULL,
	[SystemStartDate] [datetime] NOT NULL
) ON [PRIMARY]
 CREATE CLUSTERED INDEX [IXC_WaitStatistics] ON [dbo].[WaitStatistics]
(
	[CaptureDate] DESC,
	[WaitStatTypeId] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ALTER TABLE [dbo].[WaitStatistics] ADD  CONSTRAINT [DF_WaitStatistics_CaptureDate]  DEFAULT (getdate()) FOR [CaptureDate]
end
else
RAISERROR ('	Table [dbo].[WaitStatistics] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.waitstats') is null
begin
RAISERROR('	CREATING table [dbo].[waitstats]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[waitstats](
	[InstanceName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[wait_type] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[waiting_tasks_count] [bigint] NOT NULL,
	[wait_time_ms] [bigint] NOT NULL,
	[max_wait_time_ms] [bigint] NOT NULL,
	[signal_wait_time_ms] [bigint] NOT NULL,
	[CreatedOn] [datetime] NOT NULL
) ON [PRIMARY]
 ALTER TABLE [dbo].[waitstats] ADD  CONSTRAINT [DF_waitstats_CreatedOn]  DEFAULT (getdate()) FOR [CreatedOn]
end
else
RAISERROR ('	Table [dbo].[waitstats] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.WaitStats_Benign') is null
begin
RAISERROR('	CREATING table [dbo].[WaitStats_Benign]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[WaitStats_Benign](
	[WaitStatTypeName] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[Comment] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[ExcludeGroup] [varchar](40) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [pk_WaitStats_Benign] PRIMARY KEY CLUSTERED 
(
	[WaitStatTypeName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [dbo].[WaitStats_Benign] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.WaitStatType') is null
begin
RAISERROR('	CREATING table [dbo].[WaitStatType]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[WaitStatType](
	[Id] [smallint] IDENTITY(1,1) NOT NULL,
	[Name] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[CanIgnore] [bit] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[Id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 SET ANSI_PADDING ON
 CREATE UNIQUE NONCLUSTERED INDEX [IXU_WaitStatType] ON [dbo].[WaitStatType]
(
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ALTER TABLE [dbo].[WaitStatType] ADD  CONSTRAINT [DF_WaitStatType_CanIgnore]  DEFAULT ((0)) FOR [CanIgnore]
end
else
RAISERROR ('	Table [dbo].[WaitStatType] already exists.',10,1) WITH NOWAIT;
GO


if object_id('dbo.WhoIsActive') is null
begin
RAISERROR('	CREATING table [dbo].[WhoIsActive]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [dbo].[WhoIsActive](
	[dd hh:mm:ss.mss] [varchar](8000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[session_id] [smallint] NOT NULL,
	[sql_text] [xml] NULL,
	[sql_command] [xml] NULL,
	[login_name] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[wait_info] [nvarchar](4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[CPU] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[tempdb_allocations] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[tempdb_current] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[blocking_session_id] [smallint] NULL,
	[reads] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[writes] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[physical_reads] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[used_memory] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[status] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[open_tran_count] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[percent_complete] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[host_name] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[database_name] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[program_name] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[start_time] [datetime] NOT NULL,
	[login_time] [datetime] NULL,
	[request_id] [int] NULL,
	[collection_time] [datetime] NOT NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 CREATE CLUSTERED INDEX [IXC_collection_time] ON [dbo].[WhoIsActive]
(
	[collection_time] DESC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [dbo].[WhoIsActive] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Infra.Numbers') is null
begin
RAISERROR('	CREATING table [Infra].[Numbers]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Infra].[Numbers](
	[Num] [int] IDENTITY(1,1) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[Num] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [Infra].[Numbers] already exists.',10,1) WITH NOWAIT;
GO
if (select [rows] from sys.partitions where [object_id] = object_id('Infra.Numbers') and index_id = 1) < 1000000
begin
	truncate table Infra.Numbers
	if not exists (select * from sys.columns where [object_id] = object_id('Infra.Numbers') and name = 'a')
		exec('alter table Infra.Numbers add a bit')

	exec('insert into Infra.Numbers
			select top 1000000 null
			from master.sys.all_columns c
				cross join master.sys.all_columns c1

			alter table Infra.Numbers drop column a')

	ALTER INDEX ALL ON Infra.Numbers rebuild
end
GO


if object_id('Licensing.LicensingKey') is null
begin
RAISERROR('	CREATING table [Licensing].[LicensingKey]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Licensing].[LicensingKey](
	[LCK_InsertDate] [datetime] NOT NULL,
	[LCK_Key] [varbinary](max) NOT NULL,
 CONSTRAINT [PK_LicensingKey] PRIMARY KEY CLUSTERED 
(
	[LCK_InsertDate] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

end
else
RAISERROR ('	Table [Licensing].[LicensingKey] already exists.',10,1) WITH NOWAIT;
GO


if object_id('mon.DiskSpace') is null
begin
RAISERROR('	CREATING table [mon].[DiskSpace]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [mon].[DiskSpace](
	[InstanceName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[CreatedOn] [datetime] NOT NULL,
	[Drive] [varchar](500) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[TotalSize_mb] [decimal](20, 2) NOT NULL,
	[Free_mb] [decimal](20, 2) NOT NULL
) ON [PRIMARY]
 CREATE CLUSTERED INDEX [IXC_DiskSpace_CreatedOn] ON [mon].[DiskSpace]
(
	[CreatedOn] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [mon].[DiskSpace] already exists.',10,1) WITH NOWAIT;
GO


if object_id('mon.dm_exec_query_memory_grants') is null
begin
RAISERROR('	CREATING table [mon].[dm_exec_query_memory_grants]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [mon].[dm_exec_query_memory_grants](
	[collection_session_id] [int] NULL,
	[session_id] [smallint] NULL,
	[request_id] [int] NULL,
	[scheduler_id] [int] NULL,
	[dop] [smallint] NULL,
	[request_time] [datetime] NULL,
	[grant_time] [datetime] NULL,
	[requested_memory_kb] [bigint] NULL,
	[granted_memory_kb] [bigint] NULL,
	[required_memory_kb] [bigint] NULL,
	[used_memory_kb] [bigint] NULL,
	[max_used_memory_kb] [bigint] NULL,
	[query_cost] [float] NULL,
	[timeout_sec] [int] NULL,
	[resource_semaphore_id] [smallint] NULL,
	[queue_id] [smallint] NULL,
	[wait_order] [int] NULL,
	[is_next_candidate] [bit] NULL,
	[wait_time_ms] [bigint] NULL,
	[plan_handle] [varbinary](64) NULL,
	[sql_handle] [varbinary](64) NULL,
	[group_id] [int] NULL,
	[pool_id] [int] NULL,
	[is_small] [bit] NULL,
	[ideal_memory_kb] [bigint] NULL,
	[reserved_worker_count] [int] NULL,
	[used_worker_count] [int] NULL,
	[max_used_worker_count] [int] NULL,
	[reserved_node_bitmap] [bigint] NULL,
	[dm_exec_query_memory_grants_id] [int] IDENTITY(1,1) NOT NULL,
 CONSTRAINT [dm_exec_query_memory_grants_pk] PRIMARY KEY CLUSTERED 
(
	[dm_exec_query_memory_grants_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [mon].[dm_exec_query_memory_grants] already exists.',10,1) WITH NOWAIT;
GO


if object_id('mon.dm_exec_query_resource_semaphores') is null
begin
RAISERROR('	CREATING table [mon].[dm_exec_query_resource_semaphores]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [mon].[dm_exec_query_resource_semaphores](
	[collection_session_id] [int] NULL,
	[resource_semaphore_id] [smallint] NULL,
	[target_memory_kb] [bigint] NULL,
	[max_target_memory_kb] [bigint] NULL,
	[total_memory_kb] [bigint] NULL,
	[available_memory_kb] [bigint] NULL,
	[granted_memory_kb] [bigint] NULL,
	[used_memory_kb] [bigint] NULL,
	[grantee_count] [int] NULL,
	[waiter_count] [int] NULL,
	[timeout_error_count] [bigint] NULL,
	[forced_grant_count] [bigint] NULL,
	[pool_id] [int] NULL,
	[dm_exec_query_resource_semaphores_id] [int] IDENTITY(1,1) NOT NULL,
 CONSTRAINT [dm_exec_query_resource_semaphores_pk] PRIMARY KEY CLUSTERED 
(
	[dm_exec_query_resource_semaphores_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [mon].[dm_exec_query_resource_semaphores] already exists.',10,1) WITH NOWAIT;
GO


if object_id('mon.exec_plan_requests') is null
begin
RAISERROR('	CREATING table [mon].[exec_plan_requests]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [mon].[exec_plan_requests](
	[run_time] [datetime] NOT NULL,
	[session_id] [smallint] NOT NULL,
	[request_id] [int] NOT NULL,
	[start_time] [datetime] NOT NULL,
	[status] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[command] [varchar](32) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[statement_start_offset] [int] NULL,
	[statement_end_offset] [int] NULL,
	[database_id] [smallint] NOT NULL,
	[blocking_session_id] [smallint] NULL,
	[wait_type] [varchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wait_time] [int] NOT NULL,
	[wait_resource] [varchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[granted_query_memory] [int] NOT NULL,
	[transaction_id] [bigint] NOT NULL,
	[open_transaction_count] [int] NOT NULL,
	[transaction_isolation_level] [smallint] NOT NULL,
	[lock_timeout] [int] NOT NULL,
	[deadlock_priority] [int] NOT NULL,
	[scheduler_id] [int] NOT NULL,
	[cpu_time] [int] NOT NULL,
	[reads] [bigint] NOT NULL,
	[writes] [bigint] NOT NULL,
	[logical_reads] [bigint] NOT NULL,
	[row_count] [bigint] NOT NULL,
	[group_id] [int] NOT NULL,
	[nest_level] [int] NOT NULL,
	[current_max_ecid] [int] NULL,
	[percent_complete] [real] NOT NULL,
	[estimated_completion_time] [bigint] NOT NULL,
	[query_hash] [binary](8) NULL,
	[query_plan_hash] [binary](8) NULL,
	[plan_handle] [varbinary](64) NULL,
	[sql_handle] [varbinary](64) NULL,
	[context_info] [varbinary](128) NULL,
 CONSTRAINT [exec_plan_requests_PK] PRIMARY KEY CLUSTERED 
(
	[run_time] ASC,
	[session_id] ASC,
	[request_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [mon].[exec_plan_requests] already exists.',10,1) WITH NOWAIT;
GO


if object_id('mon.exec_plan_waiting_tasks') is null
begin
RAISERROR('	CREATING table [mon].[exec_plan_waiting_tasks]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [mon].[exec_plan_waiting_tasks](
	[run_time] [datetime] NOT NULL,
	[session_id] [smallint] NOT NULL,
	[exec_context_id] [int] NOT NULL,
	[waiting_task_address] [varbinary](8) NOT NULL,
	[wait_duration_ms] [bigint] NULL,
	[wait_type] [varchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[blocking_session_id] [smallint] NULL,
	[blocking_exec_context_id] [int] NULL,
	[resource_description] [varchar](3072) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [exec_plan_waiting_tasks_PK] PRIMARY KEY CLUSTERED 
(
	[run_time] ASC,
	[session_id] ASC,
	[exec_context_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [mon].[exec_plan_waiting_tasks] already exists.',10,1) WITH NOWAIT;
GO


if object_id('mon.ExecRequests') is null
begin
RAISERROR('	CREATING table [mon].[ExecRequests]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [mon].[ExecRequests](
	[CreatedOn] [datetime] NOT NULL,
	[session_id] [int] NULL,
	[RunTimeMinutes] [int] NULL,
	[RunDuration] [varchar](15) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DatabaseName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[blocking_session_id] [int] NULL,
	[status] [nvarchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[open_transaction_count] [int] NULL,
	[host_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[login_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[program_name] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wait_type] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wait_resource] [nvarchar](256) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[wait_time] [int] NULL,
	[start_time] [datetime] NULL,
	[totallogical_reads] [bigint] NULL,
	[TotalLogicalReads2] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[totalWrites] [bigint] NULL,
	[totalCPU] [bigint] NULL,
	[writes_in_tempdb] [bigint] NULL,
	[parallelquery] [smallint] NULL,
	[statement_text] [varchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[blocking_text] [varchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[sql_text] [varchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[transaction_id] [bigint] NULL,
	[percent_complete] [real] NULL,
	[estimated_completion_time] [bigint] NULL,
	[scheduler_id] [int] NULL,
	[plan_handle] [varbinary](64) NULL,
	[granted_query_memory] [int] NULL,
	[ExecutionPlan] [xml] NULL,
	[statement_text_xml] [xml] NULL,
	[sql_text_xml] [xml] NULL,
	[last_request_start_time] [datetime] NULL,
	[last_request_end_time] [datetime] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 CREATE CLUSTERED INDEX [IXC_EXECREQUEST] ON [mon].[ExecRequests]
(
	[CreatedOn] ASC,
	[session_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [mon].[ExecRequests] already exists.',10,1) WITH NOWAIT;
GO


if object_id('mon.Process_Schedulers') is null
begin
RAISERROR('	CREATING table [mon].[Process_Schedulers]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [mon].[Process_Schedulers](
	[scheduler_id] [int] NOT NULL,
	[current_tasks_count] [int] NOT NULL,
	[runnable_tasks_count] [int] NOT NULL,
	[work_queue_count] [bigint] NOT NULL,
	[pending_disk_io_count] [int] NOT NULL,
	[current_workers_count] [int] NOT NULL,
	[active_workers_count] [int] NOT NULL,
	[context_switches_count] [int] NOT NULL,
	[preemptive_switches_count] [int] NOT NULL,
	[status] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[load_factor] [int] NOT NULL,
	[CreatedOn] [datetime] NOT NULL
) ON [PRIMARY]
 CREATE CLUSTERED INDEX [IXC_Process_Schedulers] ON [mon].[Process_Schedulers]
(
	[CreatedOn] ASC,
	[scheduler_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ALTER TABLE [mon].[Process_Schedulers] ADD  CONSTRAINT [DF_Process_Schedulers_CreatedOn]  DEFAULT (getdate()) FOR [CreatedOn]
end
else
RAISERROR ('	Table [mon].[Process_Schedulers] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Monitoring.DeadlockFrames') is null
begin
RAISERROR('	CREATING table [Monitoring].[DeadlockFrames]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Monitoring].[DeadlockFrames](
	[DRF_ID] [int] IDENTITY(1,1) NOT NULL,
	[DRF_DLK_ID] [int] NOT NULL,
	[DRF_DLP_ID] [int] NOT NULL,
	[DRF_ProcName] [nvarchar](386) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DRF_Line] [int] NULL,
	[DRF_StmtStart] [bigint] NULL,
	[DRF_StmtEnd] [bigint] NULL,
	[DRF_SQLHandle] [varbinary](64) NULL,
 CONSTRAINT [PK_DeadlockFrames] PRIMARY KEY NONCLUSTERED 
(
	[DRF_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 SET ANSI_PADDING ON
 CREATE UNIQUE CLUSTERED INDEX [IX_DeadlockFrames_DRF_DLK_ID#DRF_DLP_ID#DRF_ProcName#DRF_ID] ON [Monitoring].[DeadlockFrames]
(
	[DRF_DLK_ID] ASC,
	[DRF_DLP_ID] ASC,
	[DRF_ProcName] ASC,
	[DRF_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Monitoring].[DeadlockFrames] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Monitoring.DeadlockProcesses') is null
begin
RAISERROR('	CREATING table [Monitoring].[DeadlockProcesses]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Monitoring].[DeadlockProcesses](
	[DLP_ID] [int] IDENTITY(1,1) NOT NULL,
	[DLP_DLK_ID] [int] NULL,
	[DLP_ProcessID] [varchar](23) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_SPID] [int] NULL,
	[DLP_SBID] [int] NULL,
	[DLP_ECID] [int] NULL,
	[DLP_TaskPriority] [smallint] NULL,
	[DLP_LogUsed] [bigint] NULL,
	[DLP_WaitResource] [varchar](1000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_WaitTime] [int] NULL,
	[DLP_OwnerID] [bigint] NULL,
	[DLP_TransactionName] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_LastTranStarted] [datetime] NULL,
	[DLP_XDES] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_LockMode] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_SchedulerID] [smallint] NULL,
	[DLP_KPID] [bigint] NULL,
	[DLP_Status] [varchar](20) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_Priority] [smallint] NULL,
	[DLP_TranCount] [tinyint] NULL,
	[DLP_LastBatchStarted] [datetime] NULL,
	[DLP_LastBatchCompleted] [datetime] NULL,
	[DLP_LastAttention] [datetime] NULL,
	[DLP_ClientApp] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_HostName] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_HostPID] [bigint] NULL,
	[DLP_LoginName] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_IsolationLevel] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_XactID] [bigint] NULL,
	[DLP_DatabaseID] [int] NULL,
	[DLP_DatabaseName] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_LockTimeout] [bigint] NULL,
	[DLP_ClientOption1] [int] NULL,
	[DLP_ClientOption2] [int] NULL,
	[DLP_InputBuffer] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLP_IsVictim] [int] NULL,
	[DLP_ObjectName] [nvarchar](257) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [PK_DeadlockProcesses] PRIMARY KEY NONCLUSTERED 
(
	[DLP_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 CREATE UNIQUE CLUSTERED INDEX [IX_DeadlockProcesses_DLP_DLK_ID#DLP_ProcessID#DLP_ID] ON [Monitoring].[DeadlockProcesses]
(
	[DLP_DLK_ID] ASC,
	[DLP_ProcessID] ASC,
	[DLP_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Monitoring].[DeadlockProcesses] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Monitoring.DeadlockProcessResources') is null
begin
RAISERROR('	CREATING table [Monitoring].[DeadlockProcessResources]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Monitoring].[DeadlockProcessResources](
	[DPR_ID] [int] IDENTITY(1,1) NOT NULL,
	[DPR_DLK_ID] [int] NOT NULL,
	[DPR_DLP_ID] [int] NOT NULL,
	[DPR_DLR_ID] [int] NOT NULL,
	[DPR_IsOwner] [bit] NULL,
	[DPR_Mode] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DPR_RequestType] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [PK_DeadlockProcessResources] PRIMARY KEY NONCLUSTERED 
(
	[DPR_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 CREATE UNIQUE CLUSTERED INDEX [IX_DeadlockProcessResources_DPR_DLK_ID#DPR_DLP_ID#DPR_DLR_ID#DPR_IsOwner#DPR_ID] ON [Monitoring].[DeadlockProcessResources]
(
	[DPR_DLK_ID] ASC,
	[DPR_DLP_ID] ASC,
	[DPR_DLR_ID] ASC,
	[DPR_IsOwner] ASC,
	[DPR_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Monitoring].[DeadlockProcessResources] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Monitoring.DeadlockResources') is null
begin
RAISERROR('	CREATING table [Monitoring].[DeadlockResources]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Monitoring].[DeadlockResources](
	[DLR_ID] [int] IDENTITY(1,1) NOT NULL,
	[DLR_DLK_ID] [int] NOT NULL,
	[DLR_DRT_ID] [tinyint] NULL,
	[DLR_ResourceID] [varchar](20) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLR_DatabaseID] [int] NULL,
	[DLR_Mode] [nvarchar](60) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLR_SubResource] [varchar](30) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLR_ObjectID] [int] NULL,
	[DLR_ObjectName] [nvarchar](386) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLR_LockPartition] [varchar](25) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLR_FileID] [int] NULL,
	[DLR_PageID] [int] NULL,
	[DLR_ASsociatedObjectId] [bigint] NULL,
	[DLR_HOBT] [bigint] NULL,
	[DLR_IndexName] [nvarchar](128) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLR_DatabasePrincipalID] [int] NULL,
	[DLR_Hash] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[DLR_MetadataLockInfo] [xml] NULL,
 CONSTRAINT [PK_DeadlockResources] PRIMARY KEY NONCLUSTERED 
(
	[DLR_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 CREATE UNIQUE CLUSTERED INDEX [IX_DeadlockResources_DLR_DLK_ID#DLR_ResourceID#DLR_ID] ON [Monitoring].[DeadlockResources]
(
	[DLR_DLK_ID] ASC,
	[DLR_ResourceID] ASC,
	[DLR_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Monitoring].[DeadlockResources] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Monitoring.DeadlockResourceTypes') is null
begin
RAISERROR('	CREATING table [Monitoring].[DeadlockResourceTypes]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Monitoring].[DeadlockResourceTypes](
	[DRT_ID] [tinyint] NOT NULL,
	[DRT_Name] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
 CONSTRAINT [PK_DeadlockResourceTypes] PRIMARY KEY CLUSTERED 
(
	[DRT_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 CREATE UNIQUE NONCLUSTERED INDEX [IX_PK_DeadlockResourceTypes#DRT_Name] ON [Monitoring].[DeadlockResourceTypes]
(
	[DRT_Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Monitoring].[DeadlockResourceTypes] already exists.',10,1) WITH NOWAIT;
GO


if object_id('Monitoring.Deadlocks') is null
begin
RAISERROR('	CREATING table [Monitoring].[Deadlocks]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [Monitoring].[Deadlocks](
	[DLK_ID] [int] IDENTITY(1,1) NOT NULL,
	[DLK_DateTime] [datetime2](3) NULL,
	[DLK_Graph] [xml] NOT NULL,
 CONSTRAINT [PK_Deadlocks] PRIMARY KEY NONCLUSTERED 
(
	[DLK_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
 CREATE UNIQUE CLUSTERED INDEX [IX_Deadlocks_DLK_DateTime#DLK_ID] ON [Monitoring].[Deadlocks]
(
	[DLK_DateTime] ASC,
	[DLK_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
else
RAISERROR ('	Table [Monitoring].[Deadlocks] already exists.',10,1) WITH NOWAIT;
GO


if object_id('OpsControl.OperationLog') is null
begin
RAISERROR('	CREATING table [OpsControl].[OperationLog]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [OpsControl].[OperationLog](
	[OPL_ID] [int] IDENTITY(1,1) NOT NULL,
	[OPL_OPS_ID] [smallint] NOT NULL,
	[OPL_Identifier1] [int] NULL,
	[OPL_Identifier2] [int] NULL,
	[OPL_StartDateTime] [datetime2](3) NOT NULL,
	[OPL_EndDateTime] [datetime2](3) NULL,
	[OPL_Info1] [sql_variant] NULL,
	[OPL_Info2] [sql_variant] NULL,
	[OPL_Info3] [sql_variant] NULL,
	[OPL_ErrorMessage] [nvarchar](4000) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
 CONSTRAINT [PK_OperationLog] PRIMARY KEY NONCLUSTERED 
(
	[OPL_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
 CREATE UNIQUE CLUSTERED INDEX [IX_OperationLog_OPL_OPS_ID#OPL_EndDateTime#OPL_ID] ON [OpsControl].[OperationLog]
(
	[OPL_OPS_ID] ASC,
	[OPL_EndDateTime] ASC,
	[OPL_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ALTER TABLE [OpsControl].[OperationLog] ADD  CONSTRAINT [DF_OperationLog_OPL_StartDateTime]  DEFAULT (sysdatetime()) FOR [OPL_StartDateTime]
end
else
RAISERROR ('	Table [OpsControl].[OperationLog] already exists.',10,1) WITH NOWAIT;
GO


if object_id('OpsControl.Operations') is null
begin
RAISERROR('	CREATING table [OpsControl].[Operations]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [OpsControl].[Operations](
	[OPS_ID] [smallint] NOT NULL,
	[OPS_Name] [varchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[OPS_MinutesInterval] [int] NULL,
	[OPS_Script] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[OPS_DynamicColumnsDescription] [xml] NULL,
	[OPS_IsActive] [bit] NULL,
 CONSTRAINT [PK_Operations] PRIMARY KEY CLUSTERED 
(
	[OPS_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

end
else
RAISERROR ('	Table [OpsControl].[Operations] already exists.',10,1) WITH NOWAIT;
GO


if object_id('perf.CPU') is null
begin
RAISERROR('	CREATING table [perf].[CPU]',10,1) WITH NOWAIT
SET ANSI_NULLS ON SET QUOTED_IDENTIFIER ON CREATE TABLE [perf].[CPU](
	[InstanceName] [sysname] COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[CreatedOn] [datetime] NOT NULL,
	[SQLCpu] [tinyint] NOT NULL,
	[OtherCpu] [tinyint] NOT NULL,
 CONSTRAINT [PK_CPU] PRIMARY KEY CLUSTERED 
(
	[InstanceName] ASC,
	[CreatedOn] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

end
else
RAISERROR ('	Table [perf].[CPU] already exists.',10,1) WITH NOWAIT;
GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Infra].[fn_Split]',10,1) WITH NOWAIT;
if object_id('Infra.fn_Split') is null exec('create function [Infra].[fn_Split]() returns table as return (select 1 a)')
GO
  alter function Infra.fn_Split(@Str nvarchar(max),
								@Delimiter varchar(10)) returns table
WITH ENCRYPTION
as
	return
	(select row_number() over (order by Num) ID,
		substring(@Str, Num + datalength(@Delimiter) - datalength(@Delimiter), charindex(@Delimiter, @Str + @Delimiter, Num) - Num) Val
	from Infra.Numbers
	where substring(@Delimiter + @Str, Num, datalength(@Delimiter)) = @Delimiter
		and Num <= len(@Str))

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Infra].[fn_Slash]',10,1) WITH NOWAIT;
if object_id('Infra.fn_Slash') is null exec('create function [Infra].[fn_Slash]() returns int as begin return 1 end')
GO
  alter function Infra.fn_Slash(@Path varchar(1000)) returns varchar(1000)
WITH ENCRYPTION
as
begin
	return @Path + case when @Path like '%\' then '' else '\' end
end

GO


if object_id('Licensing.fn_ValidateLicense') is null
	exec('create function Licensing.fn_ValidateLicense() returns @tab table(dt datetime) as begin return end')
GO
declare @Function nvarchar(max)
set @Function =
'alter function Licensing.fn_ValidateLicense() returns @Lic table(IsValid bit, LicensingExpirationDate datetime)
with encryption
as
begin
    declare @Key varchar(max),
            @YearLocation tinyint,
            @MonthLocation tinyint,
            @DayLocation tinyint,
            @ChecksumLocation tinyint,
            @Letters varchar(100),
            @Date datetime

    select top 1 @Key = convert(varchar(max), LCK_Key)
    from Licensing.LicensingKey
    order by LCK_InsertDate desc

    select @Letters =
        (select char(Num)
            from Infra.Numbers
            where Num between 65 and 90
                or Num between 97 and 122
            for xml path('''')
        )

    select @YearLocation = charindex(substring(@Key COLLATE Latin1_General_CS_AS, 2, 1), @Letters, 1),
        @MonthLocation = charindex(substring(@Key COLLATE Latin1_General_CS_AS, 1, 1), @Letters, 1),
        @DayLocation = charindex(substring(@Key COLLATE Latin1_General_CS_AS, 4, 1), @Letters, 1),
        @ChecksumLocation = charindex(substring(@Key COLLATE Latin1_General_CS_AS, 3, 1), @Letters, 1)

    declare @DecryptKeytable table(KeyID int,
                                    KeyVal tinyint)

    ;with KeyTable as
            (select Num KeyID, substring(@Key, Num, 1) KeyVal
                from Infra.Numbers
                where Num <= len(@Key)
            )
    insert into @DecryptKeytable(KeyID, KeyVal)
    select case when KeyID between @YearLocation and @YearLocation + 3 then KeyID - @YearLocation + 1
                when KeyID between @MonthLocation and @MonthLocation + 1 then KeyID - @MonthLocation + 5
                when KeyID between @DayLocation and @DayLocation + 1 then KeyID - @DayLocation + 7
                when KeyID between @ChecksumLocation and @ChecksumLocation + 5 then KeyID - @ChecksumLocation + 9
        end, (charindex(KeyVal COLLATE Latin1_General_CS_AS, @Letters COLLATE Latin1_General_CS_AS, 1)+9)%10
    from KeyTable
    where KeyID between @YearLocation and @YearLocation + 3
        or KeyID between @MonthLocation and @MonthLocation + 1
        or KeyID between @DayLocation and @DayLocation + 1
        or KeyID between @ChecksumLocation and @ChecksumLocation + 5
    order by 1

    set @Date = cast
        ((select cast(KeyVal as char(1))
            from @DecryptKeytable
            where exists (select *
                            from (select sum(case when KeyID between 5 and 8 then KeyVal else 0 end) ChecksumCheck1,
                                        sum(case when KeyID in (3, 4, 5, 8) then KeyVal else 0 end) ChecksumCheck2,
                                        sum(case when KeyID in (1, 3, 6, 7) then KeyVal else 0 end) ChecksumCheck3,
                                        sum(case KeyID when 9 then KeyVal*10 when 10 then KeyVal else 0 end) Checksum1,
                                        sum(case KeyID when 11 then KeyVal*10 when 12 then KeyVal else 0 end) Checksum2,
                                        sum(case KeyID when 13 then KeyVal*10 when 14 then KeyVal else 0 end) Checksum3
                                    from @DecryptKeytable
                                ) CS
                            where ChecksumCheck1 = Checksum1
                                and ChecksumCheck2 = Checksum2
                                and ChecksumCheck3 = Checksum3
                        )
                and KeyID < 9
            order by KeyID
            for xml path('''')
        ) as datetime)

    insert into @Lic
    select 1, @Date
    where @Date > getdate()

    return
end'

set @Function = replace(replace(replace(replace(replace(replace(replace(replace(replace(
					replace(replace(replace(replace(replace(@Function, char(13)+char(10), ' '), char(9), ' '), '  ', ' ^'), '^ ', ''), '^', '')
				, '@Key', '@' + replace(newid(), '-', ''))
				, '@YearLocation', '@' + replace(newid(), '-', ''))
				, '@MonthLocation', '@' + replace(newid(), '-', ''))
				, '@DayLocation', '@' + replace(newid(), '-', ''))
				, '@ChecksumLocation', '@' + replace(newid(), '-', ''))
				, '@Letters', '@' + replace(newid(), '-', ''))
				, '@Date', '@' + replace(newid(), '-', ''))
				, 'KeyID', 'k' + replace(newid(), '-', ''))
				, 'KeyVal', 'v' + replace(newid(), '-', ''))
set @Function = replace(replace(replace((select Val + '/*' + cast(newid() as varchar(100)) + '*/'
					from Infra.fn_Split(@Function, ' ')
					for xml path('')), '&#x0D;', char(13)), '&lt;', '<'), '&gt;', '>')
exec(@Function)
GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GenerateServerAuditCreateScript]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GenerateServerAuditCreateScript') is null exec('create function [Auditing].[fn_GenerateServerAuditCreateScript]() returns int as begin return 1 end')
GO
alter function Auditing.fn_GenerateServerAuditCreateScript(@AUT_ID int,
													@SessionObjectName nvarchar(128),
													@StoragePath varchar(1000)) returns nvarchar(max)
WITH ENCRYPTION
as
begin
	return (select
			'use master' + char(13)+char(10)
			+ 'create server audit ' + quotename(@SessionObjectName) + char(13)+char(10)
			+ 'to file (filepath = N''' + Infra.fn_Slash(@StoragePath) + ''', maxsize = 100 MB)' + char(13)+char(10)
			+ 'with (queue_delay = 1000, on_failure = continue)' + char(13)+char(10)
			+ 'alter server audit ' + quotename(@SessionObjectName) + ' with (state = on)' + char(13)+char(10)
			+ 'create server audit specification ' + quotename(@SessionObjectName) + char(13)+char(10)
			+ 'for server audit ' + quotename(@SessionObjectName) + char(13)+char(10)+char(9) 
				+ replace(stuff(
				(select char(9) + ', add (' + AET_Name +')' + char(13)+char(10)
					from Auditing.AuditSessions
						inner join Auditing.AuditTemplates on AUT_ID = ASE_AUT_ID
						inner join Auditing.AuditTemplateEvents on ATE_AUT_ID = AUT_ID
						inner join Auditing.EventTypes on AET_ID = ATE_AET_ID
					where AUT_ID = 1
						and ATE_IsActive = 1
						and AET_AES_ID = 2
					for xml path('')),
				1, 3, ''), '&#x0D;', char(13)) + char(13)+char(10)
			+ 'with (state = on)'
			)
end

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GenerateServerAuditDropScript]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GenerateServerAuditDropScript') is null exec('create function [Auditing].[fn_GenerateServerAuditDropScript]() returns int as begin return 1 end')
GO
  alter function Auditing.fn_GenerateServerAuditDropScript(@SessionObjectName nvarchar(128)) returns nvarchar(max)
WITH ENCRYPTION
as
begin
	return ('use master' + char(13)+char(10)
			+ 'if exists (select * from sys.server_audit_specifications where name = ''' + @SessionObjectName + ''')' + char(13)+char(10)
			+ 'begin' + char(13)+char(10)+char(9)
			+ 'alter server audit specification ' + quotename(@SessionObjectName) + ' with (state = off)' + char(13)+char(10)+char(9)
			+ 'drop server audit specification ' + quotename(@SessionObjectName) + char(13)+char(10)
			+ 'end' + char(13)+char(10)
			+ 'if exists (select * from sys.server_audits where name = ''' + @SessionObjectName + ''')' + char(13)+char(10)
			+ 'begin' + char(13)+char(10)+char(9)
			+ 'alter server audit ' + quotename(@SessionObjectName) + ' with (state = off)' + char(13)+char(10)+char(9)
			+ 'drop server audit ' + quotename(@SessionObjectName) + char(13)+char(10)
			+ 'end'
			)
end

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GenerateXESessionCreateScript]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GenerateXESessionCreateScript') is null exec('create function [Auditing].[fn_GenerateXESessionCreateScript]() returns int as begin return 1 end')
GO
  alter function Auditing.fn_GenerateXESessionCreateScript(@AUT_ID int,
													@SessionObjectName nvarchar(128),
													@StoragePath varchar(1000)) returns nvarchar(max)
WITH ENCRYPTION
as
begin
	return (select 'create event session ' + quotename(@SessionObjectName) + ' on server ' + char(13)+char(10)+char(9)
			+ replace(replace(replace(replace(stuff(
			(select char(9) + ', add event ' + AET_Name + '('
					+ isnull(char(13)+char(10)+char(9)+'action(' + ATE_AddedColumns + ')', '')
					+ isnull(char(13)+char(10)+char(9)+'where(' + ATE_Filter + ')', '')
					 + char(13)+char(10)+char(9) + ')' + char(13)+char(10)
				from Auditing.AuditSessions
					inner join Auditing.AuditTemplates on AUT_ID = ASE_AUT_ID
					inner join Auditing.AuditTemplateEvents on ATE_AUT_ID = AUT_ID
					inner join Auditing.EventTypes on AET_ID = ATE_AET_ID
				where AUT_ID = @AUT_ID
					and ATE_IsActive = 1
					and AET_AES_ID = 1
				for xml path('')), 1, 3, '')
			, '&#x0D;', char(13)), '&gt;', '>'), '&lt;', '<'), '&amp;', '&')
			+ 'add target package0.event_file(set filename=N''' + @StoragePath + @SessionObjectName + ''',max_file_size=(100),max_rollover_files=(2147483647))' + char(13)+char(10)
			+ 'with (max_memory=2048 kb,event_retention_mode=allow_single_event_loss, startup_state=on)' +char(13)+char(10)
			+ 'alter event session ' + quotename(@SessionObjectName) + ' on server state=start'
			)
end

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GenerateXESessionDropScript]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GenerateXESessionDropScript') is null exec('create function [Auditing].[fn_GenerateXESessionDropScript]() returns int as begin return 1 end')
GO
  alter function Auditing.fn_GenerateXESessionDropScript(@SessionObjectName nvarchar(128)) returns nvarchar(max)
WITH ENCRYPTION
as
begin
	return (select 'if exists (select * from sys.server_event_sessions where name = ''' + @SessionObjectName + ''')' + char(13)+char(10)+char(9)
			+ 'drop event session ' + quotename(@SessionObjectName) + ' on server')
end

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetAuditTrailIDByValue]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetAuditTrailIDByValue') is null exec('create function [Auditing].[fn_GetAuditTrailIDByValue]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetAuditTrailIDByValue(@ValueType varchar(255),
													@Value nvarchar(255)) returns table
WITH ENCRYPTION
as
return select AVM_ID ValueID
		from Auditing.AuditTrailValueTypes
			inner join Auditing.AuditTrailValueMap on AVM_AVT_ID = AVT_ID
		where AVT_Name = @ValueType
			and AVM_Name = @Value

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetAuditTrailValueByID]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetAuditTrailValueByID') is null exec('create function [Auditing].[fn_GetAuditTrailValueByID]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetAuditTrailValueByID(@ValueID int) returns table
WITH ENCRYPTION
as
return select AVM_Name Val
		from Auditing.AuditTrailValueTypes
			inner join Auditing.AuditTrailValueMap on AVM_AVT_ID = AVT_ID
		where AVM_ID = @ValueID

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetConfiguredServerAuditEvents]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetConfiguredServerAuditEvents') is null exec('create function [Auditing].[fn_GetConfiguredServerAuditEvents]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetConfiguredServerAuditEvents(@SessionObjectName nvarchar(128)) returns table
WITH ENCRYPTION
as
return select audit_action_name EventName
		from sys.server_audit_specifications sa
			inner join sys.server_audit_specification_details sd on sd.server_specification_id = sa.server_specification_id
		where sa.name = @SessionObjectName

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetConfiguredXESessionActions]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetConfiguredXESessionActions') is null exec('create function [Auditing].[fn_GetConfiguredXESessionActions]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetConfiguredXESessionActions(@SessionObjectName nvarchar(128)) returns table
WITH ENCRYPTION
as
return select e.package + '.' + e.[name] EventName, a.package + '.' + a.[name] ActionName
		from sys.server_event_sessions s
			inner join sys.server_event_session_events e on s.event_session_id = e.event_session_id
			inner join sys.server_event_session_actions a on s.event_session_id = a.event_session_id
		where s.[name] = @SessionObjectName

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetConfiguredXESessionPredicates]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetConfiguredXESessionPredicates') is null exec('create function [Auditing].[fn_GetConfiguredXESessionPredicates]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetConfiguredXESessionPredicates(@SessionObjectName nvarchar(128)) returns table
WITH ENCRYPTION
as
return select e.package + '.' + e.[name] EventName, e.[predicate] EventPredicate
		from sys.server_event_sessions s
			inner join sys.server_event_session_events e on s.event_session_id = e.event_session_id
		where s.[name] = @SessionObjectName

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetDeclaredServerAuditEvents]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetDeclaredServerAuditEvents') is null exec('create function [Auditing].[fn_GetDeclaredServerAuditEvents]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetDeclaredServerAuditEvents(@AUT_ID int) returns table
WITH ENCRYPTION
as
return select AET_Name EventName
		from Auditing.AuditSessions
			inner join Auditing.AuditTemplates on AUT_ID = ASE_AUT_ID
			inner join Auditing.AuditTemplateEvents on ATE_AUT_ID = AUT_ID
			inner join Auditing.EventTypes on AET_ID = ATE_AET_ID
		where AUT_ID = @AUT_ID
			and AET_AES_ID = 2

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetDeclaredXESessionActions]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetDeclaredXESessionActions') is null exec('create function [Auditing].[fn_GetDeclaredXESessionActions]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetDeclaredXESessionActions(@AUT_ID int) returns table
WITH ENCRYPTION
as
return select AET_Name EventName, rtrim(ltrim(Val)) ActionName
		from Auditing.AuditSessions
			inner join Auditing.AuditTemplates on AUT_ID = ASE_AUT_ID
			inner join Auditing.AuditTemplateEvents on ATE_AUT_ID = AUT_ID
			inner join Auditing.EventTypes on AET_ID = ATE_AET_ID
			cross apply Infra.fn_Split(ATE_AddedColumns, ',')
		where AUT_ID = @AUT_ID
			and AET_AES_ID = 1

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetDeclaredXESessionPredicates]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetDeclaredXESessionPredicates') is null exec('create function [Auditing].[fn_GetDeclaredXESessionPredicates]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetDeclaredXESessionPredicates(@AUT_ID int) returns table
WITH ENCRYPTION
as
return select AET_Name EventName, '(' + ATE_Filter + ')' EventPredicate
		from Auditing.AuditSessions
			inner join Auditing.AuditTemplates on AUT_ID = ASE_AUT_ID
			inner join Auditing.AuditTemplateEvents on ATE_AUT_ID = AUT_ID
			inner join Auditing.EventTypes on AET_ID = ATE_AET_ID
		where AUT_ID = @AUT_ID
			and AET_AES_ID = 1

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetExtendedEventsSessionInfo]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetExtendedEventsSessionInfo') is null exec('create function [Auditing].[fn_GetExtendedEventsSessionInfo]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetExtendedEventsSessionInfo(@Name nvarchar(128)) returns table
WITH ENCRYPTION
as
return select case when s.name is null then 0 else 1 end IsRunning,
			StoragePath
		from sys.server_event_sessions e
			left join sys.dm_xe_sessions s on s.name = e.name
			left join sys.dm_xe_session_targets t on t.event_session_address = s.address
			cross apply (select CAST(target_data as xml) TargetInfo) x
			cross apply (select TargetInfo.value('(EventFileTarget/File/@name)[1]', 'varchar(1000)') FilePath) f
			cross apply (select Infra.fn_Slash(left(FilePath, len(FilePath) - charindex('\', reverse(FilePath)))) StoragePath) p
		where e.name = @Name

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetServerAuditInfo]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetServerAuditInfo') is null exec('create function [Auditing].[fn_GetServerAuditInfo]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_GetServerAuditInfo(@Name nvarchar(128)) returns table
WITH ENCRYPTION
as
return select top 1 coalesce(nullif(sa.is_state_enabled, 1), nullif(sas.is_state_enabled, 1), 1) IsRunning, Infra.fn_Slash(sfa.log_file_path) StoragePath
		from sys.server_audits sa
			inner join sys.server_audit_specifications sas on sas.audit_guid = sa.audit_guid
			inner join sys.server_file_audits sfa on sfa.audit_id = sa.audit_id
														and sfa.audit_guid = sa.audit_guid
		where sa.name = @Name

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_GetServerAuditingPath]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_GetServerAuditingPath') is null exec('create function [Auditing].[fn_GetServerAuditingPath]() returns int as begin return 1 end')
GO
  alter function Auditing.fn_GetServerAuditingPath(@StoragePath varchar(1000)) returns varchar(1000)
WITH ENCRYPTION
as
begin
	return (select Infra.fn_Slash(@StoragePath) + replace(@@SERVERNAME, '\', '$') + '\')
end

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Auditing].[fn_ViewLogTrail]',10,1) WITH NOWAIT;
if object_id('Auditing.fn_ViewLogTrail') is null exec('create function [Auditing].[fn_ViewLogTrail]() returns table as return (select 1 a)')
GO
  alter function Auditing.fn_ViewLogTrail(@ASE_ID int,
										@StartDate datetime2(3),
										@EndDate datetime2(3)) returns table
WITH ENCRYPTION
as
return select AES_Name EventSource, ATL_EventDateTime EventDateTime, et.Val EventType, sn.Val ServerInstanceName, ot.Val ObjectType, ATL_ObjectName ObjectName, dn.Val DatabaseName,
			ATL_IndexID IndexID, ATL_PermissionBitmask PermissionBitmask, ATL_Succeeded Succeeded, ATL_SessionID SessionID, sl.Val ServerLoginName, el.Val SessionLoginName,
			un.Val Username, hn.Val HostName, an.Val ApplicationName, ATL_IsSystem IsSystem, ATL_SQLStatement SQLStatement, ATL_AdditionalInformation AdditionalInformation,
			ATL_DurationMS DurationMS, ATL_ImportDateTime ImportDateTime
		from Auditing.AuditTrail
			cross join Licensing.fn_ValidateLicense()
			inner join Auditing.EventSourceTypes on AES_ID = ATL_AES_ID
			outer apply Auditing.fn_GetAuditTrailValueByID(ATL_EventType_AVM_ID) et
			outer apply Auditing.fn_GetAuditTrailValueByID(ATL_ServerInstanceName_AVM_ID) sn
			outer apply Auditing.fn_GetAuditTrailValueByID(ATL_ObjectType_AVM_ID) ot
			outer apply Auditing.fn_GetAuditTrailValueByID(ATL_DatabaseName_AVM_ID) dn
			outer apply Auditing.fn_GetAuditTrailValueByID(ATL_ServerLoginName_AVM_ID) sl
			outer apply Auditing.fn_GetAuditTrailValueByID(ATL_SessionLoginName_AVM_ID) el
			outer apply Auditing.fn_GetAuditTrailValueByID(ATL_Username_AVM_ID) un
			outer apply Auditing.fn_GetAuditTrailValueByID(ATL_HostName_AVM_ID) hn
			outer apply Auditing.fn_GetAuditTrailValueByID(ATL_ApplicationName_AVM_ID) an
		where ATL_EventDateTime between @StartDate and @EndDate
			and ATL_ASE_ID = @ASE_ID

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [dbo].[fFormatIntReadable]',10,1) WITH NOWAIT;
if object_id('dbo.fFormatIntReadable') is null exec('create function [dbo].[fFormatIntReadable]() returns int as begin return 1 end')
GO
  -- =============================================
-- Author:		Keith Buck
-- Create date: 12/20/2016
-- Description:	Converts an integer into an easy to read number with commas
-- =============================================
alter function [dbo].[fFormatIntReadable] 
(
	@AnyInt BIGINT
)
RETURNS VARCHAR(30)
WITH ENCRYPTION
AS
BEGIN
	-- Declare the return variable here
	DECLARE @ResultVar VARCHAR(30)

	SELECT @ResultVar = REPLACE(CONVERT(VARCHAR(30), Cast(sum(@AnyInt) as money),1), '.00','') 

	-- Return the result of the function
	RETURN @ResultVar

END

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [dbo].[fFormatSecondsToRunTime]',10,1) WITH NOWAIT;
if object_id('dbo.fFormatSecondsToRunTime') is null exec('create function [dbo].[fFormatSecondsToRunTime]() returns int as begin return 1 end')
GO
  -- =============================================
-- Author:		Keith Buck
-- Create date: 2/22/2017
-- Description:	Converts a BIG INT representing seconds into an easy to read format of HH:MM:SS
-- =============================================
alter function [dbo].[fFormatSecondsToRunTime] 
(
	@seconds		BIGINT
)
RETURNS CHAR(8)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @rtn	CHAR(8)

	SET @rtn = RIGHT('0' + CAST( @seconds / 3600 AS VARCHAR),2) + ':' +
			RIGHT('0' + CAST(( @seconds / 60) % 60 AS VARCHAR),2) + ':' +
			RIGHT('0' + CAST(@seconds % 60 AS VARCHAR),2)
			
	RETURN @rtn	

END

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [dbo].[fSplit]',10,1) WITH NOWAIT;
if object_id('dbo.fSplit') is null exec('create function [dbo].[fSplit]() returns @t table (a char(1)) as begin return end')
GO
  alter function [dbo].[fSplit](@String VARCHAR(8000), @Delimiter CHAR(1))       
returns @temptable TABLE (items VARCHAR(8000))    
AS       
BEGIN       
    DECLARE		@idx INT       
    DECLARE		@slice VARCHAR(8000)       
      
    SELECT @idx = 1       
        IF len(@String)<1 or @String is null  RETURN       
      
    WHILE @idx!= 0       
    BEGIN       
        SET @idx = charindex(@Delimiter,@String)       
        IF @idx!=0       
            SET @slice = left(@String,@idx - 1)       
        ELSE       
            SET @slice = @String       
          
        IF(len(@slice)>0)  
            INSERT INTO @temptable(items) VALUES(@slice)       
  
        SET @String = right(@String,len(@String) - @idx)       
        IF len(@String) = 0 BREAK       
    END   
RETURN       
END


GO


RAISERROR('	CREATING OR ALTERING FUNCTION [dbo].[fSplit2columns]',10,1) WITH NOWAIT;
if object_id('dbo.fSplit2columns') is null exec('create function [dbo].[fSplit2columns]() returns @t table (a char(1)) as begin return end')
GO
  
alter function [dbo].[fSplit2columns](@String VARCHAR(8000), @ColumnDelimiter CHAR(1), @RowDelimiter CHAR(1))       
returns @temptable TABLE (a VARCHAR(8000), b VARCHAR(8000))    
AS       
BEGIN       
    DECLARE		@idx INT
	DECLARE		@idx2 INT        
    DECLARE		@a VARCHAR(8000)         
	  
    SELECT @idx = 1       
        IF len(@String)<1 or @String is null  RETURN       
      
    WHILE @idx!= 0       
    BEGIN       
        SET @idx = charindex(@RowDelimiter,@String)       
        IF @idx!=0       
            SET @a = left(@String,@idx - 1)       
        ELSE       
            SET @a = @String       
          
        IF(len(@a)>0)
		BEGIN
			SET @idx2 = charindex(@ColumnDelimiter,@a)
			IF @idx2 != 0
			BEGIN
				INSERT INTO @temptable(a,b) VALUES(SUBSTRING(@a, 1, @idx2 -1), SUBSTRING(@a, @idx2 + 1, LEN(@a)))
			END
			ELSE
			BEGIN
				INSERT INTO @temptable(a,b) VALUES(@a, NULL)
			END
		END
        SET @String = right(@String,len(@String) - @idx)       
        IF len(@String) = 0 BREAK       
    END   
RETURN       
END

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [dbo].[fSplitNString]',10,1) WITH NOWAIT;
if object_id('dbo.fSplitNString') is null exec('create function [dbo].[fSplitNString]() returns @t table (a char(1)) as begin return end')
GO
  
alter function [dbo].[fSplitNString]
(
   @delimited NVARCHAR(MAX),
   @delimiter NVARCHAR(100)
) 
RETURNS @t TABLE
(
-- Id column can be commented out, not required for sql splitting string
   Id INT IDENTITY(1,1), -- I use this column for numbering splitted parts
   val NVARCHAR(MAX)
)

WITH ENCRYPTION
AS
BEGIN
   DECLARE @xml XML
   SET @xml = N'<root><r>' + replace(@delimited,@delimiter,'</r><r>') + '</r></root>'

   INSERT INTO @t(val)
   SELECT 
     r.value('.','varchar(max)') AS item
   FROM @xml.nodes('//root/r') AS records(r)

   RETURN
END


GO


RAISERROR('	CREATING OR ALTERING FUNCTION [Monitoring].[fn_DeadlockParseObjectNameFromInputBuffer]',10,1) WITH NOWAIT;
if object_id('Monitoring.fn_DeadlockParseObjectNameFromInputBuffer') is null exec('create function [Monitoring].[fn_DeadlockParseObjectNameFromInputBuffer]() returns table as return (select 1 a)')
GO
  alter function Monitoring.fn_DeadlockParseObjectNameFromInputBuffer(@InputBuffer nvarchar(max)) returns table
WITH ENCRYPTION
as
return select object_schema_name(ObjectID, DatabaseID) + '.' + object_name(ObjectID, DatabaseID) ObjectName
	from (select replace(replace(replace(@InputBuffer, 'Proc [Database Id = ', ''), ' Object Id = ', ','), ']', '') ProcInfo) p1
		cross apply (select left(ProcInfo, charindex(',', ProcInfo, 1) - 1) DatabaseID, substring(ProcInfo, charindex(',', ProcInfo, 1) + 1, 1000) ObjectID) p2
	where @InputBuffer like 'Proc [[]Database Id = % Object Id = %]'

GO


RAISERROR('	CREATING OR ALTERING FUNCTION [OpsControl].[fn_GetLastLogRecord]',10,1) WITH NOWAIT;
if object_id('OpsControl.fn_GetLastLogRecord') is null exec('create function [OpsControl].[fn_GetLastLogRecord]() returns table as return (select 1 a)')
GO
  alter function OpsControl.fn_GetLastLogRecord(@OPS_ID smallint,
												@Identifier1 int = null,
												@Identifier2 int = null,
												@Info1IsNotNull bit = 0,
												@Info2IsNotNull bit = 0,
												@Info3IsNotNull bit = 0
											) returns table
WITH ENCRYPTION
as
return select top 1 OPL_EndDateTime EndDateTime, OPL_Info1 Info1, OPL_Info2 Info2, OPL_Info3 Info3
		from OpsControl.OperationLog
			cross apply Licensing.fn_ValidateLicense()
		where OPL_OPS_ID = @OPS_ID
			and (OPL_Identifier1 = @Identifier1
				or (OPL_Identifier1 is null and @Identifier1 is null)
				)
			and (OPL_Identifier2 = @Identifier2
				or (OPL_Identifier2 is null and @Identifier2 is null)
				)
			and (OPL_Info1 is not null or @Info1IsNotNull = 0)
			and (OPL_Info2 is not null or @Info2IsNotNull = 0)
			and (OPL_Info3 is not null or @Info3IsNotNull = 0)
		order by OPL_EndDateTime desc

GO


RAISERROR('	CREATING OR ALTERING VIEW [Auditing].[vw_DeclaredAuditSessions]',10,1) WITH NOWAIT;
if object_id('Auditing.vw_DeclaredAuditSessions') is null exec('create view [Auditing].[vw_DeclaredAuditSessions] as select getdate() AS [NOW]')
GO
  alter view Auditing.vw_DeclaredAuditSessions
WITH ENCRYPTION
as
select AUT_ID,
	AUT_Name SessionName,
	Auditing.fn_GetServerAuditingPath(ASE_StoragePath) StoragePath,
	ASE_IsActive IsActive
from Auditing.AuditSessions
	inner join Auditing.AuditTemplates on AUT_ID = ASE_AUT_ID

GO


RAISERROR('	CREATING OR ALTERING VIEW [dbo].[vAgentjob_history]',10,1) WITH NOWAIT;
if object_id('dbo.vAgentjob_history') is null exec('create view [dbo].[vAgentjob_history] as select getdate() AS [NOW]')
GO
  
alter view dbo.vAgentjob_history
AS
SELECT 
	h.instance_id
	,h.job_id
	,j.name as JobName
	,h.step_id
	,msdb.dbo.agent_datetime(h.run_date, h.run_time) as RunDateTime
	,dbo.fFormatSecondsToRunTime(h.run_duration) as RunTime
	,h.sql_message_id
	,h.sql_severity
	,h.run_status
	,h.message
	,h.run_duration
	,h.run_date
	,h.run_time
 FROM 
	[dbo].[agentjob_history] h
	LEFT JOIN msdb.dbo.sysjobs j on h.job_id = j.job_id

GO


RAISERROR('	CREATING OR ALTERING VIEW [dbo].[vDatabaseFileStorage]',10,1) WITH NOWAIT;
if object_id('dbo.vDatabaseFileStorage') is null exec('create view [dbo].[vDatabaseFileStorage] as select getdate() AS [NOW]')
GO
  alter view [dbo].[vDatabaseFileStorage]
AS
SELECT 
	InstanceName
	,CreatedOn		
	,DatabaseName	
	,LogicalName	
	,PhysicalName
	,[TYPE]	
	, CASE [TYPE]			
		WHEN 0 THEN 'ROWS'		
		WHEN 1 THEN 'Log'		
		WHEN 2 THEN 'FileStream'	
		WHEN 4 THEN 'FullText'
		ELSE 'Unknown' End AS Type_Desc
	,TotalSize_Mb	
	,AvailableSpace_Mb
  FROM
	dbo.DatabaseFileStorage

GO


RAISERROR('	CREATING OR ALTERING VIEW [dbo].[vDatabaseFileStorageTotal]',10,1) WITH NOWAIT;
if object_id('dbo.vDatabaseFileStorageTotal') is null exec('create view [dbo].[vDatabaseFileStorageTotal] as select getdate() AS [NOW]')
GO
  alter view [dbo].[vDatabaseFileStorageTotal]
AS
Select 
	CreatedOn		
	,DatabaseName	
	,Case [TYPE]			
		When 0 Then 'ROWS'		
		When 1 Then 'Log'		
		When 2 Then 'FileStream'	
		When 4 Then 'FullText'
		Else 'Unknown' 
	End as Type_Desc
	,SUM(TotalSize_Mb) as TotalSize_Mb
	,SUM(AvailableSpace_Mb) as AvailableSpace_Mb
	, Cast(  (cast(SUM(AvailableSpace_Mb) as decimal(18,3)) / cast(SUM(TotalSize_Mb)  as decimal(18,3))) * 100 as decimal(18,3)) As PercentFreeSpace
	,cast(cast(SUM(TotalSize_Mb) as decimal(18,2))/1024 as decimal(18,2))as TotalSize_Gb
	,cast(cast(SUM(AvailableSpace_Mb) as decimal(18,2))/1024 as decimal(18,2))as AvailableSpace_Gb
  From
	dbo.DatabaseFileStorage
Group By
	CreatedOn		
	,DatabaseName	
	,Case [TYPE]			
		When 0 Then 'ROWS'		
		When 1 Then 'Log'		
		When 2 Then 'FileStream'	
		When 4 Then 'FullText'
		Else 'Unknown' 
	End 

GO


RAISERROR('	CREATING OR ALTERING VIEW [dbo].[vDatabaseObjectStorage]',10,1) WITH NOWAIT;
if object_id('dbo.vDatabaseObjectStorage') is null exec('create view [dbo].[vDatabaseObjectStorage] as select getdate() AS [NOW]')
GO
  alter view [dbo].[vDatabaseObjectStorage] 
AS
SELECT 
	 InstanceName
	 ,[CreatedOn]
      ,[DatabaseName]
	  ,SchemaName
      ,[TableName]
      ,[IndexName]
      ,[PartitionNumber]
      ,CASE [Index_Type]
		WHEN 0 THEN 'HEAP'
		WHEN 1 THEN 'Clustered'
		WHEN 2 THEN 'NonClustered'
		WHEN 3 THEN 'XML'
		WHEN 4 THEN 'Spatial'
		WHEN 5 THEN 'Clustered columnstore index'
		WHEN 6 THEN 'Nonclustered columnstore index'
		WHEN 7 THEN 'Nonclustered hash index'
		ELSE 'Unknown' End Type_Desc
      , CASE [DataCompression]
			WHEN 0 THEN 'NONE'
			WHEN 1 THEN 'ROW'
			WHEN 2 THEN 'PAGE'
			WHEN 3 THEN 'COLUMNSTORE'
		ELSE 'Unknown' End [DataCompression] 
      ,[RecordCount]
	  ,in_row_reserved_page_count + lob_reserved_page_count + row_overflow_reserved_page_count AS reserved_page_count
	  ,sum(in_row_reserved_page_count + lob_reserved_page_count + row_overflow_reserved_page_count)/128 AS reservedSpace_mb
	  ,cast(sum(in_row_reserved_page_count + lob_reserved_page_count + row_overflow_reserved_page_count)/128 AS DECIMAL(18,2))/1024 AS reservedSpace_gb
      ,[in_row_reserved_page_count]
      ,[lob_reserved_page_count]
      ,[row_overflow_reserved_page_count]
	  ,in_row_used_page_count + lob_used_page_count + row_overflow_used_page_count AS used_page_count
	  ,sum(in_row_used_page_count + lob_used_page_count + row_overflow_used_page_count)/128 AS usedSpace_mb
	  ,cast(sum(in_row_used_page_count + lob_used_page_count + row_overflow_used_page_count)/128 AS DECIMAL(18,2))/1024 AS usedSpace_gb
      ,[in_row_used_page_count]
      ,[lob_used_page_count]
      ,[row_overflow_used_page_count]
      ,[FileGroupName]
      ,[DriveLetter]
  FROM 
	[dbo].[DatabaseObjectStorage]
GROUP BY
	 InstanceName
	 ,[CreatedOn]
	,[DatabaseName]
	,SchemaName
	,[TableName]
	,[IndexName]
	,[PartitionNumber]
	,CASE [Index_Type]
	WHEN 0 THEN 'HEAP'
	WHEN 1 THEN 'Clustered'
	WHEN 2 THEN 'NonClustered'
	WHEN 3 THEN 'XML'
	WHEN 4 THEN 'Spatial'
	WHEN 5 THEN 'Clustered columnstore index'
	WHEN 6 THEN 'Nonclustered columnstore index'
	WHEN 7 THEN 'Nonclustered hash index'
	ELSE 'Unknown' End 
	, CASE [DataCompression]
		WHEN 0 THEN 'NONE'
		WHEN 1 THEN 'ROW'
		WHEN 2 THEN 'PAGE'
		WHEN 3 THEN 'COLUMNSTORE'
	ELSE 'Unknown' End  
	,[RecordCount]
	,in_row_reserved_page_count + lob_reserved_page_count + row_overflow_reserved_page_count 
	,[in_row_reserved_page_count]
	,[lob_reserved_page_count]
	,[row_overflow_reserved_page_count]
	,in_row_used_page_count + lob_used_page_count + row_overflow_used_page_count 
	,[in_row_used_page_count]
	,[lob_used_page_count]
	,[row_overflow_used_page_count]
	,[FileGroupName]
	,[DriveLetter]

GO


RAISERROR('	CREATING OR ALTERING VIEW [dbo].[vDatabaseObjectStorage_Total]',10,1) WITH NOWAIT;
if object_id('dbo.vDatabaseObjectStorage_Total') is null exec('create view [dbo].[vDatabaseObjectStorage_Total] as select getdate() AS [NOW]')
GO
  alter view [dbo].[vDatabaseObjectStorage_Total] 
AS
SELECT InstanceName
	  ,[CreatedOn]
      ,[DatabaseName]
	  ,sum(in_row_reserved_page_count + lob_reserved_page_count + row_overflow_reserved_page_count)/128 AS reservedSpace_mb
	  ,cast ( cast(sum(in_row_reserved_page_count + lob_reserved_page_count + row_overflow_reserved_page_count)/128 AS DECIMAL(18,2))/1024 AS DECIMAL (18,2))AS reservedSpace_gb
      ,sum(in_row_used_page_count + lob_used_page_count + row_overflow_used_page_count)/128 AS usedSpace_mb
	  ,cast(cast(sum(in_row_used_page_count + lob_used_page_count + row_overflow_used_page_count)/128 AS DECIMAL(18,2))/1024 AS DECIMAL(18,2))AS usedSpace_gb
 FROM 
	[dbo].[DatabaseObjectStorage]
GROUP BY
	InstanceName
	,[CreatedOn]
	,[DatabaseName]


GO


RAISERROR('	CREATING OR ALTERING VIEW [dbo].[vDatabasePermission]',10,1) WITH NOWAIT;
if object_id('dbo.vDatabasePermission') is null exec('create view [dbo].[vDatabasePermission] as select getdate() AS [NOW]')
GO
  
alter view [dbo].[vDatabasePermission]
AS
SELECT [InstanceName]
      ,[CreatedOn]
      ,[DatabaseName]
      ,PermissionScript
	  ,CAST(PermissionScript AS XML) PermScriptXML

  FROM 
	[dbo].[DatabasePermission]

GO


RAISERROR('	CREATING OR ALTERING VIEW [dbo].[vIndexUsageStats]',10,1) WITH NOWAIT;
IF OBJECT_ID('dbo.vIndexUsageStats') IS NULL EXEC('CREATE VIEW [dbo].[vIndexUsageStats] AS SELECT GETDATE() AS [NOW]')
GO
  

ALTER  VIEW	 dbo.vIndexUsageStats AS
SELECT
		--ix.[database_id]
		d.name as DBName
      --,ix.[object_id]
	  ,OBJECT_NAME(ix.object_id, ix.database_id) AS ObjectName
      ,ix.[index_id]
      ,ix.[user_seeks]
      ,ix.[user_scans]
      ,ix.[user_lookups]
      ,ix.[user_updates]
      ,ix.[last_user_seek]
      ,ix.[last_user_scan]
      ,ix.[last_user_lookup]
      ,ix.[last_user_update]
      ,ix.[system_seeks]
      ,ix.[system_scans]
      ,ix.[system_lookups]
      ,ix.[system_updates]
      ,ix.[last_system_seek]
      ,ix.[last_system_scan]
      ,ix.[last_system_lookup]
      ,ix.[last_system_update]
      ,ix.[last_poll_user_seeks]
      ,ix.[last_poll_user_scans]
      ,ix.[last_poll_user_lookups]
      ,ix.[last_poll_user_updates]
      ,ix.[last_poll_system_seeks]
      ,ix.[last_poll_system_scans]
      ,ix.[last_poll_system_lookups]
      ,ix.[last_poll_system_updates]
      ,ix.[date_stamp]
  FROM [FDDBA].[dbo].[IndexUsageStats] ix
	LEFT JOIN sys.databases d on ix.database_id = d.database_id

WHERE 
	ix.database_id >4
	AND ix.database_id != DB_ID(N'FDDBA')
	AND OBJECT_NAME(ix.object_id, ix.database_id) IS NOT NULL
GO


RAISERROR('	CREATING OR ALTERING VIEW [dbo].[vWaitStatistics]',10,1) WITH NOWAIT;
if object_id('dbo.vWaitStatistics') is null exec('create view [dbo].[vWaitStatistics] as select getdate() AS [NOW]')
GO
  /********************************************
* Create the view which joins the tables
* this view shoudl be used in all queries
*******************************************/

alter view dbo.vWaitStatistics 
AS
Select 
	wst.Name, 
	ws.WaitingTaksCount, 
	ws.WaitTime_ms, 
	ws.SignalWaitTime_ms,
	ws.CaptureDate,
	ws.MaxWaitTime_ms, 
	ws.SystemStartDate 
 FROM 
	dbo.WaitStatistics ws 
	INNER JOIN dbo.WaitStatType  wst on ws.WaitStatTypeId  = wst.Id 

GO


RAISERROR('	CREATING OR ALTERING VIEW [dbo].[vWaitStats_Benign]',10,1) WITH NOWAIT;
if object_id('dbo.vWaitStats_Benign') is null exec('create view [dbo].[vWaitStats_Benign] as select getdate() AS [NOW]')
GO
  alter view [dbo].[vWaitStats_Benign]
AS
SELECT 
	  [WaitStatTypeName]
      ,[Comment]
      ,[ExcludeGroup]
  FROM 
	[dbo].[WaitStats_Benign]

GO


RAISERROR('	CREATING OR ALTERING VIEW [mon].[vDiskSpace]',10,1) WITH NOWAIT;
if object_id('mon.vDiskSpace') is null exec('create view [mon].[vDiskSpace] as select getdate() AS [NOW]')
GO
  

alter view [mon].[vDiskSpace]
AS
SELECT 
	InstanceName
	,CreatedOn
	,Drive
	,TotalSize_mb
	,TotalSize_mb - Free_mb AS Used_mb
	,Free_mb
	,CONVERT( DECIMAL(28,2),TotalSize_mb/1024.0) AS TotalSize_GB
	,CONVERT( DECIMAL(28,2),(TotalSize_mb - Free_mb)/1024.0)  AS Used_GB
	,CONVERT( DECIMAL(28,2),Free_mb/1024.0) AS Free_GB
 FROM 
	mon.DiskSpace

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [Auditing].[usp_ReadLogs]',10,1) WITH NOWAIT;
if object_id('Auditing.usp_ReadLogs') is null exec('create procedure [Auditing].[usp_ReadLogs] as select getdate() DT')
GO
  alter procedure Auditing.usp_ReadLogs
	@OPS_ID smallint
WITH ENCRYPTION
as
set nocount on
declare @ASE_ID int,
		@AES_ID tinyint,
		@SessionObjectName nvarchar(128),
		@StoragePath varchar(1000),
		@IsActive bit,
		@LastfileName varchar(1000),
		@LastOffset bigint,
		@ALR_ID int,
		@RowCount int,
		@ErrorMessage nvarchar(2000)

if not exists (select * from Licensing.fn_ValidateLicense()) return

declare cSessions cursor static forward_only for
	select ASE_ID, AUT_Name, Auditing.fn_GetServerAuditingPath(ASE_StoragePath), ASE_IsActive
	from Auditing.AuditSessions
		inner join Auditing.AuditTemplates on AUT_ID = ASE_AUT_ID

open cSessions

fetch next from cSessions into @ASE_ID, @SessionObjectName, @StoragePath, @IsActive
while @@FETCH_STATUS = 0
begin
	exec Auditing.usp_ReadXEData @OPS_ID = @OPS_ID,
									@ASE_ID = @ASE_ID,
									@SessionObjectName = @SessionObjectName,
									@StoragePath = @StoragePath,
									@IsActive = @IsActive

	exec Auditing.usp_ReadServerAuditData @OPS_ID = @OPS_ID,
											@ASE_ID = @ASE_ID,
											@SessionObjectName = @SessionObjectName,
											@StoragePath = @StoragePath,
											@IsActive = @IsActive
				
	fetch next from cSessions into @ASE_ID, @SessionObjectName, @StoragePath, @IsActive
end
close cSessions
deallocate cSessions

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [Auditing].[usp_ReadServerAuditData]',10,1) WITH NOWAIT;
if object_id('Auditing.usp_ReadServerAuditData') is null exec('create procedure [Auditing].[usp_ReadServerAuditData] as select getdate() DT')
GO
alter procedure Auditing.usp_ReadServerAuditData
	@OPS_ID smallint,
	@ASE_ID int,
	@SessionObjectName nvarchar(128),
	@StoragePath varchar(1000),
	@IsActive bit
with encryption
as
set nocount on
declare @AES_ID tinyint = 2,
		@LastfileName varchar(1000),
		@LastOffset bigint,
		@OPL_ID int,
		@RowCount int,
		@ErrorMessage nvarchar(2000),
		@SQL nvarchar(max)

if not exists (select * from Licensing.fn_ValidateLicense()) return

if object_id('tempdb..#ServerAuditData') is not null
	drop table #ServerAuditData

select @LastfileName = null,
			@LastOffset = null

select @LastfileName = cast(Info1 as varchar(1000)),
	@LastOffset = cast(Info2 as bigint)
from OpsControl.fn_GetLastLogRecord(@OPS_ID, @ASE_ID, @AES_ID, 1, default, default)

exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID output,
									@OPS_ID = @OPS_ID,
									@Identifier1 = @ASE_ID,
									@Identifier2 = @AES_ID

begin try
	create table #ServerAuditData(
		FName nvarchar(260),
		audit_file_offset bigint,
		EventTime datetime2(7),
		action_id varchar(4),
		server_instance_name nvarchar(128),
		class_type varchar(2),
		ObjectName nvarchar(128),
		DatabaseName nvarchar(128),
		permission_bitmask varbinary(16),
		succeeded bit,
		session_id smallint,
		server_principal_name nvarchar(128),
		session_server_principal_name nvarchar(128),
		database_principal_name nvarchar(128),
		SQLStatement nvarchar(4000),
		AdditionalInformation nvarchar(4000),
		client_ip nvarchar(128),
		application_name nvarchar(128),
		duration_milliseconds bigint
		)
	set @SQL = 'select [file_name] FName, audit_file_offset, dateadd(hour, -datediff(hour, getdate(), getutcdate()), event_time) AS EventTime, action_id, server_instance_name,
		class_type, nullif([object_name], '''') ObjectName, [database_name] DatabaseName, permission_bitmask, succeeded, session_id, server_principal_name, session_server_principal_name,
		database_principal_name, nullif([statement], '''') SQLStatement, nullif(additional_information, '''') AdditionalInformation'
	if serverproperty('ProductMajorVersion') >= 14
		set @SQL += ', client_ip, application_name, duration_milliseconds'
	else
		set @SQL += ', cast(null as nvarchar(128)) client_ip, cast(null as nvarchar(128)) application_name, cast(null as bigint) duration_milliseconds'

	set @SQL += char(13)+char(10) + 'from sys.fn_get_audit_file(Infra.fn_Slash(@StoragePath) + @SessionObjectName + ''*.sqlaudit'', @LastfileName, @LastOffset) a'

	insert into #ServerAuditData
	exec sp_executesql @SQL,
						N'@StoragePath varchar(1000),
						@SessionObjectName nvarchar(128),
						@LastfileName varchar(1000),
						@LastOffset bigint',
						@StoragePath = @StoragePath,
						@SessionObjectName = @SessionObjectName,
						@LastfileName = @LastfileName,
						@LastOffset = @LastOffset

	;with Input as
			(select distinct cast(action_id as nvarchar(255)) [Event Type],
					cast(server_instance_name as nvarchar(255)) [Server Instance Name],
					cast(class_type as nvarchar(255)) [Object Type],
					cast(DatabaseName as nvarchar(255)) [Database Name],
					cast(server_principal_name as nvarchar(255)) [Server Login name],
					cast(session_server_principal_name as nvarchar(255)) [Session Login name],
					cast(database_principal_name as nvarchar(255)) [Username],
					cast(client_ip as nvarchar(255)) [Host Name],
					cast(application_name as nvarchar(255)) [Application Name]
				from #ServerAuditData
			)
		, upvt as
			(select distinct AVT_ID, Val
				from Input
					unpivot (Val for KeyName in ([Application Name],
												[Object Type],
												[Database Name],
												[Event Type],
												[Host Name],
												[Server Instance Name],
												[Server Login name],
												[Session Login name],
												[Username])
							) u
					inner join Auditing.AuditTrailValueTypes on AVT_Name = KeyName
				where Val <> ''
					or Val is null
			)
	merge Auditing.AuditTrailValueMap
	using upvt on AVM_AVT_ID = AVT_ID
				and AVM_Name = Val
	when not matched by target then insert(AVM_AVT_ID, AVM_Name)
									values(AVT_ID, Val);

	begin transaction

	insert into Auditing.AuditTrail(ATL_ASE_ID, ATL_AES_ID, ATL_EventDateTime, ATL_EventType_AVM_ID, ATL_ServerInstanceName_AVM_ID, ATL_ObjectType_AVM_ID, ATL_ObjectName,
									ATL_DatabaseName_AVM_ID, ATL_PermissionBitmask, ATL_Succeeded, ATL_SessionID, ATL_ServerLoginName_AVM_ID, ATL_SessionLoginName_AVM_ID, ATL_Username_AVM_ID,
									ATL_HostName_AVM_ID, ATL_ApplicationName_AVM_ID, ATL_SQLStatement, ATL_AdditionalInformation, ATL_DurationMS)
	select @ASE_ID ASE_ID, @AES_ID AES_ID, EventTime, et.ValueID action_id_ID, sn.ValueID server_instance_name_ID, ot.ValueID class_type_ID, ObjectName, dn.ValueID DatabaseName_ID,
		permission_bitmask, succeeded, session_id, sl.ValueID server_principal_name_ID, el.ValueID session_server_principal_name_ID, un.ValueID database_principal_name_ID,
		hn.ValueID client_ip_ID, an.ValueID application_name_ID, SQLStatement, AdditionalInformation, duration_milliseconds
	from #ServerAuditData
		outer apply Auditing.fn_GetAuditTrailIDByValue('Event Type', action_id) et
		outer apply Auditing.fn_GetAuditTrailIDByValue('Server Instance Name', server_instance_name) sn
		outer apply Auditing.fn_GetAuditTrailIDByValue('Object Type', class_type) ot
		outer apply Auditing.fn_GetAuditTrailIDByValue('Database Name', DatabaseName) dn
		outer apply Auditing.fn_GetAuditTrailIDByValue('Server Login name', server_principal_name) sl
		outer apply Auditing.fn_GetAuditTrailIDByValue('Session Login name', session_server_principal_name) el
		outer apply Auditing.fn_GetAuditTrailIDByValue('Username', database_principal_name) un
		outer apply Auditing.fn_GetAuditTrailIDByValue('Host Name', client_ip) hn
		outer apply Auditing.fn_GetAuditTrailIDByValue('Application Name', application_name) an

	set @RowCount = @@ROWCOUNT

	select top 1 @LastfileName = Fname,
		@LastOffset = audit_file_offset
	from #ServerAuditData
	order by EventTime desc

	exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
										@Info1 = @LastfileName,
										@Info2 = @LastOffset,
										@Info3 = @RowCount,
										@Finalize = 1

	commit transaction
end try
begin catch
	if @@TRANCOUNT > 0
		rollback transaction
	set @ErrorMessage = ERROR_MESSAGE()

	if @IsActive = 0
			and @ErrorMessage like 'The specified pattern did not return any files %'
		set @ErrorMessage = null

	exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
										@Info3 = 0,
										@ErrorMessage = @ErrorMessage,
										@Finalize = 1
end catch
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [Auditing].[usp_ReadXEData]',10,1) WITH NOWAIT;
if object_id('Auditing.usp_ReadXEData') is null exec('create procedure [Auditing].[usp_ReadXEData] as select getdate() DT')
GO
  alter procedure Auditing.usp_ReadXEData
	@OPS_ID smallint,
	@ASE_ID int,
	@SessionObjectName nvarchar(128),
	@StoragePath varchar(1000),
	@IsActive bit
WITH ENCRYPTION
as
set nocount on
declare @AES_ID tinyint = 1,
		@LastfileName varchar(1000),
		@LastOffset bigint,
		@OPL_ID int,
		@RowCount int,
		@ErrorMessage nvarchar(2000)

if not exists (select * from Licensing.fn_ValidateLicense()) return

if object_id('tempdb..#XEData') is not null
	drop table #XEData

select @LastfileName = null,
			@LastOffset = null

select @LastFileName = cast(Info1 as varchar(1000)),
	@LastOffset = cast(Info2 as bigint)
from OpsControl.fn_GetLastLogRecord(@OPS_ID, @ASE_ID, @AES_ID, 1, default, default)

exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID output,
									@OPS_ID = @OPS_ID,
									@Identifier1 = @ASE_ID,
									@Identifier2 = @AES_ID

begin try
	select [file_name] Fname, file_offset, dateadd(hour, -datediff(hour, getdate(), getutcdate()), EventTime) AS EventTime, [object_name] EventType, server_instance_name,
		object_type, ObjectName, isnull(nullif(DatabaseName, ''), db_name(DatabaseID)) DatabaseName, index_id, session_id, server_principal_name, session_server_principal_name,
		username, client_hostname, client_app_name, is_system, sql_text
	into #XEData
	from sys.fn_xe_file_target_read_file(Infra.fn_Slash(@StoragePath) + @SessionObjectName + '*.xel', NULL, @LastfileName, @LastOffset)
		cross apply (select cast(event_data as xml) x) e
		cross apply (select x.value('event[1]/@timestamp', 'datetime2') EventTime
							, x.value('(event/data[@name="database_id"]/value)[1]', 'nvarchar(128)') DatabaseID
							, x.value('(event/data[@name="object_type"]/text)[1]', 'nvarchar(60)') object_type
							, x.value('(event/data[@name="index_id"]/value)[1]', 'int') index_id
							, x.value('(event/data[@name="object_name"]/value)[1]', 'nvarchar(128)') ObjectName
							, x.value('(event/data[@name="database_name"]/value)[1]', 'nvarchar(128)') DatabaseName
							, x.value('(event/action[@name="username"]/value)[1]', 'nvarchar(128)') username
							, x.value('(event/action[@name="sql_text"]/value)[1]', 'nvarchar(max)') sql_text
							, x.value('(event/action[@name="session_server_principal_name"]/value)[1]', 'nvarchar(128)') session_server_principal_name
							, x.value('(event/action[@name="session_id"]/value)[1]', 'int') session_id
							, x.value('(event/action[@name="server_principal_name"]/value)[1]', 'nvarchar(128)') server_principal_name
							, x.value('(event/action[@name="server_instance_name"]/value)[1]', 'nvarchar(128)') server_instance_name
							, x.value('(event/action[@name="is_system"]/value)[1]', 'bit') is_system
							, x.value('(event/action[@name="client_hostname"]/value)[1]', 'nvarchar(128)') client_hostname
							, x.value('(event/action[@name="client_app_name"]/value)[1]', 'nvarchar(128)') client_app_name
					) d

	;with Input as
			(select distinct cast(EventType as nvarchar(255)) [Event Type],
					cast(server_instance_name as nvarchar(255)) [Server Instance Name],
					cast(object_type as nvarchar(255)) [Object Type],
					cast(DatabaseName as nvarchar(255)) [Database Name],
					cast(server_principal_name as nvarchar(255)) [Server Login name],
					cast(session_server_principal_name as nvarchar(255)) [Session Login name],
					cast(username as nvarchar(255)) [Username],
					cast(client_hostname as nvarchar(255)) [Host Name],
					cast(client_app_name as nvarchar(255)) [Application Name]
				from #XEData
			)
		, upvt as
			(select distinct AVT_ID, Val
				from Input
					unpivot (Val for KeyName in ([Application Name],
												[Object Type],
												[Database Name],
												[Event Type],
												[Host Name],
												[Server Instance Name],
												[Server Login name],
												[Session Login name],
												[Username])
							) u
					inner join Auditing.AuditTrailValueTypes on AVT_Name = KeyName
				where Val <> ''
					or Val is null
			)
	merge Auditing.AuditTrailValueMap
	using upvt on AVM_AVT_ID = AVT_ID
				and AVM_Name = Val
	when not matched by target then insert(AVM_AVT_ID, AVM_Name)
									values(AVT_ID, Val);

	begin transaction

	insert into Auditing.AuditTrail(ATL_ASE_ID, ATL_AES_ID, ATL_EventDateTime, ATL_EventType_AVM_ID, ATL_ServerInstanceName_AVM_ID, ATL_ObjectType_AVM_ID, ATL_ObjectName,
									ATL_DatabaseName_AVM_ID, ATL_IndexID, ATL_SessionID, ATL_ServerLoginName_AVM_ID, ATL_SessionLoginName_AVM_ID, ATL_Username_AVM_ID, ATL_HostName_AVM_ID,
									ATL_ApplicationName_AVM_ID, ATL_IsSystem, ATL_SQLStatement)
	select @ASE_ID ASE_ID, @AES_ID AES_ID, EventTime, et.ValueID EventType_ID, sn.ValueID server_instance_name_ID, ot.ValueID object_type_ID, ObjectName, dn.ValueID DatabaseName_ID,
		index_id, session_id, sl.ValueID server_principal_name_ID, el.ValueID session_server_principal_name_ID, un.ValueID username_ID, hn.ValueID client_hostname_ID,
		an.ValueID client_app_name_ID, is_system, sql_text
	from #XEData
		outer apply Auditing.fn_GetAuditTrailIDByValue('Event Type', EventType) et
		outer apply Auditing.fn_GetAuditTrailIDByValue('Server Instance Name', server_instance_name) sn
		outer apply Auditing.fn_GetAuditTrailIDByValue('Object Type', object_type) ot
		outer apply Auditing.fn_GetAuditTrailIDByValue('Database Name', DatabaseName) dn
		outer apply Auditing.fn_GetAuditTrailIDByValue('Server Login name', server_principal_name) sl
		outer apply Auditing.fn_GetAuditTrailIDByValue('Session Login name', session_server_principal_name) el
		outer apply Auditing.fn_GetAuditTrailIDByValue('Username', username) un
		outer apply Auditing.fn_GetAuditTrailIDByValue('Host Name', client_hostname) hn
		outer apply Auditing.fn_GetAuditTrailIDByValue('Application Name', client_app_name) an

	set @RowCount = @@ROWCOUNT

	select top 1 @LastfileName = Fname,
		@LastOffset = file_offset
	from #XEData
	order by EventTime desc

	exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
										@Info1 = @LastFileName,
										@Info2 = @LastOffset,
										@Info3 = @RowCount,
										@Finalize = 1

	commit transaction
end try
begin catch
	if @@TRANCOUNT > 0
		rollback transaction
	set @ErrorMessage = ERROR_MESSAGE()

	if @IsActive = 0
			and @ErrorMessage like 'The log file name % is invalid%'
		set @ErrorMessage = null

	exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
										@Info3 = 0,
										@ErrorMessage = @ErrorMessage,
										@Finalize = 1
end catch

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [Auditing].[usp_ValidateConfiguration]',10,1) WITH NOWAIT;
if object_id('Auditing.usp_ValidateConfiguration') is null exec('create procedure [Auditing].[usp_ValidateConfiguration] as select getdate() DT')
GO
  alter procedure Auditing.usp_ValidateConfiguration
	@OPS_ID smallint
WITH ENCRYPTION
as
set nocount on
declare @ASE_ID int

if not exists (select * from Licensing.fn_ValidateLicense()) return

declare cSessions cursor static forward_only for
	select ASE_ID
	from Auditing.AuditSessions

open cSessions
fetch next from cSessions into @ASE_ID
while @@FETCH_STATUS = 0
begin
	exec Auditing.usp_ValidateXESession @OPS_ID = @OPS_ID,
											@ASE_ID = @ASE_ID
	exec Auditing.usp_ValidateServerAudit @OPS_ID = @OPS_ID,
											@ASE_ID = @ASE_ID

	fetch next from cSessions into @ASE_ID
end
close cSessions
deallocate cSessions

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [Auditing].[usp_ValidateServerAudit]',10,1) WITH NOWAIT;
if object_id('Auditing.usp_ValidateServerAudit') is null exec('create procedure [Auditing].[usp_ValidateServerAudit] as select getdate() DT')
GO
alter procedure Auditing.usp_ValidateServerAudit
	@OPS_ID smallint,
	@ASE_ID int
with encryption
as
set nocount on
declare @AES_ID tinyint = 2,
		@AUT_ID int,
		@Name nvarchar(128),
		@StoragePath varchar(1000),
		@IsActive bit,
		@IsRunning bit,
		@CurrentStoragePath varchar(1000),
		@SessionObjectName nvarchar(128),
		@SQL nvarchar(max),
		@OPL_ID int,
		@ErrorMessage nvarchar(4000)

if not exists (select * from Licensing.fn_ValidateLicense()) return

exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID output,
									@OPS_ID = @OPS_ID,
									@Identifier1 = @ASE_ID,
									@Identifier2 = @AES_ID

begin try
	select @AUT_ID = AUT_ID,
		@SessionObjectName = SessionName,
		@StoragePath = StoragePath,
		@IsActive = IsActive
	from Auditing.vw_DeclaredAuditSessions

	select @IsRunning = IsRunning,
		@CurrentStoragePath = StoragePath
	from Auditing.fn_GetServerAuditInfo(@SessionObjectName)

	If @IsActive = 1
	begin
		if @IsRunning is null
						or @IsRunning = 0
						or @CurrentStoragePath <> @StoragePath
						or (select count(*)
								from (select EventName
										from Auditing.fn_GetConfiguredServerAuditEvents(@SessionObjectName)
										union
										select EventName
										from Auditing.fn_GetDeclaredServerAuditEvents(@AUT_ID)
										) t
							) <>
							(select count(*)
							from Auditing.fn_GetDeclaredServerAuditEvents(@AUT_ID)
							)
		begin
			exec master.dbo.xp_create_subdir @StoragePath
			set @SQL = Auditing.fn_GenerateServerAuditDropScript(@SessionObjectName) +char(13)+char(10)
					+ Auditing.fn_GenerateServerAuditCreateScript(@AUT_ID, @SessionObjectName, @StoragePath)
			exec(@SQL)
		end
	end
	else if @IsRunning = 1
	begin
		set @SQL = Auditing.fn_GenerateServerAuditDropScript(@SessionObjectName)
		exec(@SQL)
	end
end try
begin catch
	set @ErrorMessage = ERROR_MESSAGE()
end catch

exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
									@ErrorMessage = @ErrorMessage,
									@Finalize = 1
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [Auditing].[usp_ValidateXESession]',10,1) WITH NOWAIT;
if object_id('Auditing.usp_ValidateXESession') is null exec('create procedure [Auditing].[usp_ValidateXESession] as select getdate() DT')
GO
  alter procedure Auditing.usp_ValidateXESession
	@OPS_ID smallint,
	@ASE_ID int
WITH ENCRYPTION
as
set nocount on
declare @AES_ID tinyint = 1,
		@AUT_ID int,
		@Name nvarchar(128),
		@StoragePath varchar(1000),
		@IsActive bit,
		@IsRunning bit,
		@CurrentStoragePath varchar(1000),
		@SessionObjectName nvarchar(128),
		@SQL nvarchar(max),
		@OPL_ID int,
		@ErrorMessage nvarchar(4000)

if not exists (select * from Licensing.fn_ValidateLicense()) return

exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID output,
									@OPS_ID = @OPS_ID,
									@Identifier1 = @ASE_ID,
									@Identifier2 = @AES_ID

begin try 
	select @AUT_ID = AUT_ID,
		@SessionObjectName = SessionName,
		@StoragePath = StoragePath,
		@IsActive = IsActive
	from Auditing.vw_DeclaredAuditSessions

	select @IsRunning = IsRunning,
		@CurrentStoragePath = StoragePath
	from Auditing.fn_GetExtendedEventsSessionInfo(@SessionObjectName)

	If @IsActive = 1
	begin
		if @IsRunning is null
						or @IsRunning = 0
						or @CurrentStoragePath <> @StoragePath
						or (select count(*)
								from (select EventName, EventPredicate
										from Auditing.fn_GetConfiguredXESessionPredicates(@SessionObjectName)
										union
										select EventName, EventPredicate
										from Auditing.fn_GetDeclaredXESessionPredicates(@AUT_ID)
										) t
							) <>
							(select count(*)
							from Auditing.fn_GetDeclaredXESessionPredicates(@AUT_ID)
							)
						or (select count(*)
								from (select EventName, ActionName
										from Auditing.fn_GetConfiguredXESessionActions(@SessionObjectName)
										union
										select EventName, ActionName
										from Auditing.fn_GetDeclaredXESessionActions(@AUT_ID)
										) t
							) <>
							(select count(*)
							from Auditing.fn_GetDeclaredXESessionActions(@AUT_ID)
							)
		begin
			EXEC master.dbo.xp_create_subdir @StoragePath
			set @SQL = Auditing.fn_GenerateXESessionDropScript(@SessionObjectName) +char(13)+char(10)
					+ Auditing.fn_GenerateXESessionCreateScript(@AUT_ID, @SessionObjectName, @StoragePath)
			exec(@SQL)
		end
	end
	else if @IsRunning = 1
	begin
		set @SQL = Auditing.fn_GenerateXESessionDropScript(@SessionObjectName)
		exec(@SQL)
	end
end try
begin catch
	set @ErrorMessage = ERROR_MESSAGE()
end catch

exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
									@ErrorMessage = @ErrorMessage,
									@Finalize = 1

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[AvailabiltyGroupTracking_Insert]',10,1) WITH NOWAIT;
if object_id('dbo.AvailabiltyGroupTracking_Insert') is null exec('create procedure [dbo].[AvailabiltyGroupTracking_Insert] as select getdate() DT')
GO
  

alter procedure [dbo].[AvailabiltyGroupTracking_Insert]
AS
DECLARE @primaryReplica		SYSNAME
	INSERT INTO dbo.AvailabiltyGroupTracking(AGName, FailureConditionLevel, PrimaryReplica, Note)
	SELECT 
		ag.name
		,ag.failure_condition_level
		,ISNULL(agstate.primary_replica,'null')
		,'Procedure dbo.AG_Tracking_Insert'

	 FROM
		sys.availability_groups ag
		INNER JOIN sys.dm_hadr_availability_group_states agstate on ag.group_id = agstate.group_id
	
	IF EXISTS(SELECT TOP 1 1 FROM msdb.dbo.sysjobs WHERE name = N'SQL Sentry 2.0 Alert Trap' AND enabled = 1)
		execute msdb.dbo.sp_start_job @job_name = N'SQL Sentry 2.0 Alert Trap' 

	SELECT TOP 1 @primaryReplica =  PrimaryReplica FROM dbo.AvailabiltyGroupTracking ORDER BY CreatedOn DESC
	IF ISNULL(@primaryReplica, 'null') = 'null'
	BEGIN
		WAITFOR DELAY '00:05'
		INSERT INTO dbo.AvailabiltyGroupTracking(AGName, FailureConditionLevel, PrimaryReplica, Note)
		SELECT 
			ag.name
			,ag.failure_condition_level
			,ISNULL(agstate.primary_replica,'null')
			,'Procedure dbo.AvailabiltyGroupTracking_Insert'

		 FROM
			sys.availability_groups ag
			INNER JOIN sys.dm_hadr_availability_group_states agstate on ag.group_id = agstate.group_id
	END


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[BackupException]',10,1) WITH NOWAIT;
if object_id('dbo.BackupException') is null exec('create procedure [dbo].[BackupException] as select getdate() DT')
GO
  /*******************************************************************************
Created By: Keith Buck
Created On: 4/1/2018

Purpose: Validate Full, Differential and/or Transaction Log backups for databases that are not part of an Availability Group.

Parameters:		
	@DebugOverride	BIT = 0 :	Real parameter accepted by Procedure that will override the Debug setting in the table of parameters, makes it easier to debugz
Params in the Config Table (FDDBA.dbo.config_fddba2)
	@HoursForFull		: Number of hours to check since a full backup was taken. Any database that 
							has not had a backup in the last @HoursForFull will show up in this report.
	@MinutesForDiff		: Number of minutes to check since a Diff backup was taken. Any database that 
							has not had a backup in the last @HoursForFull will show up in this report.
	@MinutesForTranLog	: Number or minutes to check since a Log backup was taken.
	@emailRecipients	: Semi-colon delimted list of email account that receive the report
	@EmailSubject		: Text for the subject, procedure will replace explict text '[SERVERNAME]' with the actual server name
	@EmailProfile		: Database Mail profile to use to send emails

	@ExcludeCopyOnly	IS NOT VALID FOR THIS VERSION DUE TO BUGS REPORTED IN TESTING
	
	@H3Text				:Text for the H3 (heading 3) section of the report. this is where we can include a message 
							specific to Agio or not. Agio would be used for prod. DO NOT inlcude the <H3> HTML tags
	@OnCleanRecipients	: Semi-colon delimted list of email account that receive an email that no exceptions were found. If blank or NULL no email will be sent.
	@WriteToErrorLog	: Bit flag indicationg to write certain output statements to the SQL Error Log with a severity of 16 if missing backups are found.
	@Debug				: Flag to use for debugging to show output of steps. 1 = on, 0 = off
	@DeviceType			:caret ^ delimted string of backup device types (tinyint) from table backupmediafamily default 2, NOT NULL  https://technet.microsoft.com/en-us/library/ms190284(v=sql.110).aspx
							2 = Disk, 5 = Tape, 7 = Virtual device, 105 = A permanent backup device.
------------------------------------------------------------------------------------------------------------------------------------------
Changes 
Date:	2018-12-27
By:		Keith Buck
Notes:	Added @DebugOverride parameter, and fixed bug with Log backups reporting failures when older copy only versions existed.

Date:	2018-02-15
By:		Keith Buck
Notes:	updated @DebugOverride default to 0, added a caret as the delimeter for the deviceType, updated db select list to exclude Log Shipped standbys is_in_standby=1
				Added exclusion on diff backup if a full was taken within the same window as a diff should have been done.
*******************************************************************************/
alter procedure [dbo].[BackupException](
	@DebugOverride	BIT = 0
)
WITH ENCRYPTION
AS
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
SET NOCOUNT ON
exec dbo.usp_UpdateVersionStatics

--parameter gathering
DECLARE @parameters				VARCHAR(3950)
DECLARE @name					VARCHAR(3950)					
DECLARE @value					VARCHAR(3950)
DECLARE @HoursForFull			INT 
DECLARE @MinutesForDiff			INT 
DECLARE @MinutesForLog			INT 
DECLARE @emailRecipients		VARCHAR(1000)
DECLARE @H3Text					VARCHAR(200)
DECLARE @OnCleanRecipients		VARCHAR(1000)
DECLARE @EmailSubject			VARCHAR(256)
DECLARE @EmailProfile			SYSNAME
DECLARE @WriteToErrorLog		BIT
DECLARE @Debug					BIT
DECLARE @DeviceType				VARCHAR(10)	
DECLARE @ver					VARCHAR(30)
DECLARE @dot1					INT
DECLARE @dot2					INT
DECLARE @verdec					DECIMAL(18,2)
DECLARE @CompleteSQL			NVARCHAR(max)


select @ver = cast(SERVERPROPERTY('productversion') as varchar(30))
select @dot1 = CHARINDEX('.',@ver)
select @dot2 = CHARINDEX('.',@ver,@dot1+1)
select @verdec = cast(SUBSTRING(@ver,1,@dot2-1) as decimal(18,2))


SELECT TOP 1 @parameters = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'parameters' and [domain] = 'BackupExceptionReport'

DECLARE param_cur CURSOR FAST_FORWARD LOCAL FOR
SELECT a, b FROM FDDBA.dbo.fSplit2columns(@parameters, '=', ',')
OPEN param_cur
FETCH NEXT FROM param_cur INTO @name, @value
WHILE @@FETCH_STATUS != -1
BEGIN
		
		SET @name = LTRIM(RTRIM(@name))
		SET @value = LTRIM(RTRIM(@value))
		IF @name = 'HoursForFull' 
			SET @HoursForFull = CAST(ISNULL(@value,'0') AS INT)
		IF @name = 'MinutesForDiff' 
			SET @MinutesForDiff = CAST(ISNULL(@value,'0') AS INT)
		IF @name = 'MinutesForLog' 
			SET @MinutesForLog = CAST(ISNULL(@value,'0') AS INT)
		IF @name = 'emailRecipients'
			SET @emailRecipients = @value
		IF @name = 'H3Text'
			SET @H3Text = @value
		IF @name = 'OnCleanRecipients'
			SET @OnCleanRecipients = @value
		IF @name = 'EmailSubject'
			SET @EmailSubject = @value
		IF @name = 'EmailProfile'
			SET @EmailProfile = @value
		IF @name = 'WriteToErrorLog'
			SET @WriteToErrorLog = CAST(ISNULL(@value,'0') AS BIT)
		IF @name = 'Debug'
			SET @Debug = CAST(ISNULL(@value,'0') AS BIT)
		IF @name = 'DeviceType'
			SET @DeviceType = @value
		FETCH NEXT FROM param_cur INTO @name, @value
END
CLOSE param_cur
DEALLOCATE param_cur

IF @DebugOverride = 1 
	SET  @Debug = @DebugOverride

IF @Debug=1
BEGIN
	PRINT '@HoursForFull=' + CAST(@HoursForFull AS VARCHAR(100))
	PRINT '@MinutesForDiff=' + CAST(@MinutesForDiff AS VARCHAR(100))
	PRINT '@MinutesForLog=' + CAST(@MinutesForLog AS VARCHAR(100))
	PRINT '@emailRecipients=' + @emailRecipients
	PRINT '@H3Text=' + @H3Text 
	PRINT '@OnCleanRecipients=' +@OnCleanRecipients 
	PRINT '@EmailSubject=' + @EmailSubject
	PRINT '@EmailProfile=' + @EmailProfile
	PRINT '@WriteToErrorLog=' + CAST(@WriteToErrorLog AS VARCHAR(100))
	PRINT '@DeviceType=' + CAST(@DeviceType AS VARCHAR(100))
END
--------------------- end of parameter gathering  ---------------------------------

DECLARE @subject			NVARCHAR(255)    
DECLARE @serverName			SYSNAME
DECLARE @Query				NVARCHAR(MAX)    
DECLARE @Body				NVARCHAR(MAX)    
DECLARE @Xml				NVARCHAR(MAX)    
DECLARE @FullDT				DATETIME
DECLARE @DiffDT				DATETIME
DECLARE @LogDT				DATETIME
DECLARE @msg				VARCHAR(2048)
DECLARE @params				VARCHAR(MAX)
DECLARE @ReportDate			VARCHAR(30)


IF @EmailSubject IS NOT NULL
BEGIN
	SET @EmailSubject = REPLACE(@EmailSubject,'[SERVERNAME]',@@SERVERNAME)
END
   
IF @HoursForFull > 0
	SET @HoursForFull = @HoursForFull * -1
IF @MinutesForDiff > 0
	SET @MinutesForDiff = @MinutesForDiff * -1 
IF @MinutesForLog > 0
	SET @MinutesForLog = @MinutesForLog * -1 

 
SET @Body				= ' '  
IF @HoursForFull != 0
	SET @FullDT				= DATEADD(HOUR,@HoursForFull,GETDATE())
IF @MinutesForDiff != 0
	SET @DiffDT			= DATEADD(MINUTE,@MinutesForDiff,GETDATE())
IF @MinutesForLog != 0 
SET @LogDT				= DATEADD(MINUTE,@MinutesForLog,GETDATE())

IF @Debug = 1
BEGIN
	SELECT 
		@FullDT as '@FullDT'
		,CASE WHEN @MinutesForDiff = 0 THEN NULL ELSE @DiffDT END AS '@DiffDT'
		,CASE WHEN @MinutesForLog = 0  THEN NULL ELSE @LogDT END AS '@LogDT'
END

IF OBJECT_ID('tempdb..#devices') IS NOT NULL
	DROP TABLE #devices
CREATE TABLE #devices(device_type tinyint NOT NULL)
INSERT INTO #devices (device_type)
SELECT * FROM dbo.fSplit(@DeviceType,'^')
				
IF @Debug = 1
BEGIN
	--2 = Disk, 5 = Tape, 7 = Virtual device, 105 = A permanent backup device.
	SELECT 
		'Device_Type' as 'Device_Type'
		,d.device_type as device_type_id
		,CASE WHEN d.device_type = 2 Then 'Disk'
			WHEN d.device_type = 5 THEN 'Tape'
			WHEN d.device_type = 7 THEN 'Virtual device'
			WHEN d.device_type = 105 THEN 'A permanent backup device'
		ELSE 'UNKNOWN'
		END AS device_type_id
	 FROM
		#devices d
END


IF OBJECT_ID('tempdb..#backups') IS NOT NULL
	DROP TABLE #backups
CREATE TABLE #backups(
	DatabaseName			SYSNAME,
	BACKUP_TYPE				VARCHAR(10) ,
	LATEST_BACKUP_DATE		DATETIME NULL, 
	HOURS_SINCE_BACKUP		INT, 
	MINUTES_SINCE_BACKUP	INT,
	RestoreDate				DATETIME NULL,
	is_copy_only			BIT NULL,
	is_damaged				BIT NULL
);

IF OBJECT_ID('tempdb..#dbs') IS NOT NULL
	DROP TABLE #dbs
CREATE TABLE #dbs (DatabaseName SYSNAME)

IF @verdec >= 11
BEGIN
	execute sp_executesql N'INSERT INTO #dbs (DatabaseName)
	SELECT 
		d.name
	 FROM 
		sys.databases d
		LEFT JOIN dbo.BackupReportExclusion ex on d.name = ex.DatabaseName
	WHERE
		d.database_id != 2						--tempdb exclusion
		AND d.state = 0							-- must be online
		AND d.source_database_id IS NULL			--not a snapshot
		AND d.replica_id IS NULL					--not part of an AG
		AND d.is_in_standby = 0						--not a log ship standby'
		--AND ex.DatabaseName IS NULL					--not in the exclusion list'
END
ELSE
BEGIN
	execute sp_executesql N'INSERT INTO #dbs (DatabaseName)
	SELECT 
		d.name
		FROM 
		sys.databases d
		LEFT JOIN dbo.BackupReportExclusion ex on d.name = ex.DatabaseName
	WHERE
		d.database_id != 2						--tempdb exclusion
		AND d.state = 0							-- must be online
		AND d.source_database_id IS NULL			--not a snapshot
		AND ex.DatabaseName IS NULL					--not in the exclusion list
		AND d.is_in_standby = 0						--not a log ship standby'
END


IF @Debug = 1
BEGIN
	SELECT 
		'#dbs' as TempTable_#dbs
		,DatabaseName
	FROM
		#dbs t
	ORDER BY 
		DatabaseName
END

--TEMP TABLE CONTAINING THE LATEST FULL AND DIFFERENTIAL BACKUP DATES FOR EVERY DATABASE
IF @HoursForFull != 0
BEGIN
	WITH cteFULL AS(
			SELECT 
				b.database_name
				,MAX(b.backup_start_date) AS backup_start_date
			 FROM  
				msdb.dbo.backupset b 
				INNER JOIN msdb.dbo.backupmediafamily a on b.media_set_id = a.media_set_id
				LEFT JOIN msdb.dbo.restorehistory res ON b.backup_set_id = res.backup_set_id and b.database_name = res.destination_database_name 
				INNER JOIN #devices ON a.device_type = #devices.device_type
			WHERE
				b.type = 'D'
				AND res.destination_database_name IS NULL --anti join, cannot be a restore entry from the msdb table or must have been restored before the FULL backup date
				AND b.is_damaged = 0
				--AND (@ExcludeCopyOnly = 1 OR  b.is_copy_only = 0) -- FULL MUST NOT BE COPYONLY
			GROUP BY 
				b.database_name
		)
	INSERT INTO #backups(DatabaseName, BACKUP_TYPE, LATEST_BACKUP_DATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP, RestoreDate, is_copy_only, is_damaged)
	SELECT 
		DISTINCT 
		t.DatabaseName
		,'FULL'
		,ISNULL(cf.backup_start_date,'1/1/1900')
		,ISNULL(DATEDIFF(HOUR, cf.backup_start_date, GETDATE()),-1)
		,ISNULL(DATEDIFF(MINUTE, cf.backup_start_date, GETDATE()),-1)
		,NULL
		,b.is_copy_only
		,b.is_damaged
	 FROM 
		#dbs t 
		LEFT JOIN cteFULL cf on t.DatabaseName = cf.database_name
		LEFT JOIN dbo.BackupReportExclusion ex on t.DatabaseName = ex.DatabaseName and ex.ExcludeFull = 1
		LEFT JOIN msdb.dbo.backupset b ON t.DatabaseName = b.database_name 
			AND b.type = 'D'
			AND cf.backup_start_date = b.backup_start_date
		LEFT JOIN msdb.dbo.backupmediafamily a on b.media_set_id = a.media_set_id
					
	WHERE
		ex.DatabaseName IS NULL 
	
END

IF @MinutesForDiff != 0
BEGIN
	WITH cteDIFF AS(
			SELECT 
				b.database_name
				,MAX(b.backup_start_date) AS backup_start_date
			 FROM  
				msdb.dbo.backupset b 
				INNER JOIN msdb.dbo.backupmediafamily a on b.media_set_id = a.media_set_id
				LEFT JOIN msdb.dbo.restorehistory res ON b.backup_set_id = res.backup_set_id and b.database_name = res.destination_database_name 
				INNER JOIN #devices ON a.device_type = #devices.device_type
			WHERE
				b.type = 'I'
				AND res.destination_database_name IS NULL --anti join, cannot be a restore entry from the msdb table or must have been restored before the FULL backup date
				AND b.is_damaged = 0
				--AND (@ExcludeCopyOnly = 1 OR  b.is_copy_only = 0) -- FULL MUST NOT BE COPYONLY
			GROUP BY 
				b.database_name
		)

	INSERT INTO #backups(DatabaseName, BACKUP_TYPE, LATEST_BACKUP_DATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP, RestoreDate,is_copy_only, is_damaged)
	SELECT 
		DISTINCT 
		t.DatabaseName
		,'DIFF'
		,ISNULL(b.backup_start_date,'1/1/1900')
		,ISNULL(DATEDIFF(HOUR, b.backup_start_date, GETDATE()),-1)
		,ISNULL(DATEDIFF(MINUTE, b.backup_start_date, GETDATE()),-1)
		,NULL
		,b.is_copy_only
		,b.is_damaged
	 FROM 
		#dbs t 
		LEFT JOIN cteDIFF cd on t.DatabaseName = cd.database_name
		LEFT JOIN msdb.dbo.backupset b ON t.DatabaseName = b.database_name 
			AND b.type = 'I'
			AND cd.backup_start_date = b.backup_start_date
		LEFT JOIN msdb.dbo.backupmediafamily a on b.media_set_id = a.media_set_id
		LEFT JOIN dbo.BackupReportExclusion ex on t.DatabaseName = ex.DatabaseName AND ex.ExcludeDiff = 1
	WHERE
		ex.DatabaseName IS NULL 
END

IF @MinutesForLog != 0
BEGIN
	WITH cteLOG AS(
			SELECT 
				b.database_name
				,MAX(b.backup_start_date) AS backup_start_date
			 FROM  
				msdb.dbo.backupset b 
				INNER JOIN msdb.dbo.backupmediafamily a on b.media_set_id = a.media_set_id
				LEFT JOIN msdb.dbo.restorehistory res ON b.backup_set_id = res.backup_set_id and b.database_name = res.destination_database_name 
				INNER JOIN #devices ON a.device_type = #devices.device_type
			WHERE
				b.type = 'L'
				AND res.destination_database_name IS NULL --anti join, cannot be a restore entry from the msdb table or must have been restored before the FULL backup date
				AND b.is_damaged = 0
				--AND (@ExcludeCopyOnly = 1 OR  b.is_copy_only = 0) -- FULL MUST NOT BE COPYONLY
			GROUP BY 
				b.database_name
				
		)

	INSERT INTO #backups(DatabaseName, BACKUP_TYPE, LATEST_BACKUP_DATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP, RestoreDate, is_copy_only, is_damaged)
	SELECT 
		t.DatabaseName
		,'LOG'
		,ISNULL(MAX(cd.backup_start_date),'1/1/1900')
		,DATEDIFF(HOUR,	ISNULL(MAX(cd.backup_start_date),'1/1/1900'), GETDATE())
		,DATEDIFF(MINUTE,	ISNULL(MAX(cd.backup_start_date),'1/1/1900'), GETDATE())
		,NULL--,res.restore_date
		,b.is_copy_only
		,b.is_damaged
	 FROM 
		#dbs t 
		INNER JOIN sys.databases d on t.DatabaseName = d.name
		LEFT JOIN cteLOG cd on t.DatabaseName = cd.database_name
		LEFT JOIN msdb.dbo.backupset b ON cd.database_name = b.database_name AND cd.backup_start_date = b.backup_start_date AND b.type = 'L'
		LEFT JOIN dbo.BackupReportExclusion ex on t.DatabaseName = ex.DatabaseName AND ex.ExcludeLog = 1
	WHERE
		ISNULL(d.recovery_model_desc,'SIMPLE') != 'SIMPLE'
		AND ex.DatabaseName IS NULL
	GROUP BY 
		t.DatabaseName
		,b.is_copy_only
		,b.is_damaged
END							
				
IF @Debug = 1
BEGIN
	SELECT 
		'#backups' as TempTable_#backups
		,b.DatabaseName
		,b.BACKUP_TYPE
		,b.LATEST_BACKUP_DATE 
		,CASE WHEN B.LATEST_BACKUP_DATE IS NULL THEN NULL ELSE DATEDIFF(HOUR,b.LATEST_BACKUP_DATE,GETDATE()) END AS HoursSinceBackup
		,CASE WHEN B.LATEST_BACKUP_DATE IS NULL THEN NULL ELSE DATEDIFF(MINUTE,b.LATEST_BACKUP_DATE,GETDATE()) END AS MinutesSinceLastBackup
		,d.recovery_model_desc
		,b.is_copy_only
		,b.is_damaged
	FROM 
		#backups b
		INNER JOIN sys.databases d on b.DatabaseName = d.name
	ORDER BY
		b.BACKUP_TYPE
		,b.DatabaseName
END




IF OBJECT_ID('tempdb..#BACKUP_EXCEPTION') IS NOT NULL	
	DROP TABLE #BACKUP_EXCEPTION
CREATE TABLE #BACKUP_EXCEPTION(DATABASENAME VARCHAR(128), BACKUP_TYPE VARCHAR(10) ,LATEST_BACKUP_DATE VARCHAR(30) ,HOURS_SINCE_BACKUP  INT, MINUTES_SINCE_BACKUP INT)

IF @HoursForFull != 0
BEGIN 
	INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATEST_BACKUP_DATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP)
	SELECT 
		d.DatabaseName
		,'Full'
		,ISNULL(b.LATEST_BACKUP_DATE,'1/1/1900')
		,ISNULL(b.HOURS_SINCE_BACKUP, -1)
		,ISNULL(b.MINUTES_SINCE_BACKUP, -1)
	 FROM
		#dbs d
		LEFT JOIN #backups b ON d.DatabaseName = b.DatabaseName AND b.BACKUP_TYPE = 'FULL' 
		LEFT JOIN dbo.BackupReportExclusion ex on d.DatabaseName = LTRIM(RTRIM(ex.DatabaseName)) and ex.ExcludeFull = 1
	WHERE
		ISNULL(b.LATEST_BACKUP_DATE,'1/1/1900') < @FullDT
		AND ex.DatabaseName IS NULL

	IF @Debug = 1
	BEGIN
		SELECT '#BACKUP_EXCEPTION (FULL)' AS [TableName], * FROM #BACKUP_EXCEPTION 
	END
END
		


IF @MinutesForDiff != 0
BEGIN 
	INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATEST_BACKUP_DATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP)
	SELECT 
		b.DatabaseName
		,'DIFF'
		,ISNULL(b.LATEST_BACKUP_DATE,'1/1/1900')
		,ISNULL(b.HOURS_SINCE_BACKUP, -1)
		,ISNULL(b.MINUTES_SINCE_BACKUP, -1)
	 FROM
		#dbs d
		INNER JOIN #backups b on d.DatabaseName = b.DatabaseName AND b.BACKUP_TYPE='DIFF'
		LEFT JOIN dbo.BackupReportExclusion ex on d.DatabaseName = LTRIM(RTRIM(ex.DatabaseName)) and ex.ExcludeDiff = 1
		LEFT JOIN #backups fulls ON d.DatabaseName = b.DatabaseName AND b.BACKUP_TYPE = 'FULL' 
	WHERE
		b.BACKUP_TYPE = 'DIFF'
		AND b.LATEST_BACKUP_DATE < @DiffDT	--backup not taken in the time for diff
		AND b.LATEST_BACKUP_DATE < @DiffDT  -- and a full was not taken within the diff time too, if we have a full we don't really need the diff
		AND d.DatabaseName NOT IN(N'msdb',N'tempdb',N'model',N'master')
		AND ex.DatabaseName IS NULL
		AND fulls.LATEST_BACKUP_DATE < @DiffDT --exclude if a full backup has been taken

	IF @Debug = 1
	BEGIN
		SELECT '#BACKUP_EXCEPTION (DIFF)' AS [TableName], * FROM #BACKUP_EXCEPTION  where BACKUP_TYPE = 'DIFF'
	END
			
END

IF @MinutesForLog != 0
BEGIN
	INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATEST_BACKUP_DATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP)
	SELECT 
		b.DatabaseName
		,b.BACKUP_TYPE
		,b.LATEST_BACKUP_DATE 
		,b.HOURS_SINCE_BACKUP
		,b.MINUTES_SINCE_BACKUP
	 FROM
		#dbs d
		INNER JOIN #backups b on d.DatabaseName = b.DatabaseName AND b.BACKUP_TYPE='LOG'
		LEFT JOIN dbo.BackupReportExclusion ex on d.DatabaseName = LTRIM(RTRIM(ex.DatabaseName)) and ex.ExcludeLog = 1
		
	WHERE
		b.BACKUP_TYPE = 'LOG'
		AND ISNULL(b.LATEST_BACKUP_DATE,GETDATE()) < @LogDT
		AND ex.DatabaseName IS NULL

	IF @Debug = 1
	BEGIN
		SELECT '#BACKUP_EXCEPTION (LOG)' AS [TableName], * FROM #BACKUP_EXCEPTION  where BACKUP_TYPE = 'LOG'
	END
END

IF @Debug = 1
BEGIN
	SELECT 
		'Backup Excpetion' as 'Table_BackupExcpetion', 
		*
	 FROM 
		dbo.BackupReportExclusion 
	ORDER BY
		DatabaseName

	SELECT
		'#BACKUP_EXCEPTION' as TempTable_BACKUP_EXCEPTION,
		DATABASENAME, 
		BACKUP_TYPE, 
		LATEST_BACKUP_DATE, 
		HOURS_SINCE_BACKUP, 
		MINUTES_SINCE_BACKUP
	
	FROM 
		#BACKUP_EXCEPTION 
	ORDER BY 
		BACKUP_TYPE, 
		DATABASENAME, 
		LATEST_BACKUP_DATE
END

SET @Body ='<html><body><H2>Fortifed Data BackUp Exception Report:   </H2>'

SELECT @ReportDate = CONVERT(VARCHAR(30), GETDATE(),100)
set @params =' <table border = 1>     
	 <tr> <th> Parameter </th> <th> Value</th>  </tr>'        
		+ '<TR><td align ="left">@HoursForFull </td> <td align ="center">' + CAST(@HoursForFull AS VARCHAR(30))+ '</tr>' 
		+ '<TR><td align ="left">@MinutesForDiff </td> <td align ="center">' + CAST(@MinutesForDiff  AS VARCHAR(30))+ '</tr>' 
		+ '<TR><td align ="left">@MinutesForLog </td> <td align ="center">' + CAST(@MinutesForLog  AS VARCHAR(30))+ '</tr>'
		--+ '<TR><td align ="left">@ExcludeCopyOnly</td> <td align ="center">' + CAST(@ExcludeCopyOnly  AS VARCHAR(30)) + '</tr>' 
		+ '<TR><td align ="left">@DeviceType</td> <td align ="center">' +  @DeviceType + '</tr>' 
		+ '<TR><td align ="left">Report Creation Time </td> <td align ="left">' + @ReportDate + '</tr>'
		+'</table><BR>'
	    


IF EXISTS ( SELECT TOP 1 1 FROM #BACKUP_EXCEPTION )    
BEGIN    
	 SET @Xml = CAST(( SELECT [DATABASENAME] AS 'td','',[BACKUP_TYPE] AS 'td','',CONVERT(VARCHAR(30),LATEST_BACKUP_DATE,100) AS 'td' ,'',[HOURS_SINCE_BACKUP] AS 'td'  ,'',[MINUTES_SINCE_BACKUP] AS 'td'         
						FROM  [#BACKUP_EXCEPTION]     
						FOR XML PATH('tr'), ELEMENTS ) AS NVARCHAR(MAX))    
    
	 SET @Body = @Body + '
	 <H3>' +@H3Text+ '</H3>    
	 <H4>The following backups needs to be checked to ensure that backup is current:  </H4>    
	 <table border = 1>     
	 <tr> <th> DATABASENAME      </th> <th> BACKUP TYPE                 </th>  <th> LATEST BACKUP DATE                 </th>  <th> HOURS WITHOUT BACKUP                 </th>  <th> MINUTES WITHOUT BACKUP                 </th> </tr>'        
    
	 SET @Body = @Body  + @Xml +  '</table><BR>' + @params + '</body></html>'     
        
	 EXEC msdb.dbo.sp_send_dbmail     
	 @recipients=@emailRecipients,         
	 @subject = @EmailSubject,    
	 @body =@Body,    
	 @body_format ='HTML',    
	 @query_result_header = 0,    
		@exclude_query_output = 1,    
		@append_query_error = 1,    
		@query_result_no_padding = 1,    
	 @profile_name = @EmailProfile;    
  


	--Wrapping this in a try catch as I do not want this procedure to error out, but I do want the notification written to the SQL Error Log.
	BEGIN TRY
		SET @msg = CONVERT(varchar(30), GETDATE(),109) +' - Procedure ' + OBJECT_NAME(@@PROCID) +', was run on server ' + @@SERVERNAME + ', BACKUP EXCEPTIONS WERE FOUND and emailed.'
		RAISERROR(@msg,10,1) WITH NOWAIT;
		IF @WriteToErrorLog = 1
			RAISERROR(@msg,16,1) WITH LOG;
	END TRY
	BEGIN CATCH -- do nothing, but have to do something
		PRINT ''
	END CATCH
END    
ELSE
BEGIN
	BEGIN TRY
		SET @msg = CONVERT(varchar(30), GETDATE(),109) +' - Procedure ' + OBJECT_NAME(@@PROCID) +', No Backup exceptions found. This is an informational message only, no user action is required.'
		RAISERROR(@msg, 10,1) WITH NOWAIT;
		IF @WriteToErrorLog = 1
			RAISERROR(@msg, 16,1) WITH LOG;
	END TRY
	BEGIN CATCH
		PRINT ''
	END CATCH
	IF ISNULL(@OnCleanRecipients,'') != ''
	BEGIN
		SET  @EmailSubject =  @EmailSubject + '  - NO Exception  found.'
		 SET @Body = @Body + '<H3>No Exceptions Found</H3><BR>' + @params + '</body></html>'     
		EXEC msdb.dbo.sp_send_dbmail     
			 @recipients= @OnCleanRecipients,         
			 @subject = @EmailSubject,    
			 @body =@Body,    
			 @body_format ='HTML',     
			 @profile_name = @EmailProfile;
		
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[BackupException_AG]',10,1) WITH NOWAIT;
if object_id('dbo.BackupException_AG') is null exec('create procedure [dbo].[BackupException_AG] as select getdate() DT')
GO
  
/*******************************************************************************************************************
Created By: Keith Buck
Created On: 3/20/2018

Purpose: Validate FULL and/or Differential and/or Transaction Log backups for databases in a Availability Group where the 
	backups could be taken by any server on which the AG resides. Report only includes DISK backups that are not corrupted.
	There are no other exclusions or inclusions from the backupset
	THIS REPORT ONLY NEEDS TO BE RUN ON THE PRIMARY REPLICA however you can run it on any or all if you like but you will get
	one email per execution depending on if issues are found.

Parameters:	
	@DebugOverride	BIT = 0 :	Real parameter accepted by Procedure that will override the Debug setting in the table of parameters, makes it easier to debugz

Former Parameters now moved to config_fddba2 Where Name=parameters and Domain =BackupExceptionReport_AG
	@NamesList			:List of Availability Group names and Listeners delimted by tilde then caret. 
							Format is AgName~ListenerName^AgName~ListenerName^AgName~ListenerName
	@InstanceNames		: tilde ~ delimetedlList of Instances in the AG.
	@HoursForFull		: Number of hours to check since a FULL backup was taken. Any database that 
							has not had a backup in the last @HoursForFull will show up in this report.
	@MinutesForDiff		: Number of hours to check since a DIFFERENTIAL backup was taken. If 0 then DIFF backups will not be checked.
	@MinutesForTranLog	: Number or minutes to check since a Log backup was taken. If 0 then TRANLOG backups will not be checked.
	@emailRecipients	: Semi-colon delimted list of email account that receive the report
	@EmailSubject		: Text for the subject, procedure will replace explict text '[SERVERNAME]' with the actual server name
	@EmailProfile		: Database Mail profile to use to send emails
	@H3Text				:Text for the H3 (heading 3) section of the report. this is where we can include a message 
							specific to Agio or not. Agio would be used for prod. DO NOT inlcude the <H3> HTML tags
	@OnCleanRecipients	: Semi-colon delimted list of email account that receive an email that no exceptions were found. If blank or NULL no email will be sent.
	@AuthAccount		: If not using windows authentication for OPENROWSET command then enter a SQL Account name, if NULL windows auth is used see post sections for permissions
	@AuthPwd			: Password to be used if @AuthAccount is not null.
	@WriteToErrorLog	: Bit flag indicationg to write certain output statements to the SQL Error Log with a severity of 16 if missing backups are found.
	@Debug				: Flag to use for debugging to show output of steps. 1 = on, 0 = off

If using a non sysadmin account for this check it will need to have the following permissions
		GRANT SELECT ON [dbo].[backupset] TO [AccountName] AS [dbo]
		GRANT SELECT ON [dbo].[backupmediafamily] TO [DBA_Backup_Reader] AS [dbo]
		GRANT VIEW ANY DEFINITION TO [DBA_Backup_Reader]
		GRANT VIEW ANY DATABASE TO [DBA_Backup_Reader]
		GRANT VIEW SERVER STATE TO [DBA_Backup_Reader]


Changes:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Date:	12/26/2019	
By:		Keith Buck
Note:	Added @DebugOverride parameter. Updated comments header and changed parameter delimters for	@NamesList and @InstanceNames list as the move to have them all in one entry in a table 
		causes a parsing issue
3/13/2019 Keith Buck - Fixed bugs where report was not accurate at all, added more columns to report to match exlusion table, added date report run to Param List in report
6/6/2019 Keith BUck - Fixed bug, email profile was hard coded, change to accept paramter @EmailProfile.
*******************************************************************************************************************/
ALTER PROCEDURE dbo.BackupException_AG(
	@DebugOverride	BIT = 0
)
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

--GET ALL THE PARAMETERS FROM THE TABLE
DECLARE @parameters				VARCHAR(3950)
DECLARE @name					VARCHAR(3950)					
DECLARE @value					VARCHAR(3950)
DECLARE @NamesList				VARCHAR(1028)
DECLARE @InstanceNames			VARCHAR(1028)
DECLARE @HoursForFull			INT
DECLARE @MinutesForDiff			INT
DECLARE @MinutesForTranLog		INT
DECLARE @EmailRecipients		VARCHAR(1000)
DECLARE @EmailSubject			VARCHAR(256)
DECLARE @EmailProfile			SYSNAME
DECLARE @H3Text					VARCHAR(200)
DECLARE @OnCleanRecipients		VARCHAR(1000)
DECLARE @AuthAccount			VARCHAR(128)
DECLARE @AuthPwd				VARCHAR(256)
DECLARE @WriteToErrorLog		BIT
DECLARE @Debug					BIT



SELECT TOP 1 @parameters = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'parameters' and [domain] = 'BackupExceptionReport_AG'

DECLARE param_cur CURSOR FAST_FORWARD LOCAL FOR
SELECT a, b FROM FDDBA.dbo.fSplit2columns(@parameters, '=', ',')
OPEN param_cur
FETCH NEXT FROM param_cur INTO @name, @value
WHILE @@FETCH_STATUS != -1
BEGIN
		SET @name = LTRIM(RTRIM(@name))
		SET @value = LTRIM(RTRIM(@value))
		IF @name = 'NamesList' 
			SET @NamesList = ISNULL(@value,'') 

		IF @name = 'InstanceNames' 
			SET @InstanceNames = ISNULL(@value,'')
		
		IF @name = 'HoursForFull' 
			SET @HoursForFull = CAST(ISNULL(@value,'0') AS INT)

		IF @name = 'MinutesForDiff' 
			SET @MinutesForDiff = CAST(ISNULL(@value,'0') AS INT)
			
		IF @name = 'MinutesForTranLog' 
			SET @MinutesForTranLog = CAST(ISNULL(@value,'0') AS INT)
		
		IF @name = 'emailRecipients'
			SET @EmailRecipients = @value

		IF @name = 'H3Text'
			SET @H3Text = @value

		IF @name = 'OnCleanRecipients'
			SET @OnCleanRecipients = @value
			
		IF @name = 'AuthAccount'
		BEGIN
			IF LEN( ISNULL(@value,'')) > 0
				SET @AuthAccount= @value
		END

		IF @name = 'AuthPwd'
		BEGIN
			IF LEN( ISNULL(@value,'')) > 0
				SET @AuthPwd= @value
		END

		IF @name = 'EmailSubject'
			SET @EmailSubject = @value

		IF @name = 'EmailProfile'
			SET @EmailProfile = @value

		IF @name = 'WriteToErrorLog'
			SET @WriteToErrorLog = CAST(ISNULL(@value,'0') AS BIT)

		IF @name = 'Debug'
		BEGIN
			IF @value IS NULL
				SET @Debug = 0
			ELSE
				SET @Debug = CAST(SUBSTRING(LTRIM(RTRIM(@value)),1,1) AS BIT)
		END
		FETCH NEXT FROM param_cur INTO @name, @value
END
CLOSE param_cur
DEALLOCATE param_cur
IF @DebugOverride = 1 
	SET  @Debug = @DebugOverride

IF @Debug = 1
BEGIN
	PRINT '@NamesList = ' + @NamesList
	PRINT '@InstanceNames = ' + @InstanceNames
	PRINT '@HoursForFull = ' + CAST(@HoursForFull AS VARCHAR(100))
	PRINT '@MinutesForDiff = ' + CAST(@MinutesForDiff AS VARCHAR(100))
	PRINT '@MinutesForTranLog = ' + CAST(@MinutesForTranLog AS VARCHAR(100))
	PRINT '@EmailRecipients = ' + @EmailRecipients
	PRINT '@H3Text = ' + @H3Text 
	PRINT '@OnCleanRecipients = ' +@OnCleanRecipients 
	PRINT '@EmailSubject = ' + @EmailSubject
	PRINT '@EmailProfile = ' + @EmailProfile
	PRINT '@WriteToErrorLog = ' + CAST(@WriteToErrorLog AS VARCHAR(100))
	PRINT '@AuthAccount = ' + ISNULL(@AuthAccount,'NULL')
	PRINT '@AuthPwd = ' + ISNULL(@AuthPwd,'NULL')
END


DECLARE @AgName						VARCHAR(1028) 
DECLARE @ListenerName				VARCHAR(128)
DECLARE @sql						NVARCHAR(MAX)
DECLARE @DBList						NVARCHAR(2024)
DECLARE @msg						NVARCHAR(2048)
DECLARE @ServerName					SYSNAME
DECLARE @DbName						SYSNAME
DECLARE @dt							DATETIME
DECLARE @ReportDate					VARCHAR(30)

DECLARE @Body						NVARCHAR(MAX)    
DECLARE @Xml						NVARCHAR(MAX)
DECLARE @HtmlExclusions				NVARCHAR(MAX)
DECLARE @HtmlParams					NVARCHAR(MAX)



--set job times to negative if a positve number was passed in
IF @HoursForFull > 0
	SET @HoursForFull = @HoursForFull * -1
--diff
IF @MinutesForDiff != 0  
BEGIN
	IF @MinutesForDiff > 0 
		SET @MinutesForDiff = @MinutesForDiff * -1
END
--log
IF @MinutesForTranLog != 0  
BEGIN
	IF @MinutesForTranLog > 0 
		SET @MinutesForTranLog = @MinutesForTranLog * -1
END

IF @EmailSubject IS NOT NULL
BEGIN
	SET @EmailSubject = REPLACE(@EmailSubject,'[SERVERNAME]',@@SERVERNAME)
END

IF @H3Text IS NOT NULL
BEGIN
	SET @H3Text = REPLACE(@H3Text,'[SERVERNAME]',@@SERVERNAME)
END

/************************************************************************
	Break down the @AgList passed in values to a table of Availability
	Grop names and listners
************************************************************************/
IF @NamesList IS NOT NULL
BEGIN
	DECLARE @agtemp						TABLE(AgList VARCHAR(1028))
	INSERT INTO @agtemp (AgList) SELECT items FROM dbo.fSplit(@NamesList, '^')

	IF @Debug = 1
	BEGIN
		select '@agtemp' as TempTableName, * from @agtemp
	END

	IF OBJECT_ID('tempdb..#AGS') IS NOT NULL
		DROP TABLE #AGS
	CREATE TABLE #AGS(AG VARCHAR(1028) NULL, Listener VARCHAR(1028) NULL)



	WHILE (SELECT COUNT(*) FROM @agtemp) >0
	BEGIN
		SET @AgName = NULL
		SELECT TOP 1 @AgName = AgList  FROM @agtemp
		INSERT INTO #AGS (AG, Listener)   SELECT SUBSTRING(@AgName,1,CHARINDEX('~',@AgName)-1) , SUBSTRING(@AgName,CHARINDEX('~',@AgName)+1,LEN(@AgName))
		DELETE FROM @agtemp WHERE	AgList = @AgName  
	END
	IF @Debug = 1
	BEGIN
		SELECT '#AGS' as TempTableName, * from #AGS
	END

END

/*********************************************************************************
	Connect to each listener and obtain a list of databases within each AG
*********************************************************************************/
IF OBJECT_ID('tempdb..#ListenerDBs') IS NOT NULL
	DROP TABLE #ListenerDBs
CREATE TABLE #ListenerDBs(AGName VARCHAR(1028), DatabaseName SYSNAME)


SET @AgName = NULL
SET @ListenerName = NULL
DECLARE curAgs  CURSOR  FAST_FORWARD LOCAL FOR 
	SELECT AG, Listener  FROM #AGS
OPEN curAgs
FETCH NEXT FROM curAgs INTO @AgName, @ListenerName
WHILE @@FETCH_STATUS = 0
BEGIN
	
	SET @sql = N'INSERT INTO #ListenerDBs(AGName, DatabaseName)
	SELECT ''' + @AgName + ''', a.DatabaseName FROM OPENROWSET(''SQLNCLI11'', ''Server=' +  @ListenerName +   
		CASE WHEN @AuthAccount IS NULL THEN 
			N';Trusted_Connection=Yes;Integrated Security=SSPI' + N';''' 
			ELSE 	
			N';UID=' + @AuthAccount + N';PWD=' + @AuthPwd + N';''' 
			END 
		+ N',
			''SELECT 
				d.name AS DatabaseName
				FROM
				sys.databases d
				INNER JOIN sys.dm_hadr_database_replica_states drs on d.group_database_id = drs.group_database_id AND d.replica_id = drs.replica_id
				INNER JOIN sys.availability_groups ag on drs.group_id = ag.group_id
			WHERE 
				d.replica_id IS NOT NULL
				AND ag.name= N''''' + @AgName  + N'''''
			ORDER BY
				ag.name,
				d.name'') AS a'
	IF @Debug = 1
	BEGIN
		SELECT @sql AS CursorLoop_SQL_Statement
	END
	EXECUTE sp_executesql @sql
	FETCH NEXT FROM curAgs INTO @AgName, @ListenerName
END
CLOSE curAgs
DEALLOCATE curAgs

IF @Debug =1
BEGIN
	SELECT '#ListenerDBs' as 'TempTableName', * FROM #ListenerDBs -- ORDER BY AGName, DatabaseName
END


select @DBList= CAST( stuff( (select ',' +  '''' + DatabaseName + ''''
				FROM #ListenerDBs
				for xml path('')), 1, 1, '') AS NVARCHAR(MAX))

IF @Debug = 1
SELECT @DBList as '@DBList'

/*********************************************************************************
	Connect to each server and obtain the latest backup for each database 
*********************************************************************************/
IF OBJECT_ID('tempdb..#BackupInfo') IS NOT NULL
	DROP TABLE #BackupInfo
CREATE TABLE #BackupInfo(ServerName SYSNAME, DatabaseName SYSNAME, BackupType VARCHAR(30), BackupStartDate DATETIME2(3))



DECLARE curBackups  CURSOR  FAST_FORWARD LOCAL FOR 
	SELECT items FROM dbo.fSplit(@InstanceNames,'~')
OPEN curBackups
FETCH NEXT FROM curBackups INTO @ServerName
WHILE @@FETCH_STATUS = 0
BEGIN 
	IF @Debug =1 
	BEGIN
		SET @msg = 'Working on backups for server: ' + @ServerName + '.'
		RAISERROR(@msg,10,1) WITH NOWAIT;
	END
	-- GET THE BACKUPS
	SET @sql = N'INSERT INTO #BackupInfo(ServerName, DatabaseName, BackupType , BackupStartDate)
	SELECT ''' + @ServerName + ''',  a.database_name,  CASE WHEN type = ''D'' THEN ''FULL'' WHEN type = ''L'' THEN ''log'' WHEN type = ''I'' THEN ''DIFF'' ELSE ''UNKNOWN'' END , a.LastBackupStart FROM OPENROWSET(''SQLNCLI11'', ''Server=' +  @ServerName +   
		CASE WHEN @AuthAccount IS NULL THEN 
			N';Trusted_Connection=Yes;Integrated Security=SSPI' +  N';''' 
			ELSE 	
			N';UID=' + @AuthAccount + N';PWD=' + @AuthPwd + N';'''
			END 
		+ N',
					''Select DISTINCT 
								s.database_name,
								s.type,
								MAX(s.BACKUP_START_DATE) AS LastBackupStart
							FROM	
								msdb..backupset s
								INNER JOIN msdb.dbo.backupmediafamily A on S.media_set_id = A.media_set_id
	
							Where
								s.type IN(''''D'''',''''L'''' ,''''I'''' )
								AND S.database_name IN('  + REPLACE(@DBList,'''','''''') +  ')
								AND a.device_type = 2 --DISK
								AND s.is_damaged = 0
							GROUP BY
								s.database_name
								,s.type
							'') AS a'
		IF @Debug = 1
		BEGIN
			RAISERROR('',10,1) WITH NOWAIT;
			RAISERROR('sp_ExecuteSQL Statement to get ALL backups.',10,1) WITH NOWAIT;
			RAISERROR(@sql,10,1) WITH NOWAIT;
		END
		EXECUTE sp_executesql @sql 

	
	FETCH NEXT FROM curBackups INTO @ServerName
END
CLOSE curBackups
DEALLOCATE curBackups

--fix to ensure there is an entry for every database for full, diff and tran log, LOOP through all the databases and insert a record if none exists
--this allows us to do inner joins later in the script and eliminates incorrect data
DECLARE curDBs CURSOR  FAST_FORWARD LOCAL FOR
SELECT REPLACE(items,'''','')  FROM DBO.fSplit(@DBList,',')
OPEN curDBs
FETCH NEXT FROM curDBS into @DbName
WHILE @@FETCH_STATUS = 0
BEGIN
	IF NOT EXISTS(SELECT * FROM #BackupInfo WHERE DatabaseName = @DbName AND BackupType = 'FULL')
		INSERT INTO #BackupInfo(ServerName, DatabaseName, BackupType , BackupStartDate) VALUES(N'NONE', @DbName, 'FULL', '1/1/2000')
	IF NOT EXISTS(SELECT * FROM #BackupInfo WHERE DatabaseName = @DbName AND BackupType = 'DIFF')
		INSERT INTO #BackupInfo(ServerName, DatabaseName, BackupType , BackupStartDate) VALUES(N'NONE', @DbName, 'DIFF', '1/1/2000')
	IF NOT EXISTS(SELECT * FROM #BackupInfo WHERE DatabaseName = @DbName AND BackupType = 'LOG')
		INSERT INTO #BackupInfo(ServerName, DatabaseName, BackupType , BackupStartDate) VALUES(N'NONE', @DbName, 'LOG', '1/1/2000')

	FETCH NEXT FROM curDBS into @DbName
END
CLOSE curDBs
DEALLOCATE curDBs


CREATE CLUSTERED INDEX cix_BackupInfo on #BackupInfo (BackupType, DatabaseName, BackupStartDate)

IF OBJECT_ID('tempdb..#BackupInfoLast') IS NOT NULL
	DROP TABLE #BackupInfoLast
CREATE TABLE #BackupInfoLast(ServerName SYSNAME, DatabaseName SYSNAME, BackupType VARCHAR(30), BackupStartDate DATETIME2(3))

INSERT INTO #BackupInfoLast(ServerName, DatabaseName, BackupType, BackupStartDate)
SELECT b.ServerName,  b.DatabaseName, b.BackupType , b.BackupStartDate 
	FROM 
	#BackupInfo b
	INNER JOIN (SELECT DatabaseName, MAX(BackupStartDate) AS BackupStartDate, BackupType FROM #BackupInfo GROUP BY DatabaseName, BackupType) as x ON b.DatabaseName = x.DatabaseName AND b.BackupStartDate = x.BackupStartDate AND b.BackupType = x.BackupType
	--LEFT JOIN dbo.BackupReportExclusion bu on b.DatabaseName = bu.DatabaseName 
--WHERE
--	bu.DatabaseName IS NULL
ORDER BY 
	b.DatabaseName 
	,b.BackupType


IF @Debug = 1
BEGIN
	SELECT '#BackupInfo' as  'TempTable_BackupInfo', * FROM #BackupInfo ORDER BY BackupType, DatabaseName, BackupStartDate
	SELECT 'BackupReportExclusion' as 'Table_BackupReportExclusion', DatabaseName  FROM dbo.BackupReportExclusion 
	SELECT 
		'#BackupInfoLast' as  'TempTable_BackupInfoLast'
		,DatabaseName
		,BackupType 
		,BackupStartDate 
		,CASE WHEN BackupType ='FULL' THEN DATEDIFF(HOUR, BackupStartDate, GETDATE()) ELSE NULL END AS HoursSinceLastBackup
		,CASE WHEN BackupType ='FULL'  THEN @HoursForFull ELSE NULL END AS '@HoursForFull'
		,CASE WHEN BackupType = 'DIFF' AND @MinutesForDiff != 0 THEN DATEDIFF(MINUTE,BackupStartDate,GETDATE()) ELSE NULL END AS MinutesSinceLastBackup
		,CASE WHEN BackupType ='DIFF' AND @MinutesForDiff != 0 THEN @MinutesForDiff  ELSE NULL END AS '@MinutesForDIFF'
		,CASE WHEN BackupType ='LOG' AND @MinutesForTranLog != 0 THEN DATEDIFF(MINUTE, BackupStartDate, GETDATE())  ELSE NULL END AS MinutesSinceLastBackup
		,CASE WHEN BackupType ='LOG' AND @MinutesForTranLog != 0 THEN @MinutesForTranLog  ELSE NULL END AS '@MinutesForTranLog'
		FROM 
		#BackupInfoLast 
	ORDER BY 
		DatabaseName
		,BackupType
END





/*********************************************************************************
	Populate a temp table with all the missing backups DB Name and Type
*********************************************************************************/

IF OBJECT_ID('tempdb..#BACKUP_EXCEPTION') IS NOT NULL	
	DROP TABLE #BACKUP_EXCEPTION
CREATE TABLE #BACKUP_EXCEPTION(DATABASENAME VARCHAR(128), BACKUP_TYPE VARCHAR(10) ,LATESTBACKUPDATE DATETIME NULL, HOURS_SINCE_BACKUP  INT, MINUTES_SINCE_BACKUP  INT, BACKUP_SERVER_NAME SYSNAME NULL)

--INSERT ANY DATABASES THAT HAVE NEVER HAD A FULL BACKUP RUN 
INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATESTBACKUPDATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP, BACKUP_SERVER_NAME)
SELECT 
	b.DatabaseName
	,b.BackupType
	,NULL
	,-1
	,-1
	,NULL
	FROM	
	#BackupInfoLast b
	LEFT JOIN #ListenerDBs db on b.DatabaseName = db.DatabaseName
WHERE
	db.DatabaseName IS NULL
	AND b.DatabaseName NOT IN(SELECT DatabaseName FROM dbo.BackupReportExclusion)


--insert any FULLS that are older than the hours parameter @HoursForFull which is passed into the procedure
IF @HoursForFull != 0
BEGIN
	SET @dt = DATEADD(HOUR,@HoursForFull, GETDATE())
	IF @Debug = 1
		SELECT @dt AS 'Full Backup Date'
	INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATESTBACKUPDATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP, BACKUP_SERVER_NAME)
	SELECT 
		b.DatabaseName
		,b.BackupType
		,b.BackupStartDate
		,DATEDIFF(HOUR,b.BackupStartDate, GETDATE())
		,DATEDIFF(MINUTE, b.BackupStartDate, GETDATE())
		,b.ServerName
		FROM	
		#ListenerDBs db
		INNER JOIN #BackupInfoLast b ON db.DatabaseName = b.DatabaseName
			AND b.BackupType = 'FULL'
			AND b.BackupStartDate < @dt
		LEFT JOIN dbo.BackupReportExclusion bu on b.DatabaseName = bu.DatabaseName AND bu.ExcludeFull = 1
	WHERE
		bu.DatabaseName IS NULL

	IF @Debug = 1
	BEGIN
		SELECT '#BACKUP_EXCEPTION (FULL)' AS [TableName], * FROM #BACKUP_EXCEPTION 
	END

END

--insert any DIFFERENTIAL backup that are older than the Minutes parameter @MinutesForDiff which is passed into the procedure
IF @MinutesForDiff != 0
BEGIN
	SET @dt = DATEADD(MINUTE,@MinutesForDiff, GETDATE())
	IF @Debug = 1
		SELECT @dt AS 'Differential Backup Date'
	
	INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATESTBACKUPDATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP,BACKUP_SERVER_NAME)
	SELECT 
		db.DatabaseName
		,'DIFF'
		,b.BackupStartDate
		,CASE WHEN b.BackupStartDate IS NULL THEN -1 ELSE DATEDIFF(HOUR,b.BackupStartDate, GETDATE()) END
		,CASE WHEN b.BackupStartDate IS NULL THEN -1 ELSE DATEDIFF(MINUTE,b.BackupStartDate, GETDATE()) END
		,b.ServerName
		FROM	
		#ListenerDBs db
		INNER JOIN #BackupInfoLast b ON db.DatabaseName = b.DatabaseName
			AND b.BackupType = 'DIFF'
			AND b.BackupStartDate < @dt
		LEFT JOIN dbo.BackupReportExclusion bu on db.DatabaseName = bu.DatabaseName and bu.ExcludeDiff = 1
		LEFT JOIN #BackupInfoLast  fulls ON db.DatabaseName = fulls.DatabaseName AND fulls.BackupType  = 'FULL' 
	WHERE
		bu.DatabaseName IS NULL
		AND fulls.BackupStartDate < @dt --exclude if a full backup has been taken

	IF @Debug = 1
	BEGIN
		SELECT '#BACKUP_EXCEPTION (DIFF)' AS [TableName], * FROM #BACKUP_EXCEPTION  where BACKUP_TYPE = 'DIFF' ORDER BY DATABASENAME
	END

END

--insert any TRANSATION LOGS that are older than the Minutes parameter @MinutesForTranLog which is passed into the procedure
IF @MinutesForTranLog != 0
BEGIN
	SET @dt = DATEADD(MINUTE,@MinutesForTranLog, GETDATE())
	IF @Debug = 1
		SELECT @dt AS 'Tran Log Backup Date'

	INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATESTBACKUPDATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP,BACKUP_SERVER_NAME)
	SELECT 
		db.DatabaseName
		,'Log'
		,b.BackupStartDate
		,ISNULL(DATEDIFF(HOUR,b.BackupStartDate, GETDATE()),-1)
		,ISNULL(DATEDIFF(MINUTE,b.BackupStartDate, GETDATE()),-1)
		,b.ServerName
		FROM	
		#ListenerDBs db
		INNER JOIN sys.databases d on db.DatabaseName = d.name 
		INNER JOIN #BackupInfoLast b ON db.DatabaseName = b.DatabaseName
			AND b.BackupType = 'Log'
			AND b.BackupStartDate <  @dt
		LEFT JOIN dbo.BackupReportExclusion bu on db.DatabaseName = bu.DatabaseName  AND bu.ExcludeLog =1
	WHERE
		bu.DatabaseName IS NULL
		AND ISNULL(d.recovery_model_desc,'SIMPLE') != 'SIMPLE'

	IF @Debug = 1
	BEGIN
		SELECT '#BACKUP_EXCEPTION (LOG)' AS [TableName], * FROM #BACKUP_EXCEPTION  where BACKUP_TYPE = 'LOG'
	END
END

IF @Debug = 1
BEGIN
	SELECT
		'#BACKUP_EXCEPTION ' AS Table_BACKUP_EXCEPTION 
		,DATABASENAME AS 'Database Name'
		,BACKUP_TYPE AS 'Backup Type'
		,LATESTBACKUPDATE AS 'Last Backup Date'
		,CASE WHEN BACKUP_TYPE= 'FULL' THEN HOURS_SINCE_BACKUP ELSE NULL END AS 'Hours Since Backup'
		,CASE WHEN BACKUP_TYPE= 'FULL' THEN  @HoursForFull * -1 ELSE NULL END AS 'Full Frequency'
		,CASE WHEN BACKUP_TYPE ='LOG' THEN MINUTES_SINCE_BACKUP ELSE NULL END 'Minutes Since Backup'
		,CASE WHEN BACKUP_TYPE= 'LOG' THEN @MinutesForTranLog * -1 ELSE NULL END AS 'Log Frequency'
		,BACKUP_SERVER_NAME AS 'Last Backup Server Name'
		FROM
		#BACKUP_EXCEPTION 
	ORDER BY
		BACKUP_TYPE
		,DATABASENAME
		,MINUTES_SINCE_BACKUP
END


/********************************************************************************************************************************
		Build the parameter list table and the exclustions table
		They will be emailed regardless of whether or not issues are found
********************************************************************************************************************************/
SELECT @ReportDate = CONVERT(VARCHAR(30), GETDATE(),100)
SET @HtmlParams = '<table border = 1>     
		<tr> <th>Parameter Name      </th> <th> Parameter Value             </th></tr>'        
		+ '<td align ="left">@NamesList </td> <td align ="left">' + @NamesList + '</tr>' 
		+ '<TR><td align ="left">@InstanceNames </td> <td align ="left">' + @InstanceNames + '</tr>' 
		+ '<TR><td align ="left">@HoursForFull </td> <td align ="left">' + CAST(@HoursForFull AS VARCHAR(30))+ '</tr>' 
		+ '<TR><td align ="left">@MinutesForDiff </td> <td align ="left">' + CAST(@MinutesForDiff  AS VARCHAR(30))+ '</tr>' 
		+ '<TR><td align ="left">@MinutesForTranLog </td> <td align ="left">' + CAST(@MinutesForTranLog  AS VARCHAR(30))+ '</tr>' 
		+ '<TR><td align ="left">Report Creation Time </td> <td align ="left">' + @ReportDate + '</tr></table>'


SET @HtmlExclusions = '<BR><table border = 1>     
		<tr><th>Database Exclusions      </th> <th>Exclude Full</th> <th>Exclude Diff</th> <th>Exclude Log</th>					</tr>'    
SELECT 
	@HtmlExclusions = @HtmlExclusions + '<tr>'
	+'<td align ="left">' + DatabaseName + '</td>' 
	+'<td align ="middle">' + CAST(ExcludeFull AS VARCHAR(10)) + '</td>' 
	+'<td align ="center">' + CAST(ExcludeDiff AS VARCHAR(10)) + '</td>' 
	+'<td align ="center">' + CAST(ExcludeLog AS VARCHAR(10)) + '</td></tr>' 
 FROM 
	dbo.BackupReportExclusion 
ORDER BY 
	DatabaseName

SET @HtmlExclusions =  @HtmlExclusions +'</table>'
IF @Debug = 1
BEGIN
	SELECT @HtmlParams AS '@HtmlParams'
	SELECT @HtmlExclusions AS '@HtmlExclusions'
END
/********************************************************************************************************************************/

IF EXISTS ( SELECT TOP 1 1 FROM #BACKUP_EXCEPTION )    
BEGIN    
		SET @Xml = CAST(( SELECT [DATABASENAME] AS 'td','',[BACKUP_TYPE] AS 'td','',CASE WHEN [LATESTBACKUPDATE] IS NULL THEN 'null' ELSE   CONVERT(VARCHAR(30),[LATESTBACKUPDATE],100) END AS 'td' ,'',[HOURS_SINCE_BACKUP] AS 'td'  ,'',[MINUTES_SINCE_BACKUP] AS 'td'    ,'',ISNULL([BACKUP_SERVER_NAME],' ') AS 'td'      
						FROM  [#BACKUP_EXCEPTION]     
						FOR XML PATH('tr'), ELEMENTS ) AS NVARCHAR(MAX))    
    
		SET @Body ='<html><body><H2>Native BackUp Exception Report:   </H2>    
		<H3>' +@H3Text+ '</H3>    
		<H4>The following backups needs to be checked to ensure that backup is current:  </H4>    
	<BR>'        
	
	SET  @Body = @Body +  @HtmlParams 
	 
	SET @Body = @Body +   '</tbody></table><BR>' 
	
	
	
	SET @Body = @Body + ' <table border = 1>     
		<tr> <th> DATABASENAME      </th> <th> BACKUP TYPE                 </th>  <th> LATEST BACKUP DATE                 </th>  <th> HOURS WITHOUT BACKUP                 </th>  <th> MINUTES WITHOUT BACKUP                 </th>  <th> LATEST BACKUP SERVER NAME                 </th> </tr>'        
    
		SET @Body = @Body + @Xml + '</table>' + @HtmlExclusions + '</body></html>'     
    
    
   
    
		EXEC msdb.dbo.sp_send_dbmail     
		@recipients=@EmailRecipients,         
		@subject = @EmailSubject,    
		@body =@Body,    
		@body_format ='HTML',    
		@query_result_header = 0,    
		@exclude_query_output = 1,    
		@append_query_error = 1,    
		@query_result_no_padding = 1,    
		@profile_name = 'Agent Mail';    
  
	--Wrapping this in a try catch as I do not want this procedure to error out, but I do want the notification written to the SQL Error Log.
	BEGIN TRY
		SET @msg = 'Procedure FDDBA..' + OBJECT_NAME(@@PROCID) +', was run on server ' + @@SERVERNAME + ', backup exceptions found and were emailed.'
		RAISERROR(@msg,10,1) WITH NOWAIT;
		IF @WriteToErrorLog =1
			RAISERROR(@msg,16,1) WITH LOG;
	END TRY
	BEGIN CATCH -- do nothing, but have to do something
		PRINT ''
	END CATCH
END    
ELSE
BEGIN
	BEGIN TRY
		SET @msg = 'Procedure FDDBA..' + OBJECT_NAME(@@PROCID) +', No Backup exceptions found. This is an informational message only, no user action is required.'
		RAISERROR(@msg, 10,1) WITH NOWAIT;
		IF @WriteToErrorLog =1
			RAISERROR(@msg, 16,1) WITH LOG;
	END TRY
	BEGIN CATCH
		PRINT ''
	END CATCH

	SET @Body ='<html><body><H2>Native BackUp Exception Report:  NO ISSUES FOUND </H2>  '
	+ @HtmlParams + @HtmlExclusions +  '</body></html>'  

	IF ISNULL(@OnCleanRecipients,'') != ''
	BEGIN
		EXEC msdb.dbo.sp_send_dbmail     
				@recipients= @OnCleanRecipients,         
				@subject = @EmailSubject,    
				@body =@Body,    
				@body_format ='HTML', 
				@profile_name = @EmailProfile;
	END
END
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_alerts]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_alerts') is null exec('create procedure [dbo].[configuration_alerts] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_alerts]
*
*	Purpose: Read configuration on database settings and create toset values that do not match suggestion
*
*	Inputs:	
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@is_set_only : OPTIONAL - when 1 it only inserts/updates toset\% rows in config_fddba2 table, this is used so configuration_set can check
*			if a configuration setting is still valid to make as the last toset value might be old or out of date
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. There are configuration values for suggested values
*		2. The name column of config_fddba2 table will be either "severity" or "error" depending on alert type
*		3. The value columns of config_fddba2 table will be in the format of  "<setting>=<value>". Here is an example of
*			error 823 not existing, and 824 needing operator notification: "823,824=<alert name>;nonotify,"
*		4. As will other value settings in config_fddba2, these value settings are multi-column, multi-value. See example in #3.
*		5. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_alerts
(
	@utc varchar(23),
	@is_set_only bit = 0,
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TODO int
	DECLARE @iValue int
	DECLARE @vcValue varchar(3950)
	DECLARE @vcValue2 varchar(3950)
	DECLARE @vcValue3 varchar(3950)
	DECLARE @vcValue4 varchar(3950)
	DECLARE @vcValue5 varchar(3950)
	DECLARE @msg varchar(400)

	DECLARE @operatorid int
	DECLARE @alertid int
	DECLARE @alertname sysname
	DECLARE @enabled bit

	DECLARE @name varchar(50)
	DECLARE @nameagt varchar(50)
	DECLARE @dsuggest varchar(100)
	DECLARE @dtoset varchar(100)
	DECLARE @dagtsug varchar(100)

	SET @name = 'severity'
	SET @nameagt = 'sql agent'
	SET @dsuggest = 'suggested\base\alerts'
	SET @dtoset = 'toset\base\alerts'
	SET @dagtsug = 'suggested\base\sqlagent'

	IF @debug = 1
		RAISERROR('Checking severity alerts', 10, 1) WITH NOWAIT

	SET @vcValue = NULL
	SELECT @vcValue = [value] FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dsuggest
	IF @vcValue IS NOT NULL
	BEGIN
		SELECT @vcValue2 = [value] FROM dbo.config_fddba2 WHERE [name] = @nameagt and [domain] = @dagtsug
		IF @vcValue2 IS NOT NULL
		BEGIN
			SELECT @vcValue3 = b FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'operator'
			IF @vcValue3 IS NOT NULL
			BEGIN
				SELECT @operatorid = id FROM msdb.dbo.sysoperators WHERE [name] = @vcValue3
			END
		END
		SET @vcValue3 = NULL

		SET @vcValue2 = ''
		DECLARE alert_severity_cur CURSOR FOR 
			SELECT CONVERT(int, items) FROM dbo.fSplit(@vcValue, ',')
		OPEN alert_severity_cur
		FETCH NEXT FROM alert_severity_cur INTO @iValue

		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @alertname = NULL
			SET @enabled = 0
			SELECT @alertid = id, @alertname = [name], @enabled = [enabled] 
				FROM msdb.dbo.sysalerts 
				WHERE message_id = 0 
					AND severity = @iValue 
					AND [database_name] IS NULL 
					AND event_description_keyword IS NULL

			IF @alertname IS NOT NULL 
			BEGIN
				IF @operatorid IS NULL
				BEGIN
					IF @enabled = 1
						SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';nonotify,'
					ELSE
						SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';disabled;nonotify,'
				END
				ELSE
				BEGIN
					IF EXISTS (SELECT 1 FROM msdb.dbo.sysnotifications WHERE alert_id = @alertid AND operator_id = @operatorid AND notification_method = 1)
					BEGIN
						IF @enabled = 1
							SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ','
						ELSE
							SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';disabled,'						
					END
					ELSE
					BEGIN
						IF @enabled = 1
							SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';nonotify,'
						ELSE
							SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';disabled;nonotify,'
					END
				END
			END

			FETCH NEXT FROM alert_severity_cur INTO @iValue
		END
		DEALLOCATE alert_severity_cur

		IF @is_set_only = 0
			INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@name, @utc, @vcValue2, 'current')

		--toset
		SET @vcValue3 = ''
		SET @vcValue5 = ''
		DECLARE alert_severity_set_cur CURSOR FOR 
			SELECT items FROM dbo.fSplit(@vcValue, ',')
		OPEN alert_severity_set_cur
		FETCH NEXT FROM alert_severity_set_cur INTO @vcValue3

		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @vcValue4 = NULL
			SELECT @vcValue4 = b FROM dbo.fSplit2columns(@vcValue2, '=',',') WHERE a = @vcValue3

			IF @vcValue4 IS NULL
			BEGIN
				SET @vcValue5 = @vcValue5 + @vcValue3 + ','
			END

			IF CHARINDEX(';',@vcValue4) > 0
			BEGIN
				SET @vcValue5 = @vcValue5 + @vcValue3 + '=' + @vcValue4 + ','
			END
			FETCH NEXT FROM alert_severity_set_cur INTO @vcValue3
		END
		DEALLOCATE alert_severity_set_cur

		IF LEN(@vcValue5) > 0
		BEGIN
			IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset)
				INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@name, @dtoset, @vcValue5)
			ELSE
			BEGIN
				UPDATE dbo.config_fddba2
					SET [value] = @vcValue5,
						UpdatedOn = GETDATE()
					WHERE [name] = @name AND [domain] = @dtoset
			END
		END
		ELSE
		BEGIN
			DELETE dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset
		END
	END
	ELSE
	BEGIN
		SET @msg = 'suggested\base\alerts\severity is NULL'
		RAISERROR(@msg,11,1) WITH NOWAIT
	END

	IF @debug = 1
		RAISERROR('Checking error alerts', 10, 1) WITH NOWAIT

	SET @name = 'error'
	SET @vcValue = NULL
	SELECT @vcValue = [value] FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dsuggest
	IF @vcValue IS NOT NULL
	BEGIN
		SET @vcValue2 = ''
		DECLARE alert_severity_cur CURSOR FOR 
			SELECT CONVERT(int, items) FROM dbo.fSplit(@vcValue, ',')
		OPEN alert_severity_cur
		FETCH NEXT FROM alert_severity_cur INTO @iValue
		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @alertname = NULL
			SET @enabled = 0
			SELECT @alertid = id, @alertname = [name], @enabled = [enabled] 
				FROM msdb.dbo.sysalerts 
				WHERE message_id = @iValue 
					AND severity = 0 
					AND [database_name] IS NULL 
					AND event_description_keyword IS NULL

			IF @alertname IS NOT NULL 
			BEGIN
				IF @operatorid IS NULL
				BEGIN
					IF @enabled = 1
						SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';nonotify,'
					ELSE
						SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';disabled;nonotify,'
				END
				ELSE
				BEGIN
					IF EXISTS (SELECT 1 FROM msdb.dbo.sysnotifications WHERE alert_id = @alertid AND operator_id = @operatorid AND notification_method = 1)
					BEGIN
						IF @enabled = 1
							SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ','
						ELSE
							SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';disabled,'						
					END
					ELSE
					BEGIN
						IF @enabled = 1
							SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';nonotify,'
						ELSE
							SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + @alertname + ';disabled;nonotify,'
					END
				END
			END

			FETCH NEXT FROM alert_severity_cur INTO @iValue
		END
		DEALLOCATE alert_severity_cur

		IF @is_set_only = 0
			INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@name, @utc, @vcValue2, 'current')

		--toset
		SET @vcValue3 = ''
		SET @vcValue5 = ''
		DECLARE alert_error_set_cur CURSOR FOR 
			SELECT items FROM dbo.fSplit(@vcValue, ',')
		OPEN alert_error_set_cur
		FETCH NEXT FROM alert_error_set_cur INTO @vcValue3

		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @vcValue4 = NULL
			SELECT @vcValue4 = b FROM dbo.fSplit2columns(@vcValue2, '=',',') WHERE a = @vcValue3

			IF @vcValue4 IS NULL
			BEGIN
				SET @vcValue5 = @vcValue5 + @vcValue3 + ','
			END

			IF CHARINDEX(';',@vcValue4) > 0
			BEGIN
				SET @vcValue5 = @vcValue5 + @vcValue3 + '=' + @vcValue4 + ','
			END
			FETCH NEXT FROM alert_error_set_cur INTO @vcValue3
		END
		DEALLOCATE alert_error_set_cur

		IF LEN(@vcValue5) > 0
		BEGIN
			IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset)
				INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@name, @dtoset, @vcValue5)
			ELSE
			BEGIN
				UPDATE dbo.config_fddba2
					SET [value] = @vcValue5,
						UpdatedOn = GETDATE()
					WHERE [name] = @name AND [domain] = @dtoset
			END
		END
		ELSE
		BEGIN
			DELETE dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset
		END
	END
	ELSE
	BEGIN
		SET @msg = 'suggested\base\alerts\error is NULL'
		RAISERROR(@msg,11,1) WITH NOWAIT
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_database_files]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_database_files') is null exec('create procedure [dbo].[configuration_database_files] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_database_files]
*
*	Purpose: Read configuration on number of files, file size, file growth and create toset values that do not match suggestion
*
*	Inputs:	
*		@database : REQUIRED - database name to check
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@logical_cpus : OPTIONAL - number of logical cpus which is needed to configure tempdb files
*		@is_set_only : OPTIONAL - when 1 it only inserts/updates toset\% rows in config_fddba2 table, this is used so configuration_set can check
*			if a configuration setting is still valid to make as the last toset value might be old or out of date
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. There are configuration values for the following databases: master, tempdb, model, msdb and all other user database (userdb)
*		2. The name column of config_fddba2 table will be in the format of "(dbid=<database_id>) <setting_type>". Here is an example of
*			msdb file growth: "(dbid=4) file growth(MB)". database_id is used since database_name could exceed column size. Note database_name will 
*			be stored in valuebig column
*		3. The value columns of config_fddba2 table will be in the format of  "<file_id>=<appropriate numeric value>". Here is an example of
*			msdb file 1 growing to 1GB and msdb log file growing to 512MB: "1=1024,2=512,"
*		4. As will other value settings in config_fddba2, these value settings are multi-column and multi-value. See example in #3.
*		5. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_database_files
(
	@database sysname,
	@utc varchar(23),
	@logical_cpus int = 0,
	@is_set_only bit = 0,
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @dbid int
	DECLARE @dbidstr varchar(12)
	DECLARE @iValue int
	DECLARE @iValue2 int
	DECLARE @iValue3 int
	DECLARE @iValue4 int
	DECLARE @iValue5 int
	DECLARE @vcValue varchar(3950)
	DECLARE @vcValue2 varchar(3950)
	DECLARE @vcValue3 varchar(3950)
	DECLARE @vcValue4 varchar(3950)
	DECLARE @vcValue5 varchar(3950)

	DECLARE @db_datasize_MB int
	DECLARE @db_logsize_MB int
	DECLARE @db_data_files_cur int
	DECLARE @db_log_files_cur int
	DECLARE @db_datafiles_suggested int
	DECLARE @db_data_sizes_cur varchar(3950)
	DECLARE @db_data_size_suggested int
	DECLARE @db_data_growths_cur varchar(3950)
	DECLARE @db_data_growth_suggested int
	DECLARE @db_log_sizes_cur varchar(3950)
	DECLARE @db_log_size_suggested int
	DECLARE @db_log_growths_cur varchar(3950)
	DECLARE @db_log_growth_suggested int
	
	DECLARE @max_file_size int
	DECLARE @fileid int

	DECLARE @TODO bit
	DECLARE @msg varchar(400)

	DECLARE @name varchar(50)
	DECLARE @namebase varchar(50)
	DECLARE @dsuggest varchar(100)
	DECLARE @dtoset varchar(100)
	DECLARE @dfcnt varchar(50)
	DECLARE @ftdata varchar(50)
	DECLARE @ftlog varchar(50)
	DECLARE @fpath varchar(50)
	DECLARE @fsize varchar(50)
	DECLARE @fgrow varchar(50)
	DECLARE @maxfsize varchar(50)
	DECLARE @ftcnt varchar(50)
	DECLARE @user varchar(50)
	DECLARE @files varchar(50)
	DECLARE @dsMB varchar(50)
	DECLARE @lsMB varchar(50)
	DECLARE @dgMB varchar(50)
	DECLARE @lgMB varchar(50)
	DECLARE @current varchar(50)

	SET @dbid = DB_ID(@database)
	SET @dbidstr = LTRIM(STR(@dbid))

	SET @dsuggest = 'suggested\base\file'
	SET @dtoset = 'toset\base\file'
	SET @namebase = '(dbid=' + @dbidstr + ')'
	SET @dfcnt = ' files count'
	SET @ftdata = ' data'
	SET @ftlog = ' log'
	SET @fpath = ' file size by path(MB)'
	SET @fsize = ' file size(MB)'
	SET @fgrow = ' file growth(MB)'
	SET @maxfsize = 'max file size(MB)'
	SET @ftcnt = ' file types count'
	SET @current = 'current: '
	SET @user = 'userdb'
	SET @files = ' files'
	SET @dsMB ='datasizeMB'
	SET @lsMB ='logsizeMB'
	SET @dgMB = 'datagrowthMB'
	SET @lgMB = 'loggrowthMB'

	IF @dbid IS NULL
	BEGIN
		SET @msg ='configuration_insert_database: ERROR: Database [' + @database + '] does not exist'
		RAISERROR(@msg,11,1)
		RETURN -1
	END

	IF @debug = 1
	BEGIN
		SET @msg = 'Getting [' + @database + '] (dbid=' + @dbidstr + ') recommendations'
		RAISERROR(@msg, 10, 1) WITH NOWAIT
	END

	SELECT @max_file_size = CONVERT(int, [value]) FROM dbo.config_fddba2 WHERE [name] = @maxfsize AND [domain] = @dsuggest

	IF @max_file_size IS NOT NULL
	BEGIN
		SET @vcValue = NULL
		IF @database IN ('master','tempdb','model','msdb')
		BEGIN
			SELECT @vcValue = [value] FROM dbo.config_fddba2 WHERE [name] = @database + @files AND [domain] = @dsuggest
		END
		ELSE
		BEGIN
			SELECT @vcValue = [value] FROM dbo.config_fddba2 WHERE [name] = @user + @files AND [domain] = @dsuggest
		END
			
		IF @vcValue IS NOT NULL
		BEGIN
			SELECT @db_data_size_suggested = CONVERT(int, b) FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = @dsMB
			SELECT @db_data_growth_suggested = CONVERT(int, b) FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = @dgMB
			SELECT @db_log_size_suggested = CONVERT(int, b) FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = @lsMB
			SELECT @db_log_growth_suggested = CONVERT(int, b) FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = @lgMB

			IF @debug = 1
			BEGIN
				--PRINT 'ds' + STR(@db_data_size_suggested)
				--PRINT 'dg' + STR(@db_data_growth_suggested)
				--PRINT 'ls' + STR(@db_log_size_suggested)
				--PRINT 'lg' + STR(@db_log_growth_suggested)
				SET @msg = 'Checking [' + @database + '] file types count'
				RAISERROR(@msg, 10, 1) WITH NOWAIT
			END

			SET @vcValue = ''
	
			DECLARE file_cur CURSOR FOR
				SELECT COUNT(*), [type] FROM sys.master_files 
					WHERE database_id = @dbid 
					GROUP BY [type] 
					ORDER BY [type]
			OPEN file_cur
			FETCH NEXT FROM file_cur into @iValue, @iValue2
	
			WHILE @@FETCH_STATUS != -1
			BEGIN
				IF @iValue2 = 0
					SET @db_data_files_cur = @iValue

				IF @iValue2 = 1
					SET @db_log_files_cur = @iValue

				SET @vcValue = @vcValue + LTRIM(STR(@iValue2)) + '=' + LTRIM(STR(@iValue)) + ','
				FETCH NEXT FROM file_cur into @iValue, @iValue2
			END
			DEALLOCATE file_cur

			IF @is_set_only = 0
				INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@namebase + @ftcnt, @utc, @vcValue, @current + @database)

			IF @debug = 1
			BEGIN
				SET @msg = 'Checking [' + @database + '] data file size and growth'
				RAISERROR(@msg, 10, 1) WITH NOWAIT
			END

			SET @db_datasize_MB = 0
			SET @iValue3 = 0
			SET @vcValue = '' --db file sizeMB
			SET @vcValue2 = '' --db file growths
			SET @vcValue3 = '' --db file path
			SET @vcValue4 = '' --db file prev path
			SET @vcValue5 = '' --db file path plus sizeMB

			DECLARE file_cur2 CURSOR FOR 
				SELECT [file_id], FLOOR(size/128), FLOOR(growth/128), SUBSTRING(physical_name, 1, LEN(physical_name) - CHARINDEX('\', REVERSE(physical_name)) + 1)
					FROM sys.master_files 
					WHERE database_id = @dbid
						AND [type] = 0 --data
					ORDER BY [file_id]
				OPEN file_cur2
			FETCH NEXT FROM file_cur2 INTO @iValue4, @iValue, @iValue2, @vcValue3
			SET @vcValue4 = @vcValue3
	
			WHILE @@FETCH_STATUS != -1
			BEGIN
				SET @db_datasize_MB = @db_datasize_MB + @iValue
				SET @vcValue = @vcValue + LTRIM(STR(@iValue4)) + '=' + LTRIM(STR(@iValue)) + ','
				SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue4)) + '=' +LTRIM(STR(@iValue2)) + ','

				IF @vcValue3 != @vcValue4
				BEGIN
					IF @vcValue4 != ''
						SET @vcValue5 = @vcValue4 + '=' + LTRIM(STR(@iValue3)) + ','
					SET @iValue3 = @iValue
				END
				ELSE
				BEGIN
					SET @iValue3 = @iValue3 + @iValue
				END

				SET @vcValue4 = @vcValue3
				FETCH NEXT FROM file_cur2 INTO @iValue4, @iValue, @iValue2, @vcValue3
			END
			SET @vcValue5 = @vcValue4 + '=' + LTRIM(STR(@iValue3)) + ','
			DEALLOCATE file_cur2

			IF @is_set_only = 0
			BEGIN
				INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@namebase + @ftdata + @fpath, @utc, @vcValue5, @current + @database)
				INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@namebase + @ftdata + @fsize, @utc, @vcValue, @current + @database)
				INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@namebase + @ftdata + @fgrow, @utc, @vcValue2, @current + @database)
			END

			SET @db_data_sizes_cur = @vcValue
			SET @db_data_growths_cur = @vcValue2

			IF @debug = 1
			BEGIN
				SET @msg = 'Checking [' + @database + '] log file size and growth'
				RAISERROR(@msg, 10, 1) WITH NOWAIT
			END

			SET @db_logsize_MB = 0
			SET @iValue3 = 0
			SET @vcValue = '' --db file sizeMB
			SET @vcValue2 = '' --db file growths
			SET @vcValue3 = '' --db path
			SET @vcValue4 = '' --db file prev path
			SET @vcValue5 = '' --db file path plus sizeMB
	
			DECLARE file_cur3 CURSOR FOR 
				SELECT [file_id], FLOOR(size/128), FLOOR(growth/128), SUBSTRING(physical_name, 1, LEN(physical_name) - CHARINDEX('\', REVERSE(physical_name)) + 1)
					FROM sys.master_files 
					WHERE database_id = @dbid
						AND [type] = 1 --log
					ORDER BY [file_id]
			OPEN file_cur3
			FETCH NEXT FROM file_cur3 INTO @iValue4, @iValue, @iValue2, @vcValue3
			SET @vcValue4 = @vcValue3
	
			WHILE @@FETCH_STATUS != -1
			BEGIN
				SET @db_logsize_MB = @db_logsize_MB + @iValue
				SET @vcValue = @vcValue + LTRIM(STR(@iValue4)) + '=' + LTRIM(STR(@iValue)) + ','
				SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue4)) + '=' +LTRIM(STR(@iValue2)) + ','

				IF @vcValue3 != @vcValue4
				BEGIN
					SET @vcValue5 = @vcValue4 + '=' + LTRIM(STR(@iValue3)) + ','
					SET @iValue3 = 0
				END
				ELSE
				BEGIN
					SET @iValue3 = @iValue3 + @iValue
				END

				SET @vcValue4 = @vcValue3
				FETCH NEXT FROM file_cur3 INTO @iValue4, @iValue, @iValue2, @vcValue3
			END
			SET @vcValue5 = @vcValue4 + '=' + LTRIM(STR(@iValue3)) + ','
			DEALLOCATE file_cur3

			IF @is_set_only = 0
			BEGIN
				INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@namebase + @ftlog + @fpath, @utc, @vcValue5, @current + @database)
				INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@namebase + @ftlog + @fsize, @utc, @vcValue, @current + @database)
				INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@namebase + @ftlog + @fgrow, @utc, @vcValue2, @current + @database)
			END

			SET @db_log_sizes_cur = @vcValue
			SET @db_log_growths_cur = @vcValue2

			IF @debug = 1
			BEGIN
				SET @msg = 'Setting [' + @database + '] data files count'
				RAISERROR(@msg, 10, 1) WITH NOWAIT
			END

			IF @database = 'tempdb'
				SET @db_datafiles_suggested = @logical_cpus
			ELSE
			BEGIN
				IF @db_datasize_MB < @max_file_size
					SET @db_datafiles_suggested = 1
				ELSE
					SET @db_datafiles_suggested = @db_datasize_MB / @max_file_size
			END

			IF @is_set_only = 0
			BEGIN
				IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @namebase + @dfcnt AND [domain] = @dsuggest  AND [comment] = @database)
					INSERT dbo.config_fddba2 ([name], [domain], [value], [comment]) VALUES (@namebase + @dfcnt, @dsuggest, LTRIM(STR(@db_datafiles_suggested)), @database)
				ELSE
				BEGIN
					UPDATE dbo.config_fddba2
						SET [value] = LTRIM(STR(@db_datafiles_suggested)),
							UpdatedOn = GETDATE()
						WHERE [name] = @namebase + @dfcnt AND [domain] = @dsuggest
				END
			END

			IF @db_data_files_cur < @db_datafiles_suggested
			BEGIN
				IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @namebase + @dfcnt AND [domain] = @dtoset  AND [comment] = @database)
					INSERT dbo.config_fddba2 ([name], [domain], [value], [comment]) VALUES (@namebase + @dfcnt, @dtoset, LTRIM(STR(@db_datafiles_suggested)), @database)
				ELSE
				BEGIN
					UPDATE dbo.config_fddba2
						SET [value] = LTRIM(STR(@db_datafiles_suggested)),
							UpdatedOn = GETDATE()
						WHERE [name] = @namebase + @dfcnt AND [domain] = @dtoset AND [comment] = @database
				END
			END
			ELSE
			BEGIN
				DELETE dbo.config_fddba2 WHERE [name] = @namebase + @dfcnt AND [domain] = @dtoset AND [comment] = @database
			END

			IF @database = 'tempdb' AND @is_set_only = 0
			BEGIN
				IF @debug = 1
				BEGIN
					SET @msg = 'Setting [tempdb] files size suggestions'
					RAISERROR(@msg, 10, 1) WITH NOWAIT
				END

				SET @db_data_size_suggested = CEILING(@db_datasize_MB/@logical_cpus)

				SET @db_log_size_suggested = FLOOR(@db_datasize_MB/4)

				SET @vcValue = @dsMB + '=' + LTRIM(STR(ISNULL(@db_data_size_suggested,0))) + ',' + @dgMB + '=' + LTRIM(STR(ISNULL(@db_data_growth_suggested,0))) 
					+ ',' + @lsMB + '=' + LTRIM(STR(ISNULL(@db_log_size_suggested,0))) + ',' + @lgMB + '=' + LTRIM(STR(ISNULL(@db_log_growth_suggested,0)))

				UPDATE dbo.config_fddba2
					SET [value] = @vcValue,
						UpdatedOn = GETDATE()
					WHERE [name] = 'tempdb files' AND [domain] = @dsuggest
			END

			IF @debug = 1
			BEGIN
				SET @msg = 'Setting [' + @database + '] data files size'
				RAISERROR(@msg, 10, 1) WITH NOWAIT
			END

			SET @vcValue = '' --file sizeMB
	
			DECLARE size_cur CURSOR FOR 
				SELECT CONVERT(int, a), CONVERT(int, b) FROM dbo.fSplit2columns(@db_data_sizes_cur, '=', ',')
			OPEN size_cur
			FETCH NEXT FROM size_cur INTO @iValue, @iValue2
	
			WHILE @@FETCH_STATUS != -1
			BEGIN
				IF @iValue2 < @db_data_size_suggested
				BEGIN
					SET @vcValue = @vcValue + LTRIM(STR(@iValue)) + '=' + LTRIM(STR(@db_data_size_suggested)) + ','
				END

				FETCH NEXT FROM size_cur INTO @iValue, @iValue2
			END
			DEALLOCATE size_cur

			IF @debug = 1
			BEGIN
				SET @msg = 'Setting [' + @database + '] data files growth'
				RAISERROR(@msg, 10, 1) WITH NOWAIT
			END

			SET @vcValue2 = '' --file growthMB
			DECLARE growth_cur CURSOR FOR 
				SELECT CONVERT(int, a), CONVERT(int, b) FROM dbo.fSplit2columns(@db_data_growths_cur, '=', ',')
			OPEN growth_cur
			FETCH NEXT FROM growth_cur INTO @iValue, @iValue2
			WHILE @@FETCH_STATUS != -1
			BEGIN
				IF @iValue2 < @db_data_growth_suggested
				BEGIN
					SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + LTRIM(STR(@db_data_growth_suggested)) + ','
				END

				FETCH NEXT FROM growth_cur INTO @iValue, @iValue2
			END
			DEALLOCATE growth_cur

			IF @debug = 1
			BEGIN
				SET @msg = 'Setting [' + @database + '] log files size'
				RAISERROR(@msg, 10, 1) WITH NOWAIT
			END

			DECLARE logsize_cur CURSOR FOR 
				SELECT CONVERT(int, a), CONVERT(int, b) FROM dbo.fSplit2columns(@db_log_sizes_cur, '=', ',')
			OPEN logsize_cur
			FETCH NEXT FROM logsize_cur INTO @iValue, @iValue2
			WHILE @@FETCH_STATUS != -1
			BEGIN
				IF @iValue2 < @db_log_size_suggested
				BEGIN
					SET @vcValue = @vcValue + LTRIM(STR(@iValue)) + '=' + LTRIM(STR(@db_log_size_suggested)) + ','
				END

				FETCH NEXT FROM logsize_cur INTO @iValue, @iValue2
			END
			DEALLOCATE logsize_cur

			IF @debug = 1
			BEGIN
				SET @msg = 'Setting [' + @database + '] log files growth'
				RAISERROR(@msg, 10, 1) WITH NOWAIT
			END

			DECLARE loggrowth_cur CURSOR FOR 
				SELECT CONVERT(int, a), CONVERT(int, b) FROM dbo.fSplit2columns(@db_log_growths_cur, '=', ',')
			OPEN loggrowth_cur
			FETCH NEXT FROM loggrowth_cur INTO @iValue, @iValue2
			WHILE @@FETCH_STATUS != -1
			BEGIN
				IF @iValue2 < @db_log_growth_suggested
				BEGIN
					SET @vcValue2 = @vcValue2 + LTRIM(STR(@iValue)) + '=' + LTRIM(STR(@db_log_growth_suggested)) + ','
				END

				FETCH NEXT FROM loggrowth_cur INTO @iValue, @iValue2
			END
			DEALLOCATE loggrowth_cur

			IF LEN(@vcValue) > 0
			BEGIN
				IF @debug = 1
				BEGIN
					SET @msg = 'Inserting [' + @database + '] files size toset'
					RAISERROR(@msg, 10, 1) WITH NOWAIT
				END

				--check status of files and remove readonly or files not in ONLINE state
				DECLARE offline_cur CURSOR FOR
					SELECT [file_id] 
						FROM sys.master_files 
							WHERE database_id = @dbid 
								AND [type] = 0 
								AND (is_read_only = 1 OR [state] != 0)
				OPEN offline_cur
				FETCH NEXT FROM offline_cur INTO @fileid

				WHILE @@FETCH_STATUS != -1
				BEGIN
					SET @iValue = NULL
					SELECT @iValue = CONVERT(int, b) FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = LTRIM(STR(@fileid))
					IF @iValue IS NOT NULL
					BEGIN
						SET @vcValue3 = LTRIM(STR(@fileid)) + '=' + LTRIM(STR(@iValue)) + ','
						SET @vcValue = REPLACE(@vcValue, @vcValue3, '')
					END 
					FETCH NEXT FROM offline_cur INTO @fileid
				END
				DEALLOCATE offline_cur

				IF LEN(@vcValue) > 0
				BEGIN
					IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @namebase + @fsize AND [domain] = @dtoset  AND [comment] = @database)
						INSERT dbo.config_fddba2 ([name], [domain], [value], [comment]) VALUES (@namebase + @fsize, @dtoset, @vcValue, @database)
					ELSE
					BEGIN
						UPDATE dbo.config_fddba2
							SET [value] = @vcValue,
								UpdatedOn = GETDATE()
							WHERE [name] = @namebase + @fsize AND [domain] = @dtoset AND [comment] = @database
					END
				END
				ELSE
				BEGIN
					DELETE dbo.config_fddba2 WHERE [name] = @namebase + @fsize AND [domain] = @dtoset AND [comment] = @database
				END
			END

			IF LEN(@vcValue2) > 0
			BEGIN
				IF @debug = 1
				BEGIN
					SET @msg = 'Inserting [' + @database + '] files growth toset'
					RAISERROR(@msg, 10, 1) WITH NOWAIT
				END

				--check status of files and remove readonly or files not in ONLINE state
				DECLARE offline_cur CURSOR FOR
					SELECT [file_id] 
						FROM sys.master_files 
							WHERE database_id = @dbid 
								AND [type] = 0 
								AND (is_read_only = 1 OR [state] != 0)
				OPEN offline_cur
				FETCH NEXT FROM offline_cur INTO @fileid

				WHILE @@FETCH_STATUS != -1
				BEGIN
					SET @iValue = NULL
					SELECT @iValue = CONVERT(int, b) FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = LTRIM(STR(@fileid))
					IF @iValue IS NOT NULL
					BEGIN
						SET @vcValue3 = LTRIM(STR(@fileid)) + '=' + LTRIM(STR(@iValue)) + ','
						SET @vcValue2 = REPLACE(@vcValue2, @vcValue3, '')
					END 
					FETCH NEXT FROM offline_cur INTO @fileid
				END
				DEALLOCATE offline_cur

				IF LEN(@vcValue2) > 0
				BEGIN
					IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @namebase + @fgrow AND [domain] = @dtoset AND [comment] = @database)
						INSERT dbo.config_fddba2 ([name], [domain], [value], [comment]) VALUES (@namebase + @fgrow, @dtoset, @vcValue2, @database)
					ELSE
					BEGIN
						UPDATE dbo.config_fddba2
							SET [value] = @vcValue2,
								UpdatedOn = GETDATE()
							WHERE [name] = @namebase + @fgrow AND [domain] = @dtoset AND [comment] = @database
					END
				END
				ELSE
				BEGIN
					DELETE dbo.config_fddba2 WHERE [name] = @namebase + @fgrow AND [domain] = @dtoset AND [comment] = @database
				END
			END
		END
		ELSE
		BEGIN
			SET @msg = 'suggested\base\file\[' + @database + '] is null'
			RAISERROR(@msg,11,1) WITH NOWAIT
		END
	END
	ELSE
	BEGIN
		SET @msg = 'suggested\base\file\max file size(MB) is NULL'
		RAISERROR(@msg,11,1) WITH NOWAIT
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_database_settings]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_database_settings') is null exec('create procedure [dbo].[configuration_database_settings] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_database_settings]
*
*	Purpose: Read configuration on database settings and create toset values that do not match suggestion
*
*	Inputs:	
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@is_set_only : OPTIONAL - when 1 it only inserts/updates toset\% rows in config_fddba2 table, this is used so configuration_set can check
*			if a configuration setting is still valid to make as the last toset value might be old or out of date
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. There are configuration values for suggested values and also values to "watch"
*		2. The name column of config_fddba2 table will be in the format of "<database_setting". Here is an example of AUTO_CREATE_STATISTICS:
*			"AUTO_CREATE_STATISTICS".
*		3. The value columns of config_fddba2 table will be in the format of  "<database_name>". Here is an example of
*			msdb and FDDBA databases needing this setting: "msdb,FDDBA,"
*		4. As will other value settings in config_fddba2, these value settings are multi-value. See example in #3.
*		5. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_database_settings
(
	@utc varchar(23),
	@is_set_only bit = 0,
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TODO int
	DECLARE @vcValue varchar(3950)
	DECLARE @vcValue2 varchar(3950)
	DECLARE @vcValue3 varchar(3950)
	DECLARE @vcValue4 varchar(3950)
	DECLARE @vcValue5 varchar(3950)
	DECLARE @vcValue6 varchar(3950)
	DECLARE @msg varchar(400)

	DECLARE @ndbset varchar(50)
	DECLARE @dtoset varchar(100)
	DECLARE @dsuggest varchar(100)
	DECLARE @dwatch varchar(100)

	SET @ndbset = 'database settings'
	SET @dtoset = 'toset\base\database'
	SET @dsuggest = 'suggested\base\database'
	SET @dwatch = 'watch\base\database'

	DECLARE @is_watched int

	IF @debug = 1
		RAISERROR('Checking database settings', 10, 1) WITH NOWAIT

	SET @vcValue = NULL
	SET @vcValue2 = NULL
	SELECT @vcValue = [value] FROM dbo.config_fddba2 WHERE [name] = @ndbset AND [domain] = @dsuggest
	SELECT @vcValue2 = [value] FROM dbo.config_fddba2 WHERE [name] = @ndbset AND [domain] = @dwatch

	IF @vcValue IS NOT NULL
	BEGIN
		IF @vcValue2 IS NOT NULL
		BEGIN
			SET @vcValue = ISNULL(@vcValue,'') + ISNULL(@vcValue2,'')

			DECLARE dbsetting_cur CURSOR FOR 
				SELECT a, b FROM dbo.fSplit2columns(@vcValue, '=', ',')
			OPEN dbsetting_cur
			FETCH NEXT FROM dbsetting_cur INTO @vcValue3, @vcValue4
			WHILE @@FETCH_STATUS != -1
			BEGIN
				IF EXISTS (SELECT 1 FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = @vcValue3)
					SET @is_watched = 1
				ELSE
					SET @is_watched = 0

				IF @vcValue3 = 'AUTO_CLOSE' AND @vcValue4 = 'OFF'
				BEGIN
					DECLARE dbsetting_cur2 CURSOR FOR 
						SELECT [name] FROM sys.databases WHERE is_auto_close_on = 1
				END
				ELSE
				BEGIN
					IF @vcValue3 = 'AUTO_SHRINK' AND @vcValue4 = 'OFF'
					BEGIN
						DECLARE dbsetting_cur2 CURSOR FOR 
							SELECT [name] FROM sys.databases WHERE is_auto_shrink_on = 1
					END
					ELSE
					BEGIN
						IF @vcValue3 = 'PAGE_VERIFY' AND @vcValue4 = 'CHECKSUM'
						BEGIN
							DECLARE dbsetting_cur2 CURSOR FOR 
								SELECT [name] FROM sys.databases WHERE page_verify_option != 2
						END
						ELSE
						BEGIN
							IF @vcValue3 = 'AUTO_CREATE_STATISTICS' AND @vcValue4 = 'ON'
							BEGIN
								DECLARE dbsetting_cur2 CURSOR FOR 
									SELECT [name] FROM sys.databases WHERE is_auto_create_stats_on = 0
							END
							ELSE
							BEGIN
								IF @vcValue3 = 'AUTO_UPDATE_STATISTICS' AND @vcValue4 = 'ON'
								BEGIN
									DECLARE dbsetting_cur2 CURSOR FOR 
										SELECT [name] FROM sys.databases WHERE is_auto_update_stats_on = 0
								END
								ELSE
								BEGIN
									--log message about any conditions not checked
									IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = 'database settings check not found' AND [domain] = @utc)
									BEGIN
										INSERT dbo.config_fddba2_history ([name], [domain], [value]) VALUES ('database settings check not found', @utc, 'contact mike to investigate check of ['+@vcValue3 + '=' + @vcValue4 + ']')
									END
									ELSE
									BEGIN
										UPDATE dbo.config_fddba2 
											SET [value] = [value] + ',['+@vcValue3 + '=' + @vcValue4 + ']'
											WHERE [name] = 'database settings check not found' AND [domain] = @utc
									END
									--create cursor with no rows
									DECLARE dbsetting_cur2 CURSOR FOR 
										SELECT [name] FROM sys.databases WHERE 0=1
								END
							END
						END
					END
				END

				SET @vcValue6 = ''
				OPEN dbsetting_cur2
				FETCH NEXT FROM dbsetting_cur2 INTO @vcValue5
				WHILE @@FETCH_STATUS != -1
				BEGIN
					SET @vcValue6 = @vcValue5 + ',' --if database names have commas then this will break
					FETCH NEXT FROM dbsetting_cur2 INTO @vcValue5
				END

				IF LEN(@vcValue6) > 0 
				BEGIN
					IF @is_watched = 0
					BEGIN
						IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @vcValue3 AND [domain] = @dtoset)
							INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@vcValue3, @dtoset, @vcValue6)
						ELSE
						BEGIN
							UPDATE dbo.config_fddba2
								SET [value] = @vcValue6,
									UpdatedOn = GETDATE()
								WHERE [name] = @vcValue3 AND [domain] = @dtoset
						END
					END
					ELSE
					BEGIN
						IF @is_set_only = 0
							INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@vcValue3, @utc, @vcValue6, 'towatch')
					END
				END

				DEALLOCATE dbsetting_cur2
				FETCH NEXT FROM dbsetting_cur INTO @vcValue3, @vcValue4
			END
			DEALLOCATE dbsetting_cur
		END
		ELSE
		BEGIN
			SET @msg = 'watch\base\database is NULL'
			RAISERROR(@msg,11,2) WITH NOWAIT
		END
	END
	ELSE
	BEGIN
		SET @msg = 'suggested\base\database is NULL'
		RAISERROR(@msg,11,2) WITH NOWAIT
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_dbmail]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_dbmail') is null exec('create procedure [dbo].[configuration_dbmail] as select getdate() DT')
GO
  

/*********************************************************************************************************************
*
*	[dbo].[configuration_dbmail]
*
*	Purpose: Read configuration on database mail and create toset values that do not match suggestion
*
*	Inputs:	
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@is_set_only : OPTIONAL - when 1 it only inserts/updates toset\% rows in config_fddba2 table, this is used so configuration_set can check
*			if a configuration setting is still valid to make as the last toset value might be old or out of date
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. There are configuration values for suggested values
*		2. The name column of config_fddba2 table will be "database mail"
*		3. The value columns of config_fddba2 table will be in the format of  "<setting>=<value>". Here is an example of
*			profile name being "Agent Mail" and smtp port being 25: "profilename=Agent Mail,smtpport=25,"
*		4. As will other value settings in config_fddba2, these value settings are multi-column, multi-value. See example in #3.
*		5. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_dbmail
(
	@utc varchar(23),
	@is_set_only bit = 0,
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TODO int
	DECLARE @iValue int
	DECLARE @vcValue varchar(3950)
	DECLARE @vcValue2 varchar(3950)
	DECLARE @vcValue3 varchar(3950)
	DECLARE @vcValue4 varchar(3950)
	DECLARE @vcValue5 varchar(3950)
	DECLARE @vcValue6 varchar(3950)
	DECLARE @msg varchar(400)

	DECLARE @profilename_start sysname
	DECLARE @profilename_sug sysname
	DECLARE @profilename_cur sysname
	DECLARE @smtpserver_sug sysname
	DECLARE @smtpserver_cur sysname
	DECLARE @smtpport_sug int
	DECLARE @smtpport_cur int
	DECLARE @usessl_sug bit
	DECLARE @usessl_cur bit
	DECLARE @accountname_sug sysname
	DECLARE @accountname_cur sysname
	DECLARE @emailaddress_start nvarchar(256)
	DECLARE @emailaddress_sug nvarchar(256)
	DECLARE @emailaddress_cur nvarchar(256)
	DECLARE @replyaddress_sug nvarchar(256)
	DECLARE @replyaddress_cur nvarchar(256)
	DECLARE @username_sug nvarchar(256)
	DECLARE @username_cur nvarchar(256)
	
	DECLARE @profileid int
	DECLARE @accountid int
	DECLARE @mailitem_id int

	DECLARE @ndbmail varchar(50)
	DECLARE @dsuggest varchar(100)
	DECLARE @dtoset varchar(100)
	DECLARE @dstartup varchar(100)

	SET @ndbmail = 'database mail'
	SET @dsuggest = 'suggested\base\dbmail'
	SET @dtoset = 'toset\base\dbmail'
	SET @dstartup = 'fddba\pStartUpCheck'

	IF @debug = 1
		RAISERROR('Checking Database Mail', 10, 1) WITH NOWAIT

	SELECT @vcValue2 = [value] FROM dbo.config_fddba2 WHERE [name] = @ndbmail and [domain] = @dsuggest

	SET @vcValue = '' -- current
	SET @vcValue3 = '' -- new suggested
	IF @vcValue2 IS NOT NULL
	BEGIN
		SELECT @profilename_sug = b FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'profilename'
		SELECT @smtpserver_sug = b FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'smtpserver'
		SELECT @smtpport_sug = CONVERT(int, b) FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'smtpport'
		SELECT @usessl_sug = CONVERT(bit,b ) FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'usessl'
		SELECT @accountname_sug = b FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'accountname'
		SELECT @emailaddress_sug = b FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'emailaddress'
		SELECT @replyaddress_sug = b FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'replyaddress'
		SELECT @username_sug = b FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'username'
		
		SELECT @profileid = profile_id FROM msdb.dbo.sysmail_profile WHERE [name] = @profilename_sug

		IF @profileid IS NULL
		BEGIN
			IF @debug = 1
				RAISERROR('DBMail: Lookup profile by operator email address', 10, 1) WITH NOWAIT

			SET @vcValue3 = NULL
			SELECT @vcValue3 = [name] FROM msdb.dbo.sysoperators WHERE email_address = @emailaddress_sug
			IF @vcValue3 IS NOT NULL
			BEGIN
				SELECT @profileid = profile_id FROM msdb.dbo.sysmail_allitems WHERE sent_status = 'sent' and recipients = @emailaddress_sug
				IF @profileid IS NOT NULL
				BEGIN
					IF @debug = 1
						RAISERROR('DBMail: Lookup profile by operator email address success', 10, 1) WITH NOWAIT

					SELECT @profilename_cur = [name] FROM msdb.dbo.sysmail_profile WHERE @profileid = profile_id
				END
			END
		END

		IF @profileid IS NULL
		BEGIN
			IF @debug = 1
				RAISERROR('DBMail: Lookup profile by fddba\pStartUpCheck', 10, 1) WITH NOWAIT

			SELECT @profilename_start = [value] FROM dbo.config_fddba2 WHERE [name] = 'profile_name' and [domain] = @dstartup
			SELECT @emailaddress_start = [value] FROM dbo.config_fddba2 WHERE [name] = 'recipients' and [domain] = @dstartup

			SELECT @profileid = profile_id FROM msdb.dbo.sysmail_profile WHERE [name] = @profilename_start
		END

		SET @vcValue = 'profilename=' + COALESCE(@profilename_start, @profilename_cur, '') + ','
		SET @vcValue3 = 'profilename=' + COALESCE(@profilename_start, @profilename_cur, @profilename_sug, '') + ','

		IF @profileid IS NOT NULL
		BEGIN
			SELECT @accountid = account_id FROM msdb.dbo.sysmail_account WHERE [name] = @accountname_sug
			IF @accountid IS NULL
			BEGIN
				IF @debug = 1
					RAISERROR('DBMail: Lookup account by operator email address', 10, 1) WITH NOWAIT
				SELECT @accountid = account_id FROM msdb.dbo.sysmail_account WHERE email_address = @emailaddress_sug
			END

			IF @accountid IS NULL
			BEGIN
				IF @debug = 1
					RAISERROR('DBMail: Lookup account by fddba\pStartUpCheck', 10, 1) WITH NOWAIT

				SELECT id FROM msdb.dbo.sysoperators where email_address = @emailaddress_start

				SELECT TOP 1 @accountid = account_id FROM msdb.dbo.sysmail_profileaccount WHERE profile_id = @profileid
				SELECT @iValue = COUNT(*) FROM msdb.dbo.sysmail_profileaccount WHERE profile_id = @profileid
				IF @iValue > 1
				BEGIN
					SET @msg = 'DBMail WARNING: ' + LTRIM(STR(@iValue)) + ' accounts found!'
					RAISERROR(@msg, 11, 1) WITH NOWAIT
				END
			END

			IF @accountid IS NOT NULL
			BEGIN
				IF @debug = 1
				BEGIN
					SET @msg = 'DBMail: Found account:' + LTRIM(STR(@accountid))
					RAISERROR(@msg, 10, 1) WITH NOWAIT
				END

				SELECT @smtpport_cur = port, @smtpserver_cur = servername, @username_cur = ISNULL(username,''), @usessl_cur = enable_ssl 
					FROM msdb.dbo.sysmail_server 
					WHERE account_id = @accountid

				SELECT @accountname_cur = [name], @emailaddress_cur = email_address, @replyaddress_cur = replyto_address FROM msdb.dbo.sysmail_account WHERE account_id = @accountid

			END
		END

--profilename=Agent Mail,smtpserver=,smtpport=25,usessl=0,accountname=DBASQLSERVER,emailaddress=dba@fortifieddata.com,replyaddress=dba@fortifieddata.com,username=,password=,

		SET @vcValue = @vcValue + 'smtpserver=' + COALESCE(@smtpserver_cur, '') + ','
		SET @vcValue = @vcValue + 'smtpport=' + LTRIM(STR(COALESCE(@smtpport_cur, -1))) + ','
		SET @vcValue = @vcValue + 'usessl=' + LTRIM(STR(COALESCE(@usessl_cur, -1))) + ','
		SET @vcValue = @vcValue + 'accountname=' + COALESCE(@accountname_cur, '') + ','
		SET @vcValue = @vcValue + 'emailaddress=' + COALESCE(@emailaddress_cur, '') + ','
		SET @vcValue = @vcValue + 'replyaddress=' + COALESCE(@replyaddress_cur, '') + ','
		SET @vcValue = @vcValue + 'username=' + COALESCE(@username_cur, '') + ','

		SET @vcValue3 = @vcValue3 + 'smtpserver=' + COALESCE(@smtpserver_cur, @smtpserver_sug, '') + ','
		SET @vcValue3 = @vcValue3 + 'smtpport=' + LTRIM(STR(COALESCE(@smtpport_cur, @smtpport_sug, 0))) + ','
		SET @vcValue3 = @vcValue3 + 'usessl=' + LTRIM(STR(COALESCE(@usessl_cur, @usessl_sug, 0))) + ','
		SET @vcValue3 = @vcValue3 + 'accountname=' + COALESCE(@accountname_cur, @accountname_sug, '') + ','
		SET @vcValue3 = @vcValue3 + 'emailaddress=' + COALESCE(@emailaddress_cur, @emailaddress_sug, '') + ','
		SET @vcValue3 = @vcValue3 + 'replyaddress=' + COALESCE(@replyaddress_cur, @replyaddress_sug, '') + ','
		SET @vcValue3 = @vcValue3 + 'username=' + COALESCE(@username_cur, @username_sug, '') + ','

		IF @is_set_only = 0
			INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@ndbmail, @utc, @vcValue, 'current')

		IF LEN(@vcValue3) > 0 AND @vcValue3 != @vcValue2
		BEGIN
			SET @vcValue2 = @vcValue3
			UPDATE dbo.config_fddba2
				SET UpdatedOn = GETDATE(),
					[comment] = 'old=value,' + [value],
					[value] = @vcValue2
				WHERE [name] = @ndbmail and [domain] = @dsuggest
		END

		--toset
		SET @vcValue6 = ''
		DECLARE dbmail_cur CURSOR FOR
			SELECT a, b FROM dbo.fSplit2columns(@vcValue2, '=', ',')
		OPEN dbmail_cur
		FETCH NEXT FROM dbmail_cur INTO @vcValue3, @vcValue4

		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @vcValue5 = NULL
			SELECT @vcValue5 = b FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = @vcValue3
			IF @vcValue5 IS NULL OR @vcValue4 != @vcValue5
			BEGIN
				SET @vcValue6 = @vcValue6 + @vcValue3 + '=' + @vcValue4 + ','
			END
			FETCH NEXT FROM dbmail_cur INTO @vcValue3, @vcValue4
		END
		DEALLOCATE dbmail_cur

		IF LEN(@vcValue6) > 0
		BEGIN
			IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @ndbmail AND [domain] = @dtoset)
				INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@ndbmail, @dtoset, @vcValue6)
			ELSE
			BEGIN
				UPDATE dbo.config_fddba2
					SET [value] = @vcValue6,
						UpdatedOn = GETDATE()
					WHERE [name] = @ndbmail AND [domain] = @dtoset
			END
		END
		ELSE
		BEGIN
			DELETE dbo.config_fddba2 WHERE [name] = @ndbmail AND [domain] = @dtoset
		END
	END
	ELSE
	BEGIN
		SET @msg = 'suggested\base\dbmail is NULL'
		RAISERROR(@msg,11,1) WITH NOWAIT
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_insert]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_insert') is null exec('create procedure [dbo].[configuration_insert] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_insert]
*
*	Purpose: Runs configuration sprocs based on flag parameters of which to run
*
*	Inputs:	
*		@server : REQUIRED - server name to "clone" configuration from so as to prevent incorrect configuration
*		@is_set_only : OPTIONAL - when 1 it only inserts/updates toset\% rows in config_fddba2 table, this is used so configuration_set can check
*			if a configuration setting is still valid to make as the last toset value might be old or out of date
*		@fsp_configure : OPTIONAL - if 1 run checks on sp_configure settings
*		@fdbfiles : OPTIONAL - if 1 run checks on database files
*		@fdbsettings : OPTIONAL - if 1 run checks on database settings
*		@fother : OPTIONAL - if 1 run "other" checks
*		@fsqlerrorlog : OPTIONAL - if 1 run checks on SQL Server errorlog settings
*		@fsqlagent : OPTIONAL - if 1 run checks on SQL Agents settings
*		@fdbmail : OPTIONAL - if 1 run checks on database mail settings
*		@falerts : OPTIONAL - if 1 run checks on SQL Agent alert settings
*		@database : OPTIONAL - if 1 database file checks on a specific database
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. See configuration_<type> stored procedure for understanding of perticular types
*		2. This is designed to be run manually or to be run by configuration_set to make sure a current setting is still valid
*		3. It is suggested to run any of the configuration_<type> stored procedures to run using this stored procedure
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_insert
(
	@server sysname = NULL, --server to pull config values from instead of inserts
	@is_set_only bit = 0,
	@fsp_configure bit = 1,
	@fdbfiles bit = 1,
	@fdbsettings bit = 1,
	@fother bit = 1,
	@fsqlerrorlog bit = 1,
	@fsqlagent bit = 1,
	@fdbmail bit = 1,
	@falerts bit = 1,
	@database sysname = NULL,
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TODO int
	DECLARE @utc varchar(23)
	DECLARE @msg varchar(400)

	DECLARE @provider varchar(20)
	DECLARE @logical_cpus int
	DECLARE @HKLM nvarchar(100)
	DECLARE @sqlbasekey nvarchar(256)
	DECLARE @sqlinstkey nvarchar(256)
	DECLARE @sqlagentkey nvarchar(256)

	SET @utc = CONVERT(varchar(23), GETUTCDATE(), 126)
	SET @provider = 'SQLNCLI'
	SET @HKLM = N'HKEY_LOCAL_MACHINE'
	SET @sqlbasekey = N'SOFTWARE\Microsoft\Microsoft SQL Server'
	SET @sqlinstkey = N'SOFTWARE\Microsoft\MSSQLServer\MSSQLServer'
	SET @sqlagentkey = N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent'

	SET NOCOUNT ON

	IF @is_set_only = 0
	BEGIN
		SELECT @logical_cpus = cpu_count from sys.dm_os_sys_info
		INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('logical cpus', @utc, LTRIM(STR(@logical_cpus)), 'current')
	END

	SELECT @logical_cpus = COUNT(*) FROM sys.dm_os_schedulers WHERE [status] = 'VISIBLE ONLINE'
	IF @is_set_only = 0
		INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('logical cpus in use', @utc, LTRIM(STR(@logical_cpus)), 'current')

	IF @fother = 1
	BEGIN
		EXEC dbo.configuration_other @utc, @is_set_only, @debug
	END

	IF @server IS NOT NULL AND @is_set_only = 0
	BEGIN
		EXEC dbo.configuration_pull_remote @utc, @server, @provider, @debug
	END

	IF @is_set_only = 0
	BEGIN
		EXEC dbo.configuration_insert_local @utc, @debug
	END

	IF @fsp_configure = 1
	BEGIN
		EXEC dbo.configuration_spconfigure 	@utc, @logical_cpus, @provider, @HKLM, @sqlbasekey, @is_set_only, @debug
	END

	IF @fdbfiles = 1
	BEGIN
		IF @database IS NOT NULL
		BEGIN
			IF @debug = 1
			BEGIN
				SET @msg = 'Checking [' + @database + '] files'
				RAISERROR(@msg, 10, 1) WITH NOWAIT
			END
			EXEC dbo.configuration_database_files @database, @utc, @logical_cpus, @is_set_only, @debug
		END
		ELSE
		BEGIN
			IF @debug = 1
				RAISERROR('Checking [master] files', 10, 1) WITH NOWAIT
			EXEC dbo.configuration_database_files 'master', @utc, @logical_cpus, @is_set_only, @debug

			IF @debug = 1
				RAISERROR('Checking [tempdb] files', 10, 1) WITH NOWAIT
			EXEC dbo.configuration_database_files 'tempdb', @utc, @logical_cpus, @is_set_only, @debug

			IF @debug = 1
				RAISERROR('Checking [model] files', 10, 1) WITH NOWAIT
			EXEC dbo.configuration_database_files 'model', @utc, @logical_cpus, @is_set_only, @debug

			IF @debug = 1
				RAISERROR('Checking [msdb] files', 10, 1) WITH NOWAIT
			EXEC dbo.configuration_database_files 'msdb', @utc, @logical_cpus, @is_set_only, @debug

			DECLARE dbname_cur CURSOR FOR
				SELECT [name] 
					FROM sys.databases 
					WHERE database_id > 4 
						AND is_read_only = 0
						AND [state] = 0 --ONLINE
			OPEN dbname_cur
			FETCH NEXT FROM dbname_cur INTO @database
			WHILE @@FETCH_STATUS != -1
			BEGIN
				IF @debug = 1
				BEGIN
					SET @msg = 'Checking [' + @database + '] files'
					RAISERROR(@msg, 10, 1) WITH NOWAIT
				END
				EXEC dbo.configuration_database_files @database, @utc, @logical_cpus, @is_set_only, @debug
				FETCH NEXT FROM dbname_cur INTO @database
			END
			DEALLOCATE dbname_cur
		END
	END

	IF @fdbsettings = 1
	BEGIN
		EXEC dbo.configuration_database_settings @utc, @is_set_only, @debug
	END
	
	IF @fsqlerrorlog = 1
	BEGIN		
		EXEC dbo.configuration_sqlerrorlog @utc, @HKLM, @sqlinstkey, @is_set_only, @debug
	END

	IF @fdbmail = 1
	BEGIN
		EXEC dbo.configuration_dbmail @utc, @is_set_only, @debug
	END

	IF @fsqlagent = 1
	BEGIN		
		EXEC dbo.configuration_sqlagent @utc, @HKLM, @sqlagentkey, @is_set_only, @debug
	END

	IF @falerts = 1
	BEGIN
		EXEC dbo.configuration_alerts @utc, @is_set_only, @debug
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_insert_local]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_insert_local') is null exec('create procedure [dbo].[configuration_insert_local] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_insert_local]
*
*	Purpose: Insert missing configuration suggestions with FD suggested values in config_fddba2 table
*
*	Inputs:	
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. Stored procedure values inserted should not be changed here unless it is an ALL CLIENTS suggestion. Otherwise the suggestion value should
*			be changed on client servers and hopefully propaged to other servers using configuration_pull_remote.
*		2. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_insert_local
(
	@utc varchar(23),
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @nseverity varchar(50)
	DECLARE @nerror varchar(50)
	DECLARE @nmaster varchar(50)
	DECLARE @ntempdb varchar(50)
	DECLARE @nmodel varchar(50)
	DECLARE @nmsdb varchar(50)
	DECLARE @nuser varchar(50)
	DECLARE @nfiles varchar(50)
	DECLARE @nspc varchar(50)
	DECLARE @ndbset varchar(50)
	DECLARE @nmfsize varchar(50)
	DECLARE @nsqlerrorlog varchar(50)
	DECLARE @nsagntjob varchar(50)
	DECLARE @ndbmail varchar(50)
	DECLARE @nsqlagnt varchar(50)
	DECLARE @dfsuggest varchar(100)
	DECLARE @dasuggest varchar(100)
	DECLARE @desuggest varchar(100)
	DECLARE @dspcsuggest varchar(100)
	DECLARE @dspcwatch varchar(100)
	DECLARE @ddbsetsuggest varchar(100)
	DECLARE @ddbsetwatch varchar(100)
	DECLARE @dsqlerrorlogsug varchar(100)
	DECLARE @dsqlagntjobsug varchar(100)
	DECLARE @ddbmailsug varchar(100)
	DECLARE @dsqlagntsug varchar(100)

	SET @nseverity = 'severity'
	SET @nerror = 'error'
	SET @nmaster = 'master'
	SET @ntempdb = 'tempdb'
	SET @nmodel = 'model'
	SET @nmsdb = 'msdb'
	SET @nuser = 'userdb'
	SET @nfiles = ' files'
	SET @nspc = 'sp_configure'
	SET @ndbset = 'database settings'
	SET @nmfsize = 'max file size(MB)'
	SET @nsqlerrorlog = 'sql errorlog'
	SET @nsagntjob = 'sql agent job history'
	SET @ndbmail = 'database mail'
	SET @nsqlagnt = 'sql agent'
	SET @dfsuggest = 'suggested\base\file'
	SET @dasuggest = 'suggested\base\alerts'
	SET @dspcsuggest = 'suggested\base\sp_configure'
	SET @dspcwatch = 'watch\base\sp_configure'
	SET @ddbsetsuggest = 'suggested\base\database'
	SET @ddbsetwatch = 'watch\base\database'

	SET @dsqlerrorlogsug = 'suggested\base\sqlerrorlog'
	SET @dsqlagntjobsug = 'suggested\base\sqlagentjob'
	SET @ddbmailsug = 'suggested\base\dbmail'
	SET @dsqlagntsug = 'suggested\base\sqlagent'

	IF @debug = 1
		RAISERROR('Inserting FD suggested values', 10, 1) WITH NOWAIT

	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nseverity AND [domain] = @dasuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nseverity,@dasuggest,'16,17,18,19,20,21,22,23,24,25')
	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nerror AND [domain] = @dasuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nerror,@dasuggest,'823,824,825,1480')

	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nmaster + @nfiles AND [domain] = @dfsuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nmaster + @nfiles,@dfsuggest,'datasizeMB=512,datagrowthMB=512,logsizeMB=512,loggrowthMB=512,')
	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nmsdb + @nfiles AND [domain] = @dfsuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nmsdb + @nfiles,@dfsuggest,'datasizeMB=512,datagrowthMB=512,logsizeMB=512,loggrowthMB=512,')
	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nmodel + @nfiles AND [domain] = @dfsuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nmodel + @nfiles,@dfsuggest,'datasizeMB=128,datagrowthMB=512,logsizeMB=128,loggrowthMB=128,')
	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @ntempdb + @nfiles AND [domain] = @dfsuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@ntempdb + @nfiles,@dfsuggest,'datagrowthMB=512,loggrowthMB=512,')
	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nuser + @nfiles AND [domain] = @dfsuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nuser + @nfiles,@dfsuggest,'datasizeMB=512,datagrowthMB=512,logsizeMB=512,loggrowthMB=512,')

	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nmfsize AND [domain] = @dfsuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nmfsize, @dfsuggest, LTRIM(STR(1024*128))) --128GB in MB

	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nspc AND [domain] = @dspcsuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nspc,@dspcsuggest,'backup compression default=1,cost threshold for parallelism=15,Database Mail XPs=1,optimize for ad hoc workloads=1,remote admin connections=1,scan for startup procs=1,max degree of parallelism=0,max server memory (MB)=2147483647,')

	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nspc AND [domain] = @dspcwatch)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nspc,@dspcwatch,'affinity I/O mask=0,affinity mask=0,affinity64 I/O mask=0,affinity64 mask=0,fill factor (%)=0,lightweight pooling=0,locks=0,max worker threads=0,open objects=0,priority boost=0,user connections=0,')

	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @ndbset AND [domain] = @ddbsetsuggest)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@ndbset, @ddbsetsuggest, 'AUTO_CLOSE=OFF,AUTO_SHRINK=OFF,PAGE_VERIFY=CHECKSUM,')
	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @ndbset AND [domain] = @ddbsetwatch)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@ndbset, @ddbsetwatch, 'AUTO_CREATE_STATISTICS=ON,AUTO_UPDATE_STATISTICS=ON,')

	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nsqlerrorlog AND [domain] = @dsqlerrorlogsug)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nsqlerrorlog, @dsqlerrorlogsug, 'NumErrorLogs=99,jobname=DBA - Cycle Errorlog Nightly,jobdaily=1,jobtime=0,')
	
	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nsagntjob AND [domain] = @dsqlagntjobsug)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nsagntjob, @dsqlagntjobsug, 'JobHistoryMaxRows=5000,JobHistoryMaxRowsPerJob=100,')
	
	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @ndbmail AND [domain] = @ddbmailsug)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@ndbmail, @ddbmailsug, 'profilename=Agent Mail,smtpserver=,smtpport=25,usessl=0,accountname=DBASQLSERVER,emailaddress=dba@fortifieddata.com,replyaddress=dba@fortifieddata.com,username=,password=,')

	IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nsqlagnt AND [domain] = @dsqlagntsug)
		INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nsqlagnt, @dsqlagntsug, 'UseDatabaseMail=1,DatabaseMailProfile=Agent Mail,operator=FDDBA,operatoremail=dba@fortifieddata.com,')
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_other]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_other') is null exec('create procedure [dbo].[configuration_other] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_other]
*
*	Purpose: Read configuration on other rules not currently configured with a suggested value 
*
*	Inputs:	
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@is_set_only : OPTIONAL - when 1 it only inserts/updates toset\% rows in config_fddba2 table, this is used so configuration_set can check
*			if a configuration setting is still valid to make as the last toset value might be old or out of date
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. The current checks are:
*			A. Give me a list of potential SharePoint databases on a server
*			B. Check resource governor settings
*		2. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	TODO: 
*		1. Implement a check for identifying ASP Session State databases
*		2. Make SharePoint detection better
*		3. max_memgrant_percent resource governor suggestion on large memory servers
*		4. Add new checks here
*		5. As appropriate add "mature" rules into separate stored procedure
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_other
(
	@utc varchar(23),
	@is_set_only bit = 0,
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TODO int
	DECLARE @iValue int
	DECLARE @iValue2 int
	DECLARE @vcValue varchar(3950)
	DECLARE @vcValue2 varchar(3950)

	CREATE TABLE #databases ([name] sysname)

	IF @debug = 1
		RAISERROR('Checking resource governor', 10, 1) WITH NOWAIT

	SELECT @iValue = is_enabled FROM sys.resource_governor_configuration
	IF @is_set_only = 0
		INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('resource governor', @utc, @iValue, 'current')
	
	SELECT @iValue = request_max_memory_grant_percent, @iValue2 = max_dop FROM sys.resource_governor_workload_groups WHERE [name] = 'default'
	IF @is_set_only = 0
		INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('resource governor default workgroup', @utc, 'request_max_memory_grant_percent=' + LTRIM(STR(@iValue)) + ',max_dop=' + LTRIM(STR(@iValue2)) + ',', 'current')

	IF @debug = 1
		RAISERROR('Checking SharePoint databases', 10, 1) WITH NOWAIT
	INSERT #databases EXEC sys.sp_MSforeachdb 'IF (SELECT COUNT(*) FROM [?].sys.tables WHERE [name] IN (''AllDocs'',''AllSites'',''AllWebs'',''Perms'')) = 4 SELECT ''?''' 
	SET @iValue = @@ROWCOUNT
	IF @iValue > 0
	BEGIN
		SET @vcValue2 = ''
		IF @is_set_only = 0
			INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('Possible SharePoint DB Count', @utc, @iValue, 'current')
		DECLARE sharepoint_cur CURSOR FOR SELECT [name] FROM #databases
		OPEN sharepoint_cur
		FETCH NEXT FROM sharepoint_cur INTO @vcValue
		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @vcValue2 = @vcValue2  + '[' + @vcValue + '],'
			FETCH NEXT FROM sharepoint_cur INTO @vcValue
		END
		DEALLOCATE sharepoint_cur
		
		IF @is_set_only = 0
			INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('Possible SharePoint DB Names', @utc, @vcValue, 'current')
	END

	IF @debug = 1
		RAISERROR('Checking ASP Session State databases', 10, 1) WITH NOWAIT
	--INSERT dbo.config_fddba2_history ([name], [domain], [value]) VALUES ('ASP Session State', @utc, '0') --0 means not detected but could be

END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_pull_remote]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_pull_remote') is null exec('create procedure [dbo].[configuration_pull_remote] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_pull_remote]
*
*	Purpose: Read suggested values from another SQL Server and insert rows into config_fddba2 table
*
*	Inputs:	
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@server : REQUIRED - server name to "clone" configuration from so as to prevent incorrect configuration
*		@provider : REQUIRED - provider to connect to SQL Server with.
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. This assumes that Ad Hoc Distributed Queries is currently enabled on server running stored procedure
*		2. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	TODO: Consider enabling Ad Hoc Distributed Queries temporarily if not currently enabled
*		
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_pull_remote
(
	@utc varchar(23),
	@server sysname,
	@provider varchar(20),
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TODO int
	DECLARE @iValue int
	DECLARE @vcValue varchar(3950)

	DECLARE @sql nvarchar(4000)
	DECLARE @sql2 nvarchar(4000)
	DECLARE @instance sysname
	DECLARE @rmtserver varchar(50)

	CREATE TABLE #config_fddba2
	(
		[name]	varchar(50) NOT NULL, 
		[domain] varchar(100) NOT NULL,
		[value]	nvarchar(3950) NULL,
		[valuebig]	nvarchar(max) NULL,
		[comment] varchar(2000) NULL,
	)

	IF @debug = 1
		RAISERROR('Inserting values from remote server', 10, 1) WITH NOWAIT

	IF EXISTS(SELECT 1 FROM sys.configurations WHERE [name] = 'Ad Hoc Distributed Queries' and CONVERT(int, value_in_use) = 1)
	BEGIN
		SET @TODO=1 -- potential bug here if remote config_fddba2 table does not have comment column
		SET @sql2 = N'SELECT [name], [domain], [value], [valuebig], [comment] FROM FDDBA.dbo.config_fddba2 WHERE ISDATE([domain]) = 0'
		SET @rmtserver = 'Server=' + @server + ';Trusted_Connection=yes;Timeout=15;'
		SET @sql = N'INSERT #config_fddba2 SELECT * FROM OPENROWSET(''' + @provider + ''', ''' + @rmtserver + ''', ''' + @sql2 + ''' )'
		
		BEGIN TRY
			EXECUTE sp_executesql @sql
		END TRY
		BEGIN CATCH
			PRINT 'Error connecting to pull configuration data: ' + @server
		END CATCH

		IF EXISTS(SELECT 1 FROM #config_fddba2 WHERE [comment] IS NULL)
		BEGIN
			INSERT dbo.config_fddba2 ([name], [domain], [value], [valuebig], [comment])
				SELECT [name], [domain], [value], [valuebig], 'source='+ @server
					FROM #config_fddba2 s 
					WHERE s.[comment] IS NULL
						AND NOT EXISTS
						(
							SELECT 1 FROM dbo.config_fddba2 d
								WHERE s.[name] = d.[name] AND s.[domain] = d.[domain]
						)
			UPDATE d
				SET [value] = s.[value],
					[valuebig] = s.[valuebig],
					[comment] = 'source='+ @server,
					UpdatedOn = GETDATE()
				FROM dbo.config_fddba2 d
					INNER JOIN #config_fddba2 s
						ON s.[name] = d.[name] AND s.[domain] = d.[domain] AND s.[comment] IS NULL

		END
			
		IF EXISTS(SELECT 1 FROM #config_fddba2 WHERE [comment] IS NOT NULL)
		BEGIN
			INSERT dbo.config_fddba2 ([name], [domain], [value], [valuebig], [comment])
				SELECT [name], [domain], [value], [valuebig], [comment]
					FROM #config_fddba2 s
					WHERE [comment] IS NOT NULL
						AND NOT EXISTS
						(
							SELECT 1 FROM dbo.config_fddba2 d
								WHERE s.[name] = d.[name] AND s.[domain] = d.[domain]
						)
			UPDATE d
				SET [value] = s.[value],
					[valuebig] = s.[valuebig],
					[comment] = s.[comment],
					UpdatedOn = GETDATE()
				FROM dbo.config_fddba2 d
					INNER JOIN #config_fddba2 s
						ON s.[name] = d.[name] AND s.[domain] = d.[domain] AND s.[comment] IS NOT NULL
		END

		EXEC [dbo].[trace_flag_fddba_convert_2_to_3] 'trace_flags', 'fddba\usp_EnableTraceFlags2', 'fddba\usp_EnableTraceFlags3'
	END
	ELSE
	BEGIN
		SET @vcValue = 'ERROR: Current server not configured for [Ad Hoc Distributed Queries] so can not get data from server=' + @server
		RAISERROR(@vcValue, 16, 1) WITH NOWAIT
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_set]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_set') is null exec('create procedure [dbo].[configuration_set] as select getdate() DT')
GO
  
		alter procedure [dbo].[configuration_set]		
		AS
		SET NOCOUNT ON
		SELECT GETDATE()	
		
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_spconfigure]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_spconfigure') is null exec('create procedure [dbo].[configuration_spconfigure] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_spconfigure]
*
*	Purpose: Read configuration on sp_configure settings and create toset values that do not match suggestion
*
*	Inputs:	
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@logical_cpus : OPTIONAL - number of logical cpus which is needed to configure various settings
*		@provider : REQUIRED - provider to connect to SQL Server with to attempt to get max server memory(MB) setting from other instances on the same machine
*		@HKLM : REQUIRED - string for use with xp_instance_regread
*		@sqlbasekey : REQUIRED - string for use with xp_instance_regread
*		@is_set_only : OPTIONAL - when 1 it only inserts/updates toset\% rows in config_fddba2 table, this is used so configuration_set can check
*			if a configuration setting is still valid to make as the last toset value might be old or out of date
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. There are configuration values for suggested values and also values to "watch"
*		2. The name column of config_fddba2 table will be "sp_configure".
*		3. The value columns of config_fddba2 table will be in the format of  "<setting>=<value>". Here is an example of
*			backup compression and cost threshold for parallelism: "backup compression default=1,cost threshold for parallelism=15,"
*		4. As will other value settings in config_fddba2, these value settings are multi-column, multi-value. See example in #3.
*		5. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	TODO: Update maxdop algorithm to be limited to schedulers/nodes as below is direct port from base default sql config.sql
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_spconfigure
(
	@utc varchar(23),
	@logical_cpus int = 0,
	@provider varchar(20),
	@HKLM nvarchar(100),
	@sqlbasekey nvarchar(256),
	@is_set_only bit = 0,
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TODO int
	DECLARE @iValue int
	DECLARE @iValue2 int
	DECLARE @vcValue varchar(3950)
	DECLARE @vcValue2 varchar(3950)
	DECLARE @vcValue3 varchar(3950)

	DECLARE @numa_nodes int
	DECLARE @physical_memory_MB int
	DECLARE @instance_count int
	DECLARE @instance sysname
	DECLARE @rmtserver varchar(50)

	DECLARE @msg varchar(400)

	DECLARE @physmemoryMB int
	DECLARE @physmemoryGB int
	DECLARE @freememGB int
	DECLARE @maxmemGB int
	DECLARE @maxmemMB_cur int
	DECLARE @minmemGB int
	DECLARE @maxmem_instance_count int
	DECLARE @maxmemMB_instances int

	DECLARE @maxdop int
	DECLARE @maxdop_cur int
	DECLARE @spconfigure_cur varchar(3950)
	DECLARE @spconfigure_suggested varchar(3950)

	DECLARE @sql nvarchar(4000)
	DECLARE @sql2 nvarchar(4000)

	DECLARE @nspc varchar(50)
	DECLARE @dtoset varchar(100)
	DECLARE @dsuggest varchar(100)
	DECLARE @dwatch varchar(100)

	SET @nspc = 'sp_configure'
	SET @dtoset = 'toset\base\sp_configure'
	SET @dsuggest = 'suggested\base\sp_configure'
	SET @dwatch = 'watch\base\sp_configure'

	DECLARE @GetInstances TABLE
	(
		[Value] varchar(100),
		InstanceNames nvarchar(100),
		[Data] nvarchar(100)
	)

	IF @debug = 1
		RAISERROR('Checking sp_configure settings', 10, 1) WITH NOWAIT

	SELECT @numa_nodes = COUNT(*) FROM sys.dm_os_nodes WHERE node_state_desc = 'ONLINE'
	IF @is_set_only = 0
		INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('numa nodes', @utc, LTRIM(STR(@numa_nodes)), 'current')

	IF @@MICROSOFTVERSION >= 167773760 --10.0.1600
	BEGIN
		SET @sql = N'SELECT @totalmem = ROUND(Cast(total_physical_memory_kb as float) /1024,0) FROM sys.dm_os_sys_memory;'
	END
	ELSE
	BEGIN
		SET @sql = N'select @totalmem = ROUND(Cast(physical_memory_in_bytes as float) /1024/1024,0) from sys.dm_os_sys_info;'
	END
	EXECUTE sp_executesql @sql, N'@totalmem int OUTPUT', @totalmem=@physical_memory_MB OUTPUT

	IF @is_set_only = 0
		INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('physical memory(MB)', @utc, LTRIM(STR(@physical_memory_MB)), 'current')

	INSERT INTO @GetInstances
		EXECUTE xp_regread
			@rootkey = @HKLM,
			@key = @sqlbasekey,
			@value_name = 'InstalledInstances'

	SELECT @instance_count = COUNT(*) FROM @GetInstances 

		IF @iValue < 1 
			SET @iValue = 1

		IF @is_set_only = 0
			INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('instance count', @utc, LTRIM(STR(@instance_count)), 'current')

		SET @maxmem_instance_count = 0
		SET @maxmemMB_instances = 0

		IF @instance_count > 1
		BEGIN
			IF @debug = 1
				RAISERROR('Checking instance max mem setting', 10, 1) WITH NOWAIT

			IF EXISTS(SELECT 1 FROM sys.configurations WHERE [name] = 'Ad Hoc Distributed Queries' and CONVERT(int, value_in_use) = 1)
			BEGIN
				SET @sql2 = N'SELECT CONVERT(int, value_in_use) as a from sys.configurations WHERE [name] = ''''max server memory (MB)'''''
				SET @vcValue = ''
				DECLARE inst_cur CURSOR FOR
					SELECT InstanceNames FROM @GetInstances
				OPEN inst_cur
				FETCH NEXT FROM inst_cur INTO @instance
				WHILE @@FETCH_STATUS != -1
				BEGIN
					SET @iValue = -1
					IF @instance = ISNULL(SERVERPROPERTY('InstanceName'),'MSSQLSERVER')
					BEGIN
						SELECT @iValue = CONVERT(int, value_in_use) FROM sys.configurations WHERE [name] = 'max server memory (MB)'
						SET @maxmemMB_cur = @iValue
					END
					ELSE
					BEGIN
						IF @instance = 'MSSQLSERVER'
						BEGIN
							SET @rmtserver = 'Server=.;Trusted_Connection=yes;Timeout=5;'
						END
						ELSE
						BEGIN
							SET @rmtserver = 'Server=.\' + @instance + ';Trusted_Connection=yes;Timeout=5;'
						END

						SET @sql = N'SELECT @i = a FROM OPENROWSET(''' + @provider + ''', ''' + @rmtserver + ''', ''' + @sql2 + ''' )'
				
						BEGIN TRY
							EXECUTE sp_executesql @sql, N'@i int OUTPUT', @i=@iValue OUTPUT

							--do not count instance if maxmem is set to default
							IF @iValue != 2147483647
							BEGIN
								SET @maxmemMB_instances = @maxmemMB_instances + @iValue
								SET @maxmem_instance_count = @maxmem_instance_count + 1
							END
						END TRY
						BEGIN CATCH
							PRINT 'Error connecting to: ' + @instance
						END CATCH
					END

					SET @vcValue = @vcValue + @instance + '=' + LTRIM(STR(@iValue)) + ','
					FETCH NEXT FROM inst_cur INTO @instance
				END
				DEALLOCATE inst_cur

				IF @is_set_only = 0
					INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('instances maxmem', @utc, @vcValue, 'current')
			END
		END
		ELSE
		BEGIN
			SELECT @maxmemMB_cur = CONVERT(int, value_in_use) FROM sys.configurations WHERE [name] = 'max server memory (MB)'
		END

	IF @debug = 1
		RAISERROR('Checking sp_configure', 10, 1) WITH NOWAIT

	SELECT @spconfigure_suggested = [value] FROM dbo.config_fddba2 WHERE [name] = @nspc AND [domain] = @dsuggest
	IF @spconfigure_suggested IS NOT NULL
	BEGIN
		SET @vcValue2 = ''
		DECLARE spconfig_cur2 CURSOR FOR 
			SELECT c.[name] + '=' + LTRIM(STR(CONVERT(int, c.value_in_use)))
				FROM sys.configurations c
					INNER JOIN dbo.fSplit2columns(@spconfigure_suggested, '=', ',') s
						ON c.[name] = s.a
		OPEN spconfig_cur2
		FETCH NEXT FROM spconfig_cur2 INTO @vcValue3
		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @vcValue2 = @vcValue2 + @vcValue3 + ','
			FETCH NEXT FROM spconfig_cur2 INTO @vcValue3
		END
		DEALLOCATE spconfig_cur2

		SET @spconfigure_cur = @vcValue2

		IF @debug = 1
			RAISERROR('Checking sp_configure watch', 10, 1) WITH NOWAIT

		SELECT @vcValue = [value] FROM dbo.config_fddba2 WHERE [name] = @nspc AND [domain] = @dwatch
		IF @vcValue IS NOT NULL
		BEGIN
			SET @vcValue2 = ''
			DECLARE spconfig_cur3 CURSOR FOR 
				SELECT c.[name] + '=' + LTRIM(STR(CONVERT(int, c.value_in_use)))
					FROM sys.configurations c
						INNER JOIN dbo.fSplit2columns(@vcValue, '=', ',') s
							ON c.[name] = s.a
			OPEN spconfig_cur3
			FETCH NEXT FROM spconfig_cur3 INTO @vcValue3
			WHILE @@FETCH_STATUS != -1
			BEGIN
				SET @vcValue2 = @vcValue2 + @vcValue3 + ','
				FETCH NEXT FROM spconfig_cur3 INTO @vcValue3
			END
			DEALLOCATE spconfig_cur3

			IF @is_set_only = 0
				INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@nspc, @utc, @spconfigure_cur + @vcValue2, 'current')
		END
		ELSE
		BEGIN
			SET @msg = 'watch\base\sp_configure is NULL'
			RAISERROR(@msg,11,1) WITH NOWAIT
		END

		IF @debug = 1
			RAISERROR('Checking maxdop', 10, 1) WITH NOWAIT

		IF @instance_count = 1
		BEGIN
			IF @logical_cpus > 8
				SET @maxdop = 8
			ELSE
				SET @maxdop = 0
		END
		ELSE
		BEGIN
			IF @logical_cpus > 8 
			BEGIN
				SET @maxdop = CAST(@logical_cpus/@numa_nodes AS INT)
				IF @maxdop > 8 
					SET @maxdop = 8
			END
			ELSE
			BEGIN
				SET @maxdop = 0
			END
		END

		SELECT @vcValue = items FROM dbo.fSplit(@spconfigure_suggested, ',') WHERE items LIKE 'max degree of parallelism=%'
		SET @vcValue2 = 'max degree of parallelism=' + LTRIM(STR(@maxdop))
		SET @spconfigure_suggested = REPLACE(@spconfigure_suggested, @vcValue, @vcValue2)

		IF @debug = 1
			RAISERROR('Checking maxmem', 10, 1) WITH NOWAIT

		IF @@MICROSOFTVERSION >= 167773760 --10.0.1600
		BEGIN
		  SET @sql = N'SELECT @totalmem = ROUND(Cast(total_physical_memory_kb as float) /1024,0) FROM sys.dm_os_sys_memory'
		END
		ELSE
		BEGIN
			SET @sql = N'select @totalmem = ROUND(Cast(physical_memory_in_bytes as float) /1024/1024,0) from sys.dm_os_sys_info'
		END
		EXECUTE sp_executesql @sql, N'@totalmem int OUTPUT', @totalmem=@physmemoryMB OUTPUT

		SET @freememGB = 1
		--round up on physical memory as sometimes it is off mb
		SET @physmemoryGB = CEILING(@physmemoryMB/1024.)

		IF @physmemoryGB > 4
		BEGIN
			IF @physmemoryGB <= 16
				SET @freememGB = @freememGB + (@physmemoryGB - 4)/4
			ELSE
				SET @freememGB = @freememGB + 3 + ((@physmemoryGB - 16)/8)
		END

		SET @maxmemGB = (@physmemoryGB - CEILING(@maxmemMB_instances/1024.) - @freememGB) / (@instance_count - @maxmem_instance_count)
		SET @minmemGB = (@physmemoryMB - CEILING(@maxmemMB_instances/1024.)) / 2 / (@instance_count - @maxmem_instance_count)

		SELECT @vcValue = items FROM dbo.fSplit(@spconfigure_suggested, ',') WHERE items LIKE 'max server memory (MB)=%'
		SET @vcValue2 = 'max server memory (MB)=' + LTRIM(STR(@maxmemGB * 1024))
		SET @spconfigure_suggested = REPLACE(@spconfigure_suggested, @vcValue, @vcValue2)

		SET @vcValue = 'physGB=' + LTRIM(STR(@physmemoryGB)) + ',freeGB=' + LTRIM(STR(@freememGB)) + ',maxmeminstcount=' + LTRIM(STR(@maxmem_instance_count)) + ',maxmeminstMB=' + LTRIM(STR(@maxmemMB_instances)) + ','
		IF @is_set_only = 0
		BEGIN
			INSERT dbo.config_fddba2_history ([name], [domain], [value]) VALUES ('max server memory compute', @utc, @vcValue)

			UPDATE dbo.config_fddba2
				SET [value] = @spconfigure_suggested,
					UpdatedOn = GETDATE()
				WHERE [name] = @nspc AND [domain] = @dsuggest
			SET @iValue = @@ROWCOUNT
			IF @iValue != 1
			BEGIN
				SET @msg = 'suggested\base\sp_configure update count=' + LTRIM(STR(@iValue))
				RAISERROR(@msg,11,1) WITH NOWAIT
			END
		END

		IF @debug = 1
			RAISERROR('Setting sp_configure', 10, 1) WITH NOWAIT

		IF @spconfigure_suggested != @spconfigure_cur
		BEGIN
			SET @vcValue = ''
			DECLARE spconfig_cur4 CURSOR FOR 
				SELECT a, b FROM dbo.fSplit2columns(@spconfigure_suggested, '=',',')
			OPEN spconfig_cur4
			FETCH NEXT FROM spconfig_cur4 INTO @vcValue2, @iValue
			WHILE @@FETCH_STATUS != -1
			BEGIN
				SET @iValue2 = NULL
				SELECT @iValue2 = b FROM dbo.fSplit2columns(@spconfigure_cur, '=',',') WHERE a = @vcValue2
				IF @iValue2 IS NULL OR @iValue > @iValue2
				BEGIN
					SET @vcValue = @vcValue + @vcValue2 + '=' + LTRIM(STR(@iValue)) + ','
				END
				FETCH NEXT FROM spconfig_cur4 INTO @vcValue2, @iValue
			END
			DEALLOCATE spconfig_cur4
		
			IF LEN(@vcValue) > 0
			BEGIN
				IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @nspc AND [domain] = @dtoset)
					INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@nspc, @dtoset, @vcValue)
				ELSE
				BEGIN
					UPDATE dbo.config_fddba2
						SET [value] = @vcValue,
							UpdatedOn = GETDATE()
						WHERE [name] = @nspc AND [domain] = @dtoset
				END
			END
			ELSE
			BEGIN
				DELETE dbo.config_fddba2 WHERE [name] = @nspc AND [domain] = @dtoset
			END
		END
	END
	ELSE
	BEGIN
		SET @msg = 'suggested\base\sp_configure is NULL'
		RAISERROR(@msg,11,1) WITH NOWAIT
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_sqlagent]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_sqlagent') is null exec('create procedure [dbo].[configuration_sqlagent] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_sqlagent]
*
*	Purpose: Read configuration on database settings and create toset values that do not match suggestion
*
*	Inputs:	
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@HKLM : REQUIRED - string for use with xp_instance_regread
*		@sqlagentkey : REQUIRED - string for use with xp_instance_regread
*		@is_set_only : OPTIONAL - when 1 it only inserts/updates toset\% rows in config_fddba2 table, this is used so configuration_set can check
*			if a configuration setting is still valid to make as the last toset value might be old or out of date
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. There are configuration values for suggested values
*		2. The name column of config_fddba2 table will be either "sql agent" or "sql agent job history"
*		3. The value columns of config_fddba2 table will be in the format of  "<setting>=<value>". Here is an example of
*			setting both JobHistoryMaxRows and JobHistoryMaxRowsPerJob: "JobHistoryMaxRows=5000,JobHistoryMaxRowsPerJob=100,"
*		4. As will other value settings in config_fddba2, these value settings are multi-column, multi-value. See example in #3.
*		5. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_sqlagent
(
	@utc varchar(23),
	@HKLM varchar(100), 
	@sqlagentkey varchar(256),
	@is_set_only bit = 0,
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TODO int
	DECLARE @iValue int
	DECLARE @iValue2 int
	DECLARE @iValue3 int
	DECLARE @vcValue varchar(3950)
	DECLARE @vcValue2 varchar(3950)
	DECLARE @vcValue3 varchar(3950)
	DECLARE @vcValue4 varchar(3950)
	DECLARE @vcValue5 varchar(3950)
	DECLARE @vcValue6 varchar(3950)
	DECLARE @msg varchar(400)

	DECLARE @profilename_cur sysname
	DECLARE @profilename_sug sysname
	DECLARE @operator_cur sysname
	DECLARE @operator_sug sysname
	DECLARE @operatoremail_cur varchar(200)
	DECLARE @operatoremail_sug varchar(200)
	DECLARE @mailitem_id int
	DECLARE @profileid int

	DECLARE @name varchar(50)
	DECLARE @dsuggest varchar(100)
	DECLARE @dtoset varchar(100)

	SET @name = 'sql agent job history'
	SET @dsuggest = 'suggested\base\sqlagentjob'
	SET @dtoset = 'toset\base\sqlagentjob'

	IF @debug = 1
		RAISERROR('Checking SQLAgent history', 10, 1) WITH NOWAIT

	SET @iValue = NULL
	SET @iValue2 = NULL
	BEGIN TRY
		EXEC xp_instance_regread @HKLM, @sqlagentkey, N'JobHistoryMaxRows', @iValue output, N'no_output'
		EXEC xp_instance_regread @HKLM, @sqlagentkey, N'JobHistoryMaxRowsPerJob', @iValue2 output, N'no_output'
	END TRY
	BEGIN CATCH
		SET @iValue3 = ERROR_NUMBER()
	END CATCH

	SET @vcValue = 'JobHistoryMaxRows=' + ISNULL(LTRIM(STR(@iValue)),'') + ',JobHistoryMaxRowsPerJob=' + ISNULL(LTRIM(STR(@iValue2)),'') + ','
	IF @is_set_only = 0
		INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES ('sql agent job history', @utc, @vcValue, 'current')

	SELECT @vcValue2 = [value] FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dsuggest
	IF @vcValue2 IS NOT NULL
	BEGIN
		--toset
		SET @vcValue6 = ''
		DECLARE jobhist_cur CURSOR FOR
			SELECT a, b FROM dbo.fSplit2columns(@vcValue2, '=', ',')
		OPEN jobhist_cur
		FETCH NEXT FROM jobhist_cur INTO @vcValue3, @vcValue4

		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @vcValue5 = NULL
			SELECT @vcValue5 = b FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = @vcValue3
			IF @vcValue5 IS NULL OR CONVERT(int, @vcValue4) > CONVERT(int, @vcValue5)
			BEGIN
				SET @vcValue6 = @vcValue6 + @vcValue3 + '=' + @vcValue4 + ','
			END
			FETCH NEXT FROM jobhist_cur INTO @vcValue3, @vcValue4
		END
		DEALLOCATE jobhist_cur

		IF LEN(@vcValue6) > 0
		BEGIN
			IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset)
				INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@name, @dtoset, @vcValue6)
			ELSE
			BEGIN
				UPDATE dbo.config_fddba2
					SET [value] = @vcValue6,
						UpdatedOn = GETDATE()
					WHERE [name] = @name AND [domain] = @dtoset
			END
		END
		ELSE
		BEGIN
			DELETE dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset
		END
	END
	ELSE
	BEGIN
		SET @msg = 'suggested\base\sqlagentjob is NULL'
	END


	IF @debug = 1
		RAISERROR('Checking SQLAgent mail and operator', 10, 1) WITH NOWAIT

	SET @name = 'sql agent'
	SET @dsuggest = 'suggested\base\sqlagent'
	SET @dtoset = 'toset\base\sqlagent'
	

	--agent mail check
	SET @iValue = NULL

	BEGIN TRY
		EXEC master.dbo.xp_instance_regread @HKLM, @sqlagentkey, N'UseDatabaseMail', @iValue OUTPUT
	END TRY
	BEGIN CATCH
		SET @iValue = 0
	END CATCH
		
	SET @vcValue = 'UseDatabaseMail=' + LTRIM(STR(@iValue)) + ',' --current
	SET @vcValue3 = 'UseDatabaseMail=1,' --new suggest

	SET @vcValue2 = NULL
	EXEC master.dbo.xp_instance_regread @HKLM, @sqlagentkey, N'DatabaseMailProfile', @vcValue2 OUTPUT
	SET @profilename_cur = @vcValue2
	SET @vcValue = @vcValue + 'DatabaseMailProfile' + '=' + ISNULL(@profilename_cur,'') + ','
	SET @vcValue3 = @vcValue3 + 'DatabaseMailProfile' + '=' + COALESCE(@profilename_cur,@profilename_sug,'') + ','

	--operator check
	SET @vcValue2 = NULL
	SELECT @vcValue2 = [value] FROM dbo.config_fddba2 WHERE [name] = @name and [domain] = @dsuggest

	SELECT @operator_sug = b FROM dbo.fSplit2columns(@vcValue2, '=', ',') WHERE a = 'operator'

	SELECT @operatoremail_cur = email_address, @iValue = last_email_date FROM msdb.dbo.sysoperators WHERE [name] = @operator_sug

	IF @operatoremail_cur IS NULL
	BEGIN
		IF @debug = 1
			RAISERROR('operator email address lookup', 10, 1) WITH NOWAIT
		SELECT @iValue = COUNT(*) FROM msdb.dbo.sysoperators WHERE email_address like 'FDAlert@%.com'
		IF @iValue = 1
		BEGIN
			IF @debug = 1
				RAISERROR('operator email address lookup success', 10, 1) WITH NOWAIT
			SELECT @operator_cur = [name], @operatoremail_cur = email_address, @iValue = last_email_date FROM msdb.dbo.sysoperators WHERE email_address like 'FDAlert@%.com'
		END
	END
	ELSE
	BEGIN
		SET @operator_cur = @operator_sug
	END 

	SET @vcValue = @vcValue + 'operator=' + ISNULL(@operator_cur,'') + ',operatoremail=' + ISNULL(@operatoremail_cur,'') + ','
	SET @vcValue3 = @vcValue3 + 'operator=' + COALESCE(@operator_cur,@operator_sug,'') + ',operatoremail=' + COALESCE(@operatoremail_cur,@operatoremail_sug,'') + ','

	IF @is_set_only = 0
	BEGIN
		INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@name, @utc, @vcValue, 'current')

		IF LEN(@vcValue3) > 0 AND @vcValue3 != @vcValue2
		BEGIN
			SET @vcValue2 = @vcValue3
			UPDATE dbo.config_fddba2
				SET UpdatedOn = GETDATE(),
					[comment] = 'old=value,' + [value],
					[value] = @vcValue2
				WHERE [name] = @name and [domain] = @dsuggest
		END
	END

	--toset
	IF @vcValue2 IS NOT NULL
	BEGIN
		SET @vcValue6 = ''
		DECLARE agent_cur CURSOR FOR
			SELECT a, b FROM dbo.fSplit2columns(@vcValue2, '=', ',')
		OPEN agent_cur
		FETCH NEXT FROM agent_cur INTO @vcValue3, @vcValue4

		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @vcValue5 = NULL
			SELECT @vcValue5 = b FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = @vcValue3
			IF @vcValue5 IS NULL OR @vcValue5 != @vcValue4
			BEGIN
				SET @vcValue6 = @vcValue6 + @vcValue3 + '=' + @vcValue4 + ','
			END
			FETCH NEXT FROM agent_cur INTO @vcValue3, @vcValue4
		END
		DEALLOCATE agent_cur

		IF LEN(@vcValue6) > 0
		BEGIN
			IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset)
				INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@name, @dtoset, @vcValue6)
			ELSE
			BEGIN
				UPDATE dbo.config_fddba2
					SET [value] = @vcValue6,
						UpdatedOn = GETDATE()
					WHERE [name] = @name AND [domain] = @dtoset
			END
		END
		ELSE
		BEGIN
			DELETE dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset
		END
	END
	ELSE
	BEGIN
		SET @msg = 'suggested\base\sqlagent setting is NULL'
		RAISERROR(@msg,11,1) WITH NOWAIT
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[configuration_sqlerrorlog]',10,1) WITH NOWAIT;
if object_id('dbo.configuration_sqlerrorlog') is null exec('create procedure [dbo].[configuration_sqlerrorlog] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[configuration_sqlerrorlog]
*
*	Purpose: Read configuration on SQL Server errorlog settings and create toset values that do not match suggestion
*
*	Inputs:	
*		@utc : REQUIRED - datetime value with GETUTCDATE() from configure_insert so that any current values inserted all have same dt value
*		@HKLM : REQUIRED - string for use with xp_instance_regread
*		@sqlinstkey : REQUIRED - string for use with xp_instance_regread
*		@is_set_only : OPTIONAL - when 1 it only inserts/updates toset\% rows in config_fddba2 table, this is used so configuration_set can check
*			if a configuration setting is still valid to make as the last toset value might be old or out of date
*		@debug : OPTIONAL - whether print statements about progess should be returned to client application
*
*	Notes:	
*		1. There are configuration values for suggested values
*		2. The name column of config_fddba2 table will be "sql errorlog"
*		3. The value columns of config_fddba2 table will be in the format of  "<setting>=<value>". Here is an example of
*			setting for 99 database and cycling job name of "DBA - Cycle Errorlog Nightly": "NumErrorLogs=99,jobname=DBA - Cycle Errorlog Nightly,"
*		4. As will other value settings in config_fddba2, these value settings are multi-column, multi-value. See example in #3.
*		5. It is suggested to that this stored procedure should not be run directly and instead via configuration_insert stored procedure
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-01			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.configuration_sqlerrorlog
(
	@utc varchar(23),
	@HKLM nvarchar(100), 
	@sqlinstkey nvarchar(256),
	@is_set_only bit = 0,
	@debug bit = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TODO int
	DECLARE @iValue int
	DECLARE @iValue2 int
	DECLARE @iValue3 int
	DECLARE @vcValue varchar(3950)
	DECLARE @vcValue2 varchar(3950)
	DECLARE @vcValue3 varchar(3950)
	DECLARE @vcValue4 varchar(3950)
	DECLARE @vcValue5 varchar(3950)
	DECLARE @vcValue6 varchar(3950)
	DECLARE @msg varchar(400)

	DECLARE @name varchar(50)
	DECLARE @dtoset varchar(100)
	DECLARE @dsuggest varchar(100)

	SET @name = 'sql errorlog'
	SET @dsuggest = 'suggested\base\sqlerrorlog'
	SET @dtoset = 'toset\base\sqlerrorlog'

/*
	--intended for use with xp_instance_regenumvalues but for NumErrorLogs it returns 3 columns instead of 2 (two Value columns with one of them being null)
	CREATE TABLE #reg_values
	(
		[Value] sysname NOT NULL,
		[Data] sql_variant NOT NULL
	)
*/

	IF @debug = 1
		RAISERROR('Checking SQL Server Errorlog count and cycle job', 10, 1) WITH NOWAIT

	--following returns 3 columns instead of 2 (two Value columns with one of them being null) for NumErrorLogs
	--INSERT #reg_values EXEC xp_instance_regenumvalues @HKLM, @sqlinstkey
	BEGIN TRY
		EXEC xp_instance_regread @HKLM, @sqlinstkey, N'NumErrorLogs', @iValue output, N'no_output'
	END TRY
	BEGIN CATCH
		SET @iValue = 6 --default value when value does not exist
	END CATCH
	IF @iValue IS NULL
		SET @iValue = 6

	SET @vcValue = 'NumErrorLogs=' + LTRIM(STR(ISNULL(@iValue,-1))) + ','
	SET @vcValue2 = NULL
	SELECT @vcValue2 = j.name
		FROM msdb.dbo.sysjobs j
			INNER JOIN msdb.dbo.sysjobsteps s 
				ON j.job_id = s.job_id
				AND j.[enabled] = 1
		WHERE LOWER(s.command) LIKE '%sp_cycle_errorlog%'
	SET @vcValue = @vcValue + 'jobname=' + ISNULL(@vcValue2,'') + ','
	
	SET @iValue2 = NULL
	SET @iValue3 = NULL
	IF @vcValue2 IS NOT NULL
	BEGIN
		SELECT @iValue3 = s.active_start_time FROM msdb.dbo.sysjobs j
			INNER JOIN msdb.dbo.sysjobschedules js
				ON j.job_id = js.job_id
				AND j.[name] = @vcValue2
			INNER JOIN msdb.dbo.sysschedules s
				ON js.schedule_id = s.schedule_id
				AND s.[enabled] = 1
				AND s.freq_type = 4
				AND s.freq_subday_type = 1
		IF @iValue3 IS NOT NULL
			SET @iValue2 = 1			
	END
	SET @vcValue = @vcValue + 'jobdaily=' + LTRIM(STR(ISNULL(@iValue2,0))) + ',jobtime=' + LTRIM(STR(ISNULL(@iValue3,-1))) + ','
	IF @is_set_only = 0
		INSERT dbo.config_fddba2_history ([name], [domain], [value], [comment]) VALUES (@name, @utc, @vcValue, 'current')

	
	SELECT @vcValue2 = [value] FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dsuggest
	IF @vcValue2 IS NOT NULL
	BEGIN
		--toset
		SET @vcValue6 = ''
		DECLARE sqlelog_cur CURSOR FOR
			SELECT a, b FROM dbo.fSplit2columns(@vcValue2, '=', ',')
		OPEN sqlelog_cur
		FETCH NEXT FROM sqlelog_cur INTO @vcValue3, @vcValue4

		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @vcValue5 = NULL
			SELECT @vcValue5 = b FROM dbo.fSplit2columns(@vcValue, '=', ',') WHERE a = @vcValue3
			IF @vcValue5 IS NULL OR @vcValue4 != @vcValue5
			BEGIN
				SET @vcValue6 = @vcValue6 + @vcValue3 + '=' + @vcValue4 + ','
			END
			FETCH NEXT FROM sqlelog_cur INTO @vcValue3, @vcValue4
		END
		DEALLOCATE sqlelog_cur

		IF LEN(@vcValue6) > 0
		BEGIN
			IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset)
				INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@name, @dtoset, @vcValue6)
			ELSE
			BEGIN
				UPDATE dbo.config_fddba2
					SET [value] = @vcValue6,
						UpdatedOn = GETDATE()
					WHERE [name] = @name AND [domain] = @dtoset
			END
		END
		ELSE
		BEGIN
			DELETE dbo.config_fddba2 WHERE [name] = @name AND [domain] = @dtoset
		END
	END
	ELSE
	BEGIN
		SET @msg = 'suggested\base\sqlerrorlog is NULL'
	END


END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[ConfigurationHistory_insert]',10,1) WITH NOWAIT;
if object_id('dbo.ConfigurationHistory_insert') is null exec('create procedure [dbo].[ConfigurationHistory_insert] as select getdate() DT')
GO
  
alter procedure dbo.ConfigurationHistory_insert
WITH ENCRYPTION
AS
SET NOCOUNT ON
DECLARE @dt		DATETIME
SELECT @dt = GETDATE()

	EXEC dbo.usp_UpdateVersionStatics

	INSERT INTO dbo.ConfigurationHistory(CreatedOn, name, value_in_use)
	SELECT @dt, name, value_in_use FROM sys.configurations


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_compute_process_checksum]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_compute_process_checksum') is null exec('create procedure [dbo].[deadlock_compute_process_checksum] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_compute_process_checksum]
*
*	Purpose: Using process, resource, query create a checksum value for process in deadlock
*
*	Inputs:	
*		@binary : OPTIONAL - 1=use CHECKSUM_BINARY, 0 = use CHECKSUM
*
*	Notes: None
*
*	TODO:
*		1. Need to update for intra-query deadlocks
*		2. Need to update for other resource types when parsing is updated for those types
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_compute_process_checksum 
(
	@binary tinyint = 0
)
WITH ENCRYPTION
AS
BEGIN
	--page locks
	UPDATE dp
		SET process_checksum = 
			CASE WHEN @binary = 0
/*
				--this method caused convergence in values
				THEN CHECKSUM(LTRIM(STR(dp.wr_dbid)) + 
					dp.lock_mode + 
					CASE WHEN ts.proc_name in ('adhoc','unknown') THEN dp.transactionname ELSE ts.proc_name END + 
					LTRIM(STR(ISNULL(ts.stmtstart,1))) + 
					LTRIM(STR(dr.hobtid,30)))
				ELSE BINARY_CHECKSUM(LTRIM(STR(dp.wr_dbid)) + 
					dp.lock_mode + 
					CASE WHEN ts.proc_name in ('adhoc','unknown') THEN dp.transactionname ELSE ts.proc_name END + 
					LTRIM(STR(ISNULL(ts.stmtstart,1))) + LTRIM(STR(dr.hobtid,30)))
*/
				THEN CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL THEN dp.transaction_name ELSE ts.proc_name END, 
					ts.stmt_start, dr.hobtId)
				ELSE BINARY_CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL THEN dp.transaction_name ELSE ts.proc_name END, 
					ts.stmt_start, dr.hobtId)
			END

		FROM dbo.deadlock_process dp
			LEFT OUTER JOIN dbo.deadlock_tsql_stack ts
				ON dp.deadlock_id = ts.deadlock_id
				AND dp.process_id = ts.process_id
			INNER JOIN dbo.deadlock_resource dr
				ON dp.deadlock_id = dr.deadlock_id
				AND dp.wr_dbid = dr.database_id
				AND dp.wr_fileid = dr.fileid
				AND dp.wr_pageid = dr.pageid
		WHERE dp.wr_type = 'PAGE' 
			AND ts.frame_id = 0
			AND dp.process_checksum IS NULL

/*
--mikez not sure IF we should do this next query AS it is very generic AND could be non-waiters
	--page locks without query or resource
	UPDATE dp
		SET process_checksum = 
			CASE WHEN @binary = 0
				THEN CHECKSUM(dp.wr_dbid, dp.lock_mode, dp.transactionname)
				ELSE BINARY_CHECKSUM(dp.wr_dbid, dp.lock_mode, dp.transactionname)
			END
		FROM dbo.deadlock_process dp
		WHERE dp.wr_type = 'PAGE' AND dp.process_checksum IS NULL
*/

	--key locks
	UPDATE dp
		SET process_checksum = 
			CASE WHEN @binary = 0
				THEN CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL THEN dp.transaction_name ELSE ts.proc_name END,
					ts.stmt_start, dp.wr_hobt)
				ELSE BINARY_CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL THEN dp.transaction_name ELSE ts.proc_name END,
					ts.stmt_start, dp.wr_hobt)
			END
		FROM dbo.deadlock_process dp
			LEFT OUTER JOIN dbo.deadlock_tsql_stack ts
				ON dp.deadlock_id = ts.deadlock_id
				AND dp.process_id = ts.process_id
		WHERE ts.frame_id = 0 
			AND dp.wr_type = 'KEY'
			AND dp.process_checksum IS NULL

	--key locks without a query
	UPDATE dp
		SET process_checksum = 
			CASE WHEN @binary = 0
				THEN CHECKSUM(dp.wr_dbid, dp.lock_mode, dp.transaction_name, dp.wr_hobt)
				ELSE BINARY_CHECKSUM(dp.wr_dbid, dp.lock_mode, dp.transaction_name, dp.wr_hobt)
			END
		FROM dbo.deadlock_process dp
		WHERE dp.wr_type = 'KEY' 
			AND dp.process_checksum IS NULL

	--object locks
	UPDATE dp
		SET process_checksum = 
			CASE WHEN @binary = 0
				THEN CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL then dp.transaction_name ELSE ts.proc_name END,
					ts.stmt_start, dp.wr_objid)
				ELSE BINARY_CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL then dp.transaction_name ELSE ts.proc_name END,
					ts.stmt_start, dp.wr_objid)
			END
		FROM dbo.deadlock_process dp
			LEFT OUTER JOIN dbo.deadlock_tsql_stack ts
				ON dp.deadlock_id = ts.deadlock_id
				AND dp.process_id = ts.process_id
		WHERE dp.wr_type = 'OBJECT' 
			AND ts.frame_id = 0
			AND dp.process_checksum IS NULL

	--metadata locks
	UPDATE dp
		SET process_checksum = 
			CASE WHEN @binary = 0
				THEN CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL then dp.transaction_name ELSE ts.proc_name END,
					ts.stmt_start, dp.wr_schid)
				ELSE BINARY_CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL then dp.transaction_name ELSE ts.proc_name END,
					ts.stmt_start, dp.wr_schid)
			END
		FROM dbo.deadlock_process dp
			LEFT OUTER JOIN dbo.deadlock_tsql_stack ts
				ON dp.deadlock_id = ts.deadlock_id
				AND dp.process_id = ts.process_id
		WHERE dp.wr_type = 'METADATA' 
			AND ts.frame_id = 0
			AND dp.process_checksum IS NULL

	--rid locks
	UPDATE dp
		SET process_checksum = 
			CASE WHEN @binary = 0
				THEN CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL then dp.transaction_name ELSE ts.proc_name END, 
					ts.stmt_start, dr.hobtId)
				ELSE BINARY_CHECKSUM(dp.wr_dbid, dp.lock_mode, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL then dp.transaction_name ELSE ts.proc_name END, 
					ts.stmt_start, dr.hobtId)
			END
		FROM dbo.deadlock_process dp
			LEFT OUTER JOIN dbo.deadlock_tsql_stack ts
				ON dp.deadlock_id = ts.deadlock_id
				AND dp.process_id = ts.process_id
			INNER JOIN dbo.deadlock_resource dr
				ON dp.deadlock_id = dr.deadlock_id
				AND dp.wr_dbid = dr.database_id
				AND dp.wr_fileid = dr.fileid
				AND dp.wr_pageid = dr.pageid
		WHERE dp.wr_type = 'RID' 
			AND ts.frame_id = 0
			AND dp.process_checksum IS NULL

	--app locks
	UPDATE dp
		SET process_checksum = 
			CASE WHEN @binary = 0
				THEN CHECKSUM(dp.wr_dbid, dp.lock_mode, dp.wait_resource,
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL THEN dp.transaction_name ELSE ts.proc_name END,
					ts.stmt_start)
				ELSE BINARY_CHECKSUM(dp.wr_dbid, dp.lock_mode, dp.wait_resource, 
					CASE WHEN ts.proc_name IN ('adhoc','unknown') OR ts.proc_name IS NULL THEN dp.transaction_name ELSE ts.proc_name END,
					ts.stmt_start)
			END
		FROM dbo.deadlock_process dp
			LEFT OUTER JOIN dbo.deadlock_tsql_stack ts
				ON dp.deadlock_id = ts.deadlock_id
				AND dp.process_id = ts.process_id
		WHERE ts.frame_id = 0 
			AND dp.wr_type = 'APPLICATION'
			AND dp.process_checksum IS NULL

	DECLARE @id int
	DECLARE @checksum bigint
	DECLARE @unique_checksum bigint
	DECLARE @unique_checksum_count tinyint
	DECLARE @msg varchar(100)
	DECLARE @pchecksum int
	DECLARE @pchecksum_last int

	DECLARE dl_cursor CURSOR FOR
		SELECT deadlock_id FROM dbo.deadlock WHERE dl_checksum IS NULL

	OPEN dl_cursor
	FETCH NEXT FROM dl_cursor INTO @id
	WHILE @@FETCH_STATUS != -1
	BEGIN
		SET @checksum = 0
	
		SELECT @checksum = SUM(CONVERT(bigint, dp.process_checksum))
			FROM dbo.deadlock_process dp
			WHERE dp.deadlock_id = @id AND dp.process_checksum IS NOT NULL

		SET @unique_checksum = 0
		SET @unique_checksum_count = 0
		SET @pchecksum_last = 0

		DECLARE dl_proc_cursor CURSOR FOR
			SELECT process_checksum FROM dbo.deadlock_process
				WHERE deadlock_id = @id AND process_checksum IS NOT NULL
				ORDER BY process_checksum

		OPEN dl_proc_cursor
		FETCH NEXT FROM dl_proc_cursor INTO @pchecksum
		WHILE @@FETCH_STATUS != -1
		BEGIN
			IF @pchecksum != @pchecksum_last
			BEGIN
				--IF @id < 10
				--BEGIN
				--	PRINT STR(@id) + STR(@pchecksum,25,0)
				--END
				SET @unique_checksum = @unique_checksum + @pchecksum
				SET @unique_checksum_count = @unique_checksum_count + 1
			END

			SET @pchecksum_last = @pchecksum
			FETCH NEXT FROM dl_proc_cursor INTO @pchecksum
		END
		DEALLOCATE dl_proc_cursor

		UPDATE dbo.deadlock 
			SET dl_checksum = @checksum,
				dl_unique_checksum = @unique_checksum,
				dl_unique_checksum_count = @unique_checksum_count
			where deadlock_id = @id

		IF @id % 100 = 0
		BEGIN
			SET @msg = CONVERT(varchar(23), GETDATE(), 126) + STR(@id)
			RAISERROR(@msg,10,1) WITH NOWAIT
		END

		FETCH NEXT FROM dl_cursor INTO @id
	END
	DEALLOCATE dl_cursor
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_errorlog]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_errorlog') is null exec('create procedure [dbo].[deadlock_parse_errorlog] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_errorlog]
*
*	Purpose: Parse errorlogs (@file_number to 0) for deadlocks
*
*	Inputs:	
*		@file_number : OPTIONAL - errorlog file number to start with
*		@debug : OPTIONAL - whether to display debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes:
*		1. By default this will process errorlogs 99 thru 0 that exist
*		2. This is designed to keep track of whether errorlogs are already parsed and on last one not completed it will skip data already analyzed
*		3. Running stored procedure as RPC will generate different process/deadlock checksums than as Language event
*		4. If deadlock_parse_error table contains any rows contact Mike for assistance
*		5. The lines to filter are in a table that can be modified to add additional messages and you should look at deadlock_message_noise for suggestions for values to add
*		6. Key to this working is that that the strings in deadlock_parse_strings are inserted in order of occurrence in deadlock messages. 
*		7. It is designed to skip missing columns without error.
*		8. If you know the number of lines in the errorlog file then the deadlock victim messages output can give you an idea of your progress
*		9. For addition usage and categorization of deadlocks see parse_deadlocks_readme.txt
*
*	Possible bugs to look for and contact Mike about:
*		1. If any errors encountered
*		2.	If dbo.deadlock_parse_errors contains any rows 
*
*	TODO:
*		1. Parse other resource types besides exchange, key, rid, object, page, metadata, application
*		2. Find way to determine END of intra-query deadlock without just waiting for the next one
*		3. Parse lock waits for intra-query deadlocks (test6)
*		4. Store all data from intra-query deadlocks
*		5. do a better job on computing checksums for ad-hoc queries
*		6. Consider effect of partitioning on checksum generation
*		7. Look into deadlocks in this process when parsing multiple files at same time on waiter/owner parse proc
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_errorlog
(
	@file_number smallint = 99,
	@debug tinyint = 0,
	@debug_lines int = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @max_lines int
	DECLARE @is_file_complete bit
	DECLARE @max_logdate datetime
	DECLARE @file_start_time datetime
	DECLARE @first_date datetime
	DECLARE @deadlock_count int

	DECLARE @len bigint
	DECLARE @lineno bigint
	DECLARE @line varchar(8000)
	DECLARE @linedate datetime
	DECLARE @linetype varchar(10)
	DECLARE @linespid int
	DECLARE @linespidstr varchar(10)
	DECLARE @pos1 bigint
	DECLARE @pos2 bigint
	DECLARE @pos3 bigint
	DECLARE @pos4 bigint
	DECLARE @pos5 bigint
	DECLARE @pos6 bigint
	DECLARE @done tinyint = 0
	DECLARE @ignore_count bigint = 0
	DECLARE @processedline tinyint

	DECLARE @spid_str	char(4)
	DECLARE @spid_s_str	char(1)
	DECLARE @spid_len	tinyint
	DECLARE @spid_s_len tinyint

	DECLARE @resource_key_str			varchar(15)
	DECLARE @resource_pag_str			varchar(15)
	DECLARE @resource_rid_str			varchar(15)
	DECLARE @resource_object_str		varchar(15)
	DECLARE @resource_exchangepipe_str	varchar(15)
	DECLARE @resource_exchangeport_str	varchar(15)
	DECLARE @resource_metadata_str		varchar(15)
	DECLARE @resource_app_str			varchar(15)
		
	DECLARE @resource_key_len			tinyint
	DECLARE @resource_pag_len			tinyint
	DECLARE @resource_rid_len			tinyint
	DECLARE @resource_object_len		tinyint
	DECLARE @resource_exchangepipe_len	tinyint
	DECLARE @resource_exchangeport_len	tinyint
	DECLARE @resource_app_len			tinyint
	DECLARE @resource_metadata_len		tinyint

	DECLARE @deadlockvictimprocess_str		varchar(25) 
	DECLARE @processidprocess_str			varchar(25) 
	DECLARE @frameprocname_str				varchar(25) 
	DECLARE @resource_keylock_hobtid_str	varchar(25) 
	DECLARE @resource_pagelock_fileid_str	varchar(25) 
	DECLARE @owneridprocess_str				varchar(25) 
	DECLARE @waiteridprocess_str			varchar(25) 
	DECLARE @exchange_pipe_str				varchar(25) 
	DECLARE @exchange_port_str				varchar(25) 
	DECLARE @resource_objectlock_str		varchar(25) 
	DECLARE @resource_rid_fileid_str		varchar(25)
	DECLARE @ProcDatabaseId_str				varchar(25)
	DECLARE @metadatalocksubresource_str	varchar(25)
	DECLARE @intraquerydl_str				varchar(25)
	DECLARE @iqdlNode_str					varchar(25)
	DECLARE @iqdlPort_str					varchar(25)
	DECLARE @iqdlResType_str 				varchar(25)
	DECLARE @iqdlSPID_str					varchar(25)
	DECLARE @iqdlInputBuf_str				varchar(25)
	DECLARE @resource_applock_hash_str		varchar(25)

	--strings to ignore so as to process adhoc inputbuffers
	DECLARE @inputbuf_str					varchar(25)
	DECLARE @deadlocklist_str				varchar(25)
	DECLARE @processlist_str				varchar(25)
	DECLARE @executionStack_str				varchar(25)
	DECLARE @resourcelist_str				varchar(25)
	DECLARE @ownerlist_str					varchar(25)
	DECLARE @waiterlist_str					varchar(25)

	DECLARE @deadlockvictimprocess_len		tinyint
	DECLARE @processidprocess_len			tinyint
	DECLARE @frameprocname_len				tinyint
	DECLARE @resource_keylock_hobtid_len	tinyint
	DECLARE @resource_pagelock_fileid_len	tinyint
	DECLARE @owneridprocess_len				tinyint
	DECLARE @waiteridprocess_len			tinyint
	DECLARE @exchange_pipe_len				tinyint
	DECLARE @exchange_port_len				tinyint
	DECLARE @objectlock_len					tinyint
	DECLARE @resource_rid_fileid_len		tinyint
	DECLARE @ProcDatabaseId_len				tinyint
	DECLARE @metadatalocksubresource_len	tinyint
	DECLARE @intraquerydl_len				tinyint
	DECLARE @iqdlNode_len					tinyint
	DECLARE @iqdlPort_len					tinyint
	DECLARE @iqdlResType_len 				tinyint
	DECLARE @iqdlSPID_len					tinyint
	DECLARE @iqdlInputBuf_len				tinyint
	DECLARE @applock_hash_len				tinyint

	DECLARE @deadlockvictimprocess_sub		tinyint
	DECLARE @processidprocess_sub			tinyint
	DECLARE @frameprocname_sub				tinyint
	DECLARE @resource_keylock_hobtid_sub	tinyint
	DECLARE @resource_pagelock_fileid_sub	tinyint
	DECLARE @owneridprocess_sub				tinyint
	DECLARE @waiteridprocess_sub			tinyint
	DECLARE @exchange_pipe_sub				tinyint
	DECLARE @exchange_port_sub				tinyint
	DECLARE @objectlock_sub					tinyint
	DECLARE @resource_rid_fileid_sub		tinyint
	DECLARE @ProcDatabaseId_sub				tinyint
	DECLARE @metadatalocksubresource_sub	tinyint
	DECLARE @iqdlPort_sub					tinyint
	DECLARE @iqdlResType_sub 				tinyint
	DECLARE @iqdlSPID_sub					tinyint
	DECLARE @iqdlInputBuf_sub				tinyint
	DECLARE @applock_hash_sub				tinyint

	DECLARE @start_time datetime = getdate()
	DECLARE @min_dl int
	DECLARE @max_dl int
	DECLARE @importfileid smallint
	DECLARE @insert_count int
	DECLARE @insert_dt datetime
	DECLARE @insert_sec int
	DECLARE @delete_count int
	DECLARE @delete_dt datetime
	DECLARE @delete_sec int
	DECLARE @fetch_dt datetime
	DECLARE @fetch_sec int

	CREATE TABLE #errorlog
	(
		logdate datetime,
		processinfo varchar(100),
		logtext varchar(8000),
		id int IDENTITY(1,1) NOT NULL PRIMARY KEY CLUSTERED (id)
	)

	--load variables from string table
	SELECT @spid_str = mystr, @spid_len = mylen  FROM dbo.deadlock_parse_strings WHERE stype = 0 AND typeid = 1
	SELECT @spid_s_str = mystr, @spid_s_len = mylen  FROM dbo.deadlock_parse_strings WHERE stype = 0 AND typeid = 2

	SELECT @resource_key_str = mystr, @resource_key_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 1
	SELECT @resource_pag_str = mystr, @resource_pag_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 2
	SELECT @resource_rid_str = mystr, @resource_rid_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 3
	SELECT @resource_object_str = mystr, @resource_object_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 4
	SELECT @resource_exchangepipe_str = mystr, @resource_exchangepipe_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 5
	SELECT @resource_exchangeport_str = mystr, @resource_exchangeport_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 6
	SELECT @resource_metadata_str = mystr, @resource_metadata_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 7
	SELECT @resource_app_str = mystr, @resource_app_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 8

	SELECT @deadlockvictimprocess_str = mystr, @deadlockvictimprocess_len = mylen, @deadlockvictimprocess_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 1
	SELECT @processidprocess_str = mystr, @processidprocess_len = mylen, @processidprocess_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 2
	SELECT @frameprocname_str = mystr, @frameprocname_len = mylen, @frameprocname_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 3
	SELECT @resource_keylock_hobtid_str = mystr, @resource_keylock_hobtid_len = mylen, @resource_keylock_hobtid_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 4
	SELECT @resource_pagelock_fileid_str = mystr, @resource_pagelock_fileid_len = mylen, @resource_pagelock_fileid_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 5
	SELECT @owneridprocess_str = mystr, @owneridprocess_len = mylen, @owneridprocess_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 6
	SELECT @waiteridprocess_str = mystr, @waiteridprocess_len = mylen, @waiteridprocess_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 7
	SELECT @exchange_pipe_str = mystr, @exchange_pipe_len = mylen, @exchange_pipe_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 8
	SELECT @exchange_port_str = mystr, @exchange_port_len = mylen, @exchange_port_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 9
	SELECT @resource_objectlock_str = mystr, @objectlock_len = mylen, @objectlock_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 10
	SELECT @resource_rid_fileid_str = mystr, @resource_rid_fileid_len = mylen, @resource_rid_fileid_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 11
	SELECT @ProcDatabaseId_str = mystr, @ProcDatabaseId_len = mylen, @ProcDatabaseId_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 12
	SELECT @metadatalocksubresource_str = mystr, @metadatalocksubresource_len = mylen, @metadatalocksubresource_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 20
	SELECT @intraquerydl_str = mystr, @intraquerydl_len = mylen  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 21
	SELECT @iqdlNode_str = mystr, @iqdlNode_len = mylen  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 22
	SELECT @iqdlPort_str = mystr, @iqdlPort_len = mylen, @iqdlPort_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 23
	SELECT @iqdlResType_str = mystr, @iqdlResType_len = mylen, @iqdlResType_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 24
	SELECT @iqdlSPID_str = mystr, @iqdlSPID_len = mylen, @iqdlSPID_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 25
	SELECT @iqdlInputBuf_str = mystr, @iqdlInputBuf_len = mylen, @iqdlInputBuf_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 26
	SELECT @resource_applock_hash_str = mystr, @applock_hash_len = mylen, @applock_hash_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 27

	--ignore strings to process adhoc inputbuffers
	SELECT @inputbuf_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 13
	SELECT @deadlocklist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 14
	SELECT @processlist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 15
	SELECT @executionStack_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 16
	SELECT @resourcelist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 17
	SELECT @ownerlist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 18
	SELECT @waiterlist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 19

	IF @debug = 1
	BEGIN
		SELECT @deadlockvictimprocess_sub, @deadlockvictimprocess_str
		SELECT @processidprocess_sub, @processidprocess_str
		SELECT @frameprocname_sub, @frameprocname_str
		SELECT @resource_keylock_hobtid_sub, @resource_keylock_hobtid_str 
		SELECT @resource_pagelock_fileid_sub, @resource_pagelock_fileid_str
		SELECT @owneridprocess_sub, @owneridprocess_str
		SELECT @waiteridprocess_sub, @waiteridprocess_str
		SELECT @exchange_pipe_sub, @exchange_pipe_str
		SELECT @exchange_port_sub, @exchange_port_str
		SELECT @objectlock_sub, @resource_objectlock_str
		SELECT @resource_rid_fileid_sub, @resource_rid_fileid_str
	END

	WHILE @file_number >= 0
	BEGIN
		SET @importfileid = NULL
		SET @file_start_time = GETDATE()

		TRUNCATE TABLE #errorlog
		INSERT #errorlog
			EXEC master.sys.xp_readerrorlog @file_number, 1, N'Microsoft SQL Server'

		SELECT TOP 1 @start_time = logdate FROM #errorlog

		SELECT	@importfileid = deadlock_file_id, 
				@is_file_complete = is_complete,
				@first_date = errorlog_last_date
			FROM dbo.deadlock_file 
			WHERE [file_name] = CONVERT(VARCHAR(23), @start_time, 126) and is_xel = 0

		IF @importfileid IS NULL
		BEGIN
			INSERT dbo.deadlock_file (is_complete, is_xel, fileid, errorlog_last_date, start_time, active_deadlocks, [file_name])
					VALUES (0, 0, @file_number, @start_time, @file_start_time, 0, CONVERT(VARCHAR(23), @start_time, 126)) 
			SET @importfileid = @@IDENTITY
			SET @is_file_complete = 0
			SET @first_date = @start_time
		END
		ELSE
		BEGIN
			IF @is_file_complete = 1
			BEGIN
				PRINT 'Errorlog.' + LTRIM(STR(@file_number)) +  ' already processed.'
			END
		END

		IF @is_file_complete = 0
		BEGIN
			TRUNCATE TABLE #errorlog
			INSERT #errorlog
				EXEC master.sys.xp_readerrorlog @file_number, 1, NULL, NULL, @first_date		

			SET @max_lines = @@ROWCOUNT

			SELECT @max_logdate = MAX(logdate) FROM #errorlog

			SET @insert_dt = GETDATE()
			SET @insert_sec = DATEDIFF(SECOND, @file_start_time, @insert_dt)

			IF @max_lines > 0
			BEGIN
				UPDATE dbo.deadlock_file 
					SET perf_comment = LTRIM(ISNULL(perf_comment, '') + ' IRC=' + LTRIM(STR(@max_lines)) + ', Isec=' + LTRIM(STR(@insert_sec)))
					WHERE deadlock_file_id = @importfileid

				PRINT 'Errorlog.' + LTRIM(STR(@file_number)) +  ' Start Time = ' + CONVERT(VARCHAR(23), @start_time, 126)
				SET @lineno = 1

				DELETE e
					FROM #errorlog e
						INNER JOIN dbo.deadlock_message_blacklist b
						ON e.logtext LIKE b.message_text

				SET @delete_count = @@ROWCOUNT
				SET @delete_dt = GETDATE()
				SET @delete_sec = DATEDIFF(SECOND, @insert_dt, @delete_dt)

				UPDATE dbo.deadlock_file 
					SET perf_comment = perf_comment + ', DRC='  + LTRIM(STR(@delete_count)) + ', Dsec=' + LTRIM(STR(@delete_sec))
					WHERE deadlock_file_id = @importfileid

				DECLARE elog_cur CURSOR FOR
					SELECT logdate, processinfo, logtext FROM #errorlog ORDER BY id
		
				OPEN elog_cur
				FETCH NEXT FROM elog_cur INTO @linedate, @linetype, @line

				SET @fetch_dt = GETDATE()
				SET @fetch_sec = DATEDIFF(SECOND, @delete_dt, @fetch_dt)

				UPDATE dbo.deadlock_file 
					SET perf_comment = perf_comment + ', Fsec=' + LTRIM(STR(@fetch_sec)),
						[file_name] = CONVERT(VARCHAR(23), @linedate, 126) 
					WHERE deadlock_file_id = @importfileid

				WHILE @@FETCH_STATUS != -1
				BEGIN
					IF @debug = 1 AND @lineno < @debug_lines
					BEGIN
						PRINT @line
					END

					--get reporting spid
					SET @linespid = NULL
					SET @pos5 = CHARINDEX(@spid_str, @linetype)
					IF @pos5 > 0 
					BEGIN
						SET @pos6 = CHARINDEX(@spid_s_str, @linetype, @pos5 + 1)
						IF @pos6 > 0 AND ISNUMERIC(SUBSTRING(@linetype, @pos5 + @spid_len, @pos6 - @pos5 - @spid_len)) = 1
						BEGIN
							SET @linespid = SUBSTRING(@linetype, @pos5 + @spid_len, @pos6 - @pos5 - @spid_len)
						END
					END

					--check IF deadlock line
					SET @pos3 = 1
					SET @pos4 = 
						CHARINDEX(@deadlockvictimprocess_str, @line, @pos3) + 
						CHARINDEX(@processidprocess_str, @line, @pos3) + 
						CHARINDEX(@frameprocname_str, @line, @pos3) + 
						CHARINDEX(@resource_keylock_hobtid_str, @line, @pos3) + 
						CHARINDEX(@resource_pagelock_fileid_str, @line, @pos3) + 
						CHARINDEX(@owneridprocess_str, @line, @pos3) + 
						CHARINDEX(@waiteridprocess_str, @line, @pos3) +
						CHARINDEX(@exchange_pipe_str, @line, @pos3) +
						CHARINDEX(@exchange_port_str, @line, @pos3) + 
						CHARINDEX(@resource_objectlock_str, @line, @pos3) +
						CHARINDEX(@resource_rid_fileid_str, @line, @pos3) + 
						CHARINDEX(@ProcDatabaseId_str, @line, @pos3) +
						CHARINDEX(@inputbuf_str, @line, @pos3) + 
						CHARINDEX(@metadatalocksubresource_str, @line, @pos3) + 
						CHARINDEX(@intraquerydl_str, @line, @pos3) + 
						CHARINDEX(@iqdlNode_str, @line, @pos3) + 
						CHARINDEX(@iqdlPort_str, @line, @pos3) + 
						CHARINDEX(@iqdlResType_str, @line, @pos3) + 
						CHARINDEX(@iqdlSPID_str, @line, @pos3) + 
						CHARINDEX(@iqdlInputBuf_str, @line, @pos3) +
						CHARINDEX(@resource_applock_hash_str, @line, @pos3)
							

					IF @pos4 > 0
					BEGIN
						SET @processedline = 0
						IF CHARINDEX(@inputbuf_str, @line, @pos3) = @pos4
						BEGIN
							SET @processedline = 1
							--turn on inputbuffer processing
							UPDATE dbo.deadlock
								SET is_processing_inputbuf = 1
								WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid
								
							--IF @lineno < @debug_lines
							--BEGIN
							--	PRINT 'IBP+' + @line
							--END
						END
						ELSE
						BEGIN
							--turn off inputbuffer processing
							UPDATE dbo.deadlock
								SET is_processing_inputbuf = 0
								WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

							--IF @lineno < @debug_lines
							--BEGIN
							--	PRINT 'IBP-' + STR(@pos4) + ': ' + @line
							--END							
						END

						IF (CHARINDEX(@ProcDatabaseId_str, @line, @pos3) = @pos4)-- AND (CHARINDEX(@iqdlInputBuf_str, @line, @pos3) = 0)
						BEGIN
							--PRINT 'ipbproc'
							SET @processedline = 1
							exec dbo.deadlock_parse_input_buf_proc @importfileid, @lineno, @line, @linespid, @pos4, @ProcDatabaseId_len, @ProcDatabaseId_sub, @debug_lines
						END

						IF CHARINDEX(@deadlockvictimprocess_str, @line, @pos3) = @pos4
						BEGIN
							SET @processedline = 1
							exec dbo.deadlock_parse_victim @importfileid, @lineno, @line, @linespid, @pos4, @deadlockvictimprocess_len, @linedate, @debug_lines
						END

						IF CHARINDEX(@frameprocname_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'frameproc'
							SET @processedline = 1
							exec dbo.deadlock_parse_tsql_frame @importfileid, @lineno, @line, @linespid, @pos4, @frameprocname_len, @frameprocname_sub, @debug_lines
						END

						IF CHARINDEX(@owneridprocess_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'owner'
							SET @processedline = 1
							exec dbo.deadlock_parse_waiterowner @importfileid, @lineno, @line, @linespid, @pos4, @owneridprocess_len, @owneridprocess_sub, 0, @linedate, @debug_lines
						END

						IF CHARINDEX(@waiteridprocess_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'waiter'
							SET @processedline = 1
							exec dbo.deadlock_parse_waiterowner @importfileid, @lineno, @line, @linespid, @pos4, @waiteridprocess_len, @waiteridprocess_sub, 1, @linedate, @debug_lines
						END

						IF CHARINDEX(@processidprocess_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'processid'
							SET @processedline = 1
							exec dbo.deadlock_parse_process @importfileid, @lineno, @line, @linespid, @pos4, @processidprocess_len, @processidprocess_sub, @debug_lines
						END

						IF CHARINDEX(@exchange_port_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'exchport'
							SET @processedline = 1
							exec dbo.deadlock_parse_exchangetype @importfileid, @lineno, @line, @linespid, @pos4, @exchange_port_len, @exchange_port_sub, @resource_exchangeport_str, @debug_lines
						END

						IF CHARINDEX(@exchange_pipe_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'exchpipe'
							SET @processedline = 1
							exec dbo.deadlock_parse_exchangetype @importfileid, @lineno, @line, @linespid, @pos4, @exchange_pipe_len, @exchange_pipe_sub, @resource_exchangepipe_str, @debug_lines
						END

						IF CHARINDEX(@resource_rid_fileid_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'rid'
							SET @processedline = 1
							exec dbo.deadlock_parse_lock_rid @importfileid, @lineno, @line, @linespid, @pos4, @resource_rid_fileid_len, @resource_rid_fileid_sub, @resource_rid_str, @debug_lines
						END

						IF CHARINDEX(@resource_keylock_hobtid_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'key'
							SET @processedline = 1
							exec dbo.deadlock_parse_lock_key @importfileid, @lineno, @line, @linespid, @pos4, @resource_keylock_hobtid_len, @resource_keylock_hobtid_sub, @resource_key_str, @debug_lines
						END

						IF CHARINDEX(@resource_pagelock_fileid_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'page'
							SET @processedline = 1
							exec dbo.deadlock_parse_lock_page @importfileid, @lineno, @line, @linespid, @pos4, @resource_pagelock_fileid_len, @resource_pagelock_fileid_sub, @resource_pag_str, @debug_lines
						END

						IF CHARINDEX(@resource_objectlock_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'obj'
							SET @processedline = 1
							exec dbo.deadlock_parse_lock_object @importfileid, @lineno, @line, @linespid, @pos4, @objectlock_len, @objectlock_sub, @resource_object_str, @debug_lines
						END

						IF CHARINDEX(@resource_applock_hash_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'app'
							SET @processedline = 1
							exec dbo.deadlock_parse_lock_app @importfileid, @lineno, @line, @linespid, @pos4, @applock_hash_len, @applock_hash_sub, @resource_app_str, @debug_lines
						END

						IF CHARINDEX(@metadatalocksubresource_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'metadata'
							SET @processedline = 1
							exec dbo.deadlock_parse_lock_metadata @importfileid, @lineno, @line, @linespid, @pos4, @metadatalocksubresource_len, @metadatalocksubresource_sub, @resource_metadata_str, @debug_lines
						END

						IF CHARINDEX(@intraquerydl_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'iqdl'
							SET @processedline = 1
							exec dbo.deadlock_parse_iq @importfileid, @lineno, @line, @linespid, @pos4, @iqdlNode_len, @iqdlNode_str, @linedate, @debug_lines
						END

						IF CHARINDEX(@iqdlNode_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'iqNode'
							SET @processedline = 1
							exec dbo.deadlock_parse_iq_dl_node @importfileid, @lineno, @line, @linespid, @pos4, @iqdlNode_len, @iqdlNode_str, @iqdlNode_str, @debug_lines
						END

						IF CHARINDEX(@iqdlPort_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'iqport'
							SET @processedline = 1
							exec dbo.deadlock_parse_iq_dl_port @importfileid, @lineno, @line, @linespid, @pos4, @iqdlPort_len, @iqdlPort_sub, @iqdlPort_str, @debug_lines
						END
							
						IF CHARINDEX(@iqdlResType_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'iqres'
							SET @processedline = 1
							exec dbo.deadlock_parse_iq_dl_res_type @importfileid, @lineno, @line, @linespid, @pos4, @iqdlResType_len, @iqdlResType_sub, @iqdlResType_str, @debug_lines
						END

						IF CHARINDEX(@iqdlSPID_str, @line, @pos3) = @pos4
						BEGIN
							--PRINT 'iqspid'
							SET @processedline = 1
							exec dbo.deadlock_parse_iq_dl_spid @importfileid, @lineno, @line, @linespid, @pos4, @iqdlSPID_len, @iqdlSPID_sub, @iqdlSPID_str, @debug_lines
						END
							
						IF CHARINDEX(@iqdlInputBuf_str, @line, @pos3) > 0
						BEGIN
							--PRINT 'iqinputbuf'
							SET @processedline = 1
							SET @pos4 = CHARINDEX(@iqdlInputBuf_str, @line, @pos3)
							exec dbo.deadlock_parse_iq_dl_input_buf @importfileid, @lineno, @line, @linespid, @pos4, @iqdlInputBuf_len, @iqdlInputBuf_sub, @iqdlInputBuf_str, @debug_lines
						END


						--this needs to be last check
						IF @processedline = 0
						BEGIN
							PRINT 'Not Processed:' + STR(@lineno)+ STR(@pos4) + ': ' + @line
						END
					END
					ELSE
					BEGIN
						--test for input buffer
						IF @linespid IS NOT NULL
						BEGIN
							--check IF ingnored deadlock line
							SET @pos4 = 
								CHARINDEX(@deadlockvictimprocess_str, @line, @pos3) + 
								CHARINDEX(@deadlocklist_str, @line, @pos3) +
								CHARINDEX(@processlist_str, @line, @pos3) +
								CHARINDEX(@executionStack_str, @line, @pos3) +
								CHARINDEX(@resourcelist_str, @line, @pos3) +
								CHARINDEX(@ownerlist_str, @line, @pos3) +
								CHARINDEX(@waiterlist_str, @line, @pos3)
	
							IF @pos4 = 0
							BEGIN
								exec dbo.deadlock_parse_input_buf_adhoc @importfileid, @lineno, @line, @linespid, @pos3, 0, 0, @debug_lines
							END
							ELSE
							BEGIN
								--turn off inputbuffer processing
								UPDATE dbo.deadlock
									SET is_processing_inputbuf = 0
									WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid
									
								--IF @lineno < @debug_lines
								--BEGIN
								--	PRINT 'IBP-' + @line
								--END	
							END
						END
					END

					SET @lineno = @lineno + 1
					FETCH NEXT FROM elog_cur INTO @linedate, @linetype, @line
				END	
				DEALLOCATE elog_cur

				PRINT 'Line count=' + STR(@lineno)

				SELECT @min_dl = MIN(deadlock_id), @max_dl = MAX(deadlock_id), @deadlock_count = COUNT(*) FROM dbo.deadlock WHERE deadlock_file_id = @importfileid

				--INSERT dbo.deadlock_script_perf VALUES (@min_dl, @max_dl, @len, @lineno, @start_time, datediff(second,@start_time, getdate()), @filename)
				UPDATE dbo.deadlock_file
					set	is_complete = CASE WHEN @file_number > 0 THEN 1 ELSE 0 END,
						first_deadlock_id = @min_dl,
						last_deadlock_id = @max_dl,
						deadlock_count = @deadlock_count,
						line_count = ISNULL(line_count, 0) + @lineno,
						errorlog_last_date = @max_logdate,
						duration_in_sec = ISNULL(duration_in_sec, 0) + DATEDIFF(SECOND, @file_start_time, GETDATE())
					WHERE deadlock_file_id = @importfileid
	
				IF exists (SELECT 1 FROM dbo.deadlock_file WHERE deadlock_file_id = @importfileid AND active_deadlocks > 0)
				BEGIN
					RAISERROR('File did not contain all completed deadlocks',11,1)
				END
			END --IF @max_lines > 0
		END --IF @is_file_complete = 0

		SET @file_number = @file_number - 1
	END --WHILE @file_number > 0
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_exchangetype]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_exchangetype') is null exec('create procedure [dbo].[deadlock_parse_exchangetype] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_exchangetype]
*
*	Purpose: Parse line for deadlock exchange type resource
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_exchangetype
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @sbid int
	DECLARE @wr_dbid int
	DECLARE @wr_hobt bigint
	DECLARE @wr_fileid int
	DECLARE @wr_pageid int
	DECLARE @wr_rid smallint

	DECLARE @resource_subresource varchar(25)
	DECLARE @resource_objectname varchar(255)
	DECLARE @resource_indexname varchar(255)
	DECLARE @resource_idlock varchar(25)
	DECLARE @lock_mode varchar(8) 
	DECLARE @address varchar(16)
	DECLARE @waittype varchar(25)
	DECLARE @nodeid tinyint
	DECLARE @wr_objid int
	DECLARE @wr_schid int

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

	--parse line
--exchangeEvent id=Port6076fa0c00 WaitType=e_waitPortOpen nodeId=12
--exchangeEvent id=Pipe579ced4c80 WaitType=e_waitPipeGetRow nodeId=19

	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

				IF @colid = 1
					SET @address = @tdata
				IF @colid = 2
					SET @waittype = @tdata
				IF @colid = 3
					SET @nodeid = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END
	
	IF @colid = 1
		SET @address = @tdata
	IF @colid = 2
		SET @waittype = @tdata
	IF @colid = 3
		SET @nodeid = @tdata

	--look up DL id based on @linespid
	SELECT @deadlock_id = deadlock_id 
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

	IF @deadlock_id IS NULL
	BEGIN
		SET @msg = 'WARNING: ' + @type + ' Missing Deadlock:' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
	ELSE
	BEGIN
		BEGIN TRAN
		INSERT dbo.deadlock_resource VALUES (@deadlock_id, @type, @wr_dbid, @wr_fileid, @wr_pageid, @wr_rid, @wr_objid, @wr_hobt, @wr_schid, @lock_mode, @resource_idlock, 
			@resource_subresource, @resource_objectname, @resource_indexname, @address, @waittype, @nodeid)
		
		UPDATE dbo.deadlock
			SET resource_count = resource_count + 1
			WHERE deadlock_id = @deadlock_id
		COMMIT TRAN
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_input_buf_adhoc]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_input_buf_adhoc') is null exec('create procedure [dbo].[deadlock_parse_input_buf_adhoc] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_input_buf_adhoc]
*
*	Purpose: Parse line for adhoc input buffer in deadlock
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/

alter procedure dbo.deadlock_parse_input_buf_adhoc
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @deadlock_id int
	DECLARE @process_id varchar(16)

	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

	--look up DL id based on @linespid, is_complete AND fileid, IF not found then this wAS not an inputbuffer string
	SELECT @deadlock_id = deadlock_id, @process_id = last_process_seen
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid AND is_processing_inputbuf = 1

	SET @tdata = RTRIM(LTRIM(SUBSTRING(@line, @pos, LEN(@line))))

	IF @deadlock_id IS NOT NULL
	BEGIN

		--IF @lineno < @debug_lines
		--BEGIN
		--	PRINT STR(@pos) + ' ' + @line
		--END

--2016-11-28 14:19:24.07 spid15s     (@SiteID nvarchar(4000),@SyncDate datetime)SELECT d.*, [AuditType], [AuditDate], CASE WHEN d.[rowguid] IS NULL THEN 0 ELSE 1 END AS [HASDataRecord], [s].[rowguid] AS [SyncGuid] FROM [sync].[Customers] s LEFT JOIN [dbo].[Customers] d ON s.[rowguid] = d.[rowguid] INNER JOIN [Site] [si] ON [d].[SiteID] = [si].[SiteID] WHERE ([d].[SiteID] = @SiteID OR [si].[ComboSiteID] = @SiteID OR [d].[AltSiteID] = @SiteID) AND [AuditDate] > @SyncDate    
							
		UPDATE dbo.deadlock_process
			SET inputbuf = ISNULL(inputbuf,'') + @tdata
			WHERE deadlock_id = @deadlock_id AND process_id = @process_id
	END
	ELSE
	BEGIN
		--record noise messages here
		DECLARE @msgid int
		SELECT @msgid = deadlock_message_noise_id FROM dbo.deadlock_message_noise WHERE message_text = LEFT(@tdata, 200)
		IF @msgid IS NOT NULL
		BEGIN
			UPDATE dbo.deadlock_message_noise SET occurrences = occurrences + 1 WHERE deadlock_message_noise_id = @msgid
		END
		ELSE
		BEGIN
			INSERT dbo.deadlock_message_noise VALUES (1, LEFT(@tdata, 200))
		END
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_input_buf_proc]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_input_buf_proc') is null exec('create procedure [dbo].[deadlock_parse_input_buf_proc] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_input_buf_proc]
*
*	Purpose: Parse line for non-adhoc input buffer in deadlock
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_input_buf_proc
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@debug_lines int,
	@xml_deadlock int = NULL,
	@process_id varchar(16) = NULL
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @line
	--END

	DECLARE @deadlock_id int

	DECLARE @dbid int
	DECLARE @procid int

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--2016-11-28 14:18:21.36 spid15s     Proc [DatabASe Id = 5 Object Id = 839990547]    
						
	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
--		PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
--			PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT 'C ' + STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

				IF @colid = 1
					SET @dbid = @tdata
				IF @colid = 2
					SET @procid = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
--	PRINT 'D ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT 'E '+ STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1
		SET @dbid = @tdata
	IF @colid = 2
		SET @procid = @tdata

	IF @xml_deadlock IS NULL
	BEGIN
		--look up DL id based on @linespid, @wr_hobt, @wr_dbid
		SELECT @deadlock_id = deadlock_id, @process_id = last_process_seen
			FROM dbo.deadlock 
			WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

		IF @deadlock_id IS NULL
		BEGIN
			SET @msg = 'WARNING: Inputbuffer Missing Deadlock:' + @line
			RAISERROR(@msg,11,1)
			INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
		END
		ELSE
		BEGIN
			BEGIN TRAN
			UPDATE dbo.deadlock_process
				SET proc_dbid = @dbid,
					proc_id = @procid
				WHERE deadlock_id = @deadlock_id AND process_id = @process_id

			UPDATE dbo.deadlock
				SET last_process_seen = ''
				WHERE deadlock_id = @deadlock_id
			COMMIT TRAN
		END
	END
	ELSE
	BEGIN
		UPDATE dbo.deadlock_process
			SET proc_dbid = @dbid,
				proc_id = @procid,
				inputbuf = NULL
			WHERE deadlock_id = @xml_deadlock AND process_id = @process_id
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_iq]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_iq') is null exec('create procedure [dbo].[deadlock_parse_iq] as select getdate() DT')
GO
  /*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_iq]
*
*	Purpose: Parse line for intra-query deadlock
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_iq
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@type varchar(15),
	@linedate datetime,
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	PRINT STR(@lineno) + ' ' + @line

	DECLARE @deadlock_id int
	DECLARE @nodebi bigint
	DECLARE @node tinyint
	DECLARE @tdata varchar(8000)

	SELECT @deadlock_id = deadlock_id 
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid
			
	IF @deadlock_id IS NOT NULL
	BEGIN
		--close prior dealock
		UPDATE dbo.deadlock
			SET is_complete = 1
			WHERE deadlock_id = @deadlock_id
	END
	
	--create new deadlock
	INSERT dbo.deadlock (deadlock_file_id, is_complete, is_database_xml, is_intraquery, spid, start_time, end_time, process_count, waiter_count, resource_count, is_processing_inputbuf, last_node_seen) 
		VALUES (@importfileid, 0, 0, 1, @linespid, @linedate, '1900-01-01', 0, 0, 0, 0, 0)
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_iq_dl_input_buf]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_iq_dl_input_buf') is null exec('create procedure [dbo].[deadlock_parse_iq_dl_input_buf] as select getdate() DT')
GO
  /*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_iq_dl_input_buf]
*
*	Purpose: Parse line for intra-query deadlock input buffers
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_iq_dl_input_buf
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + STR(@pos) + STR(@str_len) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @node tinyint

	DECLARE @restype varchar(10)
	DECLARE @stype varchar(10)
	DECLARE @spid int
	DECLARE @sbid int
	DECLARE @ecid int
	DECLARE @tASkproxy varchar(16)
	DECLARE @value varchar(8)
	DECLARE @cost varchar(20)
	DECLARE @stmt_type varchar(32)
	DECLARE @stmt_line int
	DECLARE @end_time datetime = '1900-01-01'
	DECLARE @event_type varchar(20)
	DECLARE @proc_dbid int
	DECLARE @proc_id int
	DECLARE @query varchar(500)

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--Input Buf: No Event: 
--Input Buf: Language Event: EXEC rsk.spUpdatePositionRiskModelData @startDate="2016-12-15"
--Input Buf: RPC Event: Proc [DatabASe Id = 22 Object Id = 197627797]

	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' + @tdata + 'XXX'
				--END

--Input Buf: No Event: 
--Input Buf: Language Event: EXEC rsk.spUpdatePositionRiskModelData @startDate="2016-12-15"
--Input Buf: RPC Event: Proc [DatabASe Id = 22 Object Id = 197627797]

				IF @colid = 1
				BEGIN
					SET @event_type = RTRIM(LTRIM(@tdata))
					IF @event_type = 'NO'
					BEGIN
						SET @infinite_loop_protection = 254
					END
					IF @event_type = 'Language'
					BEGIN
						SET @query = SUBSTRING(@line, @pos2 + @str_len, LEN(@line))
						SET @infinite_loop_protection = 254
					END
				END
				
				--skip 2 since have a pre string before dbid value

				IF @colid = 3
					SET @proc_dbid = @tdata

				IF @colid = 4
					SET @proc_id = @tdata

				IF @event_type = 'RPC'
				BEGIN
					SET @colid = @colidcurrent + 1
				END
				ELSE
				BEGIN
					SET @colid = 5
				END
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	--IF @colid = 3
	--	SET @proc_id = @tdata


	IF @colid = 5
	BEGIN
		--PRINT 'dbid=' + STR(@proc_dbid)

		--look up DL id based on @linespid, @wr_hobt, @wr_dbid
		SELECT @deadlock_id = deadlock_id, @node = last_node_seen
			FROM dbo.deadlock 
			WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

		IF @deadlock_id IS NULL
		BEGIN
			SET @msg = 'WARNING: IQDLInputBuf Missing Deadlock: ' + @line
			RAISERROR(@msg,11,1)
			INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
		END
		ELSE
		BEGIN
			SET @tdata = SUBSTRING(@line,1,22)
			IF ISDATE(@tdata) = 1
			BEGIN
				SET @end_time = @tdata
			END

			BEGIN TRAN

--Input Buf: No Event: 
--Input Buf: Language Event: EXEC rsk.spUpdatePositionRiskModelData @startDate="2016-12-15"
--Input Buf: RPC Event: Proc [DatabASe Id = 22 Object Id = 197627797]
			UPDATE dbo.deadlock_iq_process
				SET event_type = @event_type,
					proc_dbid = @proc_dbid,
					proc_id = @proc_id,
					inputbuf_line = @query
				WHERE deadlock_id = @deadlock_id AND node = @node
		
			UPDATE dbo.deadlock
				SET end_time = @end_time
				WHERE deadlock_id = @deadlock_id

			COMMIT TRAN
		END
	END
	ELSE
	BEGIN
		SET @msg = 'WARNING: IQDLInputBuf Possible parsing bug: ' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_iq_dl_node]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_iq_dl_node') is null exec('create procedure [dbo].[deadlock_parse_iq_dl_node] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_iq_dl_node]
*
*	Purpose: Parse line for intra-query deadlock node
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_iq_dl_node
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @nodebi bigint
	DECLARE @node tinyint
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(200)

	--parse line
	SET @tdata = SUBSTRING(@line, @pos + @str_len, LEN(@line))
	IF ISNUMERIC(@tdata) = 1
	BEGIN
		SET @nodebi = @tdata
		IF @nodebi between 0 AND 255
		BEGIN
			SET @node = @nodebi

			--look up DL id based on @linespid, @wr_hobt, @wr_dbid
			SELECT @deadlock_id = deadlock_id 
				FROM dbo.deadlock 
				WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid
			
			IF @deadlock_id IS NOT NULL
			BEGIN
				IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_iq_process WHERE deadlock_id = @deadlock_id AND node = @node)
				BEGIN 
					BEGIN TRAN
					INSERT dbo.deadlock_iq_process (deadlock_id, node) VALUES (@deadlock_id, @node)

					UPDATE dbo.deadlock 
						SET last_node_seen = @node,
							process_count = process_count + 1
						WHERE deadlock_id = @deadlock_id
					COMMIT TRAN
				END
				ELSE
				BEGIN
					SET @msg = 'WARNING: IQDLNode Node exists already: ' + @line
					RAISERROR(@msg,11,1)
					INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
				END
			END
		END
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_iq_dl_port]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_iq_dl_port') is null exec('create procedure [dbo].[deadlock_parse_iq_dl_port] as select getdate() DT')
GO
  /*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_iq_dl_port]
*
*	Purpose: Parse line for intra-query deadlock ports
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_iq_dl_port
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + STR(@pos) + STR(@str_len) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @node tinyint

	DECLARE @restype varchar(10)
	DECLARE @stype varchar(10)
	DECLARE @spid int
	DECLARE @sbid int
	DECLARE @ecid int
	DECLARE @tASkproxy varchar(16)
	DECLARE @value varchar(8)
	DECLARE @cost varchar(20)
	DECLARE @stmt_type varchar(32)
	DECLARE @stmt_line int
	DECLARE @end_time datetime = '1900-01-01'
	DECLARE @event_type varchar(20)
	DECLARE @proc_dbid int
	DECLARE @proc_id int
	DECLARE @port varchar(16)
	DECLARE @xslot int
	DECLARE @wslot int
	DECLARE @tASk varchar(16)
	DECLARE @tASk_type varchar(10)
	DECLARE @ewait_type varchar(20)
	DECLARE @merging int

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--Port: 0x00000093EDEBC8D0  Xid Slot: 7, Wait Slot: 3, TASk: 0x000000A9EC447468, (Producer), Exchange Wait Type: e_waitPipeNewRow, Merging: 1
	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

--Port: 0x00000093EDEBC8D0  Xid Slot: 7, Wait Slot: 3, TASk: 0x000000A9EC447468, (Producer), Exchange Wait Type: e_waitPipeNewRow, Merging: 1

				IF @colid = 1
					SET @port = @tdata
				IF @colid = 2
					SET @xslot = @tdata
				IF @colid = 3
					SET @wslot = @tdata
				IF @colid = 4
					SET @tASk = @tdata
				IF @colid = 5
					SET @tASk_type = @tdata
				IF @colid = 6
					SET @ewait_type = @tdata
				IF @colid = 7
					SET @merging = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 7
		SET @merging = @tdata

	IF @colid = 7
	BEGIN
		--PRINT 'dbid=' + STR(@proc_dbid)

		--look up DL id based on @linespid, @wr_hobt, @wr_dbid
		SELECT @deadlock_id = deadlock_id, @node = last_node_seen
			FROM dbo.deadlock 
			WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

		IF @deadlock_id IS NULL
		BEGIN
			SET @msg = 'WARNING: IQDLPort Missing Deadlock: ' + @line
			RAISERROR(@msg,11,1)
			INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
		END
		ELSE
		BEGIN
			BEGIN TRAN

--Port: 0x00000093EDEBC8D0  Xid Slot: 7, Wait Slot: 3, TASk: 0x000000A9EC447468, (Producer), Exchange Wait Type: e_waitPipeNewRow, Merging: 1

			UPDATE dbo.deadlock_iq_process
				SET wait_resource = @ewait_type,
					port_line = @tASk + ':' + @tASk_type + ':' + LTRIM(STR(@merging))
				WHERE deadlock_id = @deadlock_id AND node = @node
/*		
			UPDATE dbo.deadlock
				SET end_time = @end_time
				WHERE deadlock_id = @deadlock_id
*/
			COMMIT TRAN
		END
	END
	ELSE
	BEGIN
		SET @msg = 'WARNING: IQDLPort Possible parsing bug: ' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_iq_dl_res_type]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_iq_dl_res_type') is null exec('create procedure [dbo].[deadlock_parse_iq_dl_res_type] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_iq_dl_res_type]
*
*	Purpose: Parse line for intra-query deadlock resource
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_iq_dl_res_type
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @node tinyint

	DECLARE @restype varchar(10)
	DECLARE @stype varchar(10)
	DECLARE @spid int
	DECLARE @sbid int
	DECLARE @ecid int
	DECLARE @tASkproxy varchar(16)
	DECLARE @value varchar(8)
	DECLARE @cost varchar(20)
	DECLARE @end_time datetime = '1900-01-01'

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--ResType:ExchangeId Stype:"AND" SPID:146 BatchID:0 ECID:9 TASkProxy:(0x000000982AE29950) Value:0xbe2f3468 Cost:(20/0)
								
	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

--ResType:ExchangeId Stype:"AND" SPID:146 BatchID:0 ECID:9 TASkProxy:(0x000000982AE29950) Value:0xbe2f3468 Cost:(20/0)

				IF @colid = 1
					SET @restype = @tdata
				IF @colid = 2
					SET @stype = @tdata
				IF @colid = 3
					SET @spid = @tdata
				IF @colid = 4
					SET @sbid = @tdata
				IF @colid = 5
					SET @ecid = @tdata
				IF @colid = 6
					SET @tASkproxy = @tdata
				IF @colid = 7
					SET @value = @tdata
				IF @colid = 8
					SET @cost = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 9
	BEGIN
		--PRINT 'spid=' + STR(isnull(@spid,0))

		--look up DL id based on @linespid, @wr_hobt, @wr_dbid
		SELECT @deadlock_id = deadlock_id, @node = last_node_seen
			FROM dbo.deadlock 
			WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

		IF @deadlock_id IS NULL
		BEGIN
			SET @msg = 'WARNING: IQDLResType Missing Deadlock: ' + @line
			RAISERROR(@msg,11,1)
			INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
		END
		ELSE
		BEGIN
			SET @tdata = SUBSTRING(@line,1,22)
			IF ISDATE(@tdata) = 1
			BEGIN
				SET @end_time = @tdata
			END

			BEGIN TRAN
--ResType:ExchangeId Stype:"AND" SPID:146 BatchID:0 ECID:9 TASkProxy:(0x000000982AE29950) Value:0xbe2f3468 Cost:(20/0)
			UPDATE dbo.deadlock_iq_process
				SET spid = @spid,
					sbid = @sbid,
					ecid = @ecid,
					wr_type = @restype
					--, res_line = @line
				WHERE deadlock_id = @deadlock_id AND node = @node
		
			UPDATE dbo.deadlock
				SET resource_count = resource_count + 1,
					end_time = @end_time
				WHERE deadlock_id = @deadlock_id
			COMMIT TRAN
		END
	END
	ELSE
	BEGIN
		SET @msg = 'WARNING: IQDLResType Possible parsing bug: ' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_iq_dl_spid]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_iq_dl_spid') is null exec('create procedure [dbo].[deadlock_parse_iq_dl_spid] as select getdate() DT')
GO
  /*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_iq_dl_spid]
*
*	Purpose: Parse line for intra-query deadlock spid
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_iq_dl_spid
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @node tinyint

	DECLARE @restype varchar(10)
	DECLARE @stype varchar(10)
	DECLARE @spid int
	DECLARE @sbid int
	DECLARE @ecid int
	DECLARE @tASkproxy varchar(16)
	DECLARE @value varchar(8)
	DECLARE @cost varchar(20)
	DECLARE @stmt_type varchar(32)
	DECLARE @stmt_line int
	DECLARE @end_time datetime = '1900-01-01'

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--SPID: 146 ECID: 16 Statement Type: SELECT INTO Line #: 77
	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

--SPID: 146 ECID: 16 Statement Type: SELECT INTO Line #: 77

				IF @colid = 1
					SET @spid = @tdata
				IF @colid = 2
					SET @ecid = @tdata
				IF @colid = 3
					SET @stmt_type = LTRIM(@tdata)
				IF @colid = 4
					SET @stmt_line = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 4
		SET @stmt_line = @tdata

	IF @colid = 4
	BEGIN
		--PRINT 'spid=' + STR(@spid)

		--look up DL id based on @linespid, @wr_hobt, @wr_dbid
		SELECT @deadlock_id = deadlock_id, @node = last_node_seen
			FROM dbo.deadlock 
			WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

		IF @deadlock_id IS NULL
		BEGIN
			SET @msg = 'WARNING: IQDLSPID Missing Deadlock: ' + @line
			RAISERROR(@msg,11,1)
			INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
		END
		ELSE
		BEGIN
			SET @tdata = SUBSTRING(@line,1,22)
			IF ISDATE(@tdata) = 1
			BEGIN
				SET @end_time = @tdata
			END

			BEGIN TRAN

--SPID: 146 ECID: 16 Statement Type: SELECT INTO Line #: 77
			UPDATE dbo.deadlock_iq_process
				SET spid = @spid,
					ecid = @ecid,
					statement_type = @stmt_type,
					proc_line = @stmt_line
					--, spid_line = @line
				WHERE deadlock_id = @deadlock_id AND node = @node
		
			UPDATE dbo.deadlock
				SET end_time = @end_time
				WHERE deadlock_id = @deadlock_id
			COMMIT TRAN
		END
	END
	ELSE
	BEGIN
		SET @msg = 'WARNING: IQDLSPID Possible parsing bug: ' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_lock_app]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_lock_app') is null exec('create procedure [dbo].[deadlock_parse_lock_app] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_lock_app]
*
*	Purpose: Parse line for deadlock application lock resource
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_lock_app
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @sbid int
	DECLARE @wr_dbid int
	DECLARE @wr_hobt bigint
	DECLARE @wr_fileid int
	DECLARE @wr_pageid int
	DECLARE @wr_rid smallint

	DECLARE @resource_subresource varchar(25)
	DECLARE @resource_objectname varchar(255)
	DECLARE @resource_indexname varchar(255)
	DECLARE @resource_idlock varchar(25)
	DECLARE @lock_mode varchar(8)
	DECLARE @address varchar(16)
	DECLARE @waittype varchar(25)
	DECLARE @nodeid tinyint
	DECLARE @wr_objid int
	DECLARE @wr_schid int
	DECLARE @lockpartition varchar(16)

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--2017-12-27 10:09:33.360 spid22s         applicationlock hash=MyAppLock6731eaf3 databasePrincipalId=0 dbid=2 id=lock1871c8c4180 mode=X
								
	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

--2017-12-27 10:09:33.360 spid22s         applicationlock hash=MyAppLock6731eaf3 databasePrincipalId=0 dbid=2 id=lock1871c8c4180 mode=X

				IF @colid = 1 
					SET @resource_subresource = @tdata
				IF @colid = 2
					SET @wr_schid = @tdata
				IF @colid = 3
					SET @wr_dbid = @tdata
				IF @colid = 4
					SET @resource_idlock = @tdata
				IF @colid = 5
					SET @lock_mode = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1 
		SET @resource_subresource = @tdata
	IF @colid = 2
		SET @wr_schid = @tdata
	IF @colid = 3
		SET @wr_dbid = @tdata
	IF @colid = 4
		SET @resource_idlock = @tdata
	IF @colid = 5
		SET @lock_mode = @tdata

	--look up DL id based on @linespid, @wr_hobt, @wr_dbid
	SELECT @deadlock_id = deadlock_id 
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

	IF @deadlock_id IS NULL
	BEGIN
		SET @msg = 'WARNING: APPLock Missing Deadlock: ' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
	ELSE
	BEGIN
		SELECT TOP 1 @address = p.wr_hash 
			FROM dbo.deadlock_process p
			WHERE deadlock_id = @deadlock_id
				AND wr_type = 'APPLICATION'
				AND @resource_subresource = p.wait_resource + p.wr_hash

		IF @address IS NOT NULL
		BEGIN
			SET @resource_subresource =SUBSTRING(@resource_subresource, 1, CHARINDEX(@address, @resource_subresource) - 1)
		END

		BEGIN TRAN
		INSERT dbo.deadlock_resource VALUES (@deadlock_id, @type, @wr_dbid, @wr_fileid, @wr_pageid, @wr_rid, @wr_objid, @wr_hobt, @wr_schid, @lock_mode, @resource_idlock, 
			@resource_subresource, @resource_objectname, @resource_indexname, @address, @waittype, @nodeid)
		
		UPDATE dbo.deadlock
			SET resource_count = resource_count + 1
			WHERE deadlock_id = @deadlock_id
		COMMIT TRAN
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_lock_key]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_lock_key') is null exec('create procedure [dbo].[deadlock_parse_lock_key] as select getdate() DT')
GO
  /*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_lock_key]
*
*	Purpose: Parse line for deadlock key lock resource
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_lock_key
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @sbid int
	DECLARE @wr_dbid int
	DECLARE @wr_hobt bigint
	DECLARE @wr_fileid int
	DECLARE @wr_pageid int
	DECLARE @wr_rid smallint

	DECLARE @resource_subresource varchar(25)
	DECLARE @resource_objectname varchar(255)
	DECLARE @resource_indexname varchar(255)
	DECLARE @resource_idlock varchar(25)
	DECLARE @lock_mode varchar(8)
	DECLARE @address varchar(16)
	DECLARE @waittype varchar(25)
	DECLARE @nodeid tinyint
	DECLARE @wr_objid int
	DECLARE @wr_schid int
	DECLARE @lockpartition varchar(16)

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--2016-11-21 14:29:37.95 spid16s        keylock hobtid=72057605412618240 dbid=5 objectname=WinSNAP.sync.OpSumm indexname=Idx_OpSumm_AuditDate id=lock44623b6100 mode=S ASsociatedObjectId=72057605412618240
								
	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

				IF @colid = 1
					SET @wr_hobt = @tdata
				IF @colid = 2
					SET @wr_dbid = @tdata
				IF @colid = 3
					SET @resource_objectname = @tdata
				IF @colid = 4
					SET @resource_indexname = @tdata
				IF @colid = 5
					SET @resource_idlock = @tdata
				IF @colid = 6
					SET @lock_mode = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1
		SET @wr_hobt = @tdata
	IF @colid = 2
		SET @wr_dbid = @tdata
	IF @colid = 3
		SET @resource_objectname = @tdata
	IF @colid = 4
		SET @resource_indexname = @tdata
	IF @colid = 5
		SET @resource_idlock = @tdata
	IF @colid = 6
		SET @lock_mode = @tdata

	--look up DL id based on @linespid, @wr_hobt, @wr_dbid
	SELECT @deadlock_id = deadlock_id 
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

	IF @deadlock_id IS NULL
	BEGIN
		SET @msg = 'WARNING: KeyLock Missing Deadlock:' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
	ELSE
	BEGIN
		BEGIN TRAN
		INSERT dbo.deadlock_resource VALUES (@deadlock_id, @type, @wr_dbid, @wr_fileid, @wr_pageid, @wr_rid, @wr_objid, @wr_hobt, @wr_schid, @lock_mode, @resource_idlock, 
			@resource_subresource, @resource_objectname, @resource_indexname, @address, @waittype, @nodeid)
		
		UPDATE dbo.deadlock
			SET resource_count = resource_count + 1
			WHERE deadlock_id = @deadlock_id
		COMMIT TRAN
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_lock_metadata]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_lock_metadata') is null exec('create procedure [dbo].[deadlock_parse_lock_metadata] as select getdate() DT')
GO
  /*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_lock_metadata]
*
*	Purpose: Parse line for deadlock metadata lock resource
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_lock_metadata
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @sbid int
	DECLARE @wr_dbid int
	DECLARE @wr_hobt bigint
	DECLARE @wr_fileid int
	DECLARE @wr_pageid int
	DECLARE @wr_rid smallint

	DECLARE @resource_subresource varchar(25)
	DECLARE @resource_objectname varchar(255)
	DECLARE @resource_indexname varchar(255)
	DECLARE @resource_idlock varchar(25)
	DECLARE @lock_mode varchar(8)
	DECLARE @address varchar(16)
	DECLARE @waittype varchar(25)
	DECLARE @nodeid tinyint
	DECLARE @wr_objid int
	DECLARE @wr_schid int
	DECLARE @lockpartition varchar(16)

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--2017-01-25 11:27:36.85 spid50s        metadatalock subresource=SCHEMA clASsid=schema_id = 25 dbid=14 lockPartition=0 id=lock92e71bd180 mode=Sch-S
								
	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

--2017-01-25 11:27:36.85 spid50s        metadatalock subresource=SCHEMA clASsid=schema_id = 25 dbid=14 lockPartition=0 id=lock92e71bd180 mode=Sch-S

				IF @colid = 1
					SET @resource_subresource = @tdata
				IF @colid = 2
					SET @wr_schid = @tdata
				IF @colid = 3
					SET @wr_dbid = @tdata
				IF @colid = 4
					SET @lockpartition = @tdata
				IF @colid = 5
					SET @resource_idlock = @tdata
				IF @colid = 6
					SET @lock_mode = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1
		SET @resource_subresource = @tdata
	IF @colid = 2
		SET @wr_schid = @tdata
	IF @colid = 3
		SET @wr_dbid = @tdata
	IF @colid = 4
		SET @lockpartition = @tdata
	IF @colid = 5
		SET @resource_idlock = @tdata
	IF @colid = 6
		SET @lock_mode = @tdata

	--look up DL id based on @linespid, @wr_hobt, @wr_dbid
	SELECT @deadlock_id = deadlock_id 
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

	IF @deadlock_id IS NULL
	BEGIN
		SET @msg = 'WARNING: MDLock Missing Deadlock: ' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
	ELSE
	BEGIN
		BEGIN TRAN
		INSERT dbo.deadlock_resource VALUES (@deadlock_id, @type, @wr_dbid, @wr_fileid, @wr_pageid, @wr_rid, @wr_objid, @wr_hobt, @wr_schid, @lock_mode, @resource_idlock, 
			@resource_subresource, @resource_objectname, @resource_indexname, @address, @waittype, @nodeid)
		
		UPDATE dbo.deadlock
			SET resource_count = resource_count + 1
			WHERE deadlock_id = @deadlock_id
		COMMIT TRAN

		IF @resource_subresource != 'SCHEMA'
		BEGIN
			SET @msg = 'WARNING: MDLock Not SCHEMA: ' + @line
			RAISERROR(@msg,11,1)
			INSERT dbo.deadlock_parse_error VALUES (@deadlock_id, NULL, NULL, @msg)
		END
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_lock_object]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_lock_object') is null exec('create procedure [dbo].[deadlock_parse_lock_object] as select getdate() DT')
GO
  /*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_lock_object]
*
*	Purpose: Parse line for deadlock object lock resource
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_lock_object
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @sbid int
	DECLARE @wr_dbid int
	DECLARE @wr_hobt bigint
	DECLARE @wr_fileid int
	DECLARE @wr_pageid int
	DECLARE @wr_rid smallint

	DECLARE @resource_subresource varchar(25)
	DECLARE @resource_objectname varchar(255)
	DECLARE @resource_indexname varchar(255)
	DECLARE @resource_idlock varchar(25)
	DECLARE @lock_mode varchar(8) 
	DECLARE @address varchar(16)
	DECLARE @waittype varchar(25)
	DECLARE @nodeid tinyint
	DECLARE @wr_objid int
	DECLARE @wr_schid int
	DECLARE @lockpartition smallint

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

	--parse line
--2016-11-13 11:01:35.99 spid7s         objectlock lockPartition=15 objid=46939717 subresource=FULL dbid=5 objectname=unknown id=lock3a7d0e4080 mode=Sch-M ASsociatedObjectId=46939717
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

				IF @colid = 1
					SET @lockpartition = @tdata
				IF @colid = 2
					SET @wr_objid = @tdata
				IF @colid = 3
					SET @resource_subresource = @tdata
				IF @colid = 4
					SET @wr_dbid = @tdata
				IF @colid = 5
					SET @resource_objectname = @tdata
				IF @colid = 6
					SET @resource_idlock = @tdata
				IF @colid = 7
					SET @lock_mode = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1
		SET @lockpartition = @tdata
	IF @colid = 2
		SET @wr_objid = @tdata
	IF @colid = 3
		SET @resource_subresource = @tdata
	IF @colid = 4
		SET @wr_dbid = @tdata
	IF @colid = 5
		SET @resource_objectname = @tdata
	IF @colid = 6
		SET @resource_idlock = @tdata
	IF @colid = 7
		SET @lock_mode = @tdata

	--look up DL id based on @linespid
	SELECT @deadlock_id = deadlock_id 
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

	IF @deadlock_id IS NULL
	BEGIN
		SET @msg = 'WARNING: ' + @type + ' Missing Deadlock:' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
	ELSE
	BEGIN
		BEGIN TRAN
		--mikez bug @lockpartition not stored
		INSERT dbo.deadlock_resource VALUES (@deadlock_id, @type, @wr_dbid, @wr_fileid, @wr_pageid, @wr_rid, @wr_objid, @wr_hobt, @wr_schid, @lock_mode, @resource_idlock, 
			@resource_subresource, @resource_objectname, @resource_indexname, @address, @waittype, @nodeid)
		
		UPDATE dbo.deadlock
			SET resource_count = resource_count + 1
			WHERE deadlock_id = @deadlock_id
		COMMIT TRAN
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_lock_page]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_lock_page') is null exec('create procedure [dbo].[deadlock_parse_lock_page] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_lock_page]
*
*	Purpose: Parse line for deadlock page lock resource
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_lock_page
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @sbid int
	DECLARE @wr_dbid int
	DECLARE @wr_hobt bigint
	DECLARE @wr_fileid int
	DECLARE @wr_pageid int
	DECLARE @wr_rid smallint

	DECLARE @resource_subresource varchar(25)
	DECLARE @resource_objectname varchar(255)
	DECLARE @resource_indexname varchar(255)
	DECLARE @resource_idlock varchar(25)
	DECLARE @lock_mode varchar(8)
	DECLARE @address varchar(16)
	DECLARE @waittype varchar(25)
	DECLARE @nodeid tinyint
	DECLARE @wr_objid int
	DECLARE @wr_schid int
	DECLARE @lockpartition varchar(16)

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--2016-11-21 14:43:23.81 spid29s        pagelock fileid=1 pageid=4539159 dbid=5 subresource=FULL objectname=WinSNAP.sync.Customers id=lock3a43e1e200 mode=IX ASsociatedObjectId=72057605409931264

	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

				IF @colid = 1
					SET @wr_fileid = @tdata
				IF @colid = 2
					SET @wr_pageid = @tdata
				IF @colid = 3
					SET @wr_dbid = @tdata
				IF @colid = 4
					SET @resource_subresource = @tdata
				IF @colid = 5
					SET @resource_objectname = @tdata
				IF @colid = 6
					SET @resource_idlock = @tdata
				IF @colid = 7
					SET @lock_mode = @tdata
				IF @colid = 8
					SET @wr_hobt = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1
		SET @wr_fileid = @tdata
	IF @colid = 2
		SET @wr_pageid = @tdata
	IF @colid = 3
		SET @wr_dbid = @tdata
	IF @colid = 4
		SET @resource_subresource = @tdata
	IF @colid = 5
		SET @resource_objectname = @tdata
	IF @colid = 6
		SET @resource_idlock = @tdata
	IF @colid = 7
		SET @lock_mode = @tdata
	IF @colid = 8
		SET @wr_hobt = @tdata


	--look up DL id based on @linespid, @wr_dbid, @wr_fileid, @wr_pageid
	SELECT @deadlock_id = deadlock_id
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

	IF @deadlock_id IS NULL
	BEGIN
		SET @msg = 'WARNING: PageLock Missing Deadlock:' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
	ELSE
	BEGIN
		BEGIN TRAN
		INSERT dbo.deadlock_resource VALUES (@deadlock_id, @type, @wr_dbid, @wr_fileid, @wr_pageid, @wr_rid, @wr_objid, @wr_hobt, @wr_schid, @lock_mode, @resource_idlock, 
			@resource_subresource, @resource_objectname, @resource_indexname, @address, @waittype, @nodeid)

/*
		UPDATE dbo.deadlock_process 
			SET subresource = @resource_subresource,
				objectname = @resource_objectname, 
				wr_hobt = @wr_hobt,
				owner_lockmode = @owner_mode
			WHERE deadlock_id = @deadlock_id AND process_id = @process_id AND sbid = @sbid
*/
		UPDATE dbo.deadlock
			SET resource_count = resource_count + 1
			WHERE deadlock_id = @deadlock_id
		COMMIT TRAN
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_lock_rid]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_lock_rid') is null exec('create procedure [dbo].[deadlock_parse_lock_rid] as select getdate() DT')
GO
  /*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_lock_rid]
*
*	Purpose: Parse line for deadlock rid lock resource
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@type : REQUIRED - line type used for debug output
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_lock_rid
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@type varchar(15),
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@parse_val) + @type + @line
	--END

	DECLARE @deadlock_id int
	DECLARE @sbid int
	DECLARE @wr_dbid int
	DECLARE @wr_hobt bigint
	DECLARE @wr_fileid int
	DECLARE @wr_pageid int
	DECLARE @wr_rid smallint

	DECLARE @resource_subresource varchar(25)
	DECLARE @resource_objectname varchar(255)
	DECLARE @resource_indexname varchar(255)
	DECLARE @resource_idlock varchar(25)
	DECLARE @lock_mode varchar(8)
	DECLARE @address varchar(16)
	DECLARE @waittype varchar(25)
	DECLARE @nodeid tinyint
	DECLARE @wr_objid int
	DECLARE @wr_schid int
	DECLARE @lockpartition varchar(16)

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

--2016-12-28 19:45:44.900 spid48s         ridlock fileid=3 pageid=368 dbid=2 objectname=tempdb.dbo.x id=lock25af929c100 mode=X ASsociatedObjectId=1945555045335236608

								
	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

				IF @colid = 1
					SET @wr_fileid = @tdata
				IF @colid = 2
					SET @wr_pageid = @tdata
				IF @colid = 3
					SET @wr_dbid = @tdata
				IF @colid = 4
					SET @resource_objectname = @tdata
				IF @colid = 5
					SET @resource_idlock = @tdata
				IF @colid = 6
					SET @lock_mode = @tdata
				IF @colid = 7
					SET @wr_hobt = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1
		SET @wr_fileid = @tdata
	IF @colid = 2
		SET @wr_pageid = @tdata
	IF @colid = 3
		SET @wr_dbid = @tdata
	IF @colid = 4
		SET @resource_objectname = @tdata
	IF @colid = 5
		SET @resource_idlock = @tdata
	IF @colid = 6
		SET @lock_mode = @tdata
	IF @colid = 7
		SET @wr_hobt = @tdata

	--look up DL id based on @linespid, @wr_hobt, @wr_dbid
	SELECT @deadlock_id = deadlock_id 
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

	IF @deadlock_id IS NULL
	BEGIN
		SET @msg = 'WARNING: RidLock Missing Deadlock:' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
	ELSE
	BEGIN
		BEGIN TRAN
		INSERT dbo.deadlock_resource VALUES (@deadlock_id, @type, @wr_dbid, @wr_fileid, @wr_pageid, @wr_rid, @wr_objid, @wr_hobt, @wr_schid, @lock_mode, @resource_idlock, 
			@resource_subresource, @resource_objectname, @resource_indexname, @address, @waittype, @nodeid)
		
		UPDATE dbo.deadlock
			SET resource_count = resource_count + 1
			WHERE deadlock_id = @deadlock_id
		COMMIT TRAN
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_process]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_process') is null exec('create procedure [dbo].[deadlock_parse_process] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_process]
*
*	Purpose: Parse line for deadlock process
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_process
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT @line
	--END

	DECLARE @deadlock_id int
	DECLARE @process_id varchar(16)
	DECLARE @spid int
	DECLARE @sbid int = 0
	DECLARE @ecid int = -1
	DECLARE @taskpriority smallint
	DECLARE @logused bigint
	DECLARE @waitresource varchar(100)
	DECLARE @wr_type varchar(15)
	DECLARE @wr_dbid int = -1
	DECLARE @wr_hobt bigint = -1
	DECLARE @wr_hash varchar(20) 
	DECLARE @wr_fileid int = -1
	DECLARE @wr_pageid int = -1
	DECLARE @wr_objid int = -1
	DECLARE @wr_indid smallint = -1
	DECLARE @wr_schid int = -1
	DECLARE @wr_rid smallint = -1
	DECLARE @waittime int
	DECLARE @ownerid varchar(20)
	DECLARE @transactionname varchar(100)
	DECLARE @lasttranstarted datetime
	DECLARE @XDES varchar(20)
	DECLARE @lock_mode varchar(8)
	DECLARE @schedulerid tinyint
	DECLARE @kpid int
	DECLARE @status varchar(32)
	DECLARE @priority smallint
	DECLARE @trancount tinyint
	DECLARE @lastbatchstarted datetime
	DECLARE @lastbatchcompleted datetime
	DECLARE @lastattention datetime
	DECLARE @clientapp varchar(100)
	DECLARE @hostname varchar(32)
	DECLARE @hostpid bigint
	DECLARE @skiploginname tinyint
	DECLARE @loginname varchar(100)
	DECLARE @isolationlevel varchar(100)
	DECLARE @isolevelval tinyint
	DECLARE @xactid bigint
	DECLARE @currentdb int
	DECLARE @lockTimeout bigint
	DECLARE @clientoption1 int
	DECLARE @clientoption2 int
	DECLARE @full_line varchar(8000)

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @str_type tinyint
	DECLARE @str_type_old tinyint
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

	DECLARE @wr_strings tinyint
	DECLARE @iso_strings tinyint

/*
parse process line from:
process id=process467f868 taskpriority=0 logused=0 waitresource=KEY: 5:72057605470027776 (757109d662e5) waittime=3840 ownerId=32116638163 transactionname=INSERT lasttranstarted=2016-11-28T14:18:17.513 XDES=0x607eb6d0e0 lockMode=S schedulerid=15 kpid=263784 status=suspENDed spid=146 sbid=0 ecid=0 priority=0 trancount=0 lastbatchstarted=2016-11-28T14:18:16.317 lastbatchcompleted=2016-11-28T14:18:16.317 lastattention=1900-01-01T00:00:00.317 clientapp=WebSMARTT Sync Job hostname=2MTAPPPOS01 hostpid=1736 loginname=FOODSERVER\websmarttuser isolationlevel=read committed (2) xactid=32116638163 currentdb=5 lockTimeout=4294967295 clientoption1=673185824 clientoption2=128056
to:
process id=process taskpriority= logused= waitresource=KEY: 5:72057605470027776 (757109d662e5) waittime= ownerId= transactionname=INSERT lasttranstarted= XDES= lockMode=S schedulerid= kpid= status=suspENDed spid= sbid= ecid= priority= trancount= lastbatchstarted= lastbatchcompleted= lastattention= clientapp=WebSMARTT Sync Job hostname= hostpid= loginname= isolationlevel=read committed (2) xactid= currentdb= lockTimeout= clientoption1= clientoption2=

--variations that cause problems
process id=process486ee6f498 waitresource=PAGE: 5:0:0  schedulerid=69 kpid=0 status=done spid=86 sbid=0 ecid=0 priority=0 trancount=2 lastbatchstarted=2016-11-15T09:08:08.250 lastbatchcompleted=2016-11-15T09:08:08.250 lastattention=1900-01-01T00:00:00.250 clientapp=WebSMARTT Sync Job hostname=2MTAPPPOS01 hostpid=55740 loginname=FOODSERVER\websmarttuser isolationlevel=read committed (2) xactid=25657938250 currentdb=5 lockTimeout=4294967295 clientoption1=673316896 clientoption2=128056
process id=process4338187c38 waitresource=PAGE: 5:0:0  schedulerid=8 kpid=0
process id=process6842928 taskpriority=0 logused=10000 waittime=6470 schedulerid=54 kpid=250716 status=suspENDed spid=123 sbid=0 ecid=0 priority=0 trancount=2 lastbatchstarted=2016-11-28T12:49:04.010 lastbatchcompleted=2016-11-28T12:49:04.007 lastattention=1900-01-01T00:00:00.007 clientapp=WebSMARTT Sync Job hostname=2MTAPPPOS01 hostpid=1736 loginname=FOODSERVER\websmarttuser isolationlevel=read committed (2) xactid=32072054744 currentdb=5 lockTimeout=4294967295 clientoption1=673316896 clientoption2=128056
process id=process49cb436188 taskpriority=0 logused=0 waitresource=OBJECT: 5:233767890:16  waittime=3361 ownerId=23974823938 transactionname=SsvarObjPropI4Str lasttranstarted=2016-11-13T11:01:06.327 XDES=0x5fb5e0ea30 lockMode=Sch-S schedulerid=17 kpid=95840 status=suspENDed spid=91 sbid=0 ecid=0 priority=0 trancount=0 lastbatchstarted=2016-11-13T11:01:06.313 lastbatchcompleted=2016-11-13T11:01:06.313 lastattention=1900-01-01T00:00:00.313 clientapp=WebSMARTT Sync Schema hostname=2MTAPPPOS01 hostpid=55740 loginname=FOODSERVER\websmarttuser isolationlevel=read committed (2) xactid=23974822803 currentdb=5 lockTimeout=4294967295 clientoption1=671088672 clientoption2=128056

--bad iso level
process id=process59dae03868 taskpriority=0 logused=0 waitresource=PAGE: 5:1:1475697       waittime=1764 ownerId=25658037446 transactionname=SELECT            lasttranstarted=2016-11-15T09:08:21.870 XDES=0x5f634dbcf0 lockMode=S  schedulerid=23 kpid=75120 status=suspENDed spid=163 sbid=0 ecid=128 priority=0 trancount=0 lastbatchstarted=2016-11-15T09:08:21.870 lastbatchcompleted=2016-11-15T09:08:21.870 lastattention=1900-01-01T00:00:00.870 clientapp=WebSMARTT Sync Job    hostname=2MTAPPPOS01 hostpid=55740                                    isolationlevel=read committed (2) xactid=25658037446 currentdb=5 lockTimeout=4294967295 clientoption1=671088672 clientoption2=128056

*/

	--parse line
	SET @str_index = 0
	SET @str_index_old = 0
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos + 1)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

				IF @colid = 1
					SET @process_id = @tdata
				IF @colid = 2
					SET @taskpriority = @tdata
				IF @colid = 3
					SET @logused = @tdata
				IF @colid = 4
					SET @waitresource = @tdata
				IF @colid = 5
					SET @waittime = @tdata
				IF @colid = 6
					SET @ownerid = @tdata
				IF @colid = 7
					SET @transactionname = @tdata
				IF @colid = 8
					SET @lasttranstarted = @tdata
				IF @colid = 9
					SET @XDES = @tdata
				IF @colid = 10
					SET @lock_mode = @tdata
				IF @colid = 11
					SET @schedulerid = @tdata
				IF @colid = 12
					SET @kpid = @tdata
				IF @colid = 13
					SET @status = @tdata
				IF @colid = 14
					SET @spid = @tdata
				IF @colid = 15
					SET @sbid = @tdata
				IF @colid = 16
					SET @ecid = @tdata
				IF @colid = 17
					SET @priority = @tdata
				IF @colid = 18
					SET @trancount = @tdata
				IF @colid = 19
					SET @lastbatchstarted = @tdata
				IF @colid = 20
					SET @lastbatchcompleted = @tdata
				IF @colid = 21
					SET @lastattention = @tdata
				IF @colid = 22
					SET @clientapp = @tdata
				IF @colid = 23
					SET @hostname = @tdata
				IF @colid = 24
					SET @hostpid = @tdata
				IF @colid = 25
					SET @loginname = @tdata
				IF @colid = 26
					SET @isolationlevel = @tdata
				IF @colid = 27
					SET @xactid = @tdata
				IF @colid = 28
					SET @currentdb = @tdata
				IF @colid = 29
					SET @lockTimeout = @tdata
				IF @colid = 30
					SET @clientoption1 = @tdata
				IF @colid = 31
					SET @clientoption2 = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
			SET @colidcurrent = @colidcurrent + 1
		END

		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1
		SET @process_id = @tdata
	IF @colid = 2
		SET @taskpriority = @tdata
	IF @colid = 3
		SET @logused = @tdata
	IF @colid = 4
		SET @waitresource = @tdata
	IF @colid = 5
		SET @waittime = @tdata
	IF @colid = 6
		SET @ownerid = @tdata
	IF @colid = 7
		SET @transactionname = @tdata
	IF @colid = 8
		SET @lasttranstarted = @tdata
	IF @colid = 9
		SET @XDES = @tdata
	IF @colid = 10
		SET @lock_mode = @tdata
	IF @colid = 11
		SET @schedulerid = @tdata
	IF @colid = 12
		SET @kpid = @tdata
	IF @colid = 13
		SET @status = @tdata
	IF @colid = 14
		SET @spid = @tdata
	IF @colid = 15
		SET @sbid = @tdata
	IF @colid = 16
		SET @ecid = @tdata
	IF @colid = 17
		SET @priority = @tdata
	IF @colid = 18
		SET @trancount = @tdata
	IF @colid = 19
		SET @lastbatchstarted = @tdata
	IF @colid = 20
		SET @lastbatchcompleted = @tdata
	IF @colid = 21
		SET @lastattention = @tdata
	IF @colid = 22
		SET @clientapp = @tdata
	IF @colid = 23
		SET @hostname = @tdata
	IF @colid = 24
		SET @hostpid = @tdata
	IF @colid = 25
		SET @loginname = @tdata
	IF @colid = 26
		SET @isolationlevel = @tdata
	IF @colid = 27
		SET @xactid = @tdata
	IF @colid = 28
		SET @currentdb = @tdata
	IF @colid = 29
		SET @lockTimeout = @tdata
	IF @colid = 30
		SET @clientoption1 = @tdata
	IF @colid = 31
		SET @clientoption2 = @tdata

	--parse waitresource type

--OBJECT: 5:233767890:16
--KEY: 5:72057605470027776 (757109d662e5) 
--PAGE: 5:1:1190743 


	IF @waitresource IS NOT NULL
	BEGIN
		--IF @lineno < @debug_lines
		--BEGIN
		--	PRINT @waitresource
		--END

		EXEC dbo.deadlock_parse_wait_resource
			@parse_val,
			@waitresource OUTPUT,
			@wr_type OUTPUT,
			@wr_dbid OUTPUT,
			@wr_hobt OUTPUT,
			@wr_hash OUTPUT,
			@wr_fileid OUTPUT,
			@wr_pageid OUTPUT,
			@wr_objid OUTPUT,
			@wr_indid OUTPUT,
			@wr_schid OUTPUT,
			@wr_rid OUTPUT
	END

	IF @isolationlevel IS NOT NULL
	BEGIN
		--parse waitresource
		SELECT @iso_strings = childstype FROM dbo.deadlock_parse_strings WHERE stype = @parse_val AND mystr = 'isolationlevel='

		--read committed (2)
		--PRINT 'ISOLVL=' + @isolationlevel
		SET @pos = 0
		SET @str_index = 0
		SET @str_index_old = 0
		SET @str_len_old = @str_len

		SET @colid = 1
		SET @infinite_loop_protection = 0
		WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
		BEGIN
			SET @str_index = NULL
			SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
				FROM dbo.deadlock_parse_strings 
				WHERE stype = @iso_strings AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
			--PRINT 'J ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

			IF @str_index IS NOT NULL
			BEGIN
				SET @pos2 = CHARINDEX(@str, @isolationlevel, @pos + @str_len_old)
				--PRINT 'K ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
				IF @pos2 > 0
				BEGIN
					SET @tdata = RTRIM(SUBSTRING(@isolationlevel, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

					--PRINT @tdata

					IF @colid = 2
						SET @isolevelval = @tdata

					SET @colid = @colid + 1
					SET @str_len_old = @str_len
					SET @pos = @pos2
				END
			END

			SET @str_index_old = @str_index
			SET @infinite_loop_protection = @infinite_loop_protection + 1
		END
		--PRINT 'L ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
		SET @tdata = RTRIM(SUBSTRING(@isolationlevel, @pos + @str_len_old, LEN(@line)))

		IF @colid = 2
			SET @isolevelval = @tdata
	END

	--SELECT @process_id, @spid, @sbid, @ecid, @taskpriority, @logused, @waitresource, @wr_type,
	--	@wr_dbid, @wr_hobt, @wr_hash, @wr_fileid, @wr_pageid, @wr_objid, @wr_indid, @waittime, @ownerid, @transactionname,
	--	@lasttranstarted, @XDES, @lock_mode, @schedulerid, @kpid, @status, @priority, @trancount, @lastbatchstarted, 
	--	@lastbatchcompleted, @lastattention, @clientapp, @hostname, @hostpid, @loginname, @isolevelval, @xactid, @currentdb, @lockTimeout, 
	--	@clientoption1, @clientoption2

	--look up @deadlock_id by @linespid WHERE deadlock reporting is not complete yet to handle same process in multiple deadlocks
	SELECT @deadlock_id = deadlock_id 
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

	IF @deadlock_id IS NULL
	BEGIN
		SET @msg = 'WARNING: Process Missing Deadlock:' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (NULL, NULL, NULL, @msg)
	END
	ELSE
	BEGIN
		IF @taskpriority IS NULL or @waitresource IS NULL
		BEGIN
			SET @full_line = SUBSTRING(@line,1,8000)
		END

		BEGIN TRAN
		INSERT dbo.deadlock_process VALUES (@deadlock_id, @process_id, @spid, @sbid, @ecid, @taskpriority, @logused, @waitresource, @wr_type,
			@wr_dbid, @wr_hobt, @wr_hash, @wr_fileid, @wr_pageid, @wr_rid, @wr_objid, @wr_indid, @wr_schid, @waittime, @ownerid, @transactionname,
			@lasttranstarted, @XDES, @lock_mode, @schedulerid, @kpid, @status, @priority, @trancount, @lastbatchstarted, 
			@lastbatchcompleted, @lastattention, @clientapp, @hostname, @hostpid, @loginname, @isolevelval, @xactid, @currentdb, @lockTimeout, 
			@clientoption1, @clientoption2, NULL, NULL, NULL, NULL, @full_line)

		--increment waiter count
		UPDATE dbo.deadlock
			SET process_count = process_count + 1,
				last_process_seen = @process_id
			WHERE deadlock_id = @deadlock_id
		COMMIT TRAN
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_tsql_frame]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_tsql_frame') is null exec('create procedure [dbo].[deadlock_parse_tsql_frame] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_tsql_frame]
*
*	Purpose: Parse line for deadlock tsql frame
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_tsql_frame
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT @line
	--END

	DECLARE @deadlock_id int
	DECLARE @process_id varchar(16)
	DECLARE @sbid int

	DECLARE @frame_id tinyint
	DECLARE @frame_procname varchar(255)
	DECLARE @frame_line int
	DECLARE @frame_stmtstart int
	DECLARE @frame_stmtend int
	DECLARE @frame_sqlhandle varchar(128)

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)

	--frame procname=WinSNAP.sync.UpdateCustomerBalances line=71 stmtstart=2950 stmtend=4402 sqlhandle=0x03000500133d113299732b01afa6000001000000000000000000000000000000000000000000000000000000

	--parse line
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

				IF @colid = 1
					SET @frame_procname = @tdata
				IF @colid = 2
					SET @frame_line = @tdata
				IF @colid = 3
					SET @frame_stmtstart = @tdata
				IF @colid = 4
					SET @frame_stmtend = @tdata
				IF @colid = 5
					SET @frame_sqlhandle = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1
		SET @frame_procname = @tdata
	IF @colid = 2
		SET @frame_line = @tdata
	IF @colid = 3
		SET @frame_stmtstart = @tdata
	IF @colid = 4
		SET @frame_stmtend = @tdata
	IF @colid = 5
		SET @frame_sqlhandle = @tdata

	--PRINT @tdata
	SELECT @deadlock_id = deadlock_id, @process_id = last_process_seen FROM dbo.deadlock WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid
	SELECT TOP 1 @sbid = sbid FROM dbo.deadlock_process WHERE deadlock_id = @deadlock_id AND process_id = @process_id

	IF @sbid is not null
	BEGIN
		SELECT @frame_id = MAX(frame_id)+1 FROM dbo.deadlock_tsql_stack WHERE deadlock_id = @deadlock_id AND process_id = @process_id AND sbid = @sbid

		IF @frame_id IS NULL
		BEGIN
			SET @frame_id = 0
		END

		INSERT dbo.deadlock_tsql_stack VALUES (@deadlock_id, @process_id, @sbid, @frame_id, @frame_procname, @frame_line, @frame_stmtstart,
			@frame_stmtend, @frame_sqlhandle)
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_vcmax]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_vcmax') is null exec('create procedure [dbo].[deadlock_parse_vcmax] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_vcmax]
*
*	Purpose: Parse varchar(max) parameter for deadlocks (assumed to be output from SQL Server errorlog)
*
*	Inputs:	
*		@data : REQUIRED - data to parse for deadlocks
*		@filename : OPTIONAL - errorlog that data is from
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_vcmax
(
	@data varchar(max),
	@filename sysname = NULL,
	@debug_lines int = 0
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @debug tinyint = 0
	DECLARE @CRLF varchar(2) = CHAR(13) + CHAR(10)
	DECLARE @CR varchar(2) = CHAR(13)
	DECLARE @LF varchar(2) = CHAR(10)
	DECLARE @space varchar(1) = ' '
	DECLARE @lineseparator varchar(2)
	DECLARE @lineseparator_len tinyint = 2
	DECLARE @len bigint
	DECLARE @lineno bigint
	DECLARE @line varchar(8000)
	DECLARE @linedate datetime
	DECLARE @linetype varchar(10)
	DECLARE @linespid int
	DECLARE @linespidstr varchar(10)
	DECLARE @pos1 bigint
	DECLARE @pos2 bigint
	DECLARE @pos3 bigint
	DECLARE @pos4 bigint
	DECLARE @pos5 bigint
	DECLARE @pos6 bigint
	DECLARE @done tinyint = 0
	DECLARE @ignore_count bigint = 0
	DECLARE @processedline tinyint

	DECLARE @spid_str	char(4)
	DECLARE @spid_s_str	char(1)
	DECLARE @spid_len	tinyint
	DECLARE @spid_s_len tinyint

	DECLARE @resource_key_str			varchar(15)
	DECLARE @resource_pag_str			varchar(15)
	DECLARE @resource_rid_str			varchar(15)
	DECLARE @resource_object_str		varchar(15)
	DECLARE @resource_exchangepipe_str	varchar(15)
	DECLARE @resource_exchangeport_str	varchar(15)
	DECLARE @resource_metadata_str		varchar(15)
	DECLARE @resource_app_str			varchar(15)
		
	DECLARE @resource_key_len			tinyint
	DECLARE @resource_pag_len			tinyint
	DECLARE @resource_rid_len			tinyint
	DECLARE @resource_object_len		tinyint
	DECLARE @resource_exchangepipe_len	tinyint
	DECLARE @resource_exchangeport_len	tinyint
	DECLARE @resource_app_len			tinyint
	DECLARE @resource_metadata_len		tinyint

	DECLARE @deadlockvictimprocess_str		varchar(25) 
	DECLARE @processidprocess_str			varchar(25) 
	DECLARE @frameprocname_str				varchar(25) 
	DECLARE @resource_keylock_hobtid_str	varchar(25) 
	DECLARE @resource_pagelock_fileid_str	varchar(25) 
	DECLARE @owneridprocess_str				varchar(25) 
	DECLARE @waiteridprocess_str			varchar(25) 
	DECLARE @exchange_pipe_str				varchar(25) 
	DECLARE @exchange_port_str				varchar(25) 
	DECLARE @resource_objectlock_str		varchar(25) 
	DECLARE @resource_rid_fileid_str		varchar(25)
	DECLARE @ProcDatabaseId_str				varchar(25)
	DECLARE @metadatalocksubresource_str	varchar(25)
	DECLARE @intraquerydl_str				varchar(25)
	DECLARE @iqdlNode_str					varchar(25)
	DECLARE @iqdlPort_str					varchar(25)
	DECLARE @iqdlResType_str 				varchar(25)
	DECLARE @iqdlSPID_str					varchar(25)
	DECLARE @iqdlInputBuf_str				varchar(25)
	DECLARE @resource_applock_hash_str		varchar(25)

	--strings to ignore so as to process adhoc inputbuffers
	DECLARE @inputbuf_str					varchar(25)
	DECLARE @deadlocklist_str				varchar(25)
	DECLARE @processlist_str				varchar(25)
	DECLARE @executionStack_str				varchar(25)
	DECLARE @resourcelist_str				varchar(25)
	DECLARE @ownerlist_str					varchar(25)
	DECLARE @waiterlist_str					varchar(25)

	DECLARE @deadlockvictimprocess_len		tinyint
	DECLARE @processidprocess_len			tinyint
	DECLARE @frameprocname_len				tinyint
	DECLARE @resource_keylock_hobtid_len	tinyint
	DECLARE @resource_pagelock_fileid_len	tinyint
	DECLARE @owneridprocess_len				tinyint
	DECLARE @waiteridprocess_len			tinyint
	DECLARE @exchange_pipe_len				tinyint
	DECLARE @exchange_port_len				tinyint
	DECLARE @objectlock_len					tinyint
	DECLARE @resource_rid_fileid_len		tinyint
	DECLARE @ProcDatabaseId_len				tinyint
	DECLARE @metadatalocksubresource_len	tinyint
	DECLARE @intraquerydl_len				tinyint
	DECLARE @iqdlNode_len					tinyint
	DECLARE @iqdlPort_len					tinyint
	DECLARE @iqdlResType_len 				tinyint
	DECLARE @iqdlSPID_len					tinyint
	DECLARE @iqdlInputBuf_len				tinyint
	DECLARE @applock_hash_len				tinyint

	DECLARE @deadlockvictimprocess_sub		tinyint
	DECLARE @processidprocess_sub			tinyint
	DECLARE @frameprocname_sub				tinyint
	DECLARE @resource_keylock_hobtid_sub	tinyint
	DECLARE @resource_pagelock_fileid_sub	tinyint
	DECLARE @owneridprocess_sub				tinyint
	DECLARE @waiteridprocess_sub			tinyint
	DECLARE @exchange_pipe_sub				tinyint
	DECLARE @exchange_port_sub				tinyint
	DECLARE @objectlock_sub					tinyint
	DECLARE @resource_rid_fileid_sub		tinyint
	DECLARE @ProcDatabaseId_sub				tinyint
	DECLARE @metadatalocksubresource_sub	tinyint
	DECLARE @iqdlPort_sub					tinyint
	DECLARE @iqdlResType_sub 				tinyint
	DECLARE @iqdlSPID_sub					tinyint
	DECLARE @iqdlInputBuf_sub				tinyint
	DECLARE @applock_hash_sub				tinyint

	DECLARE @start_time datetime = getdate()
	DECLARE @min_dl int
	DECLARE @max_dl int
	DECLARE @importfileid smallint

	--load variables from string table
	SELECT @spid_str = mystr, @spid_len = mylen  FROM dbo.deadlock_parse_strings WHERE stype = 0 AND typeid = 1
	SELECT @spid_s_str = mystr, @spid_s_len = mylen  FROM dbo.deadlock_parse_strings WHERE stype = 0 AND typeid = 2

	SELECT @resource_key_str = mystr, @resource_key_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 1
	SELECT @resource_pag_str = mystr, @resource_pag_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 2
	SELECT @resource_rid_str = mystr, @resource_rid_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 3
	SELECT @resource_object_str = mystr, @resource_object_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 4
	SELECT @resource_exchangepipe_str = mystr, @resource_exchangepipe_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 5
	SELECT @resource_exchangeport_str = mystr, @resource_exchangeport_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 6
	SELECT @resource_metadata_str = mystr, @resource_metadata_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 7
	SELECT @resource_app_str = mystr, @resource_app_len = mylen FROM dbo.deadlock_parse_strings WHERE stype = 1 AND typeid = 8

	SELECT @deadlockvictimprocess_str = mystr, @deadlockvictimprocess_len = mylen, @deadlockvictimprocess_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 1
	SELECT @processidprocess_str = mystr, @processidprocess_len = mylen, @processidprocess_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 2
	SELECT @frameprocname_str = mystr, @frameprocname_len = mylen, @frameprocname_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 3
	SELECT @resource_keylock_hobtid_str = mystr, @resource_keylock_hobtid_len = mylen, @resource_keylock_hobtid_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 4
	SELECT @resource_pagelock_fileid_str = mystr, @resource_pagelock_fileid_len = mylen, @resource_pagelock_fileid_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 5
	SELECT @owneridprocess_str = mystr, @owneridprocess_len = mylen, @owneridprocess_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 6
	SELECT @waiteridprocess_str = mystr, @waiteridprocess_len = mylen, @waiteridprocess_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 7
	SELECT @exchange_pipe_str = mystr, @exchange_pipe_len = mylen, @exchange_pipe_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 8
	SELECT @exchange_port_str = mystr, @exchange_port_len = mylen, @exchange_port_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 9
	SELECT @resource_objectlock_str = mystr, @objectlock_len = mylen, @objectlock_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 10
	SELECT @resource_rid_fileid_str = mystr, @resource_rid_fileid_len = mylen, @resource_rid_fileid_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 11
	SELECT @ProcDatabaseId_str = mystr, @ProcDatabaseId_len = mylen, @ProcDatabaseId_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 12
	SELECT @metadatalocksubresource_str = mystr, @metadatalocksubresource_len = mylen, @metadatalocksubresource_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 20
	SELECT @intraquerydl_str = mystr, @intraquerydl_len = mylen  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 21
	SELECT @iqdlNode_str = mystr, @iqdlNode_len = mylen  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 22
	SELECT @iqdlPort_str = mystr, @iqdlPort_len = mylen, @iqdlPort_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 23
	SELECT @iqdlResType_str = mystr, @iqdlResType_len = mylen, @iqdlResType_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 24
	SELECT @iqdlSPID_str = mystr, @iqdlSPID_len = mylen, @iqdlSPID_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 25
	SELECT @iqdlInputBuf_str = mystr, @iqdlInputBuf_len = mylen, @iqdlInputBuf_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 26
	SELECT @resource_applock_hash_str = mystr, @applock_hash_len = mylen, @applock_hash_sub = childstype  FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 27


--ignore strings to process adhoc inputbuffers
	SELECT @inputbuf_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 13
	SELECT @deadlocklist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 14
	SELECT @processlist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 15
	SELECT @executionStack_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 16
	SELECT @resourcelist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 17
	SELECT @ownerlist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 18
	SELECT @waiterlist_str = mystr FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 19

	IF @debug = 1
	BEGIN
		SELECT @spid_str, @spid_s_str
		SELECT @resource_key_str, @resource_pag_str, @resource_rid_str, @resource_object_str, @resource_exchangepipe_str, @resource_exchangeport_str

		SELECT @deadlockvictimprocess_sub, @deadlockvictimprocess_str
		SELECT @processidprocess_sub, @processidprocess_str
		SELECT @frameprocname_sub, @frameprocname_str
		SELECT @resource_keylock_hobtid_sub, @resource_keylock_hobtid_str 
		SELECT @resource_pagelock_fileid_sub, @resource_pagelock_fileid_str
		SELECT @owneridprocess_sub, @owneridprocess_str
		SELECT @waiteridprocess_sub, @waiteridprocess_str
		SELECT @exchange_pipe_sub, @exchange_pipe_str
		SELECT @exchange_port_sub, @exchange_port_str
		SELECT @objectlock_sub, @resource_objectlock_str
		SELECT @resource_rid_fileid_sub, @resource_rid_fileid_str
	END

	SET @len = len(@data)

	SET @pos1 = CHARINDEX(@CRLF, @data)
	IF @pos1 > 0 
	BEGIN
		SET @lineseparator = @CRLF
	END
	ELSE
	BEGIN
		SET @lineseparator_len = 1
		SET @pos1 = CHARINDEX(@CR, @data)
		IF @pos1 > 0 
		BEGIN
			SET @lineseparator = @CR
		END
		ELSE
		BEGIN
			SET @pos1 = CHARINDEX(@LF, @data)
			IF @pos1 > 0 
			BEGIN
				SET @lineseparator = @LF
			END
			ELSE
				PRINT 'Error: No line separator found'
		END
	END

	IF @lineseparator is not null
	BEGIN
		INSERT dbo.deadlock_file (is_complete, is_xel, fileid, start_time, active_deadlocks, file_size, [file_name])
			VALUES (1, 0, 254, GETDATE(), 0, @len, @filename)

		SET @importfileid = @@IDENTITY

		PRINT 'Fileid=' + LTRIM(STR(@importfileid))+ ', Length=' + STR(@len)
		SET @lineno = 1
		SET @pos2 = @pos1
		SET @pos1 = 1

		WHILE @pos2 > 0 AND @pos2 < @len AND @done = 0
		BEGIN
			SET @line = SUBSTRING(@data, @pos1, @pos2 - @pos1)
			IF @lineno > 1000000000 -- prevent infinite loop
			BEGIN 
				SET @done = 1
			END
			ELSE
			BEGIN
				IF @debug = 1 AND @lineno < 100
					PRINT @line
			END

			--break up line
			SET @pos3 = CHARINDEX(@space, @line)
			IF @pos3 > 0 AND ISDATE(SUBSTRING(@line, 1, @pos3)) = 1
			BEGIN
				--possible datetime stamp
				SET @pos4 = CHARINDEX(@space, @line, @pos3 + 1)
				IF @pos4 > 0 AND ISDATE(SUBSTRING(@line,1, @pos4)) = 1
				BEGIN
					SET @linedate = SUBSTRING(@line, 1, @pos4)

					--IF @lineno < 100
					--	PRINT convert(varchar(23),@linedate,126)

					SET @pos3 = @pos4
					SET @pos4 = CHARINDEX(@space, @line, @pos3 + 1)
					IF @pos4 > 0
					BEGIN
						SET @linetype = SUBSTRING(@line, @pos3, @pos4-@pos3)

						--IF @lineno < 100
						--	PRINT @linetype

						--get reporting spid
						SET @linespid = NULL
						SET @pos5 = CHARINDEX(@spid_str, @linetype)
						IF @pos5 > 0 
						BEGIN
							SET @pos6 = CHARINDEX(@spid_s_str, @linetype, @pos5 + 1)
							IF @pos6 > 0 AND ISNUMERIC(SUBSTRING(@linetype, @pos5 + @spid_len, @pos6 - @pos5 - @spid_len)) = 1
							BEGIN
								SET @linespid = SUBSTRING(@linetype, @pos5 + @spid_len, @pos6 - @pos5 - @spid_len)

								--IF @lineno < 100
								--	PRINT STR(@linespid)

							END
						END

						--check IF deadlock line
						SET @pos3 = @pos4 + 1
						SET @pos4 = 
							CHARINDEX(@deadlockvictimprocess_str, @line, @pos3) + 
							CHARINDEX(@processidprocess_str, @line, @pos3) + 
							CHARINDEX(@frameprocname_str, @line, @pos3) + 
							CHARINDEX(@resource_keylock_hobtid_str, @line, @pos3) + 
							CHARINDEX(@resource_pagelock_fileid_str, @line, @pos3) + 
							CHARINDEX(@owneridprocess_str, @line, @pos3) + 
							CHARINDEX(@waiteridprocess_str, @line, @pos3) +
							CHARINDEX(@exchange_pipe_str, @line, @pos3) +
							CHARINDEX(@exchange_port_str, @line, @pos3) + 
							CHARINDEX(@resource_objectlock_str, @line, @pos3) +
							CHARINDEX(@resource_rid_fileid_str, @line, @pos3) + 
							CHARINDEX(@ProcDatabaseId_str, @line, @pos3) +
							CHARINDEX(@inputbuf_str, @line, @pos3) + 
							CHARINDEX(@metadatalocksubresource_str, @line, @pos3) + 
							CHARINDEX(@intraquerydl_str, @line, @pos3) + 
							CHARINDEX(@iqdlNode_str, @line, @pos3) + 
							CHARINDEX(@iqdlPort_str, @line, @pos3) + 
							CHARINDEX(@iqdlResType_str, @line, @pos3) + 
							CHARINDEX(@iqdlSPID_str, @line, @pos3) + 
							CHARINDEX(@iqdlInputBuf_str, @line, @pos3) +
							CHARINDEX(@resource_applock_hash_str, @line, @pos3)
							

						IF @pos4 > 0
						BEGIN
							SET @processedline = 0
							IF CHARINDEX(@inputbuf_str, @line, @pos3) = @pos4
							BEGIN
								SET @processedline = 1
								--turn on inputbuffer processing
								UPDATE dbo.deadlock
									SET is_processing_inputbuf = 1
									WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid
								
								--IF @lineno < @debug_lines
								--BEGIN
								--	PRINT 'IBP+' + @line
								--END
							END
							ELSE
							BEGIN
								--turn off inputbuffer processing
								UPDATE dbo.deadlock
									SET is_processing_inputbuf = 0
									WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid

								--IF @lineno < @debug_lines
								--BEGIN
								--	PRINT 'IBP-' + STR(@pos4) + ': ' + @line
								--END							
							END

							IF (CHARINDEX(@ProcDatabaseId_str, @line, @pos3) = @pos4)-- AND (CHARINDEX(@iqdlInputBuf_str, @line, @pos3) = 0)
							BEGIN
								--PRINT 'ipbproc'
								SET @processedline = 1
								exec dbo.deadlock_parse_input_buf_proc @importfileid, @lineno, @line, @linespid, @pos4, @ProcDatabaseId_len, @ProcDatabaseId_sub, @debug_lines
							END

							IF CHARINDEX(@deadlockvictimprocess_str, @line, @pos3) = @pos4
							BEGIN
								SET @processedline = 1
								exec dbo.deadlock_parse_victim @importfileid, @lineno, @line, @linespid, @pos4, @deadlockvictimprocess_len, @linedate, @debug_lines
							END

							IF CHARINDEX(@frameprocname_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'frameproc'
								SET @processedline = 1
								exec dbo.deadlock_parse_tsql_frame @importfileid, @lineno, @line, @linespid, @pos4, @frameprocname_len, @frameprocname_sub, @debug_lines
							END

							IF CHARINDEX(@owneridprocess_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'owner'
								SET @processedline = 1
								exec dbo.deadlock_parse_waiterowner @importfileid, @lineno, @line, @linespid, @pos4, @owneridprocess_len, @owneridprocess_sub, 0, @linedate, @debug_lines
							END

							IF CHARINDEX(@waiteridprocess_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'waiter'
								SET @processedline = 1
								exec dbo.deadlock_parse_waiterowner @importfileid, @lineno, @line, @linespid, @pos4, @waiteridprocess_len, @waiteridprocess_sub, 1, @linedate, @debug_lines
							END

							IF CHARINDEX(@processidprocess_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'processid'
								SET @processedline = 1
								exec dbo.deadlock_parse_process @importfileid, @lineno, @line, @linespid, @pos4, @processidprocess_len, @processidprocess_sub, @debug_lines
							END

							IF CHARINDEX(@exchange_port_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'exchport'
								SET @processedline = 1
								exec dbo.deadlock_parse_exchangetype @importfileid, @lineno, @line, @linespid, @pos4, @exchange_port_len, @exchange_port_sub, @resource_exchangeport_str, @debug_lines
							END

							IF CHARINDEX(@exchange_pipe_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'exchpipe'
								SET @processedline = 1
								exec dbo.deadlock_parse_exchangetype @importfileid, @lineno, @line, @linespid, @pos4, @exchange_pipe_len, @exchange_pipe_sub, @resource_exchangepipe_str, @debug_lines
							END

							IF CHARINDEX(@resource_rid_fileid_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'rid'
								SET @processedline = 1
								exec dbo.deadlock_parse_lock_rid @importfileid, @lineno, @line, @linespid, @pos4, @resource_rid_fileid_len, @resource_rid_fileid_sub, @resource_rid_str, @debug_lines
							END

							IF CHARINDEX(@resource_keylock_hobtid_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'key'
								SET @processedline = 1
								exec dbo.deadlock_parse_lock_key @importfileid, @lineno, @line, @linespid, @pos4, @resource_keylock_hobtid_len, @resource_keylock_hobtid_sub, @resource_key_str, @debug_lines
							END

							IF CHARINDEX(@resource_pagelock_fileid_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'page'
								SET @processedline = 1
								exec dbo.deadlock_parse_lock_page @importfileid, @lineno, @line, @linespid, @pos4, @resource_pagelock_fileid_len, @resource_pagelock_fileid_sub, @resource_pag_str, @debug_lines
							END

							IF CHARINDEX(@resource_objectlock_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'obj'
								SET @processedline = 1
								exec dbo.deadlock_parse_lock_object @importfileid, @lineno, @line, @linespid, @pos4, @objectlock_len, @objectlock_sub, @resource_object_str, @debug_lines
							END

							IF CHARINDEX(@resource_applock_hash_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'app'
								SET @processedline = 1
								exec dbo.deadlock_parse_lock_app @importfileid, @lineno, @line, @linespid, @pos4, @applock_hash_len, @applock_hash_sub, @resource_app_str, @debug_lines
							END

							IF CHARINDEX(@metadatalocksubresource_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'metadata'
								SET @processedline = 1
								exec dbo.deadlock_parse_lock_metadata @importfileid, @lineno, @line, @linespid, @pos4, @metadatalocksubresource_len, @metadatalocksubresource_sub, @resource_metadata_str, @debug_lines
							END

							IF CHARINDEX(@intraquerydl_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'iqdl'
								SET @processedline = 1
								exec dbo.deadlock_parse_iq @importfileid, @lineno, @line, @linespid, @pos4, @iqdlNode_len, @iqdlNode_str, @linedate, @debug_lines
							END

							IF CHARINDEX(@iqdlNode_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'iqNode'
								SET @processedline = 1
								exec dbo.deadlock_parse_iq_dl_node @importfileid, @lineno, @line, @linespid, @pos4, @iqdlNode_len, @iqdlNode_str, @iqdlNode_str, @debug_lines
							END

							IF CHARINDEX(@iqdlPort_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'iqport'
								SET @processedline = 1
								exec dbo.deadlock_parse_iq_dl_port @importfileid, @lineno, @line, @linespid, @pos4, @iqdlPort_len, @iqdlPort_sub, @iqdlPort_str, @debug_lines
							END
							
							IF CHARINDEX(@iqdlResType_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'iqres'
								SET @processedline = 1
								exec dbo.deadlock_parse_iq_dl_res_type @importfileid, @lineno, @line, @linespid, @pos4, @iqdlResType_len, @iqdlResType_sub, @iqdlResType_str, @debug_lines
							END

							IF CHARINDEX(@iqdlSPID_str, @line, @pos3) = @pos4
							BEGIN
								--PRINT 'iqspid'
								SET @processedline = 1
								exec dbo.deadlock_parse_iq_dl_spid @importfileid, @lineno, @line, @linespid, @pos4, @iqdlSPID_len, @iqdlSPID_sub, @iqdlSPID_str, @debug_lines
							END
							
							IF CHARINDEX(@iqdlInputBuf_str, @line, @pos3) > 0
							BEGIN
								--PRINT 'iqinputbuf'
								SET @processedline = 1
								SET @pos4 = CHARINDEX(@iqdlInputBuf_str, @line, @pos3)
								exec dbo.deadlock_parse_iq_dl_input_buf @importfileid, @lineno, @line, @linespid, @pos4, @iqdlInputBuf_len, @iqdlInputBuf_sub, @iqdlInputBuf_str, @debug_lines
							END


							--this needs to be last check
							IF @processedline = 0
							BEGIN
								PRINT 'Not Processed:' + STR(@lineno)+ STR(@pos4) + ': ' + @line
							END
						END
						ELSE
						BEGIN
							--test for input buffer
							IF @linespid IS NOT NULL
							BEGIN
								--check IF ingnored deadlock line
								SET @pos4 = 
									CHARINDEX(@deadlockvictimprocess_str, @line, @pos3) + 
									CHARINDEX(@deadlocklist_str, @line, @pos3) +
									CHARINDEX(@processlist_str, @line, @pos3) +
									CHARINDEX(@executionStack_str, @line, @pos3) +
									CHARINDEX(@resourcelist_str, @line, @pos3) +
									CHARINDEX(@ownerlist_str, @line, @pos3) +
									CHARINDEX(@waiterlist_str, @line, @pos3)
	
								IF @pos4 = 0
								BEGIN
									exec dbo.deadlock_parse_input_buf_adhoc @importfileid, @lineno, @line, @linespid, @pos3, 0, 0, @debug_lines
								END
								ELSE
								BEGIN
									--turn off inputbuffer processing
									UPDATE dbo.deadlock
										SET is_processing_inputbuf = 0
										WHERE spid = @linespid AND is_complete = 0 AND deadlock_file_id = @importfileid
									
									--IF @lineno < @debug_lines
									--BEGIN
									--	PRINT 'IBP-' + @line
									--END	
								END
							END
						END
					END
				END
			END
			ELSE
			BEGIN
				--handle later
				SET @ignore_count = @ignore_count + 1
			END

			SET @lineno = @lineno + 1
			SET @pos1 = @pos2 + @lineseparator_len
			SET @pos2 = CHARINDEX(@lineseparator, @data, @pos1)
		END	
	END
	PRINT 'Line count=' + STR(@lineno)

	SELECT @min_dl = MIN(deadlock_id), @max_dl = MAX(deadlock_id) FROM dbo.deadlock WHERE deadlock_file_id = @importfileid

	UPDATE dbo.deadlock_file
		set	first_deadlock_id = @min_dl,
			last_deadlock_id = @max_dl,
			line_count = @lineno,
			duration_in_sec = DATEDIFF(SECOND, start_time, GETDATE())
		WHERE deadlock_file_id = @importfileid
	
	IF exists (SELECT 1 FROM dbo.deadlock_file WHERE deadlock_file_id = @importfileid AND active_deadlocks > 0)
	BEGIN
		RAISERROR('File did not contain all completed deadlocks',11,1)
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_victim]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_victim') is null exec('create procedure [dbo].[deadlock_parse_victim] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_victim]
*
*	Purpose: Parse line for deadlock victim
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@linedate : REQUIRED - datetime of line to associate with deadlock
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_victim
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@linedate datetime,
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	PRINT STR(@lineno) + ' ' + @line

	DECLARE @deadlock_id int
	DECLARE @process_id varchar(16)

	--2016-11-21 14:28:11.64 spid29s      deadlock victim=process3a4df12188

	SET @process_id = RTRIM(SUBSTRING(@line, @pos + @str_len, LEN(@line)))

	BEGIN TRAN
	INSERT dbo.deadlock (deadlock_file_id, is_complete, is_database_xml, is_intraquery, spid, start_time, end_time, process_count, waiter_count, resource_count, victim, is_processing_inputbuf) 
		VALUES (@importfileid, 0, 0, 0, @linespid, @linedate, '1900-01-01', 0, 0, 0, @process_id, 0)
	
	UPDATE dbo.deadlock_file
		SET active_deadlocks = active_deadlocks + 1
		WHERE deadlock_file_id = @importfileid

	IF EXISTS(SELECT 1 FROM dbo.deadlock_file WHERE deadlock_file_id = @importfileid AND active_deadlocks > max_active_deadlocks)
	BEGIN
		UPDATE dbo.deadlock_file
			SET max_active_deadlocks = active_deadlocks,
				max_active_deadlocks_dt = @linedate
			WHERE deadlock_file_id = @importfileid
	END
	COMMIT TRAN
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_wait_resource]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_wait_resource') is null exec('create procedure [dbo].[deadlock_parse_wait_resource] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_wait_resource]
*
*	Purpose: Parse line for deadlock process wait_resource
*
*	Inputs:	
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
TODO MIKE
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_wait_resource
(
	@parse_val tinyint = NULL,
	@waitresource varchar(100) OUTPUT,
	@wr_type varchar(15) = NULL OUTPUT,
	@wr_dbid int = -1 OUTPUT,
	@wr_hobt bigint = -1 OUTPUT,
	@wr_hash varchar(20) = NULL OUTPUT,
	@wr_fileid int = -1 OUTPUT,
	@wr_pageid int = -1 OUTPUT,
	@wr_objid int = -1 OUTPUT,
	@wr_indid smallint = -1 OUTPUT,
	@wr_schid int = -1 OUTPUT,
	@wr_rid smallint = -1 OUTPUT
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len tinyint = 0
	DECLARE @str_len_old tinyint = 0
	DECLARE @str_type tinyint
	DECLARE @str_type_old tinyint
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos int
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)
	DECLARE @wr_wr varchar(100)

	DECLARE @wr_strings tinyint

	IF @parse_val IS NULL
	BEGIN
		SELECT --@processidprocess_str = mystr, @processidprocess_len = mylen, 
			@parse_val = childstype FROM dbo.deadlock_parse_strings WHERE stype = 2 AND typeid = 2
	END

	SELECT @wr_strings = childstype FROM dbo.deadlock_parse_strings WHERE stype = @parse_val AND mystr = 'waitresource='

	--PRINT @waitresource
	--PRINT '@wr_strings=' + STR(@wr_strings)

	--initialize values to defaults
	SET	@wr_type = NULL
	SET	@wr_dbid = -1
	SET	@wr_hobt = -1
	SET	@wr_hash = NULL
	SET	@wr_fileid = -1
	SET	@wr_pageid = -1
	SET	@wr_objid = -1
	SET	@wr_indid = -1
	SET	@wr_schid = -1
	SET	@wr_rid = -1

	SET @str_index = 0
	SET @str_index_old = 0
	SET @infinite_loop_protection = 0
	SET @pos = 0

	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen, @str_type = childstype
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @wr_strings AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'D ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @waitresource, @pos + 1)
				
			--PRINT 'E ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)

			IF @pos2 > 0
			BEGIN
				break
			END
		END

		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
		
	--PRINT 'F ' + @str + STR(@str_len) + STR(@str_type)

	IF CHARINDEX(@str, @waitresource) > 0
	BEGIN
		--parse waitresource
		SET @wr_type = LEFT(@str, @str_len - 1)

		--IF @lineno < @debug_lines
		--BEGIN
		--	PRINT @wr_type
		--END

		SET @pos = CHARINDEX(@str, @waitresource)
		SET @str_index = 0
		SET @str_index_old = 0
		SET @str_len_old = @str_len
		SET @infinite_loop_protection = 0

		SET @colid = 1
		SET @infinite_loop_protection = 0
		WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
		BEGIN
			SET @str_index = NULL
			SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
				FROM dbo.deadlock_parse_strings 
				WHERE stype = @str_type AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
			--PRINT 'G ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

			IF @str_index IS NOT NULL
			BEGIN
				SET @pos2 = CHARINDEX(@str, @waitresource, @pos + @str_len_old)
				--PRINT 'H ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
				IF @pos2 > 0
				BEGIN
					SET @tdata = RTRIM(SUBSTRING(@waitresource, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

					--IF @lineno < @debug_lines
					--BEGIN
					--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
					--END

					IF @wr_type = 'KEY' --MIKEZ find way to not hard code this
					BEGIN 
						IF @colid = 1
							SET @wr_dbid = @tdata
						IF @colid = 2
							SET @wr_hobt = @tdata
						IF @colid = 3
							SET @wr_hash = @tdata
					END

					IF @wr_type = 'PAGE'
					BEGIN 
						IF @colid = 1
							SET @wr_dbid = @tdata
						IF @colid = 2
							SET @wr_fileid = @tdata
						IF @colid = 3
							SET @wr_pageid = @tdata
					END

					--waitresource=OBJECT: 2:629577281:0
					IF @wr_type = 'OBJECT'
					BEGIN 
						IF @colid = 1
							SET @wr_dbid = @tdata
						IF @colid = 2
							SET @wr_objid = @tdata
						IF @colid = 3
							SET @wr_indid = @tdata
					END

					IF @wr_type = 'RID'
					BEGIN 
						IF @colid = 1
							SET @wr_dbid = @tdata
						IF @colid = 2
							SET @wr_fileid = @tdata
						IF @colid = 3
							SET @wr_pageid = @tdata
						IF @colid = 4
							SET @wr_rid = @tdata
					END

					--waitresource=APPLICATION: 2:0:[MyAppLock]:(6731eaf3)
					IF @wr_type = 'APPLICATION'
					BEGIN 
						IF @colid = 1
							SET @wr_dbid = @tdata
						IF @colid = 2
							SET @wr_schid = @tdata
						IF @colid = 3
							SET @wr_wr = @tdata
						IF @colid = 4
							SET @wr_hash = @tdata
					END

					IF @wr_type = 'METADATA'
					BEGIN 
						IF @colid = 2
							SET @wr_dbid = @tdata
						IF @colid = 3
							SET @wr_schid = @tdata
					END

					SET @colid = @colid + 1
					SET @str_len_old = @str_len
					SET @pos = @pos2
				END
			END

			SET @str_index_old = @str_index
			SET @infinite_loop_protection = @infinite_loop_protection + 1
		END
		--PRINT 'I ' + STR(@pos) + STR(@pos2) + STR(@str_len_old) + ' ' + @wr_type
		SET @tdata = RTRIM(SUBSTRING(@waitresource, @pos + @str_len_old, len(@waitresource)))
		--PRINT @tdata

		IF @wr_type = 'KEY' --MIKEZ find way to not hard code this
		BEGIN 
			IF @colid = 1
				SET @wr_dbid = @tdata
			IF @colid = 2
				SET @wr_hobt = @tdata
			IF @colid = 3
				SET @wr_hash = @tdata
		END

		IF @wr_type = 'PAGE'
		BEGIN 
			IF @colid = 1
				SET @wr_dbid = @tdata
			IF @colid = 2
				SET @wr_fileid = @tdata
			IF @colid = 3
				SET @wr_pageid = @tdata
		END

		IF @wr_type = 'OBJECT'
		BEGIN 
			IF @colid = 1
				SET @wr_dbid = @tdata
			IF @colid = 2
				SET @wr_objid = @tdata
			IF @colid = 3
				SET @wr_indid = @tdata
		END

		IF @wr_type = 'RID'
		BEGIN 
			IF @colid = 1
				SET @wr_dbid = @tdata
			IF @colid = 2
				SET @wr_fileid = @tdata
			IF @colid = 3
				SET @wr_pageid = @tdata
			IF @colid = 4
				SET @wr_rid = @tdata
		END

		--waitresource=APPLICATION: 2:0:[MyAppLock]:(6731eaf3)
		IF @wr_type = 'APPLICATION'
		BEGIN 
			IF @colid = 1
				SET @wr_dbid = @tdata
			IF @colid = 2
				SET @wr_schid = @tdata
			IF @colid = 3
				SET @wr_wr = @tdata
			IF @colid = 4
				SET @wr_hash = @tdata
		END

		IF @wr_type = 'METADATA'
		BEGIN 
			IF @colid = 2
				SET @wr_dbid = @tdata
			IF @colid = 3
				SET @wr_schid = @tdata
		END

		IF @wr_type != 'APPLICATION'
		BEGIN
			SET @waitresource = '' --use empty string instead of NULL so we know it wAS parsed sucessfully
		END
		ELSE
		BEGIN
			SET @waitresource = @wr_wr
		END
	END

	--PRINT @wr_type + STR(@wr_dbid) + STR(@wr_fileid) + STR(@wr_pageid)
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlock_parse_waiterowner]',10,1) WITH NOWAIT;
if object_id('dbo.deadlock_parse_waiterowner') is null exec('create procedure [dbo].[deadlock_parse_waiterowner] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_parse_waiterowner]
*
*	Purpose: Parse line for deadlock resource waiter or owner
*
*	Inputs:	
*		@importfileid : REQUIRED - deadlock_file_id value used for inserts
*		@lineno : REQUIRED - line number of file being parsed
*		@line : REQUIRED - line of file being parsed
*		@linespid : REQUIRED - spid of line of file being parsed
*		@pos : REQUIRED - offset of start of actual data in line (i.e. first non-space past spid)
*		@str_len : REQUIRED - length of line
*		@parse_val : REQUIRED - index into deadlock_parse_strings table so hard coded values not used
*		@is_waiter : REQUIRED - 1=owner, 0= waiter
*		@dt : REQUIRED - datetime of line to close out deadlock
*		@debug_lines : OPTIONAL - used for debug output
*
*	Notes: None
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlock_parse_waiterowner
(
	@importfileid smallint,
	@lineno int,
	@line varchar(8000),
	@linespid int,
	@pos int,
	@str_len int,
	@parse_val tinyint,
	@is_waiter tinyint,
	@dt datetime,
	@debug_lines int
)
WITH ENCRYPTION
AS
BEGIN
	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT @line
	--END

	DECLARE @deadlock_id int
	DECLARE @process_id varchar(16)

	DECLARE @sbid int
	DECLARE @ecid int
	DECLARE @checksum binary(8)
	DECLARE @checksum_str varchar(8000)
	DECLARE @wr_type varchar(15)
	DECLARE @wr_dbid int
	DECLARE @wr_hobt bigint
	DECLARE @wr_fileid int
	DECLARE @wr_objid int
	DECLARE @wr_indid smallint

	DECLARE @lock_mode varchar(8) = '' --need column in pk AND cant have nulls
	DECLARE @waiter_request_type varchar(10)

	DECLARE @process_count smallint
	DECLARE @waiter_count smallint

	DECLARE @resource_id int

	DECLARE @is_missing_request_type tinyint = 0

	DECLARE @str varchar(25)
	DECLARE @str_index smallint = 0
	DECLARE @str_index_old smallint = 0
	DECLARE @str_len_old tinyint = @str_len
	DECLARE @infinite_loop_protection tinyint
	DECLARE @colid tinyint = 1
	DECLARE @colidcurrent tinyint = 1
	DECLARE @pos2 int
	DECLARE @tdata varchar(8000)
	DECLARE @msg varchar(500)
	DECLARE @active_dls smallint

--2016-11-21 14:09:38.21 spid15s          waiter id=process689d868 mode=X request_type=wait
--2016-11-21 14:28:06.64 spid16s          waiter id=process5591e40cf8
--2016-11-21 14:28:11.64 spid15s          owner id=process3a4df12188 mode=S request_type=wait
--2016-11-21 14:09:38.21 spid15s          owner id=process689d868 mode=X

	--parse process id 
	SET @infinite_loop_protection = 0
	WHILE @str_index IS NOT NULL AND @infinite_loop_protection < 255
	BEGIN
		SET @str_index = NULL
		SELECT TOP 1 @str_index = deadlock_parse_strings_id, @str = mystr, @str_len = mylen 
			FROM dbo.deadlock_parse_strings 
			WHERE stype = @parse_val AND deadlock_parse_strings_id > @str_index_old ORDER BY deadlock_parse_strings_id
		
		--PRINT 'A ' + STR(@infinite_loop_protection) + STR(isnull(@str_index,0))

		IF @str_index IS NOT NULL
		BEGIN
			SET @pos2 = CHARINDEX(@str, @line, @pos)
			--PRINT 'B ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
			IF @pos2 > 0
			BEGIN
				SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, @pos2 - @pos - @str_len_old))

				--IF @lineno < @debug_lines
				--BEGIN
				--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
				--END

				IF @colid = 1
					SET @process_id = @tdata
				IF @colid = 2
					SET @lock_mode = @tdata
				IF @colid = 3
					SET @waiter_request_type = @tdata

				SET @colid = @colidcurrent + 1
				SET @str_len_old = @str_len
				SET @pos = @pos2
			END
		END

		SET @colidcurrent = @colidcurrent + 1
		SET @str_index_old = @str_index
		SET @infinite_loop_protection = @infinite_loop_protection + 1
	END
	--PRINT 'C ' + STR(@pos) + STR(@pos2) + STR(@str_len_old)
	SET @tdata = RTRIM(SUBSTRING(@line, @pos + @str_len_old, LEN(@line)))

	--IF @lineno < @debug_lines
	--BEGIN
	--	PRINT STR(@colid) +STR(@colidcurrent) + ': ' +@tdata
	--END

	IF @colid = 1
		SET @process_id = @tdata
	IF @colid = 2
		SET @lock_mode = @tdata
	IF @colid = 3
		SET @waiter_request_type = @tdata

--	SELECT @process_id, @waiter_mode, @waiter_request_type

	--get deadlock AND counts 
	SELECT @deadlock_id = deadlock_id, @process_count = process_count, @waiter_count = waiter_count
		FROM dbo.deadlock 
		WHERE spid = @linespid AND is_complete = 0

	--get latest resource for deadlock
	SELECT @resource_id = MAX(deadlock_resource_id) FROM dbo.deadlock_resource WHERE deadlock_id = @deadlock_id
	
	IF @resource_id IS NULL
	BEGIN
		SET @msg = 'WARNING: waiterowner Missing resource_id:' + @line
		RAISERROR(@msg,11,1)
		INSERT dbo.deadlock_parse_error VALUES (@deadlock_id, NULL, NULL, @msg)
	END
	ELSE
	BEGIN
--key is deadlock_id, resource_id, process_id, lock_mode
		IF @is_waiter = 1
		BEGIN
			--get process wait resource
			SELECT TOP 1 @wr_type = wr_type, @wr_dbid = wr_dbid, @wr_hobt = wr_hobt, @wr_fileid = wr_fileid, @wr_objid = wr_objid,
					@wr_indid = wr_indid, @sbid = sbid, @ecid = ecid
				FROM dbo.deadlock_process 
				WHERE deadlock_id = @deadlock_id
					and process_id = @process_id

			BEGIN TRAN

			IF NOT EXISTS (SELECT 1 FROM dbo.deadlock_waiter 
				WHERE deadlock_id = @deadlock_id AND resource_id = @resource_id AND process_id = @process_id AND lock_mode = @lock_mode)
			BEGIN
				INSERT dbo.deadlock_waiter VALUES (@deadlock_id, @resource_id, @process_id, @is_waiter, @lock_mode, 1, @waiter_request_type)
			END
			ELSE
			BEGIN
				UPDATE dbo.deadlock_waiter
					SET item_count = item_count + 1
					WHERE deadlock_id = @deadlock_id AND resource_id = @resource_id AND process_id = @process_id AND lock_mode = @lock_mode
			END

			IF @process_count = @waiter_count + 1
			BEGIN
				--IF waiter count = process count close deadlock AND decrement active deadlocks
				BEGIN TRAN
				UPDATE dbo.deadlock
					SET waiter_count = waiter_count + 1,
						last_process_seen = @process_id,
						is_complete = 1,
						end_time = @dt
					WHERE deadlock_id = @deadlock_id

				UPDATE dbo.deadlock_file
					SET active_deadlocks = active_deadlocks - 1,
						@active_dls = active_deadlocks
					WHERE deadlock_file_id = @importfileid

				IF @active_dls < 0
				BEGIN
					SET @msg = 'Active deadlocks < 0: Value=' + LTRIM(STR(@active_dls)) + ' at ' + convert(varchar(23), @dt, 126)
					RAISERROR(@msg,11,1) with nowait
				END
				COMMIT TRAN
			END
			ELSE
			BEGIN
				--increment waiter count
				UPDATE dbo.deadlock
					SET waiter_count = waiter_count + 1,
						last_process_seen = @process_id
					WHERE deadlock_id = @deadlock_id
			END
			COMMIT TRAN
		END
		ELSE
		BEGIN
			BEGIN TRAN

			IF NOT EXISTS (SELECT 1 FROM dbo.deadlock_waiter 
				WHERE deadlock_id = @deadlock_id AND resource_id = @resource_id AND process_id = @process_id AND lock_mode = @lock_mode)
			BEGIN
				INSERT dbo.deadlock_waiter VALUES (@deadlock_id, @resource_id, @process_id, @is_waiter, @lock_mode, 1, @waiter_request_type)
			END
			ELSE
			BEGIN
				UPDATE dbo.deadlock_waiter
					SET item_count = item_count + 1
					WHERE deadlock_id = @deadlock_id AND resource_id = @resource_id AND process_id = @process_id AND lock_mode = @lock_mode
			END

			COMMIT TRAN
		END
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[deadlocks_xe_xml_shred]',10,1) WITH NOWAIT;
if object_id('dbo.deadlocks_xe_xml_shred') is null exec('create procedure [dbo].[deadlocks_xe_xml_shred] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[deadlock_xe_xml_shred]
*
*	Purpose: Parse extended event file(s) for xml_deadlock_report events based on name pattern
*
*	Inputs:	
*		@filename : REQUIRED - filename pattern of extended event file to look for xml_deadlock_reports
*		@parse_all : OPTIONAL - 0=don't process both xml_deadlock_report and database_xml_deadlock_report, 1=process both type
*		@debug : OPTIONAL - used for extra output or specifying a deadlock to look at xml for
*
*	Notes:
*		1. This is designed to take a name pattern and parse all files with that pattern and if executed again pick up where it left off
*		2. Running stored procedure as RPC will generate different process/deadlock checksums than as Language event
*		3. For addtional information on parsing and deadlock categorization, please see parse_deadlocks_xe_readme.txt
*
*	Possible bugs to look for and contact Mike about:
*		1. If any errors encountered
*		2. If dbo.deadlock table has non-zero value in xml_parse_error column or (xml_deadlock column actually contains XML formatted data of the deadlock)
*
*	TODO:
*		1. Parse other resource types besides key, rid, object, page, application
*		2. implement performance tracking of parsing
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.deadlocks_xe_xml_shred
(
	@filename varchar(512) = NULL,
	@parse_all tinyint = 0,
	@debug tinyint = 0
)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @deadlock_file_id int
	DECLARE @is_file_complete bit
	DECLARE @file_start_time datetime
	--DECLARE @min_dl_dt datetime
	DECLARE @is_database_xml bit
	DECLARE @data xml
	DECLARE @file_offset bigint
	DECLARE @event_file varchar(512)
	DECLARE @event_file_prev varchar(512)

	DECLARE @deadlock_count int
	DECLARE @db_deadlock_count int
	DECLARE @xe_obj_name varchar(128)

	DECLARE @deadlock_id int = 0
	DECLARE @process_id varchar(16)
	DECLARE @start_time datetime
	DECLARE @end_time datetime
	DECLARE @victim varchar(16)
	DECLARE @process_count int
	DECLARE @waiter_count int
	DECLARE @resource_count int

	DECLARE @id int
	DECLARE @process_id_last varchar(16)
	DECLARE @frameid tinyint

	DECLARE @min_dl int
	DECLARE @max_dl int
	DECLARE @importfileid smallint

	DECLARE @waitresource varchar(100)
	DECLARE @wr_type varchar(15)
	DECLARE @wr_dbid int
	DECLARE @wr_hobt bigint
	DECLARE @wr_hash varchar(20)
	DECLARE @wr_fileid int
	DECLARE @wr_pageid int
	DECLARE @wr_objid int
	DECLARE @wr_indid smallint
	DECLARE @wr_schid int
	DECLARE @wr_rid smallint
	DECLARE @inputbuf varchar(8000)
	DECLARE @pos int
	DECLARE @ProcDatabaseId_len				tinyint
	DECLARE @ProcDatabaseId_str				varchar(25)
	DECLARE @ProcDatabaseId_sub				tinyint

	DECLARE @fUpdatedDeadlock bit 

	DECLARE @database_count int --type=2, re=102, oe=202, we=222
	DECLARE @file_count int --type=3, re=103, oe=203, we=223
	DECLARE @index_count int --type=4, re=104, oe=204, we=224
	DECLARE @object_count int --type=5, re=105, oe=205, we=225
	DECLARE @page_count int --type=6, re=106, oe=206, we=226
	DECLARE @key_count int --type=7, re=107, oe=207, we=227
	DECLARE @extent_count int --type=8, re=108, oe=208, we=228
	DECLARE @rid_count int --type=9, re=109, oe=209, we=229
	DECLARE @app_count int --type=10, re=110, oe=210, we=230
	DECLARE @metadata_count int --no type?, re=111, oe=211, we=231
	DECLARE @port_count int --no type?, re=112, oe=212, we=232
	DECLARE @node_count int --no type?, re=113, oe=213, we=233

	DECLARE @lockid varchar(16)
	DECLARE @resourceid int

	DECLARE @error tinyint
	DECLARE @error_number int
	DECLARE @error_severity int
	DECLARE @error_message varchar(1000)
	DECLARE @error_parser varchar(20)

	DECLARE @TODO tinyint --look for code that needs to be implemented

	CREATE TABLE #FileExists
	(
		DoesExist	SMALLINT,
		FileInDir	SMALLINT,
		DirExist	SMALLINT
	)

	CREATE TABLE #TSQLFrame
	(
		processid varchar(16) NOT NULL,
		sbid int NOT NULL,
		proc_name sysname NULL,
		[line] int NULL,
		stmt_start bigint NULL,
		stmt_end bigint NULL,
		[sql_handle] varchar(128) NULL,
		frame_id tinyint NULL,
		id int IDENTITY(1,1) not null
	)

	CREATE TABLE #OwnerWaiter
	(
		lockid varchar(16) NOT NULL,
		processid varchar(16) NOT NULL,
		mode varchar(8) NOT NULL,
		item_count tinyint NOT NULL,
		request_type varchar(10) NULL,
		resourceid int null
	)

	--check IF file exists
	--EXECUTE mASter.dbo.xp_fileexist 'C:\data\deadlocks_0_131533535717310000.xel'

	INSERT INTO #FileExists
		EXECUTE master.dbo.xp_fileexist @filename

	---- Query the temp table to see IF the directory exists
	IF NOT EXISTS (SELECT 1 FROM #FileExists WHERE DoesExist = 1 OR DirExist = 1)
	BEGIN
		PRINT 'File or directory (' + ISNULL(@filename, 'NULL') + ') does not exist.'
		RETURN -1
	END

	--SELECT * FROM #FileExists


	SELECT @ProcDatabaseId_str = mystr, @ProcDatabaseId_len = mylen, @ProcDatabaseId_sub = childstype
		FROM dbo.deadlock_parse_strings 
		WHERE stype = 2 AND typeid = 12

	--cursor over file(s) AND events
	DECLARE xe_cursor CURSOR FOR 
		SELECT file_offset,event_data, [file_name], [object_name]
			FROM sys.fn_xe_file_target_read_file(@filename,NULL, NULL, NULL)
			WHERE [object_name] IN ('xml_deadlock_report','database_xml_deadlock_report')

	OPEN xe_cursor

	FETCH NEXT FROM xe_cursor INTO @file_offset, @data, @event_file, @xe_obj_name

	SET @event_file_prev = ''
	WHILE @@FETCH_STATUS != -1
	BEGIN
		IF @event_file_prev != @event_file
		BEGIN
			IF @event_file_prev != '' AND @is_file_complete = 0
			BEGIN
				--close up prior file
				SELECT @min_dl = MIN(deadlock_id), @max_dl = MAX(deadlock_id) FROM dbo.deadlock WHERE deadlock_file_id = @deadlock_file_id

				UPDATE dbo.deadlock_file
					SET is_complete = 1,
						deadlock_count = ISNULL(deadlock_count, 0) + @deadlock_count,
						xml_database_deadlock_event_count = ISNULL(xml_database_deadlock_event_count, 0) + @db_deadlock_count,
						--file_size = NULL,
						first_deadlock_id = @min_dl,
						last_deadlock_id = @max_dl,
						--max_active_deadlocks = NULL,
						--max_active_deadlocks_dt = NULL,
						duration_in_sec = ISNULL(duration_in_sec, 0) + DATEDIFF(SECOND, @file_start_time, GETDATE())
					WHERE deadlock_file_id = @deadlock_file_id
			END

			SET @file_start_time = GETDATE()
			PRINT 'Event file=' + @event_file

			--check to see if exists
			SET @is_file_complete = NULL
			SELECT @is_file_complete = is_complete, @deadlock_file_id = deadlock_file_id  FROM dbo.deadlock_file WHERE [file_name] = @event_file

			IF @is_file_complete IS NULL
			BEGIN
				INSERT dbo.deadlock_file (is_complete, is_xel, fileid, start_time, active_deadlocks, [file_name])
					VALUES (0, 1, 255, @file_start_time, 0, @event_file)
				
				SET @is_file_complete = 0
				SET @deadlock_file_id = @@IDENTITY
			END

			SET @event_file_prev = @event_file
			SET @deadlock_count = 0
			SET @db_deadlock_count = 0
		END

		IF @is_file_complete = 0
		BEGIN
			SET @victim = NULL
			SET @start_time = NULL
			SET @end_time = NULL
			SET @error = 0

			BEGIN TRY
				SELECT TOP 1 @victim = SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16)
					FROM @data.nodes('/event/data/value/deadlock/victim-list/victimProcess') T(c)  
			END TRY
			BEGIN CATCH
				SET @error_number = ERROR_NUMBER()
				SET @error_severity = ERROR_SEVERITY()
				SET @error_message = ERROR_MESSAGE()
				SET @error_parser = 'victim'
				SET @error = 10
				PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
			END CATCH

			BEGIN TRY
				SELECT TOP 1 @start_time = T.c.value('(@timestamp)', 'datetime')
					FROM   @data.nodes('/event') T(c)  
			END TRY
			BEGIN CATCH
				SET @error_number = ERROR_NUMBER()
				SET @error_severity = ERROR_SEVERITY()
				SET @error_message = ERROR_MESSAGE()
				SET @error_parser = 'time'
				SET @error = 20
				PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
			END CATCH

			IF @xe_obj_name = 'database_xml_deadlock_report'
			BEGIN
				SET @is_database_xml  = 1
			END
			ELSE
			BEGIN
				SET @is_database_xml  = 0
			END

			--check for duplicate1
			IF NOT EXISTS(SELECT 1 FROM dbo.deadlock 
				WHERE deadlock_file_id = @deadlock_file_id 
					AND start_time = @start_time
					AND victim = @victim
					AND is_database_xml = @is_database_xml)
			BEGIN
				--PRINT STR(@file_offset) + ', size=' + STR(LEN(CONVERT(varchar(max),@data))) + ' vic=' + @victim + ' ' + @xe_obj_name

				--check for duplicate2
				IF @parse_all = 1
					OR NOT EXISTS(SELECT 1 FROM dbo.deadlock 
				WHERE deadlock_file_id = @deadlock_file_id 
					AND start_time = @start_time
					AND victim = @victim)
				BEGIN

					IF @is_database_xml  = 0
					BEGIN
						SET @deadlock_count = @deadlock_count + 1
					END
					ELSE
					BEGIN
						SET @db_deadlock_count = @db_deadlock_count + 1
					END

					--case statement allows for getting xml of perticular deadlock in file for debugging work
					INSERT dbo.deadlock (deadlock_file_id, is_complete, is_database_xml, is_intraquery, spid, start_time, end_time, process_count, waiter_count, resource_count, victim, is_processing_inputbuf, xml_parse_error, xml_deadlock)
						VALUES (@deadlock_file_id, 0, @is_database_xml, 0, -1, @start_time, @start_time, -1, -1, -1, @victim, 0, @error,
							CASE WHEN @debug = @deadlock_id + 1 THEN CONVERT(varchar(max),@data) ELSE @xe_obj_name END)
					SET @deadlock_id = @@IDENTITY

					--XML queries to break up deadlock
					--process
					BEGIN TRY
						SET @process_count = 0
						INSERT dbo.deadlock_process (deadlock_id, process_id, spid, sbid, ecid, task_priority, log_used, wait_resource, wait_time, ownerid, transaction_name, last_tran_started,
								xdes, lock_mode, scheduler_id, kpid, [status], [priority], tran_count, last_batch_started, last_batch_completed, last_attention, client_app, [host_name], host_pid, 
								login_name, iso_level_val, xactid, currentdb, [lock_timeout], client_option1, client_option2, inputbuf)
							SELECT @deadlock_id
									,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16)
									,T.c.value('(@spid)', 'int')-- AS spid
									,T.c.value('(@sbid)', 'int')-- AS sbid
									,T.c.value('(@ecid)', 'int')-- AS ecid
									,T.c.value('(@taskpriority)', 'smallint')-- AS taskpriority
									,T.c.value('(@logused)', 'bigint')-- AS logused
									,T.c.value('(@waitresource)', 'varchar(100)')-- AS waitresource --needs cleanup
									,T.c.value('(@waittime)', 'int')-- AS waittime
									,T.c.value('(@ownerId)', 'varchar(20)')-- AS ownerId
									,T.c.value('(@transactionname)', 'varchar(100)')-- AS transactionname
									,T.c.value('(@lasttranstarted)', 'datetime')-- AS lasttranstarted
									,T.c.value('(@XDES)', 'varchar(20)') --AS XDES
									,T.c.value('(@lockMode)', 'varchar(8)') --AS lockMode
									,T.c.value('(@schedulerid)', 'tinyint') --AS schedulerid
									,T.c.value('(@kpid)', 'bigint') --AS kpid
									,T.c.value('(@status)', 'varchar(32)') --AS status
									,T.c.value('(@priority)', 'smallint') --AS priority
									,T.c.value('(@trancount)', 'tinyint') --AS trancount
									,T.c.value('(@lastbatchstarted)', 'datetime') --AS lastbatchstarted
									,T.c.value('(@lastbatchcompleted)', 'datetime') --AS lastbatchcompleted
									,T.c.value('(@lastattention)', 'datetime') --AS lastattention
									,T.c.value('(@clientapp)', 'varchar(100)') --AS clientapp
									,T.c.value('(@hostname)', 'varchar(32)') --AS hostname
									,T.c.value('(@hostpid)', 'bigint') --AS hostpid
									,T.c.value('(@loginname)', 'varchar(100)') --AS loginname
									,SUBSTRING(T.c.value('(@isolationlevel)', 'varchar(100)'),CHARINDEX('(',T.c.value('(@isolationlevel)', 'varchar(100)')) + 1, 1) -- AS isolationlevel
									,T.c.value('(@xactid)', 'bigint') --AS xactid
									,T.c.value('(@currentdb)', 'int') --AS currentdb
									,T.c.value('(@lockTimeout)', 'bigint') --AS lockTimeout
									,T.c.value('(@clientoption1)', 'int') --AS clientoption1
									,T.c.value('(@clientoption2)', 'int') --AS clientoption2
									,T.c.value('(inputbuf[1])', 'varchar(8000)') --AS inputbuffer
								FROM @data.nodes('/event/data/value/deadlock/process-list/process') T(c)  
						SET @process_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'process'
						SET @error = 30
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					DECLARE process_cur CURSOR FOR
						SELECT process_id, wait_resource, inputbuf FROM dbo.deadlock_process WHERE deadlock_id = @deadlock_id

					OPEN process_cur

					FETCH NEXT FROM process_cur INTO @process_id, @waitresource, @inputbuf

					WHILE @@FETCH_STATUS != -1
					BEGIN
						--PRINT @waitresource
						EXEC dbo.deadlock_parse_wait_resource 
							@waitresource = @waitresource OUTPUT, 
							@wr_type = @wr_type OUTPUT,
							@wr_dbid = @wr_dbid OUTPUT,
							@wr_hobt = @wr_hobt OUTPUT,
							@wr_hash = @wr_hash OUTPUT,
							@wr_fileid = @wr_fileid OUTPUT,
							@wr_pageid = @wr_pageid OUTPUT,
							@wr_objid = @wr_objid OUTPUT,
							@wr_indid = @wr_indid OUTPUT,
							@wr_schid = @wr_schid OUTPUT,
							@wr_rid = @wr_rid OUTPUT

						--PRINT @wr_type + '|' + @waitresource + '|' + @wr_hash

						IF @waitresource = '' OR @wr_type = 'APPLICATION'
						BEGIN
							UPDATE dbo.deadlock_process
								SET wait_resource = @waitresource,
									wr_type = @wr_type,
									wr_dbid = @wr_dbid,
									wr_hobt = @wr_hobt,
									wr_hash = @wr_hash,
									wr_fileid = @wr_fileid,
									wr_pageid = @wr_pageid,
									wr_objid = @wr_objid,
									wr_indid = @wr_indid,
									wr_schid = @wr_schid,
									wr_rid = @wr_rid
								WHERE process_id = @process_id AND deadlock_id = @deadlock_id

							--debugging code: add resource types to IN list on next line AS shredding verified
							IF @fUpdatedDeadlock = 0 AND @wr_type NOT IN ('OBJECT','PAGE','KEY','RID','APPLICATION') -- 
							BEGIN
								UPDATE dbo.deadlock
									SET xml_parse_error = 255
										,xml_deadlock = CONVERT(varchar(max),@data)
									WHERE deadlock_id = @deadlock_id

								SET @fUpdatedDeadlock = 1
							END
						END

						--parse procs in inputbuf
						IF @inputbuf IS NOT NULL
						BEGIN
							SET @TODO = 1

							SET @pos = CHARINDEX(@ProcDatabaseId_str, @inputbuf)
							IF @pos != 0
							BEGIN
								EXEC dbo.deadlock_parse_input_buf_proc 
									@importfileid = -1,
									@lineno = 1,
									@line = @inputbuf,
									@linespid = 0,
									@pos = @pos,
									@str_len = @ProcDatabaseId_len,
									@parse_val = @ProcDatabaseId_sub,
									@debug_lines = 0,
									@xml_deadlock = @deadlock_id,
									@process_id = @process_id
							END
						END

						FETCH NEXT FROM process_cur INTO @process_id, @waitresource, @inputbuf
					END

					DEALLOCATE process_cur

					--tsql stack
					BEGIN TRY
						INSERT #TSQLFrame (processid, sbid, proc_name, [line], stmt_start, stmt_end, [sql_handle], frame_id)
							SELECT	SUBSTRING(T.c.value('(../../@id)', 'varchar(23)'),8,16) --AS processid
									,CASE WHEN T.c.value('(@sbid)', 'int') IS NOT NULL THEN T.c.value('(@sbid)', 'int') ELSE T.c.value('(../../@sbid)', 'int') END --AS sbid
									,T.c.value('(@procname)', 'sysname') --AS procname
									,T.c.value('(@line)', 'int') --AS line
									,T.c.value('(@stmtstart)', 'bigint') --AS stmtstart
									,T.c.value('(@stmtend)', 'bigint') --AS stmtend
									,T.c.value('(@sqlhandle)', 'varchar(76)') --AS sqlhandle --74+2
									,255 --AS frame_id
								FROM   @data.nodes('/event/data/value/deadlock/process-list/process/executionStack/frame') T(c)  
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'frame'
						SET @error = 40
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					SET @process_id_last = ''

					DECLARE tsql_frame_cursor CURSOR FOR
						SELECT id, processid 
							FROM #TSQLFrame
							ORDER BY processid, id

					OPEN tsql_frame_cursor
					FETCH NEXT FROM tsql_frame_cursor INTO @id, @process_id
					WHILE @@FETCH_STATUS != -1
					BEGIN
						IF @process_id != @process_id_last
						BEGIN
							SET @frameid = 0
						END

						UPDATE #TSQLFrame
							SET frame_id = @frameid
							where id = @id

						SET @process_id_last = @process_id
						SET @frameid = @frameid + 1
						FETCH NEXT FROM tsql_frame_cursor INTO @id, @process_id
					END

					DEALLOCATE tsql_frame_cursor

					BEGIN TRY
						INSERT dbo.deadlock_tsql_stack (deadlock_id, process_id, sbid, frame_id, proc_name, line, stmt_start, stmt_end, [sql_handle])
							SELECT @deadlock_id, processid, sbid,  frame_id, proc_name, line, stmt_start, stmt_end, [sql_handle]
								FROM #TSQLFrame
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'tsqlstkins'
						SET @error = 41
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
						SELECT * FROM #TSQLFrame
					END CATCH

					--resources

					--DATABASE
					BEGIN TRY
						SET @TODO = 1
						SET @database_count = 0
						--SET @database_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'database'
						SET @error = 102
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--FILE
					BEGIN TRY
						SET @TODO = 1
						SET @file_count = 0
						--SET @file_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'file'
						SET @error = 103
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--INDEX
					BEGIN TRY
						SET @TODO = 1
						SET @index_count = 0
						--SET @index_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'index'
						SET @error = 104
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--OBJECT
					BEGIN TRY
						SET @object_count =	0
						INSERT dbo.deadlock_resource (deadlock_id, [type], database_id, [object_id], lock_mode, sub_resource, [object_name], [address], lock)
							SELECT	DISTINCT
									@deadlock_id
									,'OBJECT'
									,T.c.value('(@dbid)', 'int') --AS dbid
									,T.c.value('(@objid)', 'int') --AS objid
									--,T.c.value('(@ASsociatedObjectId)', 'bigint') --AS ASsociatedObjectId --actually just object_id again
									,T.c.value('(@mode)', 'varchar(10)') --AS mode
									,T.c.value('(@subresource)', 'varchar(30)') --AS subresource
									,T.c.value('(@objectname)', 'varchar(500)') --AS objectname
									,T.c.value('(@lockPartition)', 'varchar(25)') --AS lockPartition --mikez bug WHERE should this be stored
									,SUBSTRING(T.c.value('(@id)', 'varchar(20)'),5,16) -- AS id --needs cleanup
								FROM   @data.nodes('/event/data/value/deadlock/resource-list/objectlock') T(c)  
						SET @object_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'object'
						SET @error = 105
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--PAGE
					BEGIN TRY
						SET @page_count = 0
						INSERT dbo.deadlock_resource (deadlock_id, [type], database_id, fileid, pageid, hobtId, lock_mode, sub_resource, [object_name], lock)
							SELECT	DISTINCT
									@deadlock_id
									,'PAGE'
									,T.c.value('(@dbid)', 'int') --AS dbid
									,T.c.value('(@fileid)', 'smallint') --AS fileid
									,T.c.value('(@pageid)', 'int') --AS pageid
									,T.c.value('(@ASsociatedObjectId)', 'bigint') --AS ASsociatedObjectId
									,T.c.value('(@mode)', 'varchar(10)') --AS mode
									,T.c.value('(@subresource)', 'varchar(30)') --AS subresource
									,T.c.value('(@objectname)', 'varchar(500)') --AS objectname
									,SUBSTRING(T.c.value('(@id)', 'varchar(20)'),5,16) --AS id
								FROM   @data.nodes('/event/data/value/deadlock/resource-list/pagelock') T(c)  
						SET @page_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'page'
						SET @error = 106
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--KEY
					BEGIN TRY
						SET @key_count = 0
						INSERT dbo.deadlock_resource (deadlock_id, [type], database_id, hobtId, lock_mode, [object_name], index_name, lock)
							SELECT	DISTINCT
									@deadlock_id
									,'KEY'
									,T.c.value('(@dbid)', 'int') --AS dbid
									,T.c.value('(@hobtid)', 'bigint') --AS hobtid
									,T.c.value('(@mode)', 'varchar(10)') --AS mode
									,T.c.value('(@objectname)', 'varchar(500)') --AS objectname
									,T.c.value('(@indexname)', 'varchar(500)') --AS indexname
									,SUBSTRING(T.c.value('(@id)', 'varchar(20)'),5,16) --AS id
								FROM   @data.nodes('/event/data/value/deadlock/resource-list/keylock') T(c)  
						SET @key_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'key'
						SET @error = 107
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--EXTENT
					BEGIN TRY
						SET @TODO = 1
						SET @extent_count = 0
						--SET @extent_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'extent'
						SET @error = 108
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--RID
					BEGIN TRY
						SET @rid_count = 0
						INSERT dbo.deadlock_resource (deadlock_id, [type], database_id, fileid, pageid, hobtId, lock_mode, [object_name], [lock])
							SELECT	DISTINCT
									@deadlock_id
									,'RID'
									,T.c.value('(@dbid)', 'int') --AS dbid
									,T.c.value('(@fileid)', 'int') --AS fileid
									,T.c.value('(@pageid)', 'int') --AS pageid
									,T.c.value('(@ASsociatedObjectId)', 'bigint') --AS ASsociatedObjectId
									,T.c.value('(@mode)', 'varchar(10)') --AS mode
									,T.c.value('(@objectname)', 'varchar(500)') --AS objectname
									,SUBSTRING(T.c.value('(@id)', 'varchar(20)'),5,16) -- AS id --needs cleanup
								FROM   @data.nodes('/event/data/value/deadlock/resource-list/ridlock') T(c)  
						SET @rid_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'rid'
						SET @error = 109
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--APP
					BEGIN TRY
						SET @app_count = 0
						INSERT dbo.deadlock_resource (deadlock_id, [type], database_id, [schema_id], sub_resource, lock_mode, [lock])
							SELECT	DISTINCT
									@deadlock_id
									,'APPLICATION'
									,T.c.value('(@dbid)', 'int') AS dbid
									,T.c.value('(@databasePrincipalId)', 'int') --AS [databasePrincipalId]
									,T.c.value('(@hash)', 'varchar(100)') --AS [hash]
									,T.c.value('(@mode)', 'varchar(10)') AS mode
									,SUBSTRING(T.c.value('(@id)', 'varchar(20)'),5,16) AS id --needs cleanup
							
								FROM   @data.nodes('/event/data/value/deadlock/resource-list/applicationlock') T(c) 
						SET @app_count = @@ROWCOUNT

						IF @app_count > 0
						BEGIN
							UPDATE r
								SET r.[address] = p.wr_hash,
									r.sub_resource = p.wait_resource
								FROM dbo.deadlock_resource r
									INNER JOIN dbo.deadlock_process p
										ON r.deadlock_id = p.deadlock_id
										AND r.deadlock_id = @deadlock_id
										AND r.[type] = p.wr_type
										AND p.wr_type = 'APPLICATION'
										AND r.sub_resource = p.wait_resource + p.wr_hash
						END
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'app'
						SET @error = 110
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--METADATA
			--metadatalock subresource=SCHEMA clASsid=schema_id = 25 dbid=14 lockPartition=0 id=lock92e71bd180 mode=Sch-S
					BEGIN TRY
						SET @TODO = 1
						SET @metadata_count = 0
						--SET @metadata_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'metadata'
						SET @error = 111
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--PORT?
			--Port: 0x00000093EDEBC8D0  Xid Slot: 7, Wait Slot: 3, TASk: 0x000000A9EC447468, (Producer), Exchange Wait Type: e_waitPipeNewRow, Merging: 1
					BEGIN TRY
						SET @TODO = 1
						SET @port_count = 0
						--SET @port_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'port'
						SET @error = 112
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

					--NODE?
					BEGIN TRY
						SET @TODO = 1
						SET @node_count = 0
						--SET @node_count = @@ROWCOUNT
					END TRY
					BEGIN CATCH
						SET @error_number = ERROR_NUMBER()
						SET @error_severity = ERROR_SEVERITY()
						SET @error_message = ERROR_MESSAGE()
						SET @error_parser = 'node'
						SET @error = 113
						PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
					END CATCH

			/*
			--resources
				deadlock_id int NOT NULL,
				[type] varchar(10) NOT NULL,
				[dbid] int NULL,
				fileid int NULL,
				pageid int NULL,
				rid smallint NULL,
				objectid int NULL,
				hobtId bigint NULL,
				schemaid int NULL,
				lock_mode varchar(8) NULL,
				lock varchar(25) NULL,
				subresource varchar(25) NULL,
				objectname varchar(255) NULL,
				indexname varchar(255) NULL,
				[address] varchar(16) NULL,
				waittype varchar(25) NULL,
				nodeid tinyint NULL,
				id int IDENTITY(1,1) NOT NULL,
			*/

					--BUG: Should @port_count, @node_count be added?
					SET @resource_count = @database_count + @file_count + @index_count + @object_count + @page_count +  @key_count + @extent_count + @rid_count + @app_count + @metadata_count + @port_count + @node_count

					--waiters/owner
					SET @waiter_count = 0
			
					IF @resource_count > 0 
					BEGIN
						TRUNCATE TABLE #OwnerWaiter

						IF @database_count > 0
						BEGIN
							BEGIN TRY
								SET @TODO = 1
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'databaseowner'
								SET @error = 202
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'databasewaiter'
								SET @error = 222
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @file_count > 0
						BEGIN
							BEGIN TRY
								SET @TODO = 1
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'fileowner'
								SET @error = 203
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'filewaiter'
								SET @error = 223
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @index_count > 0
						BEGIN
							BEGIN TRY
								SET @TODO = 1
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'indexowner'
								SET @error = 204
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'indexwaiter'
								SET @error = 224
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @object_count > 0
						BEGIN
							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') --AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/objectlock/owner-list/owner') T(c)
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'objectowner'
								SET @error = 205
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/objectlock/waiter-list/waiter') T(c)
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'objectwaiter'
								SET @error = 225
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @page_count > 0
						BEGIN
							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') --AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/pagelock/owner-list/owner') T(c)
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'pageowner'
								SET @error = 206
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/pagelock/waiter-list/waiter') T(c)
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'pagewaiter'
								SET @error = 226
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @key_count > 0
						BEGIN
							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') --AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/keylock/owner-list/owner') T(c)
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'keyowner'
								SET @error = 207
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/keylock/waiter-list/waiter') T(c)
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'keywaiter'
								SET @error = 227
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @extent_count > 0
						BEGIN
							BEGIN TRY
								SET @TODO = 1
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'extentowner'
								SET @error = 208
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'extentwaiter'
								SET @error = 228
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @rid_count > 0
						BEGIN
							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') --AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/ridlock/owner-list/owner') T(c)
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'ridowner'
								SET @error = 209
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/ridlock/waiter-list/waiter') T(c)
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'ridwaiter'
								SET @error = 229
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @app_count > 0
						BEGIN
							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') --AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/applicationlock/owner-list/owner') T(c)
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'appowner'
								SET @error = 210
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								INSERT #OwnerWaiter
									SELECT 
											SUBSTRING(T.c.value('(../../@id)', 'varchar(20)'), 5, 16) -- AS lockid
											,SUBSTRING(T.c.value('(@id)', 'varchar(23)'),8,16) --AS processid
											,T.c.value('(@mode)', 'varchar(10)') AS mode
											,0
											,T.c.value('(@request_type)', 'varchar(10)') --AS request_type
											,NULL
										FROM   @data.nodes('/event/data/value/deadlock/resource-list/applicationlock/waiter-list/waiter') T(c)
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'appwaiter'
								SET @error = 230
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @metadata_count > 0
						BEGIN
							BEGIN TRY
								SET @TODO = 1
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'metadataowner'
								SET @error = 211
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'metadatawaiter'
								SET @error = 231
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @port_count > 0
						BEGIN
							BEGIN TRY
								SET @TODO = 1
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'portowner'
								SET @error = 212
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'portwaiter'
								SET @error = 232
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						IF @node_count > 0
						BEGIN
							BEGIN TRY
								SET @TODO = 1
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'nodeowner'
								SET @error = 213
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH

							BEGIN TRY
								SET @waiter_count = @waiter_count + @@ROWCOUNT
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @error_parser = 'nodewaiter'
								SET @error = 233
								PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
							END CATCH
						END

						--mike, does this work for non resources? Not sure at this point
						-- find resourceid for all locks
						DECLARE ow_cursor CURSOR FOR 
							SELECT DISTINCT lockid FROM #OwnerWaiter

						OPEN ow_cursor
						FETCH NEXT FROM ow_cursor INTO @lockid

						WHILE @@FETCH_STATUS != -1
						BEGIN
							SET @resourceid = NULL
							SELECT TOP 1 @resourceid = deadlock_resource_id FROM dbo.deadlock_resource 
								WHERE deadlock_id = @deadlock_id AND lock = @lockid

							IF @resourceid IS NOT NULL
							BEGIN
								UPDATE #OwnerWaiter
									SET resourceid = @resourceid
									WHERE lockid = @lockid
							END

							FETCH NEXT FROM ow_cursor INTO @lockid
						END

						DEALLOCATE ow_cursor

						--debugging code --remove counts AS parsing verified
						IF	@database_count > 0
							OR @file_count > 0
							OR @index_count > 0
							OR @extent_count > 0
							OR @metadata_count > 0
							OR @port_count > 0
							OR @node_count > 0
						BEGIN
							SELECT @deadlock_id AS [deadlock],* from #OwnerWaiter
						END

						--add owners/waiters to deadlock_waiter
						BEGIN TRY
							INSERT dbo.deadlock_waiter
								SELECT DISTINCT
										@deadlock_id
										,resourceid
										,processid
										,CASE WHEN request_type IS NULL THEN 0 ELSE 1 END
										,mode
										,item_count
										,request_type
									FROM #OwnerWaiter
									WHERE resourceid IS NOT NULL
						END TRY
						BEGIN CATCH
							SET @error_number = ERROR_NUMBER()
							SET @error_severity = ERROR_SEVERITY()
							SET @error_message = ERROR_MESSAGE()
							SET @error_parser = 'ownerwaiter'
							SET @error = 240
							PRINT 'ERROR IN ' + @error_parser +' parser: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_number)) + ', Message=' + @error_message
						END CATCH
					END --IF @resource_count > 0 

					UPDATE dbo.deadlock 
						SET is_complete = 1
							, process_count = @process_count
							, waiter_count = @waiter_count
							, resource_count = @resource_count
							, xml_parse_error = CASE WHEN xml_parse_error != 255 THEN @error ELSE xml_parse_error END
							, xml_deadlock = CASE WHEN @error > 0 THEN CONVERT(varchar(max),@data) ELSE xml_deadlock END
						WHERE deadlock_id = @deadlock_id
				END --check for duplicate2
			END --check for duplicate1
		END --ELSE for IF @is_complete = 0

		FETCH NEXT FROM xe_cursor INTO @file_offset, @data, @event_file, @xe_obj_name
	END

	DEALLOCATE xe_cursor

	SELECT @min_dl = MIN(deadlock_id), @max_dl = MAX(deadlock_id) FROM dbo.deadlock WHERE deadlock_file_id = @deadlock_file_id

	--update last file
	UPDATE dbo.deadlock_file
		SET is_complete = 0,
			deadlock_count = ISNULL(deadlock_count, 0) + @deadlock_count,
			xml_database_deadlock_event_count = ISNULL(xml_database_deadlock_event_count, 0) + @db_deadlock_count,
			--file_size = NULL,
			first_deadlock_id = @min_dl,
			last_deadlock_id = @max_dl,
			--max_active_deadlocks = NULL,
			--max_active_deadlocks_dt = NULL,
			duration_in_sec = ISNULL(duration_in_sec, 0) + DATEDIFF(SECOND, @file_start_time, GETDATE())
		WHERE deadlock_file_id = @deadlock_file_id
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[fd_shrinklogfile]',10,1) WITH NOWAIT;

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[fd_shrinklogfile]') AND type IN (N'P', N'PC'))
BEGIN
	EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [dbo].[fd_shrinklogfile] AS' 
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

ALTER PROCEDURE [dbo].[fd_shrinklogfile](
	@logspaceMB			INT,			--size of log file to shrink down to, if not provided size will be set to 1 MB
	@dbname 			SYSNAME,		-- Name of db to shrink, should be "ALL" or specific database name
	@useTruncateOnly	BIT = 0			-- append the TruncateOnly statement to the end of the DBCC ShrinkFile statement, default is no
)
WITH ENCRYPTION 
AS

DECLARE @exists						BIT 
DECLARE @isql						NVARCHAR(2048)
DECLARE @logfile					SYSNAME
DECLARE @recovery_model_desc		NVARCHAR(60)
DECLARE @logspacestring				VARCHAR(max)
DECLARE @msg						VARCHAR(2048)

IF @logspaceMB IS NULL OR @logspaceMB = 0 
	SET @logspaceMB = 1

SELECT @logspacestring = CAST(@logspaceMB AS VARCHAR(max))
IF @dbname IS NULL 
	SET @dbname = 'ALL'

IF @dbname <> 'ALL'
BEGIN
	IF EXISTS (SELECT name FROM SYS.databases WHERE [name] = @dbname AND name NOT IN ('master','model','msdb','tempdb','distribution'))
		SET @exists = 1
	ELSE
	BEGIN
	RAISERROR('This database does not exist or is a system database!',10,1) WITH NOWAIT;
	RETURN
   	END
END
ELSE
	BEGIN
		SET @exists = 1
	END

	--Get size of log files into a temp table to be used later
CREATE TABLE #TmpLOGSPACE(
	DatabaseName		varchar(100)
	,LOGSIZE_MB			decimal(18, 9)
	,LOGSPACE_USED		decimal(18, 9)
	,LOGSTATUS			decimal(18, 9)) 
INSERT #TmpLOGSPACE(DatabaseName, LOGSIZE_MB, LOGSPACE_USED, LOGSTATUS) 
 EXEC('DBCC SQLPERF(LOGSPACE);')

IF @dbname <> 'ALL' 
	DELETE FROM #TmpLOGSPACE WHERE [DatabaseName] <> @dbname
DELETE FROM #TmpLOGSPACE WHERE [DatabaseName] IN ('master','model','msdb','tempdb','distribution')

IF (@dbname = 'ALL')
BEGIN
	DECLARE c1 CURSOR FOR 
	SELECT  
	d.name, mf.name as logfile, recovery_model_desc
	FROM 
	sys.master_files mf
	INNER JOIN sys.databases d ON mf.database_id = d.database_id
	WHERE 
	d.name NOT IN ('master','model','msdb','tempdb','distribution') 
	AND mf.type_desc = 'LOG'
END
ELSE
BEGIN
	 DECLARE c1 CURSOR FOR 
	SELECT  
		d.name, mf.name as logfile,	recovery_model_desc
	 FROM 
		sys.master_files mf
		INNER JOIN sys.databases d ON mf.database_id = d.database_id
	 WHERE 
		d.name = @dbname 
		AND mf.type_desc = 'LOG'
END

OPEN c1
FETCH NEXT FROM c1 INTO @dbname, @logfile,@recovery_model_desc
WHILE @@fetch_status <> -1
BEGIN
	BEGIN TRY
		EXECUTE sp_removedbreplication  @type='tran';
		WAITFOR DELAY '00:00:05'                      
	END TRY
	BEGIN CATCH
		SELECT @msg = 'Error attempting to remove replication from [' + @dbname + '], please check. Error is: ' + SUBSTRING(ERROR_MESSAGE(),1,1848)
		RAISERROR (@msg,10,1) WITH NOWAIT;
	END CATCH;
               
	IF @recovery_model_desc <> 'SIMPLE' 
	BEGIN
		SELECT @isql = 'ALTER DATABASE [' + @dbname + '] SET RECOVERY SIMPLE;'
		RAISERROR(@isql,10,1) WITH NOWAIT;
		EXEC(@isql)

		SELECT @isql='USE [' + @dbname + ']; CHECKPOINT;'
		RAISERROR(@isql,10,1) WITH NOWAIT;
		EXEC(@isql)
	END

	SELECT @isql='USE [' + @dbname + ']; DBCC SHRINKFILE ([' + @logfile + '],' + @logspacestring 
	IF @useTruncateOnly = 1
		SET @isql = @isql  + ',TRUNCATEONLY);'
	ELSE
		SET @isql = @isql  + ';'

	RAISERROR(@isql,10,1) WITH NOWAIT;
	EXEC(@isql)

	FETCH NEXT FROM c1 INTO @dbname, @logfile, @recovery_model_desc
END  
CLOSE c1
DEALLOCATE c1

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[FDDBA_Get_Version]',10,1) WITH NOWAIT;
if object_id('dbo.FDDBA_Get_Version') is null exec('create procedure [dbo].[FDDBA_Get_Version] as select getdate() DT')
GO
  
alter procedure [dbo].[FDDBA_Get_Version]
(
	@version varchar(20) OUTPUT
)
WITH ENCRYPTION
AS
BEGIN
	SET @version = '1.3.1'
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[Find_Missing_and_Failed_Job_Runs]',10,1) WITH NOWAIT;
if object_id('dbo.Find_Missing_and_Failed_Job_Runs') is null exec('create procedure [dbo].[Find_Missing_and_Failed_Job_Runs] as select getdate() DT')
GO
  alter procedure dbo.Find_Missing_and_Failed_Job_Runs
(
	@dt DATETIME = NULL
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @failed		TINYINT
	DECLARE @success	TINYINT
	DECLARE @cancelled	TINYINT
	DECLARE @running	TINYINT
	DECLARE @step0		TINYINT
 
	DECLARE @current_session_id			INT
	DECLARE @prev_session_id			INT
	DECLARE @prior_working_session_id	INT
	DECLARE @current_agent_start_time	DATETIME
	DECLARE @is_agent_running			TINYINT
 
	SET @failed = 0
	SET @success = 1
	SET @cancelled = 3
	SET @running = 4
	SET @step0 = 0
	SET @is_agent_running = 0
										       
	IF @dt IS NOT NULL
	BEGIN
		SELECT @prev_session_id = MAX(session_id) FROM msdb.dbo.syssessions
 
		IF EXISTS (SELECT 1 FROM sys.dm_server_services WHERE servicename LIKE 'SQL Server Agent %' AND [status] = @running)
		BEGIN
			SET @is_agent_running = 1
			SET @current_session_id = @prev_session_id
			SELECT @prev_session_id = MAX(session_id) FROM msdb.dbo.syssessions WHERE session_id < @current_session_id
 
			SELECT @current_agent_start_time = agent_start_date FROM msdb.dbo.syssessions WHERE session_id = @current_session_id
		END
		ELSE
		BEGIN
			SET @current_agent_start_time = getdate()
		END
 
		SELECT @prior_working_session_id = MAX(session_id) FROM msdb.dbo.syssessions WHERE agent_start_date < @dt

		--correct case where Agent does not crash
		IF @prior_working_session_id > @prev_session_id 
		BEGIN
			SET @prev_session_id = @prior_working_session_id
		END
	END
	ELSE
	BEGIN
		SELECT @prior_working_session_id = MIN(session_id), @prev_session_id = MAX(session_id) FROM msdb.dbo.syssessions
		SELECT @dt = agent_start_date FROM msdb.dbo.syssessions WHERE session_id = @prior_working_session_id
		SET @current_agent_start_time = GETDATE()
	END



	SELECT DISTINCT J.[name] AS 'Job Name', JA.job_id, JA.session_id AS 'Agent Session_id',  JA.job_history_id AS 'last instance id', JH.run_status AS 'last instance id status', --JA.start_execution_date, 
		JA.stop_execution_date, JA.next_scheduled_run_date, 

		JH2.instance_id AS 'next successful run id', CONVERT(DATETIME, STUFF(STUFF(LTRIM(STR(JH2.run_date)), 5, 0, '-'), 8, 0, '-') + ' ' + STUFF(STUFF(RIGHT('000000' + LTRIM(STR(JH2.run_time)), 6), 5, 0, ':'), 3, 0, ':')) as 'next successful run_date'
 
     	, CASE
			WHEN JH.run_status = @failed THEN 'FAILED'
            WHEN JH.run_status = @cancelled then 'INTERRUPTED'
            WHEN JA.next_scheduled_run_date < @current_agent_start_time THEN 'MISSED'
			ELSE 'UNKNOWN'
      	END AS Issue

	FROM msdb.dbo.sysjobactivity JA 
		INNER JOIN msdb.dbo.sysjobs J
			ON JA.job_id = J.job_id
				AND JA.session_id BETWEEN @prior_working_session_id AND @prev_session_id
				AND J.[enabled] = 1
				AND JA.next_scheduled_run_date < @current_agent_start_time
		INNER JOIN msdb.dbo.sysjobhistory JH
			ON J.job_id = JH.job_id
				AND JA.job_history_id = JH.instance_id
				AND JH.step_id = @step0
		LEFT OUTER JOIN msdb.dbo.sysjobhistory JH2
			ON JH.job_id = JH2.job_id
			AND JH.step_id = JH2.step_id
			AND JH2.instance_id = 
			(
				SELECT MIN(JH3.instance_id) 
					FROM msdb.dbo.sysjobhistory JH3 
					WHERE JH3.instance_id > JH.instance_id 
						AND JH3.step_id = JH.step_id 
						AND JH3.run_status = 1 
						AND JH3.job_id = JH.job_id
			)
	WHERE JA.next_scheduled_run_date != ISNULL(CONVERT(DATETIME, STUFF(STUFF(LTRIM(STR(JH2.run_date)), 5, 0, '-'), 8, 0, '-') + ' ' + STUFF(STUFF(RIGHT('000000' + LTRIM(STR(JH2.run_time)), 6), 5, 0, ':'), 3, 0, ':')),@current_agent_start_time)
	ORDER BY J.[name],JA.job_history_id
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[get_waitstats_2005]',10,1) WITH NOWAIT;
if object_id('dbo.get_waitstats_2005') is null exec('create procedure [dbo].[get_waitstats_2005] as select getdate() DT')
GO
  
alter procedure [dbo].[get_waitstats_2005] (@report_format VARCHAR(20)='all', @report_order VARCHAR(20)='resource') 
WITH ENCRYPTION
AS 
 
-- this proc will create waitstats report listing wait types by percentage.   
--     (1) total wait time is the sum of resource & signal waits, @report_format='all' reports resource & signal 
--    (2) Basics of execution model (simplified) 
--        a. spid is running THEN needs unavailable resource, moves to resource wait list at time T0 
--        b. a signal indicates resource available, spid moves to runnable queue at time T1 
--        c. spid awaits running status until T2 AS cpu works its way through runnable queue in order of arrival 
--    (3) resource wait time is the actual time waiting for the resource to be available, T1-T0 
--    (4) signal wait time is the time it takes FROM the point the resource is available (T1) 
--          to the point in which the process is running again at T2.  Thus, signal waits are T2-T1 
--    (5) Key questions: Are Resource and Signal time significant? 
--        a. Highest waits indicate the bottleneck you need to solve for scalability 
--        b. Generally IF you have LOW% SIGNAL WAITS, the CPU is handling the workload e.g. spids spend move through runnable queue quickly 
--        c. HIGH % SIGNAL WAITS indicates CPU can't keep up, significant time for spids to move up the runnable queue to reach running status 
--     (6) This proc can be run WHEN track_waitstats is executing 
-- Revision 4/19/2005 
-- (1) add computation for CPU Resource Waits = Sum(signal waits / total waits) 
-- (2) add @report_order parm to allow sorting by resource, signal or total waits 
SET nocount on 
 
DECLARE @now DATETIME, @totalwait numeric(20,1), @totalsignalwait numeric(20,1), @totalresourcewait numeric(20,1) 
    ,@endtime DATETIME,@begintime DATETIME 
    ,@hr INT, @min INT, @sec INT, @signtotalwait numeric(20,1)
 
IF not exists (SELECT 1 FROM sysobjects WHERE id = object_id ( N'[dbo].[waitstats]') and OBJECTPROPERTY(id, N'IsUserTable') = 1) 
begin 
        raiserror('Error [dbo].[waitstats] table does not exist', 16, 1) with nowait 
        RETURN 
end 
IF lower(@report_format) not in ('all','detail','simple') 
    begin 
        raiserror ('@report_format must be either ''all'',''detail'', or ''simple''',16,1) with nowait 
        RETURN 
    end 
IF lower(@report_order) not in ('resource','signal','total') 
    begin 
        raiserror ('@report_order must be either ''resource'', ''signal'', or ''total''',16,1) with nowait 
        RETURN 
    end 
IF lower(@report_format) = 'simple' and lower(@report_order) <> 'total' 
    begin 
        raiserror ('@report_format is simple so order defaults to ''total''',16,1) with nowait 
        SELECT @report_order = 'total' 
    end 
SELECT  @now=max(CreatedOn),@begintime=min(CreatedOn),@endtime=max(CreatedOn) 
FROM [dbo].[waitstats] WHERE [wait_type] = 'Total' 

--- signal wait total 
SELECT @signtotalwait = sum([wait_time_ms]) + 1, @totalsignalwait = sum([signal_wait_time_ms]) + 1 FROM waitstats  
WHERE [wait_type] not in ('CLR_SEMAPHORE','LAZYWRITER_SLEEP','RESOURCE_QUEUE','SLEEP_TASK','SLEEP_SYSTEMTASK','Total','WAITFOR', '***total***') and CreatedOn = @now 
 
--- subtract waitfor, sleep, and resource_queue FROM Total 
SELECT @totalwait = sum([wait_time_ms]) + 1, @totalsignalwait = sum([signal_wait_time_ms]) + 1 FROM waitstats  
WHERE [wait_type] not in ('CLR_SEMAPHORE','LAZYWRITER_SLEEP','RESOURCE_QUEUE','SLEEP_TASK','SLEEP_SYSTEMTASK','Total','WAITFOR', 'DISPATCHER_QUEUE_SEMAPHORE'
	,'CLR_MANUAL_EVENT','BROKER_RECEIVE_WAITFOR','CHECKPOINT_QUEUE','BROKER_TASK_STOP','FT_IFTS_SCHEDULER_IDLE_WAIT','XE_DISPATCHER_WAIT','LOGMGR_QUEUE','SQLTRACE_BUFFER_FLUSH',
	'BROKER_TO_FLUSH','SQLTRACE_WAIT_ENTRIES','BROKER_EVENTHANDLER', 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', '***total***') and CreatedOn = @now 
SELECT @totalresourcewait = 1 + @totalwait - @totalsignalwait 
-- INSERT adjusted totals, rank by percentage descending 
delete waitstats WHERE [wait_type] = '***total***' and CreatedOn = @now 
INSERT INTO waitstats SELECT @@SERVERNAME, '***total***',0,@totalwait,0,@totalsignalwait,@now  
SELECT 'start time'=@begintime,'end time'=@endtime 
        ,'duration (hh:mm:ss:ms)'=convert(VARCHAR(50),@endtime-@begintime,14) 
        ,'report format'=@report_format, 'report order'=@report_order 
IF lower(@report_format) in ('all','detail')  
    begin 
----- format=detail, column order is resource, signal, total.  ORDER BY resource desc 
    IF lower(@report_order) = 'resource' 
    SELECT top 20 InstanceName ,[wait_type],[waiting_tasks_count] 
        ,'Resource wt (T1-T0)'=[wait_time_ms]-[signal_wait_time_ms] 
        ,'res_wt_%'=cast (100*([wait_time_ms] - [signal_wait_time_ms]) /@totalresourcewait AS numeric(20,1)) 
        ,'Signal wt (T2-T1)'=[signal_wait_time_ms] 
        ,'sig_wt_%'=cast (100*[signal_wait_time_ms]/@totalsignalwait AS numeric(20,1)) 
        ,'Total wt (T2-T0)'=[wait_time_ms] 
        ,'wt_%'=cast (100*[wait_time_ms]/@totalwait AS numeric(20,1)) 
    FROM waitstats  
    WHERE [wait_type] not in ('CLR_SEMAPHORE','LAZYWRITER_SLEEP','RESOURCE_QUEUE','SLEEP_TASK','SLEEP_SYSTEMTASK','Total','WAITFOR', 'DISPATCHER_QUEUE_SEMAPHORE'
	,'CLR_MANUAL_EVENT','BROKER_RECEIVE_WAITFOR','CHECKPOINT_QUEUE','BROKER_TASK_STOP','FT_IFTS_SCHEDULER_IDLE_WAIT','XE_DISPATCHER_WAIT','LOGMGR_QUEUE','SQLTRACE_BUFFER_FLUSH',
	'BROKER_TO_FLUSH','SQLTRACE_WAIT_ENTRIES','BROKER_EVENTHANDLER', 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP') 
    and CreatedOn = @now 
    ORDER BY 'res_wt_%' desc 
----- format=detail, column order signal, resource, total.  ORDER BY signal desc 
    IF lower(@report_order) = 'signal' 
    SELECT top 20  InstanceName,[wait_type],[waiting_tasks_count] 
        ,'Signal wt (T2-T1)'=[signal_wait_time_ms] 
        ,'sig_wt_%'=cast (100*[signal_wait_time_ms]/@totalsignalwait AS numeric(20,1)) 
        ,'Resource wt (T1-T0)'=[wait_time_ms]-[signal_wait_time_ms] 
        ,'res_wt_%'=cast (100*([wait_time_ms] - [signal_wait_time_ms]) /@totalresourcewait AS numeric(20,1)) 
        ,'Total wt (T2-T0)'=[wait_time_ms] 
        ,'wt_%'=cast (100*[wait_time_ms]/@totalwait AS numeric(20,1)) 
    FROM waitstats  
    WHERE [wait_type] not in ('CLR_SEMAPHORE','LAZYWRITER_SLEEP','RESOURCE_QUEUE','SLEEP_TASK','SLEEP_SYSTEMTASK','Total','WAITFOR', 'DISPATCHER_QUEUE_SEMAPHORE'
	,'CLR_MANUAL_EVENT','BROKER_RECEIVE_WAITFOR','CHECKPOINT_QUEUE','BROKER_TASK_STOP','FT_IFTS_SCHEDULER_IDLE_WAIT','XE_DISPATCHER_WAIT','LOGMGR_QUEUE','SQLTRACE_BUFFER_FLUSH',
	'BROKER_TO_FLUSH','SQLTRACE_WAIT_ENTRIES','BROKER_EVENTHANDLER', 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP') 
    and CreatedOn = @now 
    ORDER BY 'sig_wt_%' desc 
----- format=detail, column order total, resource, signal.  ORDER BY total desc 
    IF lower(@report_order) = 'total' 
    SELECT top 20 InstanceName, [wait_type],[waiting_tasks_count] 
        ,'Total wt (T2-T0)'=[wait_time_ms] 
        ,'wt_%'=cast (100*[wait_time_ms]/@totalwait AS numeric(20,1)) 
        ,'Resource wt (T1-T0)'=[wait_time_ms]-[signal_wait_time_ms] 
        ,'res_wt_%'=cast (100*([wait_time_ms] - [signal_wait_time_ms]) /@totalresourcewait AS numeric(20,1)) 
        ,'Signal wt (T2-T1)'=[signal_wait_time_ms] 
        ,'sig_wt_%'=cast (100*[signal_wait_time_ms]/@totalsignalwait AS numeric(20,1)) 
    FROM waitstats  
    WHERE [wait_type] not in ('CLR_SEMAPHORE','LAZYWRITER_SLEEP','RESOURCE_QUEUE','SLEEP_TASK','SLEEP_SYSTEMTASK','Total','WAITFOR', 'DISPATCHER_QUEUE_SEMAPHORE'
	,'CLR_MANUAL_EVENT','BROKER_RECEIVE_WAITFOR','CHECKPOINT_QUEUE','BROKER_TASK_STOP','FT_IFTS_SCHEDULER_IDLE_WAIT','XE_DISPATCHER_WAIT','LOGMGR_QUEUE','SQLTRACE_BUFFER_FLUSH',
	'BROKER_TO_FLUSH','SQLTRACE_WAIT_ENTRIES','BROKER_EVENTHANDLER', 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP') 
    and CreatedOn = @now 
    ORDER BY 'wt_%' desc 
end 
ELSE 
---- simple format, total waits only 
    SELECT InstanceName, [wait_type],[wait_time_ms] 
            ,percentage=cast (100*[wait_time_ms]/@totalwait AS numeric(20,1)) 
    FROM dbo.waitstats  
    WHERE [wait_type] not in ('CLR_SEMAPHORE','LAZYWRITER_SLEEP','RESOURCE_QUEUE','SLEEP_TASK','SLEEP_SYSTEMTASK','Total','WAITFOR', 'DISPATCHER_QUEUE_SEMAPHORE'
	,'CLR_MANUAL_EVENT','BROKER_RECEIVE_WAITFOR','CHECKPOINT_QUEUE','BROKER_TASK_STOP','FT_IFTS_SCHEDULER_IDLE_WAIT','XE_DISPATCHER_WAIT','LOGMGR_QUEUE','SQLTRACE_BUFFER_FLUSH',
	'BROKER_TO_FLUSH','SQLTRACE_WAIT_ENTRIES','BROKER_EVENTHANDLER', 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP') 
    and CreatedOn = @now 
    ORDER BY percentage desc 



GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].p_hexadecimal',10,1) WITH NOWAIT;
if object_id('dbo.p_hexadecimal') is null exec('create procedure [dbo].p_hexadecimal as select getdate() DT')
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


ALTER PROCEDURE [dbo].[sp_hexadecimal]
    @binvalue varbinary(256),
    @hexvalue VARCHAR (514) OUTPUT
AS
DECLARE @charvalue VARCHAR (514)
DECLARE @i INT
DECLARE @length INT
DECLARE @hexstring CHAR(16)
SELECT @charvalue = '0x'
SELECT @i = 1
SELECT @length = DATALENGTH (@binvalue)
SELECT @hexstring = '0123456789ABCDEF'
WHILE (@i <= @length)
BEGIN
  DECLARE @tempint INT
  DECLARE @firstint INT
  DECLARE @secondint INT
  SELECT @tempint = CONVERT(INT, SUBSTRING(@binvalue,@i,1))
  SELECT @firstint = FLOOR(@tempint/16)
  SELECT @secondint = @tempint - (@firstint*16)
  SELECT @charvalue = @charvalue +
    SUBSTRING(@hexstring, @firstint+1, 1) +
    SUBSTRING(@hexstring, @secondint+1, 1)
  SELECT @i = @i + 1
END

SELECT @hexvalue = @charvalue
GO
exec sys.sp_MS_marksystemobject 'dbo.sp_hexadecimal';
go


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pAgentJob_History_Capture]',10,1) WITH NOWAIT;
if object_id('dbo.pAgentJob_History_Capture') is null exec('create procedure [dbo].[pAgentJob_History_Capture] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Save job history to agentjob_history table for jobs enabled in agentjob_monitor table 
*
*	Inputs:	None
*
*	Notes:	
*	1. This sproc is designed to capture job history to allow lookup of history after agent job history cleanup has occurred 
*	2. This sproc does track rows scanned in msdb.dbo.sysjobhistory to prevent repeated work
*	3. It is suggested that this procedure be run via a SQL Agent job named "FD - Monitor Statistics" every 15 minutes 
*		or so to collect data before cleanup removes history rows
*	4. For this sproc to do work the sproc pAgentJob_To_Monitor must be run first with valid parameters
*	5. A job can be disabled from collection by updating the is_enabled column of agentjob_monitor table
*
*	WORK TODO:
*	1. Implement exclusion of successful history data when report_success column of gentjob_monitor table is 0
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2017-11-29			Mike Zawadzki			Created
*	
*********************************************************************************************************************/
alter procedure [dbo].[pAgentJob_History_Capture]
WITH ENCRYPTION 
AS
BEGIN
/*
TODO:
2. Support skipping successful jobs
*/
	SET NOCOUNT ON
	exec dbo.usp_UpdateVersionStatics
	DECLARE @dt datetime
	DECLARE @max_dt datetime
	DECLARE @min_id int
	DECLARE @max_id int
	DECLARE @min_collected_id int
	DECLARE @max_collected_id int
	DECLARE @is_gap_before bit = 0
	DECLARE @error int
	DECLARE @severity int
	DECLARE @errmsg varchar(1000)
	DECLARE @message nvarchar(4000)
	DECLARE @fAllJobs bit
	DECLARE @job_id uniqueidentifier
	DECLARE @job_id_new uniqueidentifier
	DECLARE @job_name sysname

	--check if any jobs to monitor
	IF EXISTS(SELECT 1 FROM [dbo].[agentjob_monitor] WHERE is_enabled = 1)
	BEGIN
		SET @dt = GETDATE()

		--find where last scan ended to prevent full history scan
		SELECT @max_dt = MAX(runtime) FROM dbo.agentjob_search_history
		IF @max_dt IS NOT NULL
		BEGIN
			SELECT @min_collected_id = min_instance_id, @max_collected_id = max_instance_id FROM dbo.agentjob_search_history WHERE runtime = @max_dt
		END
		ELSE
		BEGIN
			SELECT @min_collected_id = MIN(instance_id), @max_collected_id = MAX(instance_id) FROM [dbo].[agentjob_history]

			IF @max_collected_id IS NULL
			BEGIN
				SET @min_collected_id = 0	
				SET @max_collected_id = 0
			END
		END

		SELECT @min_id = MIN(instance_id), @max_id = MAX(instance_id) FROM msdb.dbo.sysjobhistory

		IF @min_id > @max_collected_id
		BEGIN
			SET @is_gap_before = 1
		END

		IF EXISTS(SELECT 1 FROM [dbo].[agentjob_monitor] WHERE is_enabled = 1 AND job_id IS NULL AND job_name IS NULL)
		BEGIN
			SET @fAllJobs = 1
		END

		--update job_id via name to pick up changes
		IF @fAllJobs IS NULL 
			AND EXISTS 
			(
				SELECT 1 FROM msdb.dbo.sysjobs j
					INNER JOIN [dbo].[agentjob_monitor] m
						ON j.[name] = m.job_name
						AND j.job_id != m.job_id
			)
		BEGIN
			DECLARE aj_mon_cursor CURSOR FOR
				SELECT job_id, job_name FROM [dbo].[agentjob_monitor] WHERE is_enabled = 1
			OPEN aj_mon_cursor
			FETCH NEXT FROM aj_mon_cursor INTO @job_id, @job_name

			WHILE @@FETCH_STATUS != -1
			BEGIN
				SELECT @job_id_new = job_id FROM msdb.dbo.sysjobs WHERE [name] = @job_name
				IF @job_id_new != @job_id
				BEGIN
					BEGIN TRAN
					UPDATE [dbo].[agentjob_monitor]
						SET is_enabled = 0
						WHERE job_id = @job_id

					INSERT [dbo].[agentjob_monitor] (job_id, is_enabled, report_success, job_name, retention_days)
						SELECT @job_id_new, 1, report_success, job_name, retention_days 
							FROM [dbo].[agentjob_monitor]
							WHERE job_id = @job_id
					COMMIT TRAN
				END

				FETCH NEXT FROM aj_mon_cursor INTO @job_id, @job_name
			END

			DEALLOCATE aj_mon_cursor
		END

		--add new messages
		BEGIN TRY
			IF @fAllJobs = 1
			BEGIN
				INSERT [dbo].[agentjob_history]
					SELECT instance_id, jh.job_id, step_id, sql_message_id, sql_severity, run_status, run_date, run_time, run_duration, [message]
						FROM msdb.dbo.sysjobhistory jh
						WHERE instance_id BETWEEN @max_collected_id AND @max_id
			END
			ELSE
			BEGIN
				INSERT [dbo].[agentjob_history]
					SELECT instance_id, jh.job_id, step_id, sql_message_id, sql_severity, run_status, run_date, run_time, run_duration, [message]
						FROM msdb.dbo.sysjobhistory jh
							INNER JOIN [dbo].[agentjob_monitor] m
								ON jh.job_id = m.job_id
								AND m.is_enabled = 1
						WHERE instance_id BETWEEN @max_collected_id AND @max_id
			END

			INSERT [dbo].[agentjob_search_history]
				VALUES (@is_gap_before, @min_id, @max_id, @dt)
		END TRY
		BEGIN CATCH
			SET @error = ERROR_NUMBER()
			SET @severity = ERROR_SEVERITY()
			SET @errmsg = ERROR_MESSAGE()
			PRINT 'Insert Error:'+ STR(@error) + ', Severity:' + STR(@severity)
			PRINT @errmsg
		END CATCH

		--update of existing output should not be needed as only insert when job is complete or current history for step exceeds 8000 bytes which would be under a new instance_id value
	END
	ELSE
	BEGIN
		PRINT 'No jobs to monitor'
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pAgentJob_History_Purge]',10,1) WITH NOWAIT;
if object_id('dbo.pAgentJob_History_Purge') is null exec('create procedure [dbo].[pAgentJob_History_Purge] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Delete rows from agentjob_history table based on retention_days column
*
*	Inputs:	None
*
*	Notes:	
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2017-12-26			Mike Zawadzki			Created
*	
*********************************************************************************************************************/
alter procedure [dbo].[pAgentJob_History_Purge]
WITH ENCRYPTION 
AS
BEGIN
	DECLARE @fAllJobs smallint

	SELECT @fAllJobs = retention_days FROM [dbo].[agentjob_monitor] WHERE job_id IS NULL and job_name IS NULL

	--check if any history to possibly purge
	IF EXISTS(SELECT 1 FROM [dbo].[agentjob_history])
	BEGIN
		IF @fAllJobs IS NOT NULL
		BEGIN
			DELETE [dbo].[agentjob_history]
				WHERE run_date < DATEPART(YEAR,DATEADD(DAY, -@fAllJobs, GETDATE())) * 10000 + DATEPART(MONTH,DATEADD(DAY, -@fAllJobs, GETDATE())) * 100 + DATEPART(DAY,DATEADD(DAY, -@fAllJobs, GETDATE()))
		END
		ELSE
		BEGIN
			DELETE h
				FROM [dbo].[agentjob_history] h
					INNER JOIN [dbo].[agentjob_monitor] m
						ON h.job_id = m.job_id
						AND m.retention_days > 0
				WHERE run_date < DATEPART(YEAR,DATEADD(DAY, -retention_days, GETDATE())) * 10000 + DATEPART(MONTH,DATEADD(DAY, -retention_days, GETDATE())) * 100 + DATEPART(DAY,DATEADD(DAY, -retention_days, GETDATE()))
		END
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pAgentJob_To_Monitor]',10,1) WITH NOWAIT;
if object_id('dbo.pAgentJob_To_Monitor') is null exec('create procedure [dbo].[pAgentJob_To_Monitor] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Insert rows into agentjob_monitor table for use by sproc pAgentJob_History_Capture
*
*	Inputs:	
*		@report_success : OPTIONAL - whether to capture data about successful executions or just failures and cancels
*		@job_id : OPTIONAL - SQL Agent job_id of job to monitor
*		@job_name : OPTIONAL - SQL Agent job name of job to monitor
*		@retention_days: OPTIONAL - how many days to keep data for this job
*
*	Notes:	
*	1. Specifying @job_id and @job_name as NULL causes monitoring of all jobs
*	2. The job requesting to be monitored can not be the job that runs the monitoring sproc pAgentJob_History_Capture
*	3. Successful execution will enable the SQL Agent job "FD - Monitor Statistics"
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2017-11-29			Mike Zawadzki			Created
*	2017-12-26			Mike Zawadzki			Add support to monitor all tables and retention_days parameter
*	
*********************************************************************************************************************/
alter procedure [dbo].[pAgentJob_To_Monitor]
(
	@report_success bit = 1,
	@job_id uniqueidentifier = NULL,
	@job_name sysname = NULL,
	@retention_days smallint = NULL
)
WITH ENCRYPTION 
AS
BEGIN
	DECLARE @monitor_job_id uniqueidentifier
	SELECT @monitor_job_id = job_id from msdb.dbo.sysjobs where [name] = 'FD - Monitor Statistics'

	--check parameters
	IF @job_id IS NOT NULL
	BEGIN
		SET @job_name = NULL
		SELECT TOP 1 @job_name = [name] FROM msdb.dbo.sysjobs WHERE job_id = @job_id
		IF @job_name IS NULL
		BEGIN
			RAISERROR('Job_id parameter does not exist', 16, 1)
			RETURN 1
		END
	END
	ELSE
	BEGIN
		IF @job_name IS NOT NULL
		BEGIN
			SELECT TOP 1 @job_id = job_id FROM msdb.dbo.sysjobs WHERE name = @job_name

			IF @job_id IS NULL
			BEGIN
				RAISERROR('Job_name parameter does not exist', 16, 1)
				RETURN 2
			END
		END
	END

	IF @job_id = @monitor_job_id
	BEGIN
		RAISERROR('Job_id parameter matches monitoring job_id', 16, 1)
		RETURN 3
	END

	IF @job_id IS NULL and @job_name IS NULL
	BEGIN
		IF EXISTS(SELECT 1 FROM dbo.agentjob_monitor WHERE is_enabled = 1)
		BEGIN
			RAISERROR('Can not monitor ALL JOBS when 1 or more jobs already monitoring. Disable monitoring on other jobs first', 16, 1)
			RETURN 4
		END
	END

	IF @retention_days IS NOT NULL
	BEGIN
		INSERT dbo.agentjob_monitor (job_id, is_enabled, report_success, job_name, retention_days)
			VALUES (@job_id, 1, @report_success, @job_name, @retention_days)
	END
	ELSE
	BEGIN
		INSERT dbo.agentjob_monitor (job_id, is_enabled, report_success, job_name)
			VALUES (@job_id, 1, @report_success, @job_name)
	END

	--update job to be enabled
	EXEC msdb.dbo.sp_update_job @job_name=N'FD - Monitor Statistics', @enabled=1

	RETURN 0
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pCurrentActivity]',10,1) WITH NOWAIT;
if object_id('dbo.pCurrentActivity') is null exec('create procedure [dbo].[pCurrentActivity] as select getdate() DT')
GO
  
/*============================================================================
  Procedure:  pCurrentActivity     
  Summary:  Provides real time results for the current processes. Based on script 
		Current Activity - FMT SQL Output By Ben DeBow
  Date:     
  Versions: 2008+
  Parameters
	@getActivity			BIT = 1  Returns current running queries
	@getBlocked				BIT = 0	 Returns an output of blocked queries, does not override @getActivity so you will get two result sets
	@getSchedulers			BIT = 1	 Returns Schedulers that have a waiting task count greater than 0
	@getWaits				BIT = 1  Returns the top 5 waits on the system from sys.dm_os_waiting_tasks excluding waits in the  table dbo.vWaitStats_Benign
	@getIO					BIT = 1  Returns current file IO info from sys.dm_io_pending_io_requests 
	@activitySortBy			VARCHAR(512) = 'run_time_sec DESC'	Is the sort order of the columns you want to see for Current Running Queries, you can enter any valid sort either
		by column name or order name and specify ASC or DSEC.
 Updates:
 -------------------------------------------------------------------------------------
 Date			By				Change
 4/30/2019		Keith Buck		Added the dynamic sort of the Current Running Queries
------------------------------------------------------------------------------
  Written by Keith Buck, Fortified Data

  For more scripts and sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
============================================================================*/
alter procedure dbo.pCurrentActivity
(
	@getActivity			BIT = 1,
	@getBlocked				BIT = 0,
	@getSchedulers			BIT = 1,
	@getWaits				BIT = 1,
	@getIO					BIT = 1,
	@activitySortBy			VARCHAR(512) = 'run_time_sec DESC'

)
WITH ENCRYPTION
AS
SET NOCOUNT ON
DECLARE @sql		Nvarchar(max)

IF @getBlocked = 1
BEGIN
	SELECT
		spid
		,sp.status
		,login_name   = SUBSTRING(loginame, 1, 30)
		,host_name   = SUBSTRING(hostname, 1, 30)
		,blocked        = CONVERT(CHAR(3), blocked)
		,open_tran
		,dbname     = SUBSTRING(DB_NAME(sp.dbid),1,10)
		,cmd
		,wait_type
		,wait_resource
		,wait_time
		,start_time
		,logical_reads
		,writes
		,cpu_time
		,last_batch
		,SQLStatement =
			SUBSTRING
			(
				qt.text,
				er.statement_start_offset/2,
				(CASE WHEN er.statement_end_offset = -1
					THEN LEN(CONVERT(nvarchar(MAX), qt.text)) * 2
					ELSE er.statement_end_offset
					END - er.statement_start_offset)/2
			)
		,(SELECT query_plan 
		FROM sys.dm_exec_query_plan (plan_handle)) execution_plan
	FROM master.dbo.sysprocesses sp
	LEFT JOIN sys.dm_exec_requests er
		ON er.session_id = sp.spid
	OUTER APPLY sys.dm_exec_sql_text(er.sql_handle) AS qt
	WHERE spid IN (SELECT blocked FROM master.dbo.sysprocesses)
	AND blocked = 0
END


IF @getActivity = 1
BEGIN
SET @sql =N'
	SELECT
		x.session_id,
		CAST(DATEDIFF(SECOND, x.start_time, GETDATE()) AS BIGINT) ''run_time_sec'',
		RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 86400 AS VARCHAR),2) + '':'' +
			RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 3600 AS VARCHAR),2) + '':'' +
			RIGHT(''0'' + CAST(( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 60) % 60 AS VARCHAR),2) + '':'' +
			RIGHT(''0'' + CAST(DATEDIFF(SECOND, x.start_time,  GETDATE()) % 60 AS VARCHAR),2) as [RunTime DD:HH:MM:SS],
		status,
		x.host_name,
		COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
		[DBName],
		x.login_name,
		x.wait_type,
		x.wait_resource,
		x.wait_time,
		x.start_time,
		FDDBA.dbo.fFormatIntReadable(x.totallogical_reads) AS totallogical_reads,
		FDDBA.dbo.fFormatIntReadable(x.totalWrites) AS totalWrites,
		FDDBA.dbo.fFormatIntReadable(x.totalCPU) AS totalCPU,
		x.CPUSession,
		x.ScheduleTimeSession,
		x.TotalElapsedTimeSession,
		x.granted_query_memory,
		FDDBA.dbo.fFormatIntReadable(x.writes_in_tempdb) AS writes_in_tempdb,
		parallelquery,
	
		(
			SELECT          
				substring(text, (statement_start_offset/2)+1
					, ((case statement_end_offset
						  when -1 then datalength(text)
						  else statement_end_offset
					   end - statement_start_offset)/2) + 1)
			FROM sys.dm_exec_sql_text(x.sql_handle)
		) AS [stmt_text],
		(
			SELECT
				p.text
			FROM
			(
				SELECT
					MIN(sql_handle) AS sql_handle
				FROM sys.dm_exec_requests r2
				WHERE
					r2.session_id = x.blocking_session_id
			) AS r_blocking
			CROSS APPLY
			(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
			) p (text)
		) AS [blocking_text],
		[SQL_Text],
		ObjectName,
		x.program_name,
		transaction_id,
		percent_complete,
		estimated_completion_time,
		scheduler_id,
		x.transaction_isolation_level
		plan_handle
		, (SELECT query_plan FROM sys.dm_exec_query_plan (plan_handle)) execution_plan

	FROM
	(
		SELECT
			r.session_id,
			r.status,
			s.host_name,
			s.login_name,
			r.start_time,
			r.sql_handle,
			wait_type,
			wait_resource,
			CAST(wait_time AS BIGINT) AS wait_time,
			statement_start_offset,
			statement_end_offset,
			r.blocking_session_id,
			transaction_id,
			percent_complete,
			estimated_completion_time,
			scheduler_id,
			r.transaction_isolation_level,
			db_name(r.database_id) [DBName],
			last_request_start_time,
			count(*) AS parallelquery,
			SUM(CAST(r.logical_reads AS BIGINT)) AS totallogical_reads ,
			SUM(CAST(r.writes AS BIGINT)) AS totalWrites,
			SUM(CAST(r.cpu_time AS BIGINT)) AS totalCPU,
			SUM(CAST(s.cpu_time AS BIGINT)) AS CPUSession,
			SUM(CAST(s.total_scheduled_time AS BIGINT)) AS ScheduleTimeSession,
			SUM(CAST(s.total_elapsed_time AS BIGINT)) AS TotalElapsedTimeSession,
			SUM(CAST(tsu.user_objects_alloc_page_count + tsu.internal_objects_alloc_page_count AS BIGINT)) AS writes_in_tempdb,
			plan_handle,
			CAST(granted_query_memory AS BIGINT) AS granted_query_memory,
			program_name,
			text AS [SQL_Text],
			OBJECT_NAME(objectid, dbid) AS [ObjectName]
		FROM sys.dm_exec_requests r
		JOIN sys.dm_exec_sessions s ON s.session_id = r.session_id
		JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id and r.request_id = tsu.request_id
		CROSS APPLY sys.dm_exec_sql_text (r.sql_handle)
		WHERE r.status IN (''running'', ''runnable'', ''suspended'',''rollback'')
		AND r.session_id != @@SPID
		GROUP BY
			r.session_id,
			r.status,
			s.host_name,
			s.login_name,
			r.start_time,
			r.sql_handle,
			wait_type,
			wait_resource,
			wait_time,
			statement_start_offset,
			statement_end_offset,
			r.blocking_session_id,
			transaction_id,
			percent_complete,
			estimated_completion_time,
			scheduler_id,
			r.transaction_isolation_level,
			r.database_id,
			last_request_start_time,
			plan_handle,
			granted_query_memory,
			program_name,
			text,
			OBJECT_NAME(objectid, dbid)
	) x
	ORDER BY ' + @activitySortBy

	execute sp_executesql @sql 
END

----	PENDING PROCESSES ON THE SCHEDULERS WAITING TO BE EXECUTED
IF @getSchedulers = 1
BEGIN
	SELECT scheduler_id
		, current_tasks_count
		, runnable_tasks_count
		, work_queue_count
		, pending_disk_io_count
		, current_workers_count
		, active_workers_count
		, pending_disk_io_count
		, context_switches_count
		, preemptive_switches_count
		, status
		, load_factor
		, GETDATE() AS 'RunTime'
	FROM sys.dm_os_schedulers
	WHERE scheduler_id < 255
	AND runnable_tasks_count > 0
	ORDER BY 3 DESC
END

IF @getWaits = 1
BEGIN
	SELECT TOP 5 wait_type,
		  COUNT (*) as 'total #'
		, GETDATE() AS 'RunTime'
	from sys.dm_os_waiting_tasks
	where [wait_type] not in (select WaitStatTypeName from FDDBA.dbo.vWaitStats_Benign)
	group by wait_type
	HAVING COUNT(*) > 1
	order by count (*) desc
END


IF @getIO = 1
BEGIN
	SELECT 
		DB_Name(vfs.database_id) as dbName,
		mf.physical_name,
		io.*
	 FROM 
		sys.dm_io_pending_io_requests io
		INNER JOIN sys.dm_io_virtual_file_stats(NULL,NULL) as vfs On io.io_handle = vfs.file_handle
		INNER JOIN sys.master_files mf ON (mf.database_id = vfs.database_id) and (mf.file_id = vfs.file_id)
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pDatabaseFileStorage_Add]',10,1) WITH NOWAIT;
if object_id('dbo.pDatabaseFileStorage_Add') is null exec('create procedure [dbo].[pDatabaseFileStorage_Add] as select getdate() DT')
GO
  
alter procedure [dbo].[pDatabaseFileStorage_Add]
(	
	@databaseName	sysname 
	,@createdOn		DATETIME
)
WITH ENCRYPTION
AS
SET NOCOUNT ON
EXEC dbo.usp_UpdateVersionStatics
DECLARE @sql		NVARCHAR(max)
IF @createdOn IS NULL
	SET @createdOn = GetDate()

IF OBJECT_ID('tempdb..##Results') is not null
	DROP TABLE ##Results   
	
CREATE TABLE ##Results (
	[Database Name] sysname
	,[File Name] sysname
	,[Physical Name] NVARCHAR(260)
	,[TYPE] VARCHAR(4)
	,[Total Size in Mb] INT
	,[Available Space in Mb] INT
)  

SELECT @sql =   
	N'USE [?] 
	IF DB_NAME() = N''' + @databaseName + N'''
	Begin
	INSERT INTO ##Results([Database Name], [File Name], [Physical Name],   
		[TYPE]
		, [Total Size in Mb]
		, [Available Space in Mb])   
	SELECT DB_NAME(),  
		[name] AS [File Name],   
		physical_name AS [Physical Name],   
		[TYPE],  
		CASE ceiling([size]/128)   
			WHEN 0 THEN 1  
			ELSE ceiling([size]/128)  
		END,  
		CASE ceiling([size]/128)  
		WHEN 0 THEN  ISNULL( (1 - CAST(FILEPROPERTY([name], ''SpaceUsed''' + ') AS INT) /128)  ,0)
		ELSE ISNULL( (([size]/128) - CAST(FILEPROPERTY([name], ''SpaceUsed''' + ') AS INT) /128),0)
		END  
	FROM sys.database_files  
	End'  
EXECUTE sp_MSforeachdb @sql

INSERT INTO .dbo.DatabaseFileStorage (InstanceName,CreatedOn,DatabaseName, LogicalName,PhysicalName, 
	[TYPE], TotalSize_Mb, AvailableSpace_Mb)
SELECT 
	@@SERVERNAME
	,@createdOn
	,[Database Name]
	,[File Name]
	,[Physical Name]
	,[TYPE]
	,[Total Size in Mb] 
	,[Available Space in Mb]
  FROM
	##Results

IF OBJECT_ID('tempdb..##Results') is not null
	DROP TABLE ##Results 


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pDatabaseFileStorage_AddByDatabaseName]',10,1) WITH NOWAIT;
if object_id('dbo.pDatabaseFileStorage_AddByDatabaseName') is null exec('create procedure [dbo].[pDatabaseFileStorage_AddByDatabaseName] as select getdate() DT')
GO
  alter procedure [dbo].[pDatabaseFileStorage_AddByDatabaseName]
	(	
		@databaseNameList		VARCHAR(max)
		,@delimiter				CHAR(1)
		,@allUserDatabases		bit = 0
	)
	WITH ENCRYPTION
	AS
	SET NOCOUNT ON

	DECLARE @dbname				sysname
	DECLARE @dblist				table(DBName VARCHAR(128))
	DECLARE @CreatedDateTime	DATETIME
	DECLARE @msg				VARCHAR(2048)
	DECLARE @hasError			BIT 


	SET @CreatedDateTime = GETDATE()
	EXEC dbo.usp_UpdateVersionStatics

	IF @allUserDatabases = 1
	begin
		--Insert all online user databases and check if in an AG then only take those that are the primary replica
		--check mirroring too and only choose PRINCIPAL
		INSERT INTO @dblist
		SELECT 
			d.name 
		 FROM 
			sys.databases d
			LEFT JOIN sys.dm_hadr_database_replica_states drs on d.group_database_id = drs.group_database_id AND d.replica_id = drs.replica_id
			LEFT JOIN sys.availability_groups ag on drs.group_id = ag.group_id
			LEFT JOIN sys.dm_hadr_availability_group_states agstate on ag.group_id = agstate.group_id
			LEFT JOIN sys.database_mirroring m ON d.database_id = m.database_id
		WHERE 
			d.database_id > 4 
			And state_desc = 'ONLINE' 
			and source_database_id IS NULL
			AND ( agstate.group_id IS NULL 
					OR	
				agstate.primary_replica = @@SERVERNAME )
			AND (m.mirroring_role_desc IS NULL
				OR
				m.mirroring_role_desc =N'PRINCIPAL')

		--adding in tempdb here, if you want all user databases then you probably want that too
		INSERT INTO @dblist select 'tempdb'
	end
	ELSE
	begin
		IF ISNULL(@databaseNameList,'') = '' or ISNULL(@delimiter,'') = ''
		begin
			RAISERROR('Must pass in a valid value for parameters @databaseNameList and/or @delimiter',15,125) WITH NOWAIT;
			RETURN
		end
		INSERT INTO @dblist
		SELECT 
			x.[items] 
		 FROM 
			dbo.fSplit(@databaseNameList,@delimiter) as x
			INNER JOIN sys.databases d ON x.items = d.name
			LEFT JOIN sys.dm_hadr_database_replica_states drs on d.group_database_id = drs.group_database_id AND d.replica_id = drs.replica_id
			LEFT JOIN sys.availability_groups ag on drs.group_id = ag.group_id
			LEFT JOIN sys.dm_hadr_availability_group_states agstate on ag.group_id = agstate.group_id
			LEFT JOIN sys.database_mirroring m ON d.database_id = m.database_id
		WHERE 
			d.database_id > 4 
			And state_desc = 'ONLINE' 
			and source_database_id IS NULL
			AND ( agstate.group_id IS NULL 
					OR	
				agstate.primary_replica = @@SERVERNAME )
			AND (m.mirroring_role_desc IS NULL
				OR
				m.mirroring_role_desc =N'PRINCIPAL')
	end

	DECLARE curDB CURSOR FAST_FORWARD LOCAL FOR	
		SELECT DBName FROM @dblist
	Open curDB
	Fetch Next FROM curDB INTO @dbname
	WHILE @@FETCH_STATUS = 0
	Begin
		BEGIN TRY
			EXECUTE dbo.pDatabaseFileStorage_Add @databaseName = @dbname, @createdOn = @CreatedDateTime
		END TRY
		BEGIN CATCH
			SELECT @msg = 'Error occurred in dbo.pDatabaseFileStorage_AddByDatabaseName while calling procedure dbo.pDatabaseFileStorage_Add, Database name is [' +
			@dbname + '], and created date is [' + convert(VARCHAR(30),@CreatedDateTime ,109) + '] and the error message is: '
				+ ERROR_MESSAGE()
				RAISERROR (@msg, 10,1) WITH NOWAIT;
				SET @hasError = 1
		END CATCH
		Fetch Next FROM curDB INTO @dbname
	End
	Close curDB
	Deallocate curDB
	IF @hasError = 1 --ERRORS OCCURED, THROW GENERIC MESSAGE TO CHECK LOG
		RAISERROR('Errors occured in procedure dbo.pDatabaseFileStorage_AddByDatabaseName, please check log for details.', 19,12) WITH LOG;
GO


IF (select VerDec from #FDVER) >= 11.0
BEGIN
RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pDatabaseFileStorageGrowth]',10,1) WITH NOWAIT;
if object_id('dbo.pDatabaseFileStorageGrowth') is null exec('create procedure [dbo].[pDatabaseFileStorageGrowth] as select getdate() DT')
exec('alter procedure [dbo].[pDatabaseFileStorageGrowth]
(
	@DatabaseName	SYSNAME   = ''ALL''
)
WITH ENCRYPTION
 AS
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
SET NOCOUNT ON
EXEC dbo.usp_UpdateVersionStatics
If @DatabaseName = N''ALL''
BEGIN
	WITH cteInfo AS(
		SELECT 
			CreatedOn		
			,DatabaseName	
			,''ROWS''	AS Type_Desc
			,SUM(TotalSize_Mb) as TotalSize_Mb
			,SUM(AvailableSpace_Mb) as AvailableSpace_Mb
			, Cast(  (cast(SUM(AvailableSpace_Mb) as decimal(18,3)) / cast(SUM(TotalSize_Mb)  as decimal(18,3))) * 100 as decimal(18,3)) As PercentFreeSpace
			,cast(cast(SUM(TotalSize_Mb) as decimal(18,2))/1024 as decimal(18,2))as TotalSize_Gb
			,cast(cast(SUM(AvailableSpace_Mb) as decimal(18,2))/1024 as decimal(18,2))as AvailableSpace_Gb
		  From
			dbo.DatabaseFileStorage s
			INNER JOIN sys.databases d on s.DatabaseName = d.name
		WHERE
			[TYPE] = 0
			AND (DATEPART(dd,[CreatedOn]) = 1
					or CAST([CreatedOn] as date) = (select CAST(MAX(CreatedOn) as date)  from [dbo].DatabaseFileStorage)
					) 
		Group By
			CreatedOn		
			,DatabaseName)
	SELECT 
		CAST([CreatedOn] as date)as [CreatedOn]
		,[DatabaseName]
		,[TotalSize_Gb]
		,TotalSize_Gb - (LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName ORDER BY CreatedOn DESC)) AS GrowthOverPrevPeriod_Gb
		,CASE WHEN LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName ORDER BY  CreatedOn DESC) < 1 THEN NULL
			ELSE CAST(((TotalSize_Gb - (LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName ORDER BY CreatedOn DESC))) / LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName ORDER BY  CreatedOn DESC) ) * 100 AS MONEY)
			END AS GrowthPercentage
		,LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName  ORDER BY  CreatedOn DESC) AS PrevPeriod
		,[AvailableSpace_Gb]
		,[PercentFreeSpace]
		, DATEDIFF(DAY,(LEAD(cast(CreatedOn AS DATE),1) OVER (PARTITION  BY DatabaseName  ORDER BY CreatedOn DESC)), Cast([CreatedOn] AS date)) AS DaysInPeriod
	 FROM 
		cteInfo
	ORDER BY  
		DatabaseName
		,CreatedOn Desc
END
ELSE
BEGIN
	WITH cteInfo AS(
		SELECT 
			CreatedOn		
			,DatabaseName	
			,''ROWS''	AS Type_Desc
			,SUM(TotalSize_Mb) as TotalSize_Mb
			,SUM(AvailableSpace_Mb) as AvailableSpace_Mb
			, Cast(  (cast(SUM(AvailableSpace_Mb) as decimal(18,3)) / cast(SUM(TotalSize_Mb)  as decimal(18,3))) * 100 as decimal(18,3)) As PercentFreeSpace
			,cast(cast(SUM(TotalSize_Mb) as decimal(18,2))/1024 as decimal(18,2))as TotalSize_Gb
			,cast(cast(SUM(AvailableSpace_Mb) as decimal(18,2))/1024 as decimal(18,2))as AvailableSpace_Gb
		  From
			dbo.DatabaseFileStorage 
		WHERE
			[TYPE] = 0
			AND DatabaseName = @DatabaseName
			AND (DATEPART(dd,[CreatedOn]) = 1
					or CAST([CreatedOn] as date) = (select CAST(MAX(CreatedOn) as date)  from [dbo].DatabaseFileStorage)
					) 
		Group By
			CreatedOn		
			,DatabaseName)
	SELECT 
		CAST([CreatedOn] as date)as [CreatedOn]
		,[DatabaseName]
		,[TotalSize_Gb]
		,TotalSize_Gb - (LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName ORDER BY CreatedOn DESC)) AS GrowthOverPrevPeriod_Gb
		,CASE WHEN LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName ORDER BY  CreatedOn DESC) < 1 THEN NULL
			ELSE CAST(((TotalSize_Gb - (LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName ORDER BY CreatedOn DESC))) / LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName ORDER BY  CreatedOn DESC) ) * 100 AS MONEY)
			END AS GrowthPercentage
		,LEAD(TotalSize_Gb,1) OVER (PARTITION  BY DatabaseName  ORDER BY  CreatedOn DESC) AS PrevPeriod
		,[AvailableSpace_Gb]
		,[PercentFreeSpace]
		, DATEDIFF(DAY,(LEAD(cast(CreatedOn AS DATE),1) OVER (PARTITION  BY DatabaseName  ORDER BY CreatedOn DESC)), Cast([CreatedOn] AS date)) AS DaysInPeriod
	 FROM 
		cteInfo
	ORDER BY  
		DatabaseName
		,CreatedOn Desc
END')
end
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pDatabaseMirroring_Performance_Collect]',10,1) WITH NOWAIT;
if object_id('dbo.pDatabaseMirroring_Performance_Collect') is null exec('create procedure [dbo].[pDatabaseMirroring_Performance_Collect] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Monitor performance of database mirroring connections to be able to troubleshoot 1474 and 1479 errors
*
*	Inputs:	None
*
*	Notes:	
*	1. This stored procedure is designed to run continuously and should be run on both partners
*	2. The tables with names that end in "changes" will only insert a new row if there is a change from prior values
*		and other tables should insert row on every run
*	3. It is suggested that this procedure be run every 10 seconds for possible restarts
*
*	Work ToDo:
*	1. Support having Witness connections as this is not in current design and will cause problems.
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2017-11-29			Mike Zawadzki			Created
*	
*********************************************************************************************************************/
alter procedure dbo.pDatabaseMirroring_Performance_Collect 
WITH ENCRYPTION 
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @database_mirroring_changes_id int
	DECLARE @receive_id int
	DECLARE @send_id int
	DECLARE @dt datetime
	DECLARE @dtprev datetime
	DECLARE @bytes0_prev bigint
	DECLARE @bytes1_prev bigint
	DECLARE @role tinyint
	DECLARE @dtconnperfmax datetime

	--initialize starting values
	SELECT TOP 1 @dtprev = MAX(dt) FROM dbo.database_mirroring_lsns
	SELECT TOP 1 @database_mirroring_changes_id = MAX(database_mirroring_changes_id) FROM dbo.database_mirroring_changes
	SELECT TOP 1 @role = [role] FROM dbo.database_mirroring_changes WHERE database_mirroring_changes_id = @database_mirroring_changes_id
	SELECT TOP 1 @receive_id = MAX(database_mirroring_connect_changes_id) FROM dbo.database_mirroring_connect_changes WHERE is_accept = 1
	SELECT TOP 1 @send_id = MAX(database_mirroring_connect_changes_id) FROM dbo.database_mirroring_connect_changes WHERE is_accept = 0
	SELECT TOP 1 @dtconnperfmax = MAX(dt) FROM dbo.database_mirroring_connect_performance
	SELECT TOP 1 @bytes0_prev = total_bytes_sent+total_bytes_received FROM dbo.database_mirroring_connect_performance WHERE is_accept = 0 AND dt = @dtconnperfmax
	SELECT TOP 1 @bytes1_prev = total_bytes_sent+total_bytes_received FROM dbo.database_mirroring_connect_performance WHERE is_accept = 1 AND dt = @dtconnperfmax
	IF @bytes0_prev IS NULL
		SET @bytes0_prev = 0
	IF @bytes1_prev IS NULL
		SET @bytes1_prev = 0

	WHILE 1=1
	BEGIN

		-- insert database_mirroring_end_of_log_lsn and database_mirroring_failover_lsn every second
		-- maybe only insert if changes here as well
		SET @dt = GETDATE()
		IF @dtprev IS NULL
		BEGIN
			INSERT dbo.database_mirroring_lsns
				SELECT @dt, database_id, mirroring_end_of_log_lsn, mirroring_failover_lsn 
					FROM sys.database_mirroring 
					WHERE mirroring_guid IS NOT NULL
			SET @dtprev = @dt
		END
		ELSE
		BEGIN
			INSERT dbo.database_mirroring_lsns
				SELECT @dt, database_id, mirroring_end_of_log_lsn, mirroring_failover_lsn 
					FROM sys.database_mirroring m
						INNER JOIN dbo.database_mirroring_lsns c
						ON m.database_id = c.[dbid]
						AND c.dt = @dtprev
						AND m.mirroring_guid IS NOT NULL
						AND m.mirroring_end_of_log_lsn > c.end_of_log_lsn
			SET @dtprev = @dt
		END

		-- insert remaining columns when changes
		IF @database_mirroring_changes_id is null
		BEGIN
			INSERT dbo.database_mirroring_changes
				SELECT @dt, database_id, mirroring_state, mirroring_role, mirroring_safety_level, mirroring_connection_timeout 
					FROM sys.database_mirroring 
					WHERE mirroring_guid is not null
			SET @database_mirroring_changes_id = IDENT_CURRENT('dbo.database_mirroring_changes')
		END
		ELSE
		BEGIN
			INSERT dbo.database_mirroring_changes
				SELECT @dt, m.database_id, m.mirroring_state, m.mirroring_role, m.mirroring_safety_level, m.mirroring_connection_timeout 
					FROM sys.database_mirroring m
						INNER JOIN dbo.database_mirroring_changes c
						ON m.database_id = c.[dbid]
						AND c.database_mirroring_changes_id = @database_mirroring_changes_id
						AND m.mirroring_guid IS NOT NULL
					WHERE m.mirroring_state != c.[state]
						OR m.mirroring_role != c.[role]
						OR m.mirroring_safety_level != c.[safety]
						OR m.mirroring_connection_timeout != c.[timeout]
			IF @@ROWCOUNT > 0 
			BEGIN
				SET @database_mirroring_changes_id = IDENT_CURRENT('dbo.database_mirroring_changes')
				SELECT TOP 1 @role = [role] FROM dbo.database_mirroring_changes WHERE database_mirroring_changes_id = @database_mirroring_changes_id
			END
		END

		--insert if last_activity_time > 2 seconds ago
		INSERT dbo.database_mirroring_connect_performance
			SELECT @dt, is_accept, [state], is_receive_flow_controlled, is_send_flow_controlled, total_bytes_sent, total_bytes_received, last_activity_time,
				CASE 
					WHEN is_accept = 0 and @bytes0_prev > total_bytes_sent + total_bytes_received THEN 0 --connection reset
					WHEN is_accept = 0 and @bytes0_prev <= total_bytes_sent + total_bytes_received THEN total_bytes_sent + total_bytes_received - @bytes0_prev
					WHEN is_accept = 1 and @bytes1_prev > total_bytes_sent + total_bytes_received THEN 0 --connection reset
					WHEN is_accept = 1 and @bytes1_prev <= total_bytes_sent + total_bytes_received THEN total_bytes_sent + total_bytes_received - @bytes1_prev
					ELSE -1
				END
				FROM sys.dm_db_mirroring_connections 
				--WHERE datediff(millisecond, last_activity_time, getdate()) > 1000
		IF @@ROWCOUNT > 0
		BEGIN
			SELECT TOP 1 @bytes0_prev = total_bytes_sent + total_bytes_received FROM dbo.database_mirroring_connect_performance WHERE is_accept = 0 AND dt = @dt
			SELECT TOP 1 @bytes1_prev = total_bytes_sent + total_bytes_received FROM dbo.database_mirroring_connect_performance WHERE is_accept = 1 AND dt = @dt
		END

		--insert if connect_time has changed or state != 4 or login_state != 12
		if @receive_id IS NULL
		BEGIN
			INSERT dbo.database_mirroring_connect_changes
				SELECT @dt, is_accept, [state], login_state, connect_time FROM sys.dm_db_mirroring_connections
			IF @@ROWCOUNT > 0
			BEGIN
				SELECT TOP 1 @receive_id = MAX(database_mirroring_connect_changes_id) FROM dbo.database_mirroring_connect_changes WHERE is_accept = 1
				SELECT TOP 1 @send_id = MAX(database_mirroring_connect_changes_id) FROM dbo.database_mirroring_connect_changes WHERE is_accept = 0
			END
		END
		ELSE
		BEGIN
			INSERT dbo.database_mirroring_connect_changes
				SELECT @dt, m.is_accept, m.[state], m.login_state, m.connect_time
					FROM sys.dm_db_mirroring_connections m
						INNER JOIN dbo.database_mirroring_connect_changes c
						ON m.is_accept = c.is_accept
						AND c.database_mirroring_connect_changes_id IN (@receive_id, @send_id)
					WHERE m.[state] != c.[state]
						OR m.login_state != c.login_state
						OR m.connect_time != c.connect_time
			IF @@ROWCOUNT > 0
			BEGIN
				SELECT TOP 1 @receive_id = MAX(database_mirroring_connect_changes_id) FROM dbo.database_mirroring_connect_changes WHERE is_accept = 1
				SELECT TOP 1 @send_id = MAX(database_mirroring_connect_changes_id) FROM dbo.database_mirroring_connect_changes WHERE is_accept = 0
			END
		END

		WAITFOR DELAY '00:00:03' --run 3 times in default 10 second timeout
	END
END

GO


IF (select VerDec from #FDVER) >= 11.0
BEGIN
RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pDatabaseObjectGrowth]',10,1) WITH NOWAIT;
if object_id('dbo.pDatabaseObjectGrowth') is null exec('create procedure [dbo].[pDatabaseObjectGrowth] as select getdate() DT')
exec('alter procedure [dbo].pDatabaseObjectGrowth
	(
		@DatabaseName				SYSNAME		= N''ALL'',
		@MinMbUsed					INT			= 512
	)
	WITH ENCRYPTION
	 AS
	SET NOCOUNT ON
	set TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
	EXEC dbo.usp_UpdateVersionStatics
	--get the list of objects that meet the size requirement and database name
	;with cteMyList AS(
	SELECT distinct 
		v.DatabaseName
		,v.SchemaName
		,v.TableName
		,v.IndexName
	FROM 
		[dbo].[vDatabaseObjectStorage] v
	WHERE 
		1=1
		AND (v.DatabaseName = @DatabaseName OR @DatabaseName = N''ALL'')
		AND v.Type_Desc in (''Heap'',''Clustered'') 
		AND v.[usedSpace_mb] >= @MinMbUsed
	)


	SELECT 
		CAST(v.CreatedOn as date)as [CreatedOn]
		,v.DatabaseName
		,v.SchemaName
		,v.TableName
		,v.reservedSpace_mb
		,LEAD(v.reservedSpace_mb,1,v.reservedSpace_mb) OVER ( PARTITION  BY v.DatabaseName, v.TableName ORDER BY v.DatabaseName, v.TableName, v.CreatedOn desc) AS PrevPeriod
		,v.reservedSpace_mb - LEAD(v.reservedSpace_mb,1,v.reservedSpace_mb) OVER ( PARTITION  BY v.DatabaseName, v.TableName ORDER BY v.DatabaseName, v.TableName, v.CreatedOn desc) as GrowthOverPrevPeriod_mb
		,CAST(v.reservedSpace_mb - LEAD(v.reservedSpace_mb,1,v.reservedSpace_mb) OVER ( PARTITION  BY v.DatabaseName, v.TableName ORDER BY v.DatabaseName, v.TableName, v.CreatedOn desc)as money)/1024 as GrowthOverPrevPeriod_GB
		,CASE WHEN LEAD(v.reservedSpace_mb,1) OVER ( PARTITION  BY v.DatabaseName, v.TableName ORDER BY v.DatabaseName, v.TableName, v.CreatedOn desc)  < 1 THEN NULL
			ELSE
				CAST(((v.reservedSpace_mb - LEAD(v.reservedSpace_mb,1) OVER ( PARTITION  BY v.DatabaseName, v.TableName ORDER BY v.DatabaseName, v.TableName, v.CreatedOn desc)) /
				CAST(LEAD(v.reservedSpace_mb,1) OVER ( PARTITION  BY v.DatabaseName, v.TableName ORDER BY v.DatabaseName, v.TableName, v.CreatedOn desc)AS MONEY) ) * 100 AS MONEY)
		END AS GrowthPercentage
		, DATEDIFF(DAY,(LEAD(cast(CreatedOn AS DATE),1) OVER ( PARTITION  BY v.DatabaseName, v.TableName ORDER BY v.DatabaseName, v.TableName, v.CreatedOn desc)), Cast([CreatedOn] AS date)) AS DaysInPeriod

	  FROM 
		[dbo].[vDatabaseObjectStorage] v
		INNER JOIN cteMyList c on v.DatabaseName = c.DatabaseName
				AND v.SchemaName = c.SchemaName
				AND v.TableName = c.TableName
				AND v.IndexName = c.IndexName
	WHERE 
		1=1
		AND (datepart(dd,[CreatedOn]) = 1
				or Cast([CreatedOn] as date) = (select cast(max(CreatedOn) as date)  from [dbo].[vDatabaseObjectStorage])
				)
	ORDER BY  
		v.DatabaseName 
		,v.TableName
		,v.CreatedOn Desc
		,v.reservedSpace_mb desc')
end
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pDatabaseObjectStorage_Add]',10,1) WITH NOWAIT;
if object_id('dbo.pDatabaseObjectStorage_Add') is null exec('create procedure [dbo].[pDatabaseObjectStorage_Add] as select getdate() DT')
GO
  
alter procedure [dbo].pDatabaseObjectStorage_Add
(	
	@databaseName	sysname 
	,@createdOn		DATETIME
)
WITH ENCRYPTION
AS

SET NOCOUNT ON
DECLARE @sql		NVARCHAR(max)
IF @createdOn IS NULL
	SET @createdOn = GetDate()

SET @sql = N'INSERT INTO dbo.DatabaseObjectStorage (InstanceName,CreatedOn,DatabaseName, SchemaName,TableName, IndexName, PartitionNumber, 
	Index_Type, DataCompression, RecordCount, in_row_reserved_page_count, lob_reserved_page_count, 
	row_overflow_reserved_page_count, in_row_used_page_count, lob_used_page_count, row_overflow_used_page_count, 
	FileGroupName, DriveLetter)
SELECT 
	@@SERVERNAME
	,N''' + convert(VARCHAR(30), @createdOn ,113) + N'''
	,N''' + @databaseName + N'''
	,sc.name
	,t.name 
	,CASE WHEN i.type_desc = N''HEAP'' THEN N''HEAP'' ELSE i.[name]  End
	,p.partition_number 
	,i.TYPE
	,p.data_compression
	,p.[rows]
	,s.in_row_reserved_page_count 
	,s.lob_reserved_page_count 
	,s.row_overflow_reserved_page_count
	,s.in_row_used_page_count 
	,s.lob_used_page_count 
	,s.row_overflow_used_page_count
	,fg.name 
	,fgs.DriveLetter
FROM 
	['+ @databaseName + N'].sys.dm_db_partition_stats AS s
	inner join ['+ @databaseName + N'].sys.partitions p on s.partition_id = p.partition_id
	inner join ['+ @databaseName + N'].sys.tables t on s.object_id = t.object_id
	inner join ['+ @databaseName + N'].sys.schemas sc on t.schema_id = sc.schema_id
	INNER JOIN ['+ @databaseName + N'].sys.indexes AS i ON s.[object_id] = i.[object_id]
		AND s.[index_id] = i.[index_id]
	inner join ['+ @databaseName + N'].sys.filegroups fg on i.data_space_id = fg.data_space_id
	left join  (SELECT distinct 
					fg.name, 
					MIN(SUBSTRING(df.physical_name,1,1) )AS DriveLetter 
				FROM 
					['+ @databaseName + N'].sys.filegroups fg
					inner join ['+ @databaseName + N'].sys.database_files df on fg.data_space_id = df.data_space_id
				GROUP BY
					fg.name
			) AS fgs on   fg.name = fgs.name
'
EXECUTE sp_executesql @sql 


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pDatabaseObjectStorage_AddByDatabaseName]',10,1) WITH NOWAIT;
if object_id('dbo.pDatabaseObjectStorage_AddByDatabaseName') is null exec('create procedure [dbo].[pDatabaseObjectStorage_AddByDatabaseName] as select getdate() DT')
GO
  alter procedure [dbo].[pDatabaseObjectStorage_AddByDatabaseName]
(	
	@databaseNameList		VARCHAR(max)
	,@delimiter				CHAR(1)
	,@allUserDatabases		bit = 0
)
WITH ENCRYPTION
AS
SET NOCOUNT ON
exec dbo.usp_UpdateVersionStatics

DECLARE @dbname				sysname
DECLARE @dblist				table(DBName VARCHAR(128))
DECLARE @CreatedDateTime	DATETIME


SET @CreatedDateTime = GETDATE()

IF @allUserDatabases = 1
begin
	--Insert all online user databases and check if in an AG then only take those that are the primary replica
	--check mirroring too and only choose PRINCIPAL
	INSERT INTO @dblist
	SELECT 
		d.name 
	 FROM 
		sys.databases d
		LEFT JOIN sys.dm_hadr_database_replica_states drs on d.group_database_id = drs.group_database_id AND d.replica_id = drs.replica_id
		LEFT JOIN sys.availability_groups ag on drs.group_id = ag.group_id
		LEFT JOIN sys.dm_hadr_availability_group_states agstate on ag.group_id = agstate.group_id
		LEFT JOIN sys.database_mirroring m ON d.database_id = m.database_id
	WHERE 
		d.database_id > 4 
		And state_desc = 'ONLINE' 
		and source_database_id IS NULL
		AND ( agstate.group_id IS NULL 
				OR	
			agstate.primary_replica = @@SERVERNAME )
		AND (m.mirroring_role_desc IS NULL
			OR
			m.mirroring_role_desc =N'PRINCIPAL')

end
ELSE
begin
	IF ISNULL(@databaseNameList,'') = '' or ISNULL(@delimiter,'') = ''
	begin
		RAISERROR('Must pass in a valid value for parameters @databaseNameList and/or @delimiter',15,125) WITH NOWAIT;
		RETURN
	end
	INSERT INTO @dblist
	SELECT 
		x.[items] 
	 FROM 
		dbo.fSplit(@databaseNameList,@delimiter) as x
		INNER JOIN sys.databases d ON x.items = d.name
		LEFT JOIN sys.dm_hadr_database_replica_states drs on d.group_database_id = drs.group_database_id AND d.replica_id = drs.replica_id
		LEFT JOIN sys.availability_groups ag on drs.group_id = ag.group_id
		LEFT JOIN sys.dm_hadr_availability_group_states agstate on ag.group_id = agstate.group_id
		LEFT JOIN sys.database_mirroring m ON d.database_id = m.database_id
	WHERE 
		d.database_id > 4 
		And state_desc = 'ONLINE' 
		and source_database_id IS NULL
		AND ( agstate.group_id IS NULL 
				OR	
			agstate.primary_replica = @@SERVERNAME )
		AND (m.mirroring_role_desc IS NULL
			OR
			m.mirroring_role_desc =N'PRINCIPAL')
end

DECLARE curDB CURSOR FAST_FORWARD LOCAL FOR	
	SELECT DBName FROM @dblist
Open curDB
Fetch Next FROM curDB INTO @dbname
WHILE @@FETCH_STATUS = 0
Begin
	EXECUTE dbo.pDatabaseObjectStorage_Add @databaseName = @dbname, @createdOn = @CreatedDateTime
	Fetch Next FROM curDB INTO @dbname
End
Close curDB
Deallocate curDB
GO


RAISERROR ('	CREATING OR ALTERING PROCEDURE dbo.pFileStats_Gather',10,1) WITH NOWAIT;


IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pFileStats_Gather]') AND TYPE in (N'P', N'PC'))
BEGIN
	EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[pFileStats_Gather]		
AS
SET NOCOUNT ON
SELECT GETDATE()	
'
END

GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO
IF (select VerDec from #FDVER) >= 10.5
BEGIN
	EXEC sp_executesql @stmt = N'/****************************************************************
	*				pFileStats_Gather
	*  Stores a snapshot of the virtual file stats. This data can then
	* be used to see IO numbers between gathered periods.
	*****************************************************************/
ALTER PROCEDURE dbo.pFileStats_Gather
	@exclusionList		varchar(8000) = NULL,
	@delimeter			char(1) = NULL
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
exec dbo.usp_UpdateVersionStatics

	DECLARE @start	DATETIME2(3)
	DECLARE @now	DATETIME2(3)
	SELECT @start = CAST(sqlserver_start_time AS DATETIME2(3)) FROM sys.dm_os_sys_info
	SELECT @now = CAST(GETDATE()AS DATETIME2(3))
	
	INSERT INTO dbo.FileStats (InstanceName, CreatedOn, LastSqlStartOn, DatabaseName,
		Database_Id, File_id, LogicalFileName, Sample_ms, Num_of_reads,
		Num_of_bytes_read, Io_stall_read_ms, Num_of_writes, Num_of_bytes_written,
		Io_stall_write_ms, Io_stall, Size_on_disk_bytes )
	
	
	SELECT  
		@@SERVERNAME, 
		@now, 
		@start, 
		d.name,
		fs.database_id, 
		fs.file_id ,
		af.name,
		fs.sample_ms,num_of_reads,
		fs.num_of_bytes_read, 
		fs.io_stall_read_ms, 
		fs.num_of_writes, 
		fs.num_of_bytes_written,
		fs.io_stall_write_ms, 
		fs.io_stall, 
		fs.size_on_disk_bytes
	 FROM  
		sys.dm_io_virtual_file_stats (null,null) fs 
		INNER JOIN sys.databases d ON fs.database_id = d.database_id 
		INNER JOIN sys.sysaltfiles af ON fs.database_id = af.dbid 
					AND fs.file_id = af.fileid 
	 WHERE 
		d.name NOT IN (SELECT LTRIM(RTRIM(items)) FROM dbo.fSplit(@exclusionList, @delimeter))'

END
ELSE 
BEGIN
	EXEC sp_executesql @stmt = N'/****************************************************************
	*				pFileStats_Gather
	*  Stores a snapshot of the virtual file stats. This data can then
	* be used to see IO numbers between gathered periods.
	*****************************************************************/
ALTER PROCEDURE dbo.pFileStats_Gather
	@exclusionList		varchar(8000) = NULL,
	@delimeter			char(1) = NULL
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
exec dbo.usp_UpdateVersionStatics
	DECLARE @start	DATETIME
	DECLARE @now	DATETIME
	SELECT @start = create_date from sys.databases where name = N''tempdb''
	SELECT @now = CAST(GETDATE()AS DATETIME)
	
	INSERT INTO dbo.FileStats (InstanceName, CreatedOn, LastSqlStartOn, DatabaseName,
		Database_Id, File_id, LogicalFileName, Sample_ms, Num_of_reads,
		Num_of_bytes_read, Io_stall_read_ms, Num_of_writes, Num_of_bytes_written,
		Io_stall_write_ms, Io_stall, Size_on_disk_bytes )
	
	
	SELECT  
		@@SERVERNAME, 
		@now, 
		@start, 
		d.name,
		fs.database_id, 
		fs.file_id ,
		af.name,
		fs.sample_ms,num_of_reads,
		fs.num_of_bytes_read, 
		fs.io_stall_read_ms, 
		fs.num_of_writes, 
		fs.num_of_bytes_written,
		fs.io_stall_write_ms, 
		fs.io_stall, 
		fs.size_on_disk_bytes
	 FROM  
		sys.dm_io_virtual_file_stats (null,null) fs 
		INNER JOIN sys.databases d ON fs.database_id = d.database_id 
		INNER JOIN sys.sysaltfiles af ON fs.database_id = af.dbid 
					AND fs.file_id = af.fileid 
	 WHERE 
		d.name NOT IN (SELECT LTRIM(RTRIM(items)) FROM dbo.fSplit(@exclusionList, @delimeter))'
END
--------------------------------------------------------------------------------------------------------------------------
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGenerateRestore]',10,1) WITH NOWAIT;
if object_id('dbo.pGenerateRestore') is null exec('create procedure [dbo].[pGenerateRestore] as select getdate() DT')
GO
  

alter procedure dbo.pGenerateRestore (
@dbname							SYSNAME	,				--Name of database to restore from
@asofdate						DATETIME = NULL,		-- Date and time of backup, null means latest
@getOneLogFollowingAsOfDate		BIT	 = 1,				-- If true (1) will return 1 log file past the @asofdate if available
@newdbname						NVARCHAR(128) = NULL,	-- Name of new database if restoring to a new name
@moveDataFileLocation			NVARCHAR(240) = NULL,	-- location to move all data files
@moveLogFileLocation			NVARCHAR(240) = NULL,	--location to move log file(s)
@withNORecovery					BIT = 0,				--Restore Recovery Option, default is 0 (with recovery) set to 1 to leave database in resotring mode
@currentDriveName				VARCHAR(200) = NULL,	--Current drive and replacement drive are used to replace the backup drive path so you can replace a UNC with a drive name 
@replacementDriveName			VARCHAR(200) = NULL,	-- or a different unc path or a srive letter and path
@bufferCount					INT  = NULL,			--Specifies the total number of I/O buffers to be used for the restore operation. You can specify any positive integer; however, large numbers of buffers might cause "out of memory" errors because of inadequate virtual address space in the Sqlservr.exe process.
@maxTransferSize				INT	 = NULL,			-- Specifies the largest unit of transfer in bytes to be used between the backup media and SQL Server. The possible values are multiples of 65536 bytes (64 KB) ranging up to 4194304 bytes (4 MB).
@blockSize						INT  = NULL,			-- Specifies the physical block size, in bytes. The supported sizes are 512, 1024, 2048, 4096, 8192, 16384, 32768, and 65536 (64 KB) bytes. 
@debug							BIT = 0					-- Will return the result sets used for logical/Physical names and backup file information

)
WITH ENCRYPTION
AS
BEGIN
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

	
DECLARE @lastFullStartDate			DATETIME
DECLARE @recoverymodel				NVARCHAR(60)
DECLARE @hasSnapShot				BIT
DECLARE @fullFirstLsn				NUMERIC(25,0)
DECLARE @currentFile				NVARCHAR(260)
DECLARE @fileList					NVARCHAR(max)
DECLARE @sql						NVARCHAR(max)
DECLARE @sqlOut						NVARCHAR(max)
DECLARE @physicalFile				NVARCHAR(260)
DECLARE @logicalFile				SYSNAME
DECLARE @lsn						DECIMAL(25,0)
DECLARE @passedFrist				BIT

if not exists (select * from Licensing.fn_ValidateLicense())
IF @asofdate IS NULL
	SET @asofdate = GETDATE()
--If move location does not end in a slash add one
IF @moveDataFileLocation IS NOT NULL
BEGIN
	IF (SUBSTRING(REVERSE(@moveDataFileLocation),1,1) != '\')
			SET @moveDataFileLocation = @moveDataFileLocation + '\'
END
IF @moveLogFileLocation IS NOT NULL
BEGIN
	IF (SUBSTRING(REVERSE(@moveLogFileLocation),1,1) != '\')
			SET @moveLogFileLocation = @moveLogFileLocation + '\'
END

If Object_id('tempdb..#LogicalList') IS NOT NULL
	DROP TABLE #LogicalList
CREATE TABLE #LogicalList(LogicalName SYSNAME, PhysicalName NVARCHAR(260), FileType CHAR(1))

INSERT INTO #LogicalList(LogicalName, PhysicalName, FileType)
SELECT	
	bf.logical_name as LogicalName,
	bf.physical_name as PhysicalName,
	bf.file_type
 FROM msdb..backupset s inner join msdb..backupfile bf ON
		s.backup_set_id = bf.backup_set_id 
		
WHERE s.database_name = @dbname  
	--most recent full 
  AND s.backup_start_date = 
			(SELECT max(s.backup_start_date) 
				FROM msdb..backupset s 
			  where s.database_name = @dbname AND s.type = 'D'	 )
ORDER BY LogicalName, physical_name 

/*******************************************************************************
  Retrievs list of the SET of backupfiles needed to restore the
  supplied database up to the most recent diff, full or log 
  backup as of the supplied @asofdate.
******************************************************************************/
If Object_id('tempdb..#RestoreList') IS NOT NULL
	DROP TABLE #RestoreList
CREATE TABLE #RestoreList(
	Id int IDENTITY(1,1) not null PRIMARY KEY CLUSTERED, 
	RecoveryModel NVARCHAR(60),	
	BackupFile varchar(260), 
	BackupType varchar(60), 
	BackupStartDate DATETIME, 
	BackupFinishDate DATETIME, 
	FirstLsn DECIMAL(25,0), 
	DatabaseBackupLsn DECIMAL(25,0), 
	DifferentialBaseLsn DECIMAL(25,0), 
	IsSnapshot BIT, 
	IsCopyOnly BIT
)


--get the date of the last full that was not a copy and is <= the @asofdate param
SELECT 
	 @lastFullStartDate = MAX(backup_start_date) 
 FROM  
	msdb.dbo.backupset 
WHERE 
	database_name = @dbname 
	AND [type] = 'D'
	AND is_copy_only = 0 
	AND is_snapshot = 0
	AND backup_start_date <= @asofdate 


--insert the last full backup
INSERT INTO #RestoreList (RecoveryModel, BackupFile, BackupType, BackupStartDate, BackupFinishDate, FirstLsn, DatabaseBackupLsn, DifferentialBaseLsn,IsSnapshot, IsCopyOnly )
SELECT 
	DISTINCT 
	b.recovery_model, 
	bmf.physical_device_name,
	CASE b.[type]	
	  WHEN 'D' THEN 'Full'
	  WHEN 'I' THEN 'Differential'
	  WHEN 'L' THEN 'Transaction Log'
	  ELSE 'ERROR'
	END,	 
	b.backup_start_date, 
	b.backup_finish_date, 
	b.first_lsn, 
	b.database_backup_lsn, 
	b.differential_base_lsn, 
	b.is_snapshot, 
	b.is_copy_only 
 FROM 
	msdb.dbo.backupset b  
	INNER JOIN 	msdb.dbo.backupfile	buf ON b.backup_set_id = buf.backup_set_id 
	INNER JOIN msdb.dbo.backupmediafamily bmf ON b.media_set_id = bmf.media_set_id 
 WHERE 
	b.database_name = @dbname 
	AND b.backup_start_date = @lastFullStartDate 
	AND b.[type] = 'D'
  
SELECT TOP 1 @fullFirstLsn =  FirstLsn FROM #RestoreList
--INSERT THE LAST DIFFERENTIAL
INSERT INTO #RestoreList (RecoveryModel, BackupFile, BackupType, BackupStartDate, BackupFinishDate, FirstLsn, DatabaseBackupLsn, DifferentialBaseLsn,IsSnapshot, IsCopyOnly )
SELECT 
	DISTINCT 
	b.recovery_model, 
	bmf.physical_device_name,
	CASE b.[type]	
	  WHEN 'D' THEN 'Full'
	  WHEN 'I' THEN 'Differential'
	  WHEN 'L' THEN 'Transaction Log'
	  ELSE 'ERROR'
	END,	
	b.backup_start_date, 
	b.backup_finish_date, 
	b.first_lsn, 
	b.database_backup_lsn, 
	b.differential_base_lsn, 
	b.is_snapshot, 
	b.is_copy_only
 FROM msdb.dbo.backupset b  
	INNER JOIN 	msdb.dbo.backupfile	buf ON b.backup_set_id = buf.backup_set_id 
	INNER JOIN msdb.dbo.backupmediafamily bmf ON b.media_set_id = bmf.media_set_id 
 WHERE 
	b.database_name = @dbname 
	AND b.[type] = 'I'
	AND b.database_backup_lsn = @fullFirstLsn
	AND b.backup_start_date = (	SELECT 
									MAX(backup_start_date) 
								  FROM  
									msdb.dbo.backupset 
								 WHERE 
									database_name = @dbname 
									AND [type] = 'I'
									AND backup_start_date > @lastFullStartDate   
									AND backup_start_date <= @asofdate
							  )
							  
--INSERT ANY TRANSACTION LOGS
If EXISTS (SELECT TOP 1 1 FROM #RestoreList where RecoveryModel = N'FULL')
Begin
--get the last start time of the last backup whether full or diff, if there is a diff then use that
-- otherwise we already have the date
	If EXISTS (SELECT BackupStartDate FROM  #RestoreList WHERE BackupType  = 'Differential')
		SELECT  @lastFullStartDate = MAX(BackupStartDate) FROM  #RestoreList WHERE BackupType  = 'Differential'
		
	IF @getOneLogFollowingAsOfDate = 0
	BEGIN
	INSERT INTO #RestoreList (RecoveryModel, BackupFile, BackupType, BackupStartDate, BackupFinishDate, FirstLsn, DatabaseBackupLsn, DifferentialBaseLsn,IsSnapshot, IsCopyOnly )
		SELECT 
			DISTINCT 
			b.recovery_model, 
			bmf.physical_device_name,
			CASE b.[type]	
			  WHEN 'D' THEN 'Full'
			  WHEN 'I' THEN 'Differential'
			  WHEN 'L' THEN 'Transaction Log'
			  ELSE 'ERROR'
			END,	
			b.backup_start_date, 
			b.backup_finish_date, 
			b.first_lsn, 
			b.database_backup_lsn, 
			b.differential_base_lsn, 
			b.is_copy_only, 
			b.is_snapshot 
		 FROM msdb.dbo.backupset b  
			INNER JOIN 	msdb.dbo.backupfile	buf ON b.backup_set_id = buf.backup_set_id 
			INNER JOIN msdb.dbo.backupmediafamily bmf ON b.media_set_id = bmf.media_set_id 
		WHERE 
			b.database_name = @dbname 
			AND b.[type] = 'L'
			AND b.database_backup_lsn = @fullFirstLsn
			AND b.backup_start_date >= @lastFullStartDate
			AND b.backup_start_date <= @asofdate
	END
	ELSE
	BEGIN
	INSERT INTO #RestoreList (RecoveryModel, BackupFile, BackupType, BackupStartDate, BackupFinishDate, FirstLsn, DatabaseBackupLsn, DifferentialBaseLsn,IsSnapshot, IsCopyOnly )
		SELECT 
			DISTINCT 
			b.recovery_model, 
			bmf.physical_device_name,
			CASE b.[type]	
			  WHEN 'D' THEN 'Full'
			  WHEN 'I' THEN 'Differential'
			  WHEN 'L' THEN 'Transaction Log'
			  ELSE 'ERROR'
			END,	
			b.backup_start_date, 
			b.backup_finish_date, 
			b.first_lsn, 
			b.database_backup_lsn, 
			b.differential_base_lsn, 
			b.is_copy_only, 
			b.is_snapshot 
		 FROM msdb.dbo.backupset b  
			INNER JOIN 	msdb.dbo.backupfile	buf ON b.backup_set_id = buf.backup_set_id 
			INNER JOIN msdb.dbo.backupmediafamily bmf ON b.media_set_id = bmf.media_set_id 
		WHERE 
			b.database_name = @dbname 
			AND b.[type] = 'L'
			AND b.database_backup_lsn = @fullFirstLsn
			AND b.backup_start_date >= @lastFullStartDate
			AND b.backup_start_date <= (SELECT ISNULL(MIN(backup_start_date),@asofdate) 
										 FROM msdb.dbo.backupset 
										 WHERE database_name = @dbname AND [type] ='L' AND b.database_backup_lsn = @fullFirstLsn 
											AND backup_start_date >  @asofdate)
	END
End
  
  
IF @debug = 1
BEGIN
	SELECT * FROM #RestoreList 
	SELECT * FROM #LogicalList
END


/*********************************************************************************************************************
						Build the Restore Statement
*********************************************************************************************************************/
SET @sql = N'Use [' + ISNULL(@newdbname,@dbname) + N']' + CHAR(10)  + 
	N' ALTER DATABASE [' + ISNULL(@newdbname,@dbname) + N'] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;' + CHAR(10)  +
	N' ALTER DATABASE [' + ISNULL(@newdbname,@dbname) + N'] SET MULTI_USER;' +CHAR(10)  +
	N' USE Master' + CHAR(10) + 'GO' + CHAR(10)  


SET @sql = @sql + 'RESTORE DATABASE [' + ISNULL(@newdbname,@dbname) + '] FROM '


/************************************************************************************
		Loop through the records and build the command to restore the FULL backup	
*************************************************************************************/
SET @fileList  = ''
WHILE (SELECT COUNT(*) FROM #RestoreList WHERE BackupType = 'Full') > 0
BEGIN
	SELECT TOP 1 @currentFile = BackupFile FROM #RestoreList WHERE BackupType = 'Full'
	IF @fileList = ''
		SET @fileList = @fileList + 'DISK=N''' + @currentFile + ''''
	ELSE
		SET @fileList = @fileList + CHAR(10)  +',DISK=N''' + @currentFile + ''''

	DELETE FROM #RestoreList WHERE BackupType = 'Full' AND  BackupFile = @currentFile
END

--drive mapping
IF(@currentDriveName IS NOT NULL AND @replacementDriveName IS NOT NULL)
BEGIN
	SET @fileList = REPLACE(@fileList,@currentDriveName,@replacementDriveName)
END


SET @sql = @sql + @fileList + CHAR(10) + 'WITH STATS=10'  + CHAR(10)
SET @sqlOut = @sql 

PRINT @sql
SET @sql = N''

If @moveDataFileLocation IS NOT NULL
BEGIN
	DECLARE curDataFile CURSOR FAST_FORWARD LOCAL FOR 
		SELECT LogicalName, PhysicalName FROM #LogicalList WHERE FileType = 'D'
	OPEN curDataFile
	FETCH NEXT FROM curDataFile INTO @logicalFile, @physicalFile
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF @newdbname IS NULL
			SET @sql = @sql + ',MOVE ''' + @logicalFile +''' to ''' + @moveDataFileLocation + REVERSE(SUBSTRING (REVERSE(@physicalFile),1, CHARINDEX('\',REVERSE(@physicalFile),1) -1)) + '''' + CHAR(10)
		ELSE
			SET @sql = @sql + ',MOVE ''' + @logicalFile +''' to ''' + @moveDataFileLocation + REPLACE(REVERSE(SUBSTRING (REVERSE(@physicalFile),1, CHARINDEX('\',REVERSE(@physicalFile),1) -1)), @dbname, @newdbname) + '''' + CHAR(10)

		FETCH NEXT FROM curDataFile INTO @logicalFile, @physicalFile
	END
	CLOSE curDataFile
	DEALLOCATE curDataFile
END
 
If @moveLogFileLocation IS NOT NULL
BEGIN
	DECLARE curLogFile CURSOR FAST_FORWARD LOCAL FOR 
		SELECT LogicalName, PhysicalName FROM #LogicalList WHERE FileType = 'L'
	OPEN curLogFile
	FETCH NEXT FROM curLogFile INTO @logicalFile, @physicalFile
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF @newdbname IS NULL
			SET @sql = @sql + ',MOVE ''' + @logicalFile +''' to ''' + @moveLogFileLocation + REVERSE(SUBSTRING (REVERSE(@physicalFile),1, CHARINDEX('\',REVERSE(@physicalFile),1) -1)) + '''' +CHAR(10)
		ELSE
			SET @sql = @sql + ',MOVE ''' + @logicalFile +''' to ''' + @moveLogFileLocation + REPLACE(REVERSE(SUBSTRING (REVERSE(@physicalFile),1, CHARINDEX('\',REVERSE(@physicalFile),1) -1)),@dbname,@newdbname) + '''' +CHAR(10)
		FETCH NEXT FROM curLogFile INTO @logicalFile, @physicalFile
	END
	CLOSE curLogFile
	DEALLOCATE curLogFile
END



IF @bufferCount IS NOT NULL
	SET @sql = @sql + ', BUFFERCOUNT = ' + CAST(@bufferCount AS NVARCHAR(100)) 
IF @maxTransferSize IS NOT NULL
	SET @sql = @sql + ', MAXTRANSFERSIZE = ' + CAST(@maxTransferSize AS NVARCHAR(100)) 
IF @blockSize IS NOT NULL
	SET @sql = @sql + ', BLOCKSIZE = ' + CAST(@blockSize AS NVARCHAR(100)) 


--If we have no differential or transaction log to restore then we can set the recovery/norecovery param
IF EXISTS(SELECT TOP 1 1 FROM #RestoreList)
BEGIN
	SET @sql = @sql + ', NORECOVERY;'
END
ELSE
BEGIN
	IF @withNORecovery = 1
		SET @sql = @sql + ', NORECOVERY;'
	ELSE
		SET @sql = @sql + ', RECOVERY;'
END


SET @sqlOut = @sqlOut + @sql
PRINT @sql
PRINT ''
PRINT ''

SET @sqlOut = @sqlOut + CHAR(10)+ char(13) + CHAR(10)+ char(13)

/********************************************************************
		Create Differential backup restore
********************************************************************/

SET @fileList  = ''
SET @sql = 'RESTORE DATABASE [' + ISNULL(@newdbname,@dbname) + '] FROM '
IF EXISTS(SELECT TOP 1 1 FROM #RestoreList WHERE BackupType = 'Differential')
BEGIN
	WHILE (SELECT COUNT(*) FROM #RestoreList WHERE BackupType = 'Differential') > 0
	BEGIN
		SELECT TOP 1 @currentFile = BackupFile FROM #RestoreList WHERE BackupType = 'Differential' 
		IF @fileList = ''
			SET @fileList = @fileList + 'DISK=N''' + @currentFile + ''''
		ELSE
			SET @fileList = @fileList + CHAR(10)  +',DISK=N''' + @currentFile + ''''

		DELETE FROM #RestoreList WHERE BackupType = 'Differential' AND  BackupFile = @currentFile
	END

	--Overwrite the drive path
	IF(@currentDriveName IS NOT NULL AND @replacementDriveName IS NOT NULL)
	BEGIN
		SET @fileList = REPLACE(@fileList,@currentDriveName,@replacementDriveName)
	END
	SET @sql = @sql + @fileList + CHAR(10) + 'WITH STATS=10'  + CHAR(10)

	IF @bufferCount IS NOT NULL
		SET @sql = @sql + ', BUFFERCOUNT = ' + CAST(@bufferCount AS NVARCHAR(100)) 
	IF @maxTransferSize IS NOT NULL
		SET @sql = @sql + ', MAXTRANSFERSIZE = ' + CAST(@maxTransferSize AS NVARCHAR(100)) 
	IF @blockSize IS NOT NULL
		SET @sql = @sql + ', BLOCKSIZE = ' + CAST(@blockSize AS NVARCHAR(100)) 


	--If we have no transaction log to restore then we can set the recovery/norecovery param
	IF EXISTS(SELECT TOP 1 1 FROM #RestoreList)
	BEGIN
		SET @sql = @sql + ', NORECOVERY;'
	END
	ELSE
	BEGIN
		IF @withNORecovery = 1
			SET @sql = @sql + ', NORECOVERY;'
		ELSE
			SET @sql = @sql + ', RECOVERY;'
	END


	SET @sqlOut = @sqlOut + @sql + CHAR(10)
	PRINT @sql
END

PRINT ''''
PRINT ''''
/********************************************************************
		Create LOG backup restores
********************************************************************/

SET @fileList  = ''
WHILE EXISTS (SELECT TOP 1 1 FROM #RestoreList WHERE BackupType = 'Transaction Log')
BEGIN
	SELECT TOP 1 @lsn = FirstLsn FROM #RestoreList  WHERE BackupType = 'Transaction Log'
	SET @fileList = ''
	SET @passedFrist = 0  
	SET @sql = 'RESTORE LOG [' + ISNULL(@newdbname,@dbname) + '] FROM '
	DECLARE curLog CURSOR FAST_FORWARD LOCAL FOR
		SELECT BackupFile FROM #RestoreList WHERE FirstLsn =@lsn
	OPEN curLog
	FETCH NEXT FROM curLog INTO @currentFile
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF @passedFrist = 1
			SET @sql = @sql + ','
		ELSE
			SET @passedFrist = 1
		SET @sql = @sql + 'DISK=N''' +  CASE WHEN @currentDriveName IS NOT NULL AND @replacementDriveName IS NOT NULL THEN REPLACE(@currentFile,@currentDriveName,@replacementDriveName)
				ELSE @currentFile END + '''' 
		
		FETCH NEXT FROM curLog INTO @currentFile
	END
	CLOSE curLog
	DEALLOCATE curLog

	DELETE FROM #RestoreList WHERE BackupType = 'Transaction Log' AND  FirstLsn = @lsn


	IF (SELECT COUNT(*) FROM #RestoreList WHERE BackupType = 'Transaction Log') > 0
		SET @sql = @sql + ' WITH NORECOVERY;' + CHAR(10)
	ELSE
		SET @sql = @sql + CASE WHEN @withNORecovery = 1 THEN ' WITH NORECOVERY;' ELSE ' WITH RECOVERY;' END + CHAR(10)

	PRINT @sql
	SET @sqlOut = @sqlOut + @sql

END

SELECT @sqlOut as [Restore Statement]

If Object_id('tempdb..#LogicalList') IS NOT NULL
	DROP TABLE #LogicalList
If Object_id('tempdb..#RestoreList') IS NOT NULL
	DROP TABLE #RestoreList
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGenerateRestore2]',10,1) WITH NOWAIT;
if object_id('dbo.pGenerateRestore2') is null exec('create procedure [dbo].[pGenerateRestore2] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*	Written By:	Keith Buck
*	Purpose: 	Generate a restore statment for a database based on the parameters passed in. Will include all
*				Full, Differential and Transaction Log backups if needed.
*
*	Inputs:	
*	@dbname						SYSNAME	,				-- Name of database to restore from
*	@asofdate					DATETIME = NULL,		-- Date and time of backup, null means latest
*	@newdbname					NVARCHAR(128) = NULL,	-- Name of new database if restoring to a new name
*	@moveDataFileLocation		NVARCHAR(240) = NULL,	-- Location to move all data files
*	@moveLogFileLocation		NVARCHAR(240) = NULL,	-- Location to move log file(s)
*	@withNORecovery				BIT = 0,				-- Restore Recovery Option, default is 0 (with recovery) SET to 1 to leave database in resotring mode
*	@currentDriveName			VARCHAR(200) = NULL,	-- Current drive and replacement drive are used to replace the backup drive path so you can replace a UNC with a drive name 
*	@replacementDriveName		VARCHAR(200) = NULL,	--or a different unc path or a srive letter and path
*	@bufferCount				INT  = NULL,			-- Specifies the total number of I/O buffers to be used for the restore operation. You can specify any positive integer; however, large numbers of buffers might cause "out of memory" errors because of inadequate virtual address space in the Sqlservr.exe process.
*	@maxTransferSize			INT	 = NULL,			-- Specifies the largest unit of transfer in bytes to be used between the backup media and SQL Server. The possible values are multiples of 65536 bytes (64 KB) ranging up to 4194304 bytes (4 MB).
*	@IgnoreCopyOnly				BIT = 1,				-- Set this if you want to ignore Copy Only backups, this can come in handy when dealing with Availability Groups where the backup preference is set to Secondary, default is 1 yes which means it will not include a FULL that was copy_only
*   
*	@InclBufferMaxTranInLogs	BIT = 0	,				-- Include the buffercount and MaxTransferSize options in the tran log restores, only applies if a value is explicitly set for @bufferCount and @maxTransferSize
*	@includeTranLog				BIT = 1					-- Include the transaction log restore statement
*	@includeDiff				BIT = 1					-- Include the differential backup in the restore statement
*	@debug						BIT = 0					-- Will return the result sets used for logical/Physical names and backup file information
*
*	Notes:	
*	1. Be Careful using the @IgnoreCopyOnly parameter as copy_only backups can be tricky
*	2. Will skip any backup where is_snapshot = 1
*	3. This procedure should be used in place of pGenerateRestore
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2017-10-26			Keith Buck				Created
*   2017-11-06			Keith Buck				Updated to ensure backups were only disk backups
*	2019-09-16			Keith Buck				Update to not set and unset single user mode but to take db offline
*	2019-09-30			keith Buck				Added the missing single quote on line 329 (the alter db set offline) 
												Added new parameters @includeTranLog and @includeDiff
*********************************************************************************************************************/

alter procedure dbo.pGenerateRestore2 (
@dbname							SYSNAME	,				-- Name of database to restore from
@asofdate						DATETIME = NULL,		-- Date and time of backup, null means latest
@newdbname						NVARCHAR(128) = NULL,	-- Name of new database if restoring to a new name
@moveDataFileLocation			NVARCHAR(240) = NULL,	-- Location to move all data files
@moveLogFileLocation			NVARCHAR(240) = NULL,	-- Location to move log file(s)
@withNORecovery					BIT = 0,				-- Restore Recovery Option, default is 0 (with recovery) SET to 1 to leave database in resotring mode
@currentDriveName				VARCHAR(200) = NULL,	-- Current drive and replacement drive are used to replace the backup drive path so you can replace a UNC with a drive name 
@replacementDriveName			VARCHAR(200) = NULL,	--or a different unc path or a srive letter and path
@bufferCount					INT  = NULL,			-- Specifies the total number of I/O buffers to be used for the restore operation. You can specify any positive integer; however, large numbers of buffers might cause "out of memory" errors because of inadequate virtual address space in the Sqlservr.exe process.
@maxTransferSize				INT	 = NULL,			-- Specifies the largest unit of transfer in bytes to be used between the backup media and SQL Server. The possible values are multiples of 65536 bytes (64 KB) ranging up to 4194304 bytes (4 MB).
@IgnoreCopyOnly					BIT = 1,				-- Set this if you want to ignore Copy Only backups, this can come in handy when dealing with Availability Groups where the backup preference is set to Secondary, default is 1 yes which means it will not include a FULL that was copy_only
@InclBufferMaxTranInLogs		BIT = 0	,				-- Include the buffercount and MaxTransferSize options in the tran log restores, only applies if a value is explicitly set for @bufferCount and @maxTransferSize
@debug							BIT = 0,					-- Will return the result sets used for logical/Physical names and backup file information
@includeTranLog					BIT = 1,					-- Include the transaction log restore statement
@includeDiff					BIT = 1,				-- Include the differential backup in the restore statement
@SQLOutput						NVARCHAR(MAX) = NULL OUTPUT 
)
WITH ENCRYPTION
AS
BEGIN
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

	
DECLARE @lastFullStartDate			DATETIME
DECLARE @recoverymodel				NVARCHAR(60)
DECLARE @hasSnapShot				BIT
DECLARE @fullFirstLsn				NUMERIC(25,0)
DECLARE @currentFile				NVARCHAR(260)
DECLARE @fileList					NVARCHAR(max)
DECLARE @sql						NVARCHAR(max)
DECLARE @sqlOut						NVARCHAR(max)
DECLARE @physicalFile				NVARCHAR(260)
DECLARE @logicalFile				SYSNAME
DECLARE @lsn						DECIMAL(25,0)
DECLARE @passedFrist				BIT
DECLARE @isCopyOnly					BIT
DECLARE @LogicalFileType			CHAR(1)
DECLARE @backupSetId				INT
DECLARE @prevBackupSetId			INT
DECLARE @filename					VARCHAR(256)
DECLARE @filepath					VARCHAR(256)
DECLARE @backupStartDate			datetime
DECLARE @backup_set_id_start		INT
DECLARE @backup_set_id_end			INT
DECLARE @diff_backup_set_id_start	INT
DECLARE @maxdiffdate				DATETIME
DECLARE @file						VARCHAR(256)
DECLARE @isfirst					BIT

IF @asofdate IS NULL
	SET @asofdate = GETDATE()

--If move location does not end in a slash add one
IF @moveDataFileLocation IS NOT NULL
BEGIN
	IF (SUBSTRING(REVERSE(@moveDataFileLocation),1,1) != '\')
			SET @moveDataFileLocation = @moveDataFileLocation + '\'
END
IF @moveLogFileLocation IS NOT NULL
BEGIN
	IF (SUBSTRING(REVERSE(@moveLogFileLocation),1,1) != '\')
			SET @moveLogFileLocation = @moveLogFileLocation + '\'
END

If Object_id('tempdb..#LogicalList') IS NOT NULL
	DROP TABLE #LogicalList
CREATE TABLE #LogicalList(LogicalName SYSNAME, PhysicalName NVARCHAR(260), FileType CHAR(1))


/*******************************************************************************
  Retrievs list of backup_set_id and restore statements
******************************************************************************/
If Object_id('tempdb..#RestoreList') IS NOT NULL
	DROP TABLE #RestoreList
CREATE TABLE #RestoreList(
	Id int IDENTITY(1,1) not null PRIMARY KEY CLUSTERED, 
	BackupSetId		INT,	
	BackupFilePath	VARCHAR(800),
	Type			CHAR(1),
	FileNm			VARCHAR(256)		
)


--get the backup_set_id of the last full that is <= the @asofdate param
--and has the correct copy_only value
IF @IgnoreCopyOnly = 1
BEGIN
	SELECT 
		@backup_set_id_start = MAX(b.backup_set_id) 
	 FROM  
		msdb.dbo.backupset b
		INNER JOIN msdb.dbo.backupmediafamily f ON b.media_set_id = f.media_set_id AND f.device_type = 2 -- only disk backups
	WHERE 
		b.database_name = @dbname 
		AND b.type = 'D' 
		AND b.backup_start_date <= @asofdate
		AND b.is_copy_only = 0 
		AND b.is_snapshot = 0
		

	SELECT 
		@backup_set_id_end = MIN(b.backup_set_id) 
	 FROM  
		msdb.dbo.backupset b 
		INNER JOIN msdb.dbo.backupmediafamily f ON b.media_set_id = f.media_set_id AND f.device_type = 2 -- only disk backups
	WHERE 
		database_name = @dbname 
		AND b.type = 'D'
		AND b.backup_set_id > @backup_set_id_start
		AND b.backup_start_date < @asofdate
		AND b.backup_start_date <= @asofdate
		AND b.is_copy_only = 0 
		AND b.is_snapshot = 0
END
ELSE
BEGIN
	SELECT 
		@backup_set_id_start = MAX(b.backup_set_id) 
	 FROM  
		msdb.dbo.backupset  b
		INNER JOIN msdb.dbo.backupmediafamily f ON b.media_set_id = f.media_set_id AND f.device_type = 2 -- only disk backups
	WHERE 
		b.database_name = @dbname 
		AND b.type = 'D' 
		AND b.backup_start_date <= @asofdate
		AND b.is_snapshot = 0

	SELECT 
		@backup_set_id_end = MIN(b.backup_set_id) 
	 FROM  
		msdb.dbo.backupset b 
		INNER JOIN msdb.dbo.backupmediafamily f ON b.media_set_id = f.media_set_id AND f.device_type = 2 -- only disk backups
	WHERE 
		b.database_name = @dbname 
		AND b.type = 'D'
		AND b.backup_set_id > @backup_set_id_start
		AND b.backup_start_date < @asofdate
		AND b.backup_start_date <= @asofdate
		AND b.is_snapshot = 0
END


--If the backup set end id is null, set it to max int
IF @backup_set_id_end IS NULL SET @backup_set_id_end = 2147483647 

SELECT 
	 @lastFullStartDate = MAX(b.backup_start_date) 
 FROM  
	msdb.dbo.backupset  b
	INNER JOIN msdb.dbo.backupmediafamily f ON b.media_set_id = f.media_set_id AND f.device_type = 2 -- only disk backups
WHERE 
	b.database_name = @dbname 
	AND b.[type] = 'D'
	AND b.backup_start_date <= @asofdate 

--get the recovery model and is_copy_only values
SELECT 
	@recoverymodel = b.recovery_model
	,@isCopyOnly = b.is_copy_only
 FROM    
	msdb.dbo.backupset b
    INNER JOIN msdb.dbo.backupmediafamily mf ON b.media_set_id = mf.media_set_id
WHERE
	b.database_name = @dbname
    AND b.backup_set_id = @backup_set_id_start

IF @debug = 1
	SELECT  @backup_set_id_start AS '@backup_set_id_start', @backup_set_id_end AS '@backup_set_id_end', @lastFullStartDate AS '@lastFullStartDate', @recoverymodel AS '@recoverymodel', @moveDataFileLocation as '@moveDataFileLocation', @moveLogFileLocation as '@moveLogFileLocation'

--insert the last full backup
INSERT INTO #RestoreList (BackupSetId, BackupFilePath, Type)
SELECT 
	backup_set_id
	,mf.physical_device_name 
	,b.type
 FROM    
	msdb.dbo.backupset b
    INNER JOIN msdb.dbo.backupmediafamily mf ON b.media_set_id = mf.media_set_id
WHERE
	b.database_name = @dbname
    AND b.backup_set_id = @backup_set_id_start

	
--GET THE LOGICAL FILE LIST FROM THE FULL  BACKUP
INSERT INTO #LogicalList(LogicalName, PhysicalName, FileType)
SELECT	
	bf.logical_name as LogicalName,
	bf.physical_name as PhysicalName,
	bf.file_type
 FROM 
	msdb..backupset b 
	INNER JOIN msdb..backupfile bf ON b.backup_set_id = bf.backup_set_id 
WHERE 
	b.database_name = @dbname  
    AND b.backup_set_id = @backup_set_id_start
ORDER BY LogicalName, physical_name 




--INSERT THE LAST DIFFERENTIAL IF THE LAST BACKUP IS NOT A COPYONLY
IF @isCopyOnly = 0
BEGIN
	--GET THE MAX DIFF DATE
	SELECT 
		@maxdiffdate  = MAX(b.backup_start_date )
	FROM    
		msdb.dbo.backupset b
		INNER JOIN msdb.dbo.backupmediafamily mf ON b.media_set_id = mf.media_set_id and mf.device_type = 2
	WHERE
		b.database_name = @dbname
		AND b.backup_set_id >= @backup_set_id_start 
		AND b.backup_set_id < @backup_set_id_end
		AND b.type = 'I'
		AND backup_start_date < @asofdate
	
	--GET THE DIFF START backup set id
	IF @includeDiff = 1
	BEGIN
		SELECT 
			@diff_backup_set_id_start = backup_set_id
		FROM    
			msdb.dbo.backupset b
			INNER JOIN msdb.dbo.backupmediafamily mf ON b.media_set_id = mf.media_set_id and mf.device_type = 2
		WHERE
			b.database_name = @dbname
			AND b.backup_set_id >= @backup_set_id_start 
			AND b.backup_set_id < @backup_set_id_end
			AND b.type = 'I'
			AND backup_start_date < @asofdate

		--INSERT THE DIFF BACKUP INTO THE TABLE
		INSERT INTO #RestoreList (BackupSetId, BackupFilePath, Type)
	
		SELECT 
			backup_set_id
			,mf.physical_device_name 
			,b.type
		FROM    
			msdb.dbo.backupset b
			INNER JOIN msdb.dbo.backupmediafamily mf ON b.media_set_id = mf.media_set_id and mf.device_type = 2
		WHERE
			b.database_name = @dbname
			AND b.backup_set_id >= @backup_set_id_start 
			AND b.backup_set_id < @backup_set_id_end
			AND b.type = 'I'
			AND backup_start_date = @maxdiffdate
	END
END


						  
--INSERT ANY TRANSACTION LOGS
IF @recoverymodel = N'FULL' AND @includeTranLog = 1
BEGIN
	
	INSERT INTO #RestoreList (BackupSetId, BackupFilePath, Type)
	SELECT 
		b.backup_set_id,
		mf.physical_device_name,
		b.type
	 FROM    
		msdb.dbo.backupset b
        INNER JOIN msdb.dbo.backupmediafamily mf ON b.media_set_id = mf.media_set_id and mf.device_type = 2
	WHERE    
		b.database_name = @dbname
        AND b.backup_set_id >= ISNULL(@diff_backup_set_id_start,@backup_set_id_start) 
		AND b.backup_set_id < @backup_set_id_end
        AND b.type = 'L'
		AND b.backup_start_date <= @asofdate
End
  
  
IF @debug = 1
BEGIN
	SELECT '#RestoreList'  as TableName, * FROM #RestoreList 
	SELECT '#LogicalList' as TableName, * FROM #LogicalList
END


/*********************************************************************************************************************
						Build the Restore Statement
*********************************************************************************************************************/
SET @sql = 'IF EXISTS(SELECT 1 FROM sys.databases WHERE name = N''' + ISNULL(@newdbname,@dbname) + ''' AND state_desc = ''ONLINE'')
BEGIN 
	EXECUTE sp_executesql @STMT = N''' +
	N'	Use [master]' + CHAR(10)  + 
	N'	ALTER DATABASE [' + ISNULL(@newdbname,@dbname) + N'] SET OFFLINE WITH ROLLBACK IMMEDIATE;''' + CHAR(10)  +
N'END
USE Master' + CHAR(10) + 'GO' + CHAR(10)  

/************************************************************************************
		Loop through the records and build the command to restore the FULL backup	
*************************************************************************************/




SET @sql = @sql +  N'RESTORE DATABASE [' + ISNULL(@newdbname,@dbname) + N'] FROM '
SET @isfirst = 1

--LOOP THROUGH ALL THE BACKUP FILES AND CREATE THE FROM DISK STATEMENT
DECLARE curFull CURSOR FAST_FORWARD LOCAL FOR SELECT r.BackupFilePath FROM #RestoreList r WHERE r.type = 'D' ORDER BY r.Id 
OPEN curFull 
FETCH NEXT FROM curFull INTO @file
WHILE @@FETCH_STATUS = 0
BEGIN
	SET @sql = @sql + 
		 CASE WHEN @isfirst = 1 
			THEN  ' DISK = '''   
		ELSE   ', DISK = '''   END
		 +   --drive mapping
		CASE WHEN @currentDriveName IS NOT NULL AND @replacementDriveName IS NOT NULL  THEN 
					REPLACE(@file,@currentDriveName,@replacementDriveName)
		Else @file END
		+ ''' '   + CHAR(10) + CHAR(13) 
	SET @isfirst = 0
	FETCH NEXT FROM curFull INTO @file
END
CLOSE curFull 
DEALLOCATE curFull 



SET @sql = @sql +  'WITH STATS=10, REPLACE'  + CHAR(10) + CHAR(13) 

--CREATE A MOVE STATEMENT IF NEEDED
IF NOT(@moveDataFileLocation IS NULL AND @moveLogFileLocation IS NULL AND @newdbname IS NULL)
BEGIN
	--LOOP THROUGH ALL THE LOGICAL FILES AND CREATE A MOVE STATEMENT
	DECLARE curLogical CURSOR FAST_FORWARD LOCAL FOR 
	SELECT LogicalName, PhysicalName, FileType FROM #LogicalList 
	OPEN curLogical
	FETCH NEXT FROM curLogical INTO @logicalFile, @physicalFile, @LogicalFileType
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @file = REVERSE(SUBSTRING (REVERSE(@physicalFile),1, CHARINDEX('\',REVERSE(@physicalFile),1) -1)) 
		SET @filepath = REVERSE(SUBSTRING(  REVERSE(@physicalFile), CHARINDEX('\',REVERSE(@physicalFile),1),len(@physicalFile)))
		IF @debug =1
			SELECT @physicalFile AS '@physicalFile', @file AS '@file' , @filepath AS '@filepath'
		IF @LogicalFileType ='L'
		BEGIN
			IF @newdbname IS NULL
				SET @sql = @sql + ', MOVE ''' + @logicalFile +''' to '''  + ISNULL(@moveLogFileLocation,@filepath) + @file + '''' + CHAR(10) + CHAR(13) 
			ELSE
				SET @sql = @sql + ', MOVE ''' + @logicalFile +''' to '''  + ISNULL(@moveLogFileLocation,@filepath) + REPLACE(@file,@dbname, @newdbname)  + '''' + CHAR(10) + CHAR(13) 

		END
		ELSE
		BEGIN
			IF @newdbname IS NULL
				SET @sql = @sql + ', MOVE ''' + @logicalFile +''' to ''' + ISNULL(@moveDataFileLocation,@filepath) + @file + '''' + CHAR(10) + CHAR(13) 
			ELSE
				SET @sql = @sql + ', MOVE ''' + @logicalFile +''' to ''' + ISNULL(@moveDataFileLocation,@filepath) + REPLACE(@file,@dbname, @newdbname)  + '''' + CHAR(10) + CHAR(13) 
		END

		FETCH NEXT FROM curLogical INTO @logicalFile, @physicalFile, @LogicalFileType
	END
	CLOSE curLogical
	DEALLOCATE curLogical
END
ELSE
	print 'NO MOVE STATEMENT IS GOING TO BE CREATED'

--SET THE PERFORMANCE PARAMETERS
IF @bufferCount IS NOT NULL
	SET @sql = @sql + ', BUFFERCOUNT = ' + CAST(@bufferCount AS NVARCHAR(100)) 

IF @maxTransferSize IS NOT NULL
	SET @sql = @sql + ', MAXTRANSFERSIZE = ' + CAST(@maxTransferSize AS NVARCHAR(100)) 


SET @sql = @sql + ', NORECOVERY;'


--PRINT OUT THE STATEMENT AND THEN RESET IT TO NOTHING
SET @sqlOut = @sql 
SET @SQLOutput = @sql 
PRINT @sql
SET @sql = N''
SET @fileList  = ''




/********************************************************************
		Create Differential backup restore
********************************************************************/
IF (@isCopyOnly = 0)
BEGIN
	IF EXISTS (SELECT TOP 1 1 FROM #RestoreList WHERE Type = 'I')
	BEGIN
		SET @sql = N'RESTORE DATABASE [' + ISNULL(@newdbname,@dbname) + N'] FROM '
		SET @isfirst = 1

		--LOOP THROUGH ALL THE BACKUP FILES AND CREATE THE FROM DISK STATEMENT
		DECLARE curFull CURSOR FAST_FORWARD LOCAL FOR SELECT r.BackupFilePath FROM #RestoreList r WHERE r.type = 'I' ORDER BY r.Id 
		OPEN curFull 
		FETCH NEXT FROM curFull INTO @file
		WHILE @@FETCH_STATUS = 0
		BEGIN
			SET @sql = @sql +  CHAR(10) + CHAR(13) + 
				 CASE WHEN @isfirst = 1 
					THEN  ' DISK = '''   
				ELSE   ', DISK = '''   END
				 +   --drive mapping
				CASE WHEN @currentDriveName IS NOT NULL AND @replacementDriveName IS NOT NULL  THEN 
							REPLACE(@file,@currentDriveName,@replacementDriveName)
				Else @file END
				+ ''' ' 
			SET @isfirst = 0
			FETCH NEXT FROM curFull INTO @file
		END
		CLOSE curFull 
		DEALLOCATE curFull 

		SET @sql = @sql + CHAR(10) + CHAR(13) +  'WITH STATS=10'  
		
		--SET THE PERFORMANCE PARAMETERS
		IF @bufferCount IS NOT NULL
			SET @sql = @sql + ', BUFFERCOUNT = ' + CAST(@bufferCount AS NVARCHAR(100)) 

		IF @maxTransferSize IS NOT NULL
			SET @sql = @sql + ', MAXTRANSFERSIZE = ' + CAST(@maxTransferSize AS NVARCHAR(100)) 


		SET @sql = @sql + ', NORECOVERY;'
		SET @sqlOut = @sqlOut + CHAR(10) + CHAR(13)  + @sql + + CHAR(10) + CHAR(13) 
		PRINT @sql
		
		PRINT ''
		PRINT ''
	END
	ELSE
	BEGIN
		IF @debug = 1
			SELECT 'No Differential Backups found' as 'No Differential Backups found' 
	END

END
/********************************************************************
		Create LOG backup restores
********************************************************************/
--LOOP THROUGH ALL THE BACKUP FILES AND CREATE THE FROM DISK STATEMENT
SET @sqlOut = @sqlOut + CHAR(10) + CHAR(13)
SET @isfirst			= 1
SET @sql				= N''
SET @prevBackupSetId	= 0

IF EXISTS(SELECT TOP 1 1 FROM #RestoreList WHERE Type = 'L')
BEGIN
	--SET @sql = 'RESTORE LOG [' + @dbname + '] FROM '

	DECLARE curLog CURSOR FAST_FORWARD LOCAL FOR SELECT r.BackupFilePath, r.BackupSetId FROM #RestoreList r WHERE r.type = 'L' ORDER BY r.Id 
	OPEN curLog 
	FETCH NEXT FROM curLog INTO @file, @backupSetId
	WHILE @@FETCH_STATUS = 0
	BEGIN
		--CHECK IF THIS IS THE SAME BACKUP SET, IF SO JUST ADD ANOTHER DISK STATEMENT, IF NOT FINISH IT UP
		IF @backupSetId = @prevBackupSetId
		BEGIN -- same backup set so add the file
			SET @sql = @sql + 
				CASE WHEN @backupSetId != @prevBackupSetId THEN  ' DISK = '''   
				ELSE   ', DISK = '''   END
					+   --drive mapping
				CASE WHEN @currentDriveName IS NOT NULL AND @replacementDriveName IS NOT NULL  THEN  REPLACE(@file,@currentDriveName,@replacementDriveName)
				Else @file END
				+ ''' ' 
		END
		ELSE
		--THIS IS A NEW BACKUP SET, SO FINISH THE PREVIOUS ONE AND START THE NEW ONE
		BEGIN
			--iF THIS IS THE FIRST TIME THROUGH JUST CREATE THE RESTORE AND DO NOTHING ELSE
			IF @isfirst = 1
			BEGIN
				SET @isfirst = 0
				SELECT 
					@sql = 'RESTORE LOG [' + ISNULL(@newdbname, @dbname) + '] FROM ' +
					CASE WHEN @backupSetId != @prevBackupSetId THEN  ' DISK = ''' ELSE   ', DISK = '''   END
					+   --drive mapping
					CASE WHEN @currentDriveName IS NOT NULL AND @replacementDriveName IS NOT NULL  THEN REPLACE(@file,@currentDriveName,@replacementDriveName) Else @file END
					+ ''' ' 
			END
			ELSE
			BEGIN
				--Finishing the existing statement
				SET @sql = @sql + ' WITH NORECOVERY, STATS '
				IF @InclBufferMaxTranInLogs = 1
				BEGIN
					IF @bufferCount IS NOT NULL
						SET @sql = @sql + ', BUFFERCOUNT = ' + CAST(@bufferCount AS NVARCHAR(100)) 

					IF @maxTransferSize IS NOT NULL
						SET @sql = @sql + ', MAXTRANSFERSIZE = ' + CAST(@maxTransferSize AS NVARCHAR(100)) 
				END
				--print out the statement and build on the @sqlout
				SET @sql = @sql + ';' + CHAR(10) --+ CHAR(13)
				PRINT @sql
				SET @sqlOut = @sqlOut + @sql 
				--START THE NEXT STATEMETN
				SELECT 
					@sql = 'RESTORE LOG [' + ISNULL(@newdbname, @dbname) + '] FROM ' +
					CASE WHEN @backupSetId != @prevBackupSetId THEN  ' DISK = ''' ELSE   ', DISK = '''   END
					+   --drive mapping
					CASE WHEN @currentDriveName IS NOT NULL AND @replacementDriveName IS NOT NULL  THEN REPLACE(@file,@currentDriveName,@replacementDriveName) Else @file END
					+ ''' ' 
			END
		END		

		SET @prevBackupSetId = @backupSetId
		FETCH NEXT FROM curLog INTO @file, @backupSetId
	END
	CLOSE curLog 
	DEALLOCATE curLog 
	-- FINISH OFF THE LAST STATEMENT AND PRINT IT OUT 
	SET @sql = @sql + ' WITH NORECOVERY, STATS '
	IF @InclBufferMaxTranInLogs = 1
	BEGIN
		IF @bufferCount IS NOT NULL
			SET @sql = @sql + ', BUFFERCOUNT = ' + CAST(@bufferCount AS NVARCHAR(100)) 

		IF @maxTransferSize IS NOT NULL
			SET @sql = @sql + ', MAXTRANSFERSIZE = ' + CAST(@maxTransferSize AS NVARCHAR(100)) 
	END
	--print out the statement and build on the @sqlout
	SET @sql = @sql + ';'
	PRINT @sql
	SET @sqlOut = @sqlOut + @sql 
END


IF @withNORecovery = 0
BEGIN
	SET @sql =  'RESTORE DATABASE [' + ISNULL(@newdbname, @dbname) + '] WITH RECOVERY;'
	SET @sqlOut = 	@sqlOut + CHAR(10) + CHAR(13) + 'RESTORE DATABASE [' + ISNULL(@newdbname, @dbname) + '] WITH RECOVERY;'
	PRINT @sql
END
SELECT @sqlOut  AS 'SQL OUTPUT'
If Object_id('tempdb..#LogicalList') IS NOT NULL
	DROP TABLE #LogicalList
If Object_id('tempdb..#RestoreList') IS NOT NULL
	DROP TABLE #RestoreList
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetAgSyncInfo]',10,1) WITH NOWAIT;
IF OBJECT_ID('dbo.pGetAgSyncInfo') IS NULL EXEC('CREATE procedure [dbo].pGetAgSyncInfo as select getdate() DT')
GO
  /******************************************************************************************************************************************
	dbo.pGetAgSyncInfo
  Summary:  Gets information about the current availability groups and the synchronization 

  Date:  9/12/2019
  Versions: 2012 and greater
  Parameters:	@SortBy			VARCHAR(512) = 'AGName, DBName' 
	Is the sort order of the columns you want to see for Current Running Queries, you can enter any valid sort either
		by column name or order name and specify ASC or DSEC.
	,@OutputColumnNotes	 BIT = 0 Will print notes about what some columns mean
------------------------------------------------------------------------------
  Written by Keith Buck, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
  INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.  
  WHAT SOME OF THESE COLUMNS MEAN OR NOTES
	IsCommitParticipantDescription 
		-- For a database on an asynchronous-commit availability replica, this value is always 0.
		-- For a database on a synchronous-commit availability replica, this value is accurate only on the primary database.
	LastTeceivedTime,	--Time when the log block ID in last message received was read on the secondary replica.
	LogSendQueueSize,	--Amount of log records of the primary database that has not been sent to the secondary databases, in kilobytes (KB).
	LogSendRate,		--Average rate at which primary replica instance sent data during last active period, in kilobytes (KB)/second.
	RedoQueueSize,		--Amount of log records of the primary database that has not been sent to the secondary databases, in kilobytes (KB).
	RedoRate,			--Average Rate at which the log records are being redone on a given secondary database, in kilobytes (KB)/second.
	LastCommitTime,		--Time corresponding to the last commit record.On the secondary database, this time is the same as on the primary database. On the primary replica, each secondary database row displays the time that the secondary replica that hosts that secondary database has reported back to the primary replica. 
******************************************************************************************************************************************/
ALTER PROCEDURE dbo.pGetAgSyncInfo(
	@SortBy				varchar(512) = 'AGName, replica_server_name,DBName' ,
	@PrintColumnNotes	 bit = 0 
)
WITH ENCRYPTION 
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

DECLARE @sql	nvarchar(max)

SET @sql= '
SELECT 
	ar.replica_server_name			AS replica_server_name, 
	adc.[database_name]				AS DBName, 
	ag.[name]						AS AGName, 
	drs.is_local					AS IsLocalReplica, 
	drs.is_primary_replica			AS IsPrimaryReplica, 
	drs.synchronization_state_desc	AS SynchronizationStateDesc, 
	drs.is_commit_participant		AS IsCommitParticipant, 
	Case WHEN 	is_commit_participant	= 0 Then ''Transaction commit is not synchronized with respect to this database.''
		Else ''Transaction commit is synchronized with respect to this database.''
	end								AS IsCommitParticipantDescription,
	drs.synchronization_health_desc AS SynchronizationHealthDesc, 
	drs.last_received_lsn			AS LastReceivedLsn, 
	drs.last_received_time			AS LastTeceivedTime,
	drs.last_hardened_time			AS LastHardenedTime,
	drs.last_redone_time			AS LastRedoneTime, 
	drs.log_send_queue_size			AS LogSendQueueSize,
	CAST(drs.log_send_queue_size/1024.0 AS DECIMAL(24,2)) AS LogSendQueueSizeMB,
	CAST(drs.log_send_queue_size/1024.0/1024.0 AS DECIMAL(24,2)) AS LogSendQueueSizeGB,
	drs.log_send_rate				AS LogSendRate,
	CAST(drs.log_send_rate/1024.0	AS DECIMAL(24,2)) as LogSendRateMB,
	drs.redo_queue_size				AS RedoQueueSize,
	CAST(drs.redo_queue_size/1024.0 AS DECIMAL(24,2)) as RedoQueueSizeMB,
	drs.redo_rate					AS RedoRate,
	CAST(drs.redo_rate/1024.0		AS DECIMAL(24,2)) as RedoRateMbSec,
	drs.filestream_send_rate		AS FilestreamSendRate,  
	drs.last_commit_time			AS LastCommitTime,
	drs.is_suspended				AS IsSuspended,
	drs.suspend_reason_desc			AS SuspendRTasonDesc,	
	drs.recovery_lsn				AS RecoveryLsn, 
	drs.truncation_lsn				AS TruncationLsn, 
	drs.last_sent_lsn				AS LastSentLsn,
	drs.last_sent_time				AS LastSentTime, 
	drs.last_hardened_lsn			AS LastHardenedLsn, 
	drs.last_redone_lsn				AS LastRedoneLsn, 
	drs.end_of_log_lsn				AS EndOfLogLsn, 
	drs.last_commit_lsn				AS LastCommitLsn

FROM sys.dm_hadr_database_replica_states AS drs
	INNER JOIN sys.availability_databases_cluster AS adc 
		ON drs.group_id = adc.group_id AND 
		drs.group_database_id = adc.group_database_id
	INNER JOIN sys.availability_groups AS ag
		ON ag.group_id = drs.group_id
	INNER JOIN sys.availability_replicas AS ar 
		ON drs.group_id = ar.group_id AND 
		drs.replica_id = ar.replica_id
'
+ 
CASE WHEN @SortBy IS NULL  THEN N'ORDER BY AGName, replica_server_name, DBName' 

	ELSE N'ORDER BY ' + CAST(@SortBy as nvarchar(max))
END

EXECUTE sp_executesql @sql 


If @PrintColumnNotes = 1
BEGIN
	PRINT '	IsCommitParticipantDescription 
		-- For a database on an asynchronous-commit availability replica, this value is always 0.
		-- For a database on a synchronous-commit availability replica, this value is accurate only on the primary database.
	LastTeceivedTime,	--Time when the log block ID in last message received was read on the secondary replica.
	LogSendQueueSize,	--Amount of log records of the primary database that has not been sent to the secondary databases, in kilobytes (KB).
	LogSendRate,		--Average rate at which primary replica instance sent data during last active period, in kilobytes (KB)/second.
	RedoQueueSize,		--Amount of log records of the primary database that has not been sent to the secondary databases, in kilobytes (KB).
	RedoRate,			--Average Rate at which the log records are being redone on a given secondary database, in kilobytes (KB)/second.
	LastCommitTime,		--Time corresponding to the last commit record.On the secondary database, this time is the same as on the primary database. On the primary replica, each secondary database row displays the time that the secondary replica that hosts that secondary database has reported back to the primary replica. '
END
GO


--renamed procedure, this removes the old name
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pGet_AvailabilityGroupInfo]') AND type in (N'P', N'PC'))
	EXECUTE sp_executesql N'DROP PROCEDURE dbo.pGet_AvailabilityGroupInfo'



SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

IF (select VerDec from #FDVER) >= 11.0
BEGIN
	RAISERROR ('	CREATING OR ALTERING PROCEDURE dbo.pGetAvailabilityGroupInfo',10,1) WITH NOWAIT;

	IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pGetAvailabilityGroupInfo]') AND type in (N'P', N'PC'))
	BEGIN
		EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [dbo].[pGetAvailabilityGroupInfo]
	AS
	SET NOCOUNT ON
	DECLARE @dt		DATETIME
	SELECT @dt = GETDATE()
	' 
	END
END
GO
IF (select VerDec from #FDVER) >= 11.0
BEGIN
	EXEC dbo.sp_executesql @statement = N'ALTER PROCEDURE dbo.pGetAvailabilityGroupInfo
	WITH ENCRYPTION
	AS
	SET NOCOUNT ON
	IF NOT EXISTS (SELECT * FROM Licensing.fn_ValidateLicense()) RETURN;
	SELECT 
		ag.name as [Availability Group Name],
		l.dns_name as ListenerName,
		d.name AS [Database Name],
		d.state_desc AS [State Desc],
		CASE WHEN agstate.primary_replica = @@SERVERNAME THEN ''Primary'' ELSE ''Replica'' END AS [Primary Or Replica],
		drs.synchronization_state_desc, 
		drs.synchronization_health_desc,
		CASE WHEN drs.is_suspended= 0 THEN ''No'' ELSE ''Yes'' END AS [Is Suspended],
		drs.suspend_reason_desc AS [Suspend Reason],
		DATEDIFF(SECOND,drs.last_commit_time,GETDATE()) AS SecondsSinceLastCommit ,
		r.availability_mode_desc AS [Availability Mode],
		r.primary_role_allow_connections_desc,
		r.failover_mode_desc,
		ag.failure_condition_level,
		ag.health_check_timeout,
		ag.automated_backup_preference_desc,
		r.secondary_role_allow_connections_desc,
		r.read_only_routing_url,
		ag.group_id
		FROM
		sys.databases d
		INNER JOIN sys.dm_hadr_database_replica_states drs on d.group_database_id = drs.group_database_id AND d.replica_id = drs.replica_id
		INNER JOIN sys.availability_groups ag on drs.group_id = ag.group_id
		INNER JOIN sys.availability_replicas r on drs.group_id = r.group_id and drs.replica_id = r.replica_id
		INNER JOIN sys.dm_hadr_availability_group_states agstate on ag.group_id = agstate.group_id
		LEFT JOIN sys.availability_group_listeners l on ag.group_id = l.group_id
	WHERE 
		d.replica_id IS NOT NULL
	ORDER BY
		ag.name,
		d.name'
END
GO
------------------------------------------------------------------------


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetBackupHistory]',10,1) WITH NOWAIT;
if object_id('dbo.pGetBackupHistory') is null exec('create procedure [dbo].[pGetBackupHistory] as select getdate() DT')
GO
  /******************************************************************************************************************************************
  dbo.pGetBackupHistory
  Summary:  Returns backup details for the supplied database(s), for the supplied type for the supplied time fram

  Date:  5/5/2019
  Versions: 2008 and greater
  Parameters:
	@dbname			sysname		-  Database to check or ALL, default is ALL
	@typeList		varchar(5)	-  Delimeted list of types default is 'D,I,L'
	@hoursBack		int			-  Time frame back to check, default is -24 hours
	@deviceTypeList varchar(20) -  Delimted list of device_type per BACKUPMEDIAFAMILY.device_type, Default = 2 (DISK)
------------------------------------------------------------------------------
  Written by Keith Buck, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
Change List
By			Date		Notes
Keith Buck	2019-09-07	Added @deviceTypeList parameter, delimted list of device types per BACKUPMEDIAFAMILY.device_type
******************************************************************************************************************************************/
alter procedure dbo.pGetBackupHistory(
	@dbname			SYSNAME = 'ALL'
	,@typeList			varchar(6) ='D,I,L'
	,@hoursBack			int = -24
	,@deviceTypeList	varchar(20) = '2'
)
WITH ENCRYPTION
AS
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
IF @hoursBack > 0
	SET @hoursBack = @hoursBack * -1
If @deviceTypeList IS NULL or LTRIM(RTRIM(@deviceTypeList)) = ''
	SET @deviceTypeList = '2'

Select DISTINCT 
	S.database_name,
	Case When S.Type = 'D' Then 'Database'
		 When S.Type = 'I' Then 'Differential database'
		 When S.Type = 'L' Then 'Log'
		 When S.Type = 'F' Then 'File or filegroup'
		 When S.Type = 'G' Then 'Differential file'
		 When S.Type = 'P' Then 'Partial'
		 When S.Type = 'Q' Then 'Differential partial'
		 When S.Type is null Then 'null'
		 Else 'unknown' End BU_TYPE_DESC,
	CASE a.device_type
		WHEN NULL THEN 'NULL'
		WHEN 2 THEN 'Disk'
		WHEN 5 THEN 'Tape'
		WHEN 7 THEN 'Virtual Device'
		WHEN 105 THEN 'A permanent backup device'
	ELSE '' END AS [Backup Device Type]	,
	DATENAME(WEEKDAY,S.BACKUP_START_DATE) AS StartDay,
	S.BACKUP_START_DATE,
	Case When CHARINDEX('\', A.PHYSICAL_DEVICE_NAME,1) = 0 Then A.physical_device_name 
	Else REVERSE(SUBSTRING(REVERSE(A.PHYSICAL_DEVICE_NAME),1,CHARINDEX('\', REVERSE(A.PHYSICAL_DEVICE_NAME))-1)) 
	End AS FILENAME,
	CONVERT(DECIMAL(20,0),  cast(s.backup_size  as decimal)/1024/1024) as BackupSize_MB,
	CONVERT(DECIMAL(20,2),  cast(s.compressed_backup_size   as decimal)/1024/1024) as Compressed_MB ,
	CONVERT(DECIMAL(20,2),  cast(s.compressed_backup_size   as decimal)/1024/1024/1024) as Compressed_GB ,
	DATEDIFF(SECOND,S.BACKUP_START_DATE,S.backup_finish_date) as Run_time_sec
	, RIGHT('0' + CAST( DATEDIFF(SECOND,S.BACKUP_START_DATE,S.backup_finish_date) / 3600 AS VARCHAR),2) + ':' +
			RIGHT('0' + CAST(( DATEDIFF(SECOND,S.BACKUP_START_DATE,S.backup_finish_date) / 60) % 60 AS VARCHAR),2) + ':' +
			RIGHT('0' + CAST(DATEDIFF(SECOND,S.BACKUP_START_DATE,S.backup_finish_date) % 60 AS VARCHAR),2) AS RunTime,
	CASE WHEN DATEDIFF(SECOND,S.BACKUP_START_DATE,S.backup_finish_date) >=1 Then
			CAST( (CONVERT(DECIMAL(20,2),  cast(s.compressed_backup_size   as decimal(20,2))/1024/1024)) / (DATEDIFF(SECOND,S.BACKUP_START_DATE,S.backup_finish_date)) AS DECIMAL(28,3))
		ELSE 0 END AS mb_sec
	,s.recovery_model
	,s.is_copy_only 
	,A.physical_block_size 
	,s.description 
	,s.is_snapshot
	,s.is_damaged 
	,s.is_password_protected
	,s.is_readonly
	,s.is_force_offline
	,A.PHYSICAL_DEVICE_NAME
	,S.backup_finish_date
    ,s.user_name
	,s.has_backup_checksums
	,s.has_bulk_logged_data
	,s.has_incomplete_metadata
	,s.is_damaged
FROM	
	msdb..backupset s
    INNER JOIN msdb..BACKUPMEDIAFAMILY A on S.MEDIA_SET_ID = A.MEDIA_SET_ID 
	LEFT JOIN msdb..restorehistory rs ON s.backup_set_id = rs.backup_set_id and rs.destination_database_name = s.database_name
Where
	1=1
	AND rs.destination_database_name IS NULL
	AND s.type IN (select items from FDDBA..fSplit (@typeList,','))
	AND (S.database_name  = @dbname or @dbname = N'ALL')
	and S.BACKUP_START_DATE >= DATEADD(HOUR,@hoursBack,getdate())
	AND (@deviceTypeList IS NULL OR A.device_type in(select items from dbo.fSplit(@deviceTypeList,',')))
ORDER BY 
	S.database_name,
	S.BACKUP_START_DATE DESC,
	BackupSize_MB DESC

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetDBMailInfo]',10,1) WITH NOWAIT;

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pGetDBMailInfo]') AND type in (N'P', N'PC'))
BEGIN
	EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [dbo].[pGetDBMailInfo] AS select getdate() as DT' 
END

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


ALTER PROCEDURE [dbo].[pGetDBMailInfo] (
	@SendTestMailprofile_Id			INT = 0,
	@SendTestMailRecipients			VARCHAR(MAX) = 'TEAM1@fortifieddata.com',
	@SendTestMailUsExecQuery		BIT = 1,
	@ScriptOutCreate_AccountId		INT = 0,
	@ScriptOutCreate_ProfileId		INT = 0
)
WITH ENCRYPTION 
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

SELECT 
	a.name as AccountName
	,a.account_id
	,p.profile_id
	,p.name		 as ProfileName 
	,CASE WHEN def.is_default IS NOT NULL THEN 'Yes' ELSE 'No' END as IsDefaultProfile
	,a.email_address
	,a.display_name
	,a.replyto_address
	,s.servertype
	,s.servername
	,a.description as Account_Description
	,p.description as Profile_Decription
	,s.port
	,s.username
	,s.credential_id
	,s.enable_ssl
	,s.flags
	,s.timeout

	FROM 
		msdb.dbo.sysmail_account a
		INNER JOIN msdb.dbo.sysmail_server s on a.account_id = s.account_id
		INNER JOIN msdb.dbo.sysmail_profileaccount pa on pa.account_id = a.account_id
		INNER JOIN msdb.dbo.sysmail_profile p on pa.profile_id = p.profile_id
		LEFT JOIN msdb.dbo.sysmail_principalprofile def on p.profile_id = def.profile_id and def.principal_sid = 0x00


/***********************************************************************************************************
Send test email 
***********************************************************************************************************/

DECLARE	@profileName				SYSNAME
DECLARE @sql						NVARCHAR(MAX)

IF ISNULL(@SendTestMailprofile_Id,0) > 0
BEGIN
	SELECT @profileName = name FROM  msdb.dbo.sysmail_profile  WHERE profile_id = @SendTestMailprofile_Id

	IF @SendTestMailUsExecQuery = 1
	BEGIN
		SET @sql ='EXEC msdb.dbo.sp_send_dbmail
				@profile_name =  ''' + @profileName + ''',
				@recipients = ''' + @SendTestMailRecipients + ''',
				@query = ''select @@servername'',
				@subject = ''Test Message from Database Server'' ;'
	END
	ELSE
	BEGIN
		DECLARE @body		varchar(300)
		SELECT @body = @@servername 

		SET @sql ='EXEC msdb.dbo.sp_send_dbmail
				@profile_name =  ''' + @profileName + ''',
				@recipients = ''' + @SendTestMailRecipients + ''',
				@body = ''' + @body + ''',
				@subject = ''Test Message from Database Server'' ;'
	END
	
	RAISERROR (@sql,10,1) WITH NOWAIT;
	RAISERROR ('',10,1) WITH NOWAIT;
	EXEC sp_executesql @sql 			
END

/***********************************************************************************************************
	This script will generate the statement needed to create an exisitng mail account. Use this to copy
	from one server to another.
	SET @accountid and @profileid to non zero values to generate the create script for a specific account
	It will output to the Messages tab for easy copy and paste
***********************************************************************************************************/

DECLARE @mailProfileName						SYSNAME  
DECLARE @mailAccountName						SYSNAME
DECLARE @mailAccountDisplayName					SYSNAME
DECLARE @mailAccountDescription					NVARCHAR(256) 
DECLARE @mailEmailAddress						NVARCHAR(128) 
DECLARE @mailReplyAddress						NVARCHAR(128)	--Reply to Email address for DB Mail
DECLARE @mailSMTP								SYSNAME		--Mail server SMTP address or IP
DECLARE @mailPort								INT -- Will be defaulted to 25
DECLARE @mailUseSSL								BIT -- will be defaulted to 0 (No)
DECLARE @mailUserName							SYSNAME	-- user name to log onto mail server, leave NULL if the mail server does not require authentication
DECLARE @mailUserPassword						SYSNAME -- leave NULL unless @mailUserName is NOT NULL


select 
	@mailAccountName = a.name 
	,@mailProfileName = p.name
	,@mailEmailAddress = a.email_address
	,@mailAccountDisplayName = a.display_name
	,@mailReplyAddress = a.replyto_address
	,@mailSMTP = s.servername
	,@mailPort = s.port
	,@mailUseSSL = s.enable_ssl
	,@mailAccountDescription = a.[description]
	,@mailUserName = s.username
	,@mailUserPassword = CASE WHEN s.username IS NULL THEN NULL ELSE 'INSERT PASSWORD' END
	from 
		msdb.dbo.sysmail_account a
		INNER JOIN msdb.dbo.sysmail_server s on a.account_id = s.account_id
		INNER JOIN msdb.dbo.sysmail_profileaccount pa on pa.account_id = a.account_id
		INNER JOIN msdb.dbo.sysmail_profile p on pa.profile_id = p.profile_id
WHERE
	pa.account_id = @ScriptOutCreate_AccountId
	AND pa.profile_id = @ScriptOutCreate_ProfileId
IF ISNULL(@ScriptOutCreate_AccountId,0) >0 AND ISNULL(@ScriptOutCreate_ProfileId,0) > 0
BEGIN
	
		SET @sql = 'IF EXISTS(SELECT * FROM sys.configurations WHERE name = ''Database Mail XPs'' and CAST(value_in_use AS VARCHAR)  = ''0'')
BEGIN
	exec sp_configure ''show advanced options'',1
	RECONFIGURE
	exec sp_configure ''Database Mail XPs'',1
	RECONFIGURE
END'
		RAISERROR (@sql,10,1) WITH NOWAIT;	
		RAISERROR ('',10,1) WITH NOWAIT;

	SELECT  @sql = '-- Create a Database Mail account
	EXECUTE msdb.dbo.sysmail_add_account_sp
		@account_name = '''+ @mailAccountName + ''',
		@description = ''Mail account for administrative e-mail.'',
		@email_address = ''' + @mailEmailAddress + ''',
		@replyto_address = ''' + @mailReplyAddress + ''',
		@display_name = ''DBA SQL Server Support Mail'',
		@mailserver_name = ''' + @mailSMTP  +  ''',
		@enable_ssl = ' + cast(@mailUseSSL as char(1)) + '' +
		CASE WHEN @mailUserName IS NULL THEN ';'
			ELSE
				',
		@username = N''' + @mailUserName + ''',
		@password = N''' + ISNULL(@mailUserPassword,N'') + ''';'
			END
			RAISERROR (@sql,10,1) WITH NOWAIT;	
			RAISERROR ('',10,1) WITH NOWAIT;
	
			SET @sql = '-- Create a Database Mail profile
		EXECUTE msdb.dbo.sysmail_add_profile_sp
			@profile_name = ''' + @mailProfileName + ''',
			@description = ''Profile used for DBA administrative mail.'' ;'
			RAISERROR (@sql,10,1) WITH NOWAIT;



			SET	@sql = '-- Add the account to the profile
		EXECUTE msdb.dbo.sysmail_add_profileaccount_sp
			@profile_name = ''' + @mailProfileName + ''',
			@account_name = ''' + @mailAccountName + ''',
			@sequence_number =1 ;'
			RAISERROR (@sql,10,1) WITH NOWAIT;
			RAISERROR ('',10,1) WITH NOWAIT;

			SET @sql = '-- Grant access to the profile to all users in the msdb database
		EXECUTE msdb.dbo.sysmail_add_principalprofile_sp
			@profile_name = ''' + @mailProfileName + ''',
			@principal_name = ''public'',
			@is_default = 1 ;'
			RAISERROR (@sql,10,1) WITH NOWAIT;
			RAISERROR ('',10,1) WITH NOWAIT;

		SET @sql ='--send a test email
			EXEC msdb.dbo.sp_send_dbmail
			@profile_name =  ''' + @mailProfileName + ''',
			@recipients = ''' +  ISNULL(@SendTestMailRecipients,'TEAM1@fortifieddata.com') + ''',
			@query = ''select @@servername'',
			@subject = ''Test Message from Database Mail Creation Script'' ;'
			RAISERROR (@sql,10,1) WITH NOWAIT;
			RAISERROR ('',10,1) WITH NOWAIT;
END
go


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetDBMailProfilesAndAccounts]',10,1) WITH NOWAIT;
if object_id('dbo.pGetDBMailProfilesAndAccounts') is null exec('create procedure [dbo].[pGetDBMailProfilesAndAccounts] as select getdate() DT')
GO

ALTER PROCEDURE dbo.pGetDBMailProfilesAndAccounts (
	 @sendtestmailProfileId			int
	,@recipients					varchar(max) = 'TEAM1@fortifieddata.com'
	,@generateScriptProfileId		int 
	,@generateScriptAccountId		int 
)
WITH ENCRYPTION
AS
declare @sql			nvarchar(max)
declare @profileName	sysname

set @sql = N'
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

SELECT 
	a.name as AccountName
	,a.account_id
	,p.profile_id
	,p.name		 as ProfileName 
	,CASE WHEN def.is_default IS NOT NULL THEN ''Yes'' ELSE ''No'' END as IsDefaultProfile
	,a.email_address
	,a.display_name
	,a.replyto_address
	,s.servertype
	,s.servername
	,a.description as Account_Description
	,p.description as Profile_Decription
	,s.port
	,s.username
	,s.credential_id
	,s.enable_ssl
	,s.flags
	,s.timeout

	FROM 
		msdb.dbo.sysmail_account a
		INNER JOIN msdb.dbo.sysmail_server s on a.account_id = s.account_id
		INNER JOIN msdb.dbo.sysmail_profileaccount pa on pa.account_id = a.account_id
		INNER JOIN msdb.dbo.sysmail_profile p on pa.profile_id = p.profile_id
		LEFT JOIN msdb.dbo.sysmail_principalprofile def on p.profile_id = def.profile_id and def.principal_sid = 0x00'

	execute sp_executesql @sql 



/***********************************************************************************************************
Send test email 
***********************************************************************************************************/
IF ISNULL(@sendtestmailProfileId,0) > 0
BEGIN
	SELECT @profileName = name FROM  msdb.dbo.sysmail_profile  WHERE profile_id = @sendtestmailProfileId
	IF @profileName IS NOT NULL
	BEGIN
		SET @sql ='EXEC msdb.dbo.sp_send_dbmail 
					@profile_name =  ''' + @profileName + ''',
					@recipients = '' ' + @recipients + ''',
					@query = ''select @@servername'',
					@subject = ''Test Message from Database Server'' ;'
					RAISERROR (@sql,10,1) WITH NOWAIT;
					RAISERROR ('',10,1) WITH NOWAIT;

		EXEC sp_executesql @sql 			
	END 
	ELSE
		RAISERROR('Unable to determine profile based on the profile id passed in, cannot send email.',10,1) WITH NOWAIT;
END

/***********************************************************************************************************
	This script will generate the statement needed to create an exisitng mail account. Use this to copy
	from one server to another.
	SET @accountid and @profileid to non zero values to generate the create script for a specific account
	It will output to the Messages tab for easy copy and paste
***********************************************************************************************************/

IF ISNULL(@generateScriptProfileId,0) > 0 AND  ISNULL(@generateScriptAccountId,0) >0
BEGIN

DECLARE @accountid								INT = 0
DECLARE @profileid								INT = 0
DECLARE @mailProfileName						SYSNAME  
DECLARE @mailAccountName						SYSNAME
DECLARE @mailAccountDisplayName					SYSNAME
DECLARE @mailAccountDescription					NVARCHAR(256) 
DECLARE @mailEmailAddress						NVARCHAR(128) 
DECLARE @mailReplyAddress						NVARCHAR(128)	--Reply to Email address for DB Mail
DECLARE @mailSMTP								SYSNAME		--Mail server SMTP address or IP
DECLARE @mailPort								INT -- Will be defaulted to 25
DECLARE @mailUseSSL								BIT -- will be defaulted to 0 (No)
DECLARE @mailUserName							SYSNAME	-- user name to log onto mail server, leave NULL if the mail server does not require authentication
DECLARE @mailUserPassword						SYSNAME -- leave NULL unless @mailUserName is NOT NULL


select 
	@mailAccountName = a.name 
	,@mailProfileName = p.name
	,@mailEmailAddress = a.email_address
	,@mailAccountDisplayName = a.display_name
	,@mailReplyAddress = a.replyto_address
	,@mailSMTP = s.servername
	,@mailPort = s.port
	,@mailUseSSL = s.enable_ssl
	,@mailAccountDescription = a.[description]
	,@mailUserName = s.username
	,@mailUserPassword = CASE WHEN s.username IS NULL THEN NULL ELSE 'INSERT PASSWORD' END
	from 
		msdb.dbo.sysmail_account a
		INNER JOIN msdb.dbo.sysmail_server s on a.account_id = s.account_id
		INNER JOIN msdb.dbo.sysmail_profileaccount pa on pa.account_id = a.account_id
		INNER JOIN msdb.dbo.sysmail_profile p on pa.profile_id = p.profile_id
WHERE
	pa.account_id = @accountid
	AND pa.profile_id = @profileid
IF ISNULL(@accountid,0) >0 AND ISNULL(@profileid,0) > 0
BEGIN
	
		SET @sql = 'IF EXISTS(SELECT * FROM sys.configurations WHERE name = ''Database Mail XPs'' and CAST(value_in_use AS VARCHAR)  = ''0'')
BEGIN
	exec sp_configure ''show advanced options'',1
	RECONFIGURE
	exec sp_configure ''Database Mail XPs'',1
	RECONFIGURE
END'
		RAISERROR (@sql,10,1) WITH NOWAIT;	
		RAISERROR ('',10,1) WITH NOWAIT;

	SELECT  @sql = '-- Create a Database Mail account
	EXECUTE msdb.dbo.sysmail_add_account_sp
		@account_name = '''+ @mailAccountName + ''',
		@description = ''Mail account for administrative e-mail.'',
		@email_address = ''' + @mailEmailAddress + ''',
		@replyto_address = ''' + @mailReplyAddress + ''',
		@display_name = ''DBA SQL Server Support Mail'',
		@mailserver_name = ''' + @mailSMTP  +  ''',
		@enable_ssl = ' + cast(@mailUseSSL as char(1)) + '' +
		CASE WHEN @mailUserName IS NULL THEN ';'
			ELSE
				',
		@username = N''' + @mailUserName + ''',
		@password = N''' + ISNULL(@mailUserPassword,N'') + ''';'
			END
			RAISERROR (@sql,10,1) WITH NOWAIT;	
			RAISERROR ('',10,1) WITH NOWAIT;
	
			SET @sql = '-- Create a Database Mail profile
		EXECUTE msdb.dbo.sysmail_add_profile_sp
			@profile_name = ''' + @mailProfileName + ''',
			@description = ''Profile used for DBA administrative mail.'' ;'
			RAISERROR (@sql,10,1) WITH NOWAIT;



			SET	@sql = '-- Add the account to the profile
		EXECUTE msdb.dbo.sysmail_add_profileaccount_sp
			@profile_name = ''' + @mailProfileName + ''',
			@account_name = ''' + @mailAccountName + ''',
			@sequence_number =1 ;'
			RAISERROR (@sql,10,1) WITH NOWAIT;
			RAISERROR ('',10,1) WITH NOWAIT;

			SET @sql = '-- Grant access to the profile to all users in the msdb database
		EXECUTE msdb.dbo.sysmail_add_principalprofile_sp
			@profile_name = ''' + @mailProfileName + ''',
			@principal_name = ''public'',
			@is_default = 1 ;'
			RAISERROR (@sql,10,1) WITH NOWAIT;
			RAISERROR ('',10,1) WITH NOWAIT;

		SET @sql ='--send a test email
			EXEC msdb.dbo.sp_send_dbmail
			@profile_name =  ''' + @mailProfileName + ''',
			@recipients = ''miodba@fortifieddata.com'',
			@query = ''select @@servername'',
			@subject = ''Test Message from Database Mail Creation Script'' ;'
			RAISERROR (@sql,10,1) WITH NOWAIT;
			RAISERROR ('',10,1) WITH NOWAIT;
END
ELSE
	RAISERROR('Unable to get information for provided profile and accountId.',10,1) WITH NOWAIT;

END 
go


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetDiskSpace]',10,1) WITH NOWAIT;
if object_id('dbo.pGetDiskSpace') is null exec('create procedure [dbo].[pGetDiskSpace] as select getdate() DT')
GO
  

/****************************************************************************
This procedure uses xp_cmdshell and calls wmi to get information about all
the drives. If xp_cmdshell is not enabled it WILL ENABLE IT and then disable
it when it is done. It will return a result set of space information
****************************************************************************/
alter procedure dbo.pGetDiskSpace
(
	@driveletter		CHAR(1) = NULL
)
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
SET ARITHIGNORE ON

DECLARE @vSQL						NVARCHAR(1000);
DECLARE @tDrvLetter					TABLE (Drive VARCHAR(500));
DECLARE @vMsg						VARCHAR(1000);
DECLARE @vCurrentRuntime			DATETIME 
DECLARE @STRLine					VARCHAR(max);
DECLARE @Drive						VARCHAR(500);
DECLARE @TotalSize					REAL;
DECLARE @Freesize					REAL;
DECLARE @VolumeName					VARCHAR(64);
DECLARE @cmdshellEnabled			BIT

EXEC dbo.usp_UpdateVersionStatics
set @vCurrentRuntime = getdate()
SELECT @cmdshellEnabled = cast(value_in_use as bit) FROM SYS.configurations Where name = 'xp_cmdshell'

IF @cmdshellEnabled = 0
BEGIN
       RAISERROR('xp_cmdshell is NOT enabled, will enable it for the report and then turn it off when completed.',10,1) WITH NOWAIT;
       EXEC sp_configure 'xp_cmdshell',1;
       RECONFIGURE
END


DECLARE @tDrvInfo TABLE(
       Drive VARCHAR(500) null,
       [MB free] DECIMAL(20,2),
       [MB TotalSize] DECIMAL(20,2),
       [Volume Name] VARCHAR(64),
       [Pct Free] DECIMAL(20,2)
       );

INSERT INTO @tDrvLetter
EXEC xp_cmdshell 'wmic volume where drivetype="3" get caption, freespace, capacity, label';

DELETE FROM @tDrvLetter
WHERE Drive IS NULL OR len(Drive) < 4 OR Drive LIKE '%Capacity%' OR Drive LIKE  '%\\%\Volume%';


WHILE EXISTS(SELECT 1 FROM @tDrvLetter)
BEGIN
       SET ROWCOUNT 1;
       SELECT @STRLine = Drive FROM @tDrvLetter;

       -- Get TotalSize
       SET @TotalSize= CAST(LEFT(@STRLine,CHARINDEX(' ',@STRLine)) AS REAL)/1024/1024;
       --SELECT @TotalSize

       -- Remove Total Size
       SET @STRLine = REPLACE(@STRLine, LEFT(@STRLine,CHARINDEX(' ',@STRLine)),'');
       -- Get Drive

       SET @Drive = LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine)));
       --SELECT @Drive

       SET @STRLine = RTRIM(LTRIM(REPLACE(LTRIM(@STRLine), LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))),'')));

       SET @Freesize = CAST(LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))) as REAL)/1024/1024;
       --SELECT @Freesize/1024/1024

       SET @STRLine = RTRIM(LTRIM(REPLACE(LTRIM(@STRLine), LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))),'')));
       SET @VolumeName = @STRLine;
       -- 

       INSERT INTO @tDrvInfo SELECT @Drive, @Freesize, @TotalSize, @VolumeName,@Freesize/@TotalSize*100;

       DELETE FROM @tDrvLetter;
END

SET ROWCOUNT 0

-- POPULATE TEMP TABLE WITH LOGICAL DISKS
-- This is FIX/Workaround for Windows 2003 bug that WMIC doesn't return volume name that is over X number of charactors.
SET @vSQL ='wmic /FailFast:ON logicaldisk where (drivetype ="3" and volumename!="RECOVERY" AND volumename!="System Reserved") get deviceid,volumename  /Format:csv'

DECLARE @toutput1 TABLE (Col1 VARCHAR(2048));
INSERT INTO @toutput1
EXEC master..xp_cmdshell @vSQL;
DELETE @toutput1 where ltrim(Col1) is null or len(Col1) = 1 or Col1 like 'Node,DeviceID,VolumeName%';

DECLARE @tlogicaldisk TABLE (DeviceID VARCHAR(128),VolumeName VARCHAR(256));
DECLARE @NodeName VARCHAR(128);
SET @NodeName = (SELECT TOP 1 LEFT(Col1, CHARINDEX(',',Col1)) FROM @toutput1);

-- Clean up server name
UPDATE @toutput1 SET Col1 = REPLACE(Col1, @NodeName, '');

INSERT INTO @tlogicaldisk
SELECT LEFT(Col1, CHARINDEX(',',Col1)-2),  SUBSTRING(Col1, CHARINDEX(',',Col1)+1, LEN(Col1))
FROM @toutput1;


UPDATE dr
SET dr.[Volume Name] = ld.VolumeName
       FROM @tDrvInfo dr RIGHT OUTER JOIN @tlogicaldisk ld ON left(dr.Drive,1) = ld.DeviceID
WHERE LEN([Volume Name]) = 1

SELECT 
	CASE	WHEN LEN(Drive) = 3 THEN LEFT(Drive,1)
    ELSE Drive
    END AS drive
    ,[MB TotalSize] - [MB free] as [MB Used] 
    ,[MB free]
    ,[MB TotalSize]
    ,[Volume Name]
    ,[Pct Free]
    ,cast([MB TotalSize]/1024 AS DECIMAL(18,2)) as GB_TotalSize
    ,cast([MB free]/1024 as DECIMAL(18,2)) as GB_Free
    ,CONVERT(MONEY ,([MB TotalSize] - [MB free])/1024.0,1) as [GB Used]
FROM 
	@tDrvInfo
WHERE 
	CASE WHEN LEN(Drive) = 3 THEN LEFT(Drive,1) ELSE Drive  END =@driveletter
	OR 
		@driveletter IS NULL
ORDER BY 1;

IF @cmdshellEnabled = 0
BEGIN
        If EXISTS(SELECT 1 FROM SYS.configurations Where name = 'xp_cmdshell' AND value_in_use = CAST(1 AS sql_variant))
        BEGIN
                RAISERROR('Disabling xp_cmdshell .',10,1) WITH NOWAIT;
                EXEC sp_configure 'xp_cmdshell',0;
                RECONFIGURE
        END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetFileGrowthFromDefaultTrace]',10,1) WITH NOWAIT;
if object_id('dbo.pGetFileGrowthFromDefaultTrace') is null exec('create procedure [dbo].[pGetFileGrowthFromDefaultTrace] as select getdate() DT')
GO
  
alter procedure dbo.pGetFileGrowthFromDefaultTrace
WITH ENCRYPTION
AS
SET NOCOUNT ON
set TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
/****************************************************************************
  READ DEFAULT TRACE FILE -  get file growth and shrinks
****************************************************************************/

If Exists(SELECT 1 FROM sys.configurations WHERE name = N'default trace enabled' and value_in_use = 1)
BEGIN
	DECLARE @path			NVARCHAR(256)
	DECLARE @curnum			SMALLINT
	DECLARE @newnum			SMALLINT
	DECLARE @i				TINYINT

	SET @i = 1
	SELECT 
		@path =[PATH]
	 FROM 
		sys.traces
	WHERE 
		Id = 1

	If @path IS NOT NULL
	BEGIN
		If OBJECT_ID('tempdb..#TraceTemp') IS NOT NULL
			Drop table #TraceTemp

		SELECT 
			* 
			INTO #TraceTemp
		 FROM 
			::fn_trace_gettable(@path, 1)

		-- fn_trace_gettable passing in DEFAULT for number of files is not working, so loop through up to 5 files
		While @i < 5
		BEGIN
			BEGIN try
				set @curnum =  CAST(SUBSTRING(@path,CHARINDEX('.trc',@path,1)-3,3) AS INT)
				set @newnum = @curnum - 1
				set @path = REPLACE(@path, Cast(@curnum as nvarchar), cast(@newnum as nvarchar))
				INSERT INTO #TraceTemp
				SELECT * FROM ::fn_trace_gettable(@path, 1)
			set @i = @i + 1
			END try
			BEGIN catch
				DECLARE @errmsg	nvarchar(2048)
				set @errmsg = ERROR_MESSAGE()
				If @errmsg NOT like '%@either does not exist or there was an error opening the file%'
				BEGIN
					RAISERROR(@errmsg,10,1) WITH NOWAIT;
				END
				SET @i = 100
			END catch
		END 
		SELECT 
			CASE EVENTCLASS
				When  92 Then 'Data File Auto Grow'
				When  93 Then 'Log File Auto Grow'
				When  94 Then 'Data File Auto Shrink'
				When  95 Then 'Log File Auto Shrink'
			END AS Event
			,duration/1000 as duration_ms
			,databaseID
			,DatabaseName
			,[FileName]
			,StartTime
			,ISNULL(IntegerData,0)/128 as Growth_MB
			,NTDomainName
			,HostName
			,ClientProcessID
			,ApplicationName
			,SPID
			,Duration
			,EndTime
			,IntegerData
			,ServerName
			,EventClass
			,LoginSid
			,SessionLoginName
		FROM  
			#TraceTemp
		WHERE 
			EventClass between 92 and 95 --Data/Log File Auto Grow/Shrink
		ORDER BY
			StartTime desc
	END
END
Else
	RAISERROR( 'Unable to get path to log files, cannot process auto grow/shrink check. A default trace must be enabled for this procedure to work.', 15,1) WITH NOWAIT;

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetIndexCompressionEstimate]',10,1) WITH NOWAIT;
if object_id('dbo.pGetIndexCompressionEstimate') is null exec('create procedure [dbo].[pGetIndexCompressionEstimate] as select getdate() DT')
GO
  /******************************************************************************************************************************************
  dbo.pGetIndexCompressionEstimate
  Summary:  Gets compression estimates for the supplied database schema table index.

  Date:  5/3/2019
  Versions: 2012 and greater
  Parameters:
	@dbname			sysname	-  Database to check
	@tablename		sysname	-  Table to check
	@schemaname		sysname	-  schema of table, default is dbo
	@indexid		int	-  specific index to check, default is 1 which is the clustered index
------------------------------------------------------------------------------
  Written by Keith Buck, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
******************************************************************************************************************************************/
alter procedure dbo.pGetIndexCompressionEstimate(
	 @dbname		sysname 
	,@tablename		sysname  
	,@schemaname	sysname	 = 'dbo'
	,@indexid		int = 1
)
WITH ENCRYPTION
AS
IF (@dbname  IS NULL) OR (@tablename IS NULL) OR @schemaname IS NULL OR @indexid IS NULL
BEGIN
	RAISERROR('Please provide valid input for all paramters',15,1) WITH NOWAIT;
	RETURN
END

declare @sql		nvarchar(max)
declare @paramDef	nvarchar(500)


declare @result	table (
	object_name sysname
	,schema_name sysname
	,index_id	int --0 = Heap 1 = Clustered index > 1 = Nonclustered index
	,partition_number int
	,[size_with_current_compression_setting (KB)] bigint
	,[size_with_requested_compression_setting (KB)]		bigint
	,[sample_size_with_current_compression_setting (KB)] bigint
	,[sample_size_with_requested_compression_setting (KB)] bigint
)

SET @sql = N'exec [' + @dbname + N']..sp_estimate_data_compression_savings @schema_name = ['+ @schemaname + N'], @object_name = [' +@tablename +
	+N'], @index_id = ' + cast(@indexid as varchar(20)) + N', @partition_number = null, @data_compression= ''PAGE'''
Insert into @result
exec(@sql)


Select 
	'Page' as CompressionType
	,object_name 
	,schema_name
	,index_id	
	,partition_number 
	,convert(varchar(30),cast([size_with_current_compression_setting (KB)] /1024 as money),1) as Current_mb
	,convert(varchar(30),cast([size_with_requested_compression_setting (KB)] /1024 as money),1) as compressed_mb
	,(cast(([size_with_current_compression_setting (KB)] - [size_with_requested_compression_setting (KB)])/1024 as money)
		/ ([size_with_current_compression_setting (KB)] /1024 ) 
		)* 100 as PercentSavings

	,convert(varchar(30),cast(([size_with_current_compression_setting (KB)] - [size_with_requested_compression_setting (KB)])/1024 as money),1)as savings_mb
	,[size_with_current_compression_setting (KB)] 
	,[size_with_requested_compression_setting (KB)]
	,[sample_size_with_current_compression_setting (KB)] 
	,[sample_size_with_requested_compression_setting (KB)] 
From
	@result


delete @result
SET @sql = N'exec [' + @dbname + N']..sp_estimate_data_compression_savings @schema_name = ['+ @schemaname + N'], @object_name = [' +@tablename +
	+N'], @index_id = ' + cast(@indexid as varchar(20)) + N', @partition_number = null, @data_compression= ''ROW'''
Insert into @result
exec(@sql)


Select 
	'Row' as CompressionType
	,object_name 
	,schema_name
	,index_id	
	,partition_number 
	,convert(varchar(30),cast([size_with_current_compression_setting (KB)] /1024 as money),1) as Current_mb
	,convert(varchar(30),cast([size_with_requested_compression_setting (KB)] /1024 as money),1) as compressed_mb
	,(cast(([size_with_current_compression_setting (KB)] - [size_with_requested_compression_setting (KB)])/1024 as money)
		/ ([size_with_current_compression_setting (KB)] /1024 ) 
		)* 100 as PercentSavings

	,convert(varchar(30),cast(([size_with_current_compression_setting (KB)] - [size_with_requested_compression_setting (KB)])/1024 as money),1)as savings_mb
	,[size_with_current_compression_setting (KB)] 
	,[size_with_requested_compression_setting (KB)]
	,[sample_size_with_current_compression_setting (KB)] 
	,[sample_size_with_requested_compression_setting (KB)] 
From
	@result

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetIndexInformation]',10,1) WITH NOWAIT;
if object_id('dbo.pGetIndexInformation') is null exec('create procedure [dbo].[pGetIndexInformation] as select getdate() DT')
GO
  

/******************************************************************************************************************************************
	dbo.pGetIndexInformation
  Summary:  Gets index details for all indexes in a table. 

  Date:  5/10/2019
  Versions: 2008 and greater
  Parameters:
	@dbname			sysname	-  Database to check
	@tablename		sysname	-  Table to check
	@schemaname		sysname	-  schema of table, default is dbo
	,@IncludeIndexSize		bit:		Include total size of each index, default is 0 (No)
	,@IncludePartitionSize	bit:		Include total size of each Partition in each index if it is  = 0
------------------------------------------------------------------------------
  Written by Keith Buck, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
******************************************************************************************************************************************/
ALTER PROCEDURE dbo.pGetIndexInformation(
	 @dbname				sysname 
	,@table					sysname  
	,@schema				sysname	 = 'dbo'
	,@IncludeIndexSize		bit = 0
	,@IncludePartitionSize	bit = 0
)
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

IF ISNULL(@dbname,'') = ''
BEGIN
	RAISERROR('Parameter @dbname must be supplied',11,1) WITH NOWAIT;
	RETURN
END

IF ISNULL(@table,'') = ''
BEGIN
	RAISERROR('Parameter @table must be supplied',11,1) WITH NOWAIT;
	RETURN
END

IF ISNULL(@schema,'') = ''
BEGIN
	RAISERROR('Parameter @schema must be supplied',11,1) WITH NOWAIT;
	RETURN
END


DECLARE @sql					nvarchar(MAX)
DECLARE @ParmDefinition			nvarchar(500)
DECLARE @IntVariable			int
DECLARE @objid					int	


declare @objname nvarchar(256) = N'dbo.MKT_VALUATION_NONNUMERIC'
SET @ParmDefinition = N'@tablename sysname, @schemaname sysname, @objectid int OUTPUT'

select @sql = N'SELECT @objectid = OBJECT_ID from [' + @dbname + '].sys.objects o INNER JOIN [' + @dbname + '].sys.schemas s on o.schema_id = s.schema_id WHERE s.name = @schemaname AND o.name = @tablename'
EXECUTE sp_executesql @sql, @ParmDefinition, @tablename = @table, @schemaname = @schema,  @objectid = @objid OUTPUT


If @objid IS NULL
begin
	raiserror('Not a valid object name',15,1) with nowait;
	return;
end

/*******************************************************
			TOTAL SIZE OF EACH INDEX
*******************************************************/
SET @sql = N'SELECT 
	ix.name as [Index],
	ix.index_id,
	ix.type_desc,
	CASE WHEN SUM(ISNULL(allInRow.total_pages,0)) + 	SUM(ISNULL(allLob.total_pages,0)) + SUM(ISNULL(allOver.total_pages,0)) = 0 THEN ''0''
		ELSE FDDBA.dbo.fFormatIntReadable((SUM(ISNULL(allInRow.total_pages,0)) + 	
							SUM(ISNULL(allLob.total_pages,0)) + 
							SUM(ISNULL(allOver.total_pages,0)))/128.0) 
	END AS TotalSize_MB,
	FDDBA.dbo.fFormatIntReadable(SUM(ISNULL(allInRow.total_pages,0)) + 	SUM(ISNULL(allLob.total_pages,0)) + SUM(ISNULL(allOver.total_pages,0))) AS TotalPages,
	FDDBA.dbo.fFormatIntReadable(SUM(allInRow.total_pages)) AS InRowPages,
	FDDBA.dbo.fFormatIntReadable(SUM(allLob.total_pages)) AS LobPages,
	FDDBA.dbo.fFormatIntReadable(SUM(allOver.total_pages)) AS RowOverFlowPages  
 FROM
	[' + @dbname + '].sys.objects o 
	INNER JOIN [' + @dbname + '].sys.schemas sch on o.schema_id = sch.schema_id
	LEFT JOIN [' + @dbname + '].sys.indexes ix on o.object_id = ix.object_id --and s.name = ix.name
	INNER JOIN [' + @dbname + '].sys.partitions p on ix.object_id = p.object_id And ix.index_id = p.index_id
	LEFT JOIN [' + @dbname + '].sys.allocation_units allInRow on p.hobt_id = allInRow.container_id and allInRow.type = 1
	LEFT JOIN [' + @dbname + '].sys.allocation_units allLob on p.partition_id = allLob.container_id and allLob.type = 2
	LEFT JOIN [' + @dbname + '].sys.allocation_units allOver on p.partition_id = allLob.container_id and allLob.type = 3
WHERE
	o.object_id = @objectid 
GROUP BY 
	ix.name ,
	ix.index_id,
	ix.type_desc
ORDER BY
	CASE WHEN ix.type_desc =N''NONCLUSTERED'' THEN 2 ELSE 1 END
	,ix.name'

SET @ParmDefinition = N'@objectid int'
IF ISNULL(@IncludeIndexSize,1) = 1
	EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid

/*******************************************************
			TOTAL SIZE OF EACH PARTITION
*******************************************************/
SET @sql = N'SELECT 
	ix.name as [Index],
	ix.type_desc,
	p.partition_number,
	CASE WHEN ISNULL(allInRow.total_pages,0) + 	ISNULL(allLob.total_pages,0) + ISNULL(allOver.total_pages,0) = 0 THEN ''0''
		ELSE FDDBA.dbo.fFormatIntReadable((ISNULL(allInRow.total_pages,0) + 	ISNULL(allLob.total_pages,0) + ISNULL(allOver.total_pages,0))/128) 
	END AS TotalSize_MB,
	ISNULL(allInRow.total_pages,0) + 	ISNULL(allLob.total_pages,0) + ISNULL(allOver.total_pages,0) as TotalPages,
	allInRow.total_pages as InRowPages,
	allLob.total_pages as LobPages,
	allOver.total_pages as RowOverFlowPages  
 FROM
	[' + @dbname + '].sys.objects o 
	INNER JOIN  [' + @dbname + '].sys.schemas sch on o.schema_id = sch.schema_id
	LEFT JOIN [' + @dbname + '].sys.indexes ix on o.object_id = ix.object_id --and s.name = ix.name
	INNER JOIN [' + @dbname + '].sys.partitions p on ix.object_id = p.object_id And ix.index_id = p.index_id
	LEFT JOIN [' + @dbname + '].sys.allocation_units allInRow on p.hobt_id = allInRow.container_id and allInRow.type = 1
	LEFT JOIN [' + @dbname + '].sys.allocation_units allLob on p.partition_id = allLob.container_id and allLob.type = 2
	LEFT JOIN [' + @dbname + '].sys.allocation_units allOver on p.partition_id = allLob.container_id and allLob.type = 3
WHERE
	o.object_id = @objectid 
ORDER BY
	CASE WHEN ix.type_desc =N''NONCLUSTERED'' THEN 2 ELSE 1 END
	,ix.name 
	,p.partition_number'


IF ISNULL(@IncludePartitionSize,1) = 1
	EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid


/*******************************************************
			INDEX INFORMATION INCLUDING ALL COLUMNS
			FOR EACH INDEX
*******************************************************/
SET @sql = N'
Select 
		''' + @dbname +''' AS [Database],
		i.object_id,  
        sc.name as TableSchema,  
        tbl.name as TableName, 
        i.name as IndexName, 
        i.type_desc, 
        i.index_id, 
		i.has_filter,
		CASE WHEN ic.partition_ordinal = 1 THEN ''Yes'' ELSE ''No'' End as IsPartCol,
		i.is_unique,
        i.fill_factor, 
        c.name as ColumnName, 
        ic.key_ordinal, 
		p.data_compression_desc,
        t.name as DataType, 
        c.max_length,
        Case When ic.is_included_column = 1 Then ''Yes'' Else ''No'' End as is_included_column ,
        i.is_hypothetical,
		sum(a.total_pages) as total_pages,
		sum(a.used_pages) as used_pages,
        Convert(varchar(20),Cast(p.rows as money),1) as RecordCount ,
		sum(a.total_pages)/128 as TotalSpace_mb,
		sum(a.used_pages)/128 as TotalUsedSpace_mb,
		ISNULL (CONVERT (VARCHAR (10), STATS_DATE (tbl.[object_id], i.index_id), 23), '''') AS statistics_date,
		i.filter_definition
from 
	[' + @dbname + N'].sys.indexes i
    left join [' + @dbname + N'].sys.index_columns ic on i.object_id = ic.object_id
                        and i.index_id = ic.index_id
    left join [' + @dbname + N'].sys.tables tbl on i.object_id = tbl.object_id
    left join [' + @dbname + N'].sys.schemas sc on tbl.schema_id = sc.schema_id
    left join [' + @dbname + N'].sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id
    left join [' + @dbname + N'].sys.types t on c.user_type_id = t.user_type_id and c.system_type_id = t.system_type_id
    left join [' + @dbname + N'].sys.partitions p on i.object_id = p.object_id and i.index_id = p.index_id
                                and p.partition_number = 1
	left join [' + @dbname + N'].sys.allocation_units a on p.partition_id = a.container_id
		 
where 
  i.object_id = @objectid

Group By
		i.object_id,  
        sc.name,  
        tbl.name, 
        i.name, 
        i.type_desc, 
		i.is_unique,
        i.index_id, 
		i.has_filter,
        i.fill_factor, 
        c.name , 
        ic.key_ordinal, 
		p.data_compression_desc,
        t.name , 
        c.max_length,
        ic.is_included_column,
        i.is_hypothetical,
        Convert(varchar(20),Cast(p.rows as money),1),
		ISNULL (CONVERT (VARCHAR (10), STATS_DATE (tbl.[object_id], i.index_id), 23), ''''),
		i.filter_definition,
		ic.partition_ordinal
ORDER BY 
	i.object_id
	,i.index_id
	,ic.is_included_column
	,ic.key_ordinal
	,c.name'


EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid


SET @sql = N'
select 
	i.object_id,  
	sc.name as TableSchema,  
	tbl.name as TableName, 
	i.name as IndexName, 
	i.type_desc, 
	sum(a.total_pages) as total_pages,
	sum(a.used_pages) as used_pages,
	Convert(varchar(20),Cast(part.rows as money),1)  as RecordCount,
	part.partition_number, 
	sum(a.total_pages)/128 as TotalSpace_mb,
	sum(a.used_pages)/128 as TotalUsedSpace_mb,
	(sum(a.total_pages)/128)/1024.0 as TotalSpace_GB

from 
	[' + @dbname + N'].sys.indexes i
    inner join [' + @dbname + N'].sys.objects tbl on i.object_id = tbl.object_id
    inner join [' + @dbname + N'].sys.schemas sc on tbl.schema_id = sc.schema_id
	left join [' + @dbname + N'].sys.partitions part on i.object_id = part.object_id AND i.index_id = part.index_id
	left join [' + @dbname + N'].sys.allocation_units a on part.partition_id = a.container_id
		 
where 
  i.object_id = @objectid

Group By
		i.object_id,  
        sc.name,  
        tbl.name, 
        i.name, 
        i.type_desc, 
		part.rows,
		part.partition_number,
		i.index_id 
ORDER BY
	i.index_id 
	,part.partition_number desc'
EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetIndexUsageDetail]',10,1) WITH NOWAIT;
if object_id('dbo.pGetIndexUsageDetail') is null exec('create procedure [dbo].[pGetIndexUsageDetail] as select getdate() DT')
GO
  
/******************************************************************************************************************************************
	dbo.pGetIndexUsageDetail
  Summary:  Gets index usage details for all indexes in a table

  Date:  5/10/2019
  Versions: 2008 and greater
  Parameters:
	@dbname			sysname	-  Database to check
	@tablename		sysname	-  Table to check
	@schemaname		sysname	-  schema of table, default is dbo
	,@IncludeIndexSize		bit:		Include total size of each index, default is 0 (No)
	,@IncludePartitionSize	bit:		Include total size of each Partition in each index, default is 0 (No)
------------------------------------------------------------------------------
  Written by Keith Buck, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
******************************************************************************************************************************************/
ALTER PROCEDURE dbo.pGetIndexUsageDetail(
	 @dbname				sysname 
	,@table					sysname  
	,@schema				sysname	 = 'dbo'
	,@IncludeIndexSize		bit = 0
	,@IncludePartitionSize	bit = 0
)
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

IF ISNULL(@dbname,'') = ''
BEGIN
	RAISERROR('Parameter @dbname must be supplied',11,1) WITH NOWAIT;
	RETURN
END

IF ISNULL(@table,'') = ''
BEGIN
	RAISERROR('Parameter @table must be supplied',11,1) WITH NOWAIT;
	RETURN
END

IF ISNULL(@schema,'') = ''
BEGIN
	RAISERROR('Parameter @schema must be supplied',11,1) WITH NOWAIT;
	RETURN
END


DECLARE @sql					nvarchar(MAX)
DECLARE @ParmDefinition			nvarchar(500)
DECLARE @IntVariable			int
DECLARE @objid					int	


declare @objname nvarchar(256) = N'dbo.MKT_VALUATION_NONNUMERIC'
SET @ParmDefinition = N'@tablename sysname, @schemaname sysname, @objectid int OUTPUT'

select @sql = N'SELECT @objectid = OBJECT_ID from [' + @dbname + '].sys.objects o INNER JOIN [' + @dbname + '].sys.schemas s on o.schema_id = s.schema_id WHERE s.name = @schemaname AND o.name = @tablename'
EXECUTE sp_executesql @sql, @ParmDefinition, @tablename = @table, @schemaname = @schema,  @objectid = @objid OUTPUT


If @objid IS NULL
begin
	raiserror('Not a valid object name',15,1) with nowait;
	return;
end

/*******************************************************
			TOTAL SIZE OF EACH INDEX
*******************************************************/
SET @sql = N'SELECT 
	ix.name as [Index],
	ix.index_id,
	ix.type_desc,
	CASE WHEN SUM(ISNULL(allInRow.total_pages,0)) + 	SUM(ISNULL(allLob.total_pages,0)) + SUM(ISNULL(allOver.total_pages,0)) = 0 THEN ''0''
		ELSE FDDBA.dbo.fFormatIntReadable((SUM(ISNULL(allInRow.total_pages,0)) + 	
							SUM(ISNULL(allLob.total_pages,0)) + 
							SUM(ISNULL(allOver.total_pages,0)))/128.0) 
	END AS TotalSize_MB,
	FDDBA.dbo.fFormatIntReadable(SUM(ISNULL(allInRow.total_pages,0)) + 	SUM(ISNULL(allLob.total_pages,0)) + SUM(ISNULL(allOver.total_pages,0))) AS TotalPages,
	FDDBA.dbo.fFormatIntReadable(SUM(allInRow.total_pages)) AS InRowPages,
	FDDBA.dbo.fFormatIntReadable(SUM(allLob.total_pages)) AS LobPages,
	FDDBA.dbo.fFormatIntReadable(SUM(allOver.total_pages)) AS RowOverFlowPages  
 FROM
	[' + @dbname + '].sys.objects o 
	INNER JOIN [' + @dbname + '].sys.schemas sch on o.schema_id = sch.schema_id
	LEFT JOIN [' + @dbname + '].sys.indexes ix on o.object_id = ix.object_id --and s.name = ix.name
	INNER JOIN [' + @dbname + '].sys.partitions p on ix.object_id = p.object_id And ix.index_id = p.index_id
	LEFT JOIN [' + @dbname + '].sys.allocation_units allInRow on p.hobt_id = allInRow.container_id and allInRow.type = 1
	LEFT JOIN [' + @dbname + '].sys.allocation_units allLob on p.partition_id = allLob.container_id and allLob.type = 2
	LEFT JOIN [' + @dbname + '].sys.allocation_units allOver on p.partition_id = allLob.container_id and allLob.type = 3
WHERE
	o.object_id = @objectid 
GROUP BY 
	ix.name ,
	ix.index_id,
	ix.type_desc
ORDER BY
	CASE WHEN ix.type_desc =N''NONCLUSTERED'' THEN 2 ELSE 1 END
	,ix.name'

SET @ParmDefinition = N'@objectid int'
IF ISNULL(@IncludeIndexSize,1) = 1
	EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid

/*******************************************************
			TOTAL SIZE OF EACH PARTITION
*******************************************************/
SET @sql = N'SELECT 
	ix.name as [Index],
	ix.type_desc,
	p.partition_number,
	CASE WHEN ISNULL(allInRow.total_pages,0) + 	ISNULL(allLob.total_pages,0) + ISNULL(allOver.total_pages,0) = 0 THEN ''0''
		ELSE FDDBA.dbo.fFormatIntReadable((ISNULL(allInRow.total_pages,0) + 	ISNULL(allLob.total_pages,0) + ISNULL(allOver.total_pages,0))/128) 
	END AS TotalSize_MB,
	ISNULL(allInRow.total_pages,0) + 	ISNULL(allLob.total_pages,0) + ISNULL(allOver.total_pages,0) as TotalPages,
	allInRow.total_pages as InRowPages,
	allLob.total_pages as LobPages,
	allOver.total_pages as RowOverFlowPages  
 FROM
	[' + @dbname + '].sys.objects o 
	INNER JOIN  [' + @dbname + '].sys.schemas sch on o.schema_id = sch.schema_id
	LEFT JOIN [' + @dbname + '].sys.indexes ix on o.object_id = ix.object_id --and s.name = ix.name
	INNER JOIN [' + @dbname + '].sys.partitions p on ix.object_id = p.object_id And ix.index_id = p.index_id
	LEFT JOIN [' + @dbname + '].sys.allocation_units allInRow on p.hobt_id = allInRow.container_id and allInRow.type = 1
	LEFT JOIN [' + @dbname + '].sys.allocation_units allLob on p.partition_id = allLob.container_id and allLob.type = 2
	LEFT JOIN [' + @dbname + '].sys.allocation_units allOver on p.partition_id = allLob.container_id and allLob.type = 3
WHERE
	o.object_id = @objectid 
ORDER BY
	CASE WHEN ix.type_desc =N''NONCLUSTERED'' THEN 2 ELSE 1 END
	,ix.name 
	,p.partition_number'


IF ISNULL(@IncludePartitionSize,1) = 1
	EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid

SET @sql = N'
SELECT DB_NAME( s.database_id ) AS DbName
	, objectname=object_name(s.object_id)
	, s.object_id
	, indexname=i.name
	, i.index_id
	, i.type_desc
	, s2.rowcnt
	, isz.[Indexsize(MB)]
	, fg.name as FileGroup
	,dbo.fFormatIntReadable((s.user_seeks + s.user_scans + s.user_lookups ))  as TotalReads
	,dbo.fFormatIntReadable(user_seeks) as user_seeks
	,dbo.fFormatIntReadable(user_scans) as user_scans
	,dbo.fFormatIntReadable(user_lookups) as user_lookups
	, Case When (s.user_seeks + s.user_scans + s.user_lookups ) < 1 then 0 Else cast( ( (s.user_seeks + s.user_scans + s.user_lookups )/cast(s.user_seeks + s.user_scans + s.user_lookups + s.user_updates as decimal(18,2))) * 100  as money) End as PercentUserSeeks
	, user_updates
	,Case When (s.user_seeks + s.user_scans + s.user_lookups + s.user_updates)< 1 then 0 Else cast( (user_updates/cast((s.user_seeks + s.user_scans + s.user_lookups + s.user_updates) as decimal(18,2))) * 100  as money) End as PercentUserUpdates
	, system_seeks
	, system_scans
	, system_lookups
	,i.is_unique
	,i.is_disabled
	,i.has_filter
	,s.last_user_scan
	,s.last_user_seek
	,s.last_user_lookup
from [' + @dbname + N'].sys.dm_db_index_usage_stats s
	 INNER JOIN [' + @dbname + N'].sys.indexes i ON s.object_id = i.object_id AND s.index_id = i.index_id
	 left JOIN [' + @dbname + N'].sys.filegroups fg on i.data_space_id = fg.data_space_id
	 left JOIN [' + @dbname + N']..sysindexes s2 ON i.object_id = s2.id AND i.index_id = s2.indid
	 OUTER APPLY(
				SELECT
					ind.object_id   ,
					ind.name AS IndexName,
					ind.index_id AS IndexID,
					8 * SUM(a.total_pages)/1024 AS ''Indexsize(MB)''
					FROM [' + @dbname + N'].sys.indexes AS ind
					JOIN [' + @dbname + N'].sys.partitions AS p ON p.OBJECT_ID = ind.OBJECT_ID AND p.index_id = ind.index_id
					JOIN [' + @dbname + N'].sys.allocation_units AS a ON a.container_id = p.partition_id
					Where ind.object_id = i.object_id
					  ANd	ind.index_id = i.index_id
					GROUP BY ind.OBJECT_ID,ind.index_id,ind.name
	 ) as isz
where 
	1=1
	And s.database_id = db_id(''' + @dbname + N''')
	AND i.object_id =  @objectid
order by 
	 (s.user_scans + s.user_lookups + s.user_seeks ) desc
	 ,DbName
	 ,objectname
	 , i.index_id'

print @sql	
print @objid
EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid


SET @sql = N'select i.object_id,  
        sc.name as TableSchema,  
        tbl.name as TableName, 
        i.name as IndexName, 
        i.type_desc, 
        sum(a.total_pages) as total_pages,
		sum(a.used_pages) as used_pages,

		Convert(varchar(20),Cast(part.rows as money),1)  as RecordCount,
		part.partition_number, 
		sum(a.total_pages)/128 as TotalSpace_mb,
		sum(a.used_pages)/128 as TotalUsedSpace_mb,
		(sum(a.total_pages)/128)/1024.0 as TotalSpace_GB

from 
	[' + @dbname + N'].sys.indexes i
    inner join [' + @dbname + N'].sys.objects tbl on i.object_id = tbl.object_id
    inner join [' + @dbname + N'].sys.schemas sc on tbl.schema_id = sc.schema_id
	left join [' + @dbname + N'].sys.partitions part on i.object_id = part.object_id AND i.index_id = part.index_id
	left join [' + @dbname + N'].sys.allocation_units a on part.partition_id = a.container_id
		 
where i.object_id > 99
  AND i.object_id = @objectid

Group By
		i.object_id,  
        sc.name,  
        tbl.name, 
        i.name, 
        i.type_desc, 
		part.rows,
		part.partition_number,
		i.index_id 	
ORDER BY
	i.index_id 
	,part.partition_number desc'

EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetPLE]',10,1) WITH NOWAIT;
if object_id('dbo.pGetPLE') is null exec('create procedure [dbo].[pGetPLE] as select getdate() DT')
GO
  
alter procedure [dbo].[pGetPLE]
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

DECLARE @recPLE			BIGINT	
DECLARE @avg			BIGINT

SELECT 
	@recPLE = (cast(cntr_value as decimal(18,2))/128/1024/4) *300
 FROM 
	sys.dm_os_performance_counters
WHERE  
	[object_name] like N'%:Buffer Manager%'
	AND counter_name = N'Database pages'   

IF @recPLE < 300
	SET @recPLE = 300

-- Get the values per Numa Node
SELECT 
	@avg =  avg(cntr_value)
 FROM 
	sys.dm_os_performance_counters
WHERE 
	[object_name] like N'%:Buffer Node%' -- Modify this if you have named instances
	And counter_name = N'Page life expectancy'
OPTION (RECOMPILE);

SELECT 
	instance_name as NumaNode, 
	cntr_value as PLE, 
	@recPLE as [Recommended Min PLE], convert(varchar(30), cast(cntr_value - @recPLE as money),1) as 'Node PLE Variance From Recommended', 
	@avg as AveragePLE
 FROM 
	sys.dm_os_performance_counters
WHERE 
	[object_name] like N'%:Buffer Node%' -- Modify this if you have named instances
	And counter_name = N'Page life expectancy'
OPTION (RECOMPILE);

GO


--name typo, this proc is in another file, this is to delete it.
if object_id('dbo.pGetResotoreInfo') is not null 
	exec('drop procedure [dbo].[pGetResotoreInfo]')
GO
 


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetRestoreInfo]',10,1) WITH NOWAIT;
if object_id('dbo.pGetRestoreInfo') is null exec('create procedure [dbo].[pGetRestoreInfo] as select getdate() DT')
GO
  
/******************************************************************************************************************************************
dbo.pGetRestoreInfo
 Summary:  Reads restore information from msdb for the supplied databases over the supplied
	time range for the supplied restore types.

  Date:  4/25/2019
  Versions: 2008 R2 and greater
  Parameters:
	@dbName			sysname default N'ALL'		- single database name or ALL
	@backupTypeList	varchar(10) default 'D,L,I'	- Backup type list delimited by a comma
	@daysBack		int default -7				- days back to check restore information
	@debug			bit default 0				- enable debugging, will show parameters
------------------------------------------------------------------------------
  Written by Keith Buck, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
******************************************************************************************************************************************/
alter procedure  dbo.pGetRestoreInfo(
		@dbName					sysname = N'ALL'
	,@backupTypeList		varchar(10) = 'D,L,I'		
	,@daysBack				int = -7
	,@debug					bit = 0
	
)
WITH ENCRYPTION 
AS

SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

IF @daysBack > 0
	SET @daysBack = @daysBack * -1

DECLARE @typelist	TABLE (TypeName CHAR(1))
INSERT INTO @typelist (TypeName) SELECT * FROM dbo.fSplit(@backupTypeList,',')

IF @debug = 1
BEGIN
	SELECT '@typelist' AS 'TableName', * FROM @typelist
	SELECT @dbName AS '@dbName', @backupTypeList AS '@backupTypeList',  @daysBack AS '@daysBack'
END

SELECT 
	[rs].[destination_database_name], 
	[rs].[restore_date], 
	[bs].[backup_start_date], 
	[bs].[backup_finish_date], 
	[bs].[database_name] as [source_database_name], 
	[bmf].[physical_device_name] as [backup_file_used_for_restore],
	bs.user_name as BackupUserName,
	bs.machine_name AS BackupOriginatingServer,
	rs.restore_type,
	rs.user_name RestoreUserName
FROM 
	msdb..restorehistory rs
	INNER JOIN msdb..backupset bs ON [rs].[backup_set_id] = [bs].[backup_set_id]
	INNER JOIN msdb..backupmediafamily bmf ON [bs].[media_set_id] = [bmf].[media_set_id] 
Where 
	(destination_database_name = @dbName OR @dbName != 'ALL')
	AND rs.[restore_date] >= DATEADD(DAY,@daysBack,GETDATE())
	AND rs.restore_type in (SELECT TypeName FROM @typelist) 
	AND bs.machine_name != @@SERVERNAME --exclude backups taken by this server
ORDER BY 
	rs.destination_database_name,
	[rs].[restore_date] DESC
	
GO


USE FDDBA
go


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetServerAndDatabasePermissionsAndRolesForLogin]',10,1) WITH NOWAIT;
if object_id('dbo.pGetServerAndDatabasePermissionsAndRolesForLogin') is null exec('create procedure [dbo].[pGetServerAndDatabasePermissionsAndRolesForLogin] as select getdate() DT')
GO
  /******************************************************************************************************************************************
  dbo.pGetServerAndDatabasePermissionsAndRolesForLogin
  Summary:  Returns role and explicit permissions at server and specified database level for a server level login

  Date:  9/16/2019
  Versions: 2008R2 and greater
  Parameters:
	@dbname			sysname		-  Database to check 
	@LoginName		sysname		-  Server Level Login to Check. Can be SQL User, windows user or Group
	@ShowDefinedDatabaseRoles	BIT	 - Will show all database roles
	@excludeServeConnectPermission BIT - Exclude server level permission for CONNECT permission

  Written by Keith Buck, Fortified Data
------------------------------------------------------------------------------
  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
Change List
By			Date	Notes
2019-09-20	kbuck	Added check for DB Only object (@IsDBOnly) like roles or users in contained databases. 
					Ensuring proc does not return failure for those types
******************************************************************************************************************************************/
alter procedure dbo.pGetServerAndDatabasePermissionsAndRolesForLogin(
	@dbname								SYSNAME,
	@LoginName							SYSNAME,
	@ShowDefinedDatabaseRoles			BIT =1,
	@excludeServeConnectPermission		BIT = 0
)
WITH ENCRYPTION 
AS

SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
SET NOCOUNT ON
 
DECLARE @hasConnect				nvarchar(60)
DECLARE @username				sysname 
DECLARE @userid					int
DECLARE @IsLocked				bit
DECLARE @IsDBOnly				bit = 0  -- flags the account as a db role or a login in a contained database
--DECLARE @InclucdeAllDBRoles		bit = 0
DECLARE @sql					nvarchar(MAX)
DECLARE @ParmDefinition			nvarchar(500)
DECLARE @IntVariable			int
DECLARE @idout					int	

IF @dbname IS NULL or DB_ID (@dbname) is null
BEGIN
	RAISERROR('Database name is missing or does not exist (pGetServerAndDatabasePermissionsAndRolesForLogin).',15,1) WITH NOWAIT;
	RETURN
END

IF @LoginName IS NULL or NOT EXISTS (SELECT * FROM sys.server_principals WHERE name = ISNULL(@LoginName,''))
BEGIN
	--first check the database to see as it may be a role
	set @sql = N'select * from [' + @dbname + N'].sys.database_principals where name = ''' + @LoginName +''''
	execute sp_executesql @sql 
	select @idout = @@ROWCOUNT 
	print '@idout = ' + cast(@idout as varchar(5))

	--IF WE GET A ROW BACK THEN IT IS A LOGIN
	IF @idout = 1
		SET @IsDBOnly = 1
	ELSE
	BEGIN
		RAISERROR('Login name is NULL or unable to find matching server level login for name matching @LoginName (pGetServerAndDatabasePermissionsAndRolesForLogin).',15,1) WITH NOWAIT;
		RETURN
	END
END




SET @ParmDefinition = N'@LoginNameIn sysname, @useridin int OUTPUT'
SELECT @sql = N'SELECT @useridin = principal_id from [' + @dbname + '].sys.database_principals WHERE name = @LoginNameIn '
EXECUTE sp_executesql @sql, @ParmDefinition, @LoginNameIn = @LoginName, @useridin = @userid  OUTPUT

select @IsLocked =  Cast(LOGINPROPERTY(@username,'IsLocked')  as bit)


SET @ParmDefinition = N'@useridIn INT, @hasConnectIn nvarchar(60) OUTPUT'
SELECT @sql = N'SELECT @hasConnectIn = state_desc from [' + @dbname + '].sys.database_permissions WHERE permission_name = ''CONNECT''	AND grantee_principal_id =  @useridIn'
EXECUTE sp_executesql @sql, @ParmDefinition, @useridIn = @userid, @hasConnectIn = @hasConnect  OUTPUT


If @hasConnect IS NULL
	set @hasConnect = N'Does Not Have Connect Database'



select 
	@userid as '@userid'
	,@dbname as DatbaseName
	,HAS_DBACCESS(@dbname) as HasDatabaseAccess
	,CASE WHEN @IsDBOnly = 1 THEN  'DB Level Object' Else CASE WHEN ISNULL(@IsLocked,0) = 1 THEN 'True' ELSE 'False' END End  as IsLocked
	,@hasConnect as 'Can Connect Database'

 

set @sql = N'SELECT ''server_principal_Info'' as ''server_principal_Info'' , * FROM sys.server_principals WHERE NAME = ''' + @LoginName + N''''
execute ( @sql )


select 'sys.database_principals' as 'sys.database_principals', * from sys.database_principals Where principal_id = @userid

--See who is assigned to the DBO role
set @sql = N'select p.name as DBO_LoginName	,suser_sname(p.sid) as suser_DBO_LoginName 	,p.* 
	from [' + @dbname + '].	sys.database_principals p 
where 	p.name = N''dbo'''
execute ( @sql )	

	
--SERVER ROLE MEMEBERSHIP
Select 
	'Server Role Memebership' as 'Server Role Memebership'
	,dprole.name
	,sp.name as LoginName
	,dpmem.name as UserName
	,'exec sp_dropsrvrolemember  @rolename = N'''  + dprole.name + ''', @loginame =N''' + dpmem.name + '''' As DropStatement
	,'exec sp_addsrvrolemember  @rolename = N'''  + dprole.name + ''', @loginame =N''' + dpmem.name + '''' As AddStatement
 from 
	sys.server_role_members drm 
	inner join sys.server_principals dprole ON drm.role_principal_id = dprole.principal_id 
    inner join sys.server_principals dpmem ON drm.member_principal_id = dpmem.principal_id 
	inner join master.sys.server_principals sp on dpmem.sid = sp.sid
 Where
	sp.name = @username
order by 
	sp.name
	,dpmem.name;
--SERVER LEVEL PERMISSIONS
select
	'Server Level Permissions' as 'Output Type'
	,r.state_desc  as cmd_state
	,r.permission_name
	 ,'TO [' + p.name + ']' as PrincipalName
 from 
	sys.server_permissions r
	inner join sys.server_principals p on r.grantee_principal_id = p.principal_id
where 
	p.name = @username

--DATABASE PERMISSIONS

SET @sql =N'SELECT 
	CASE WHEN P.state_desc = ''GRANT_WITH_GRANT_OPTION'' THEN ''GRANT'' ELSE P.state_desc END AS cmd_state,        
	P.permission_name,        
	''ON ''+ CASE P.class_desc            
			WHEN ''DATABASE'' THEN ''DATABASE::''+QUOTENAME(DB_NAME())            
			WHEN ''SCHEMA'' THEN ''SCHEMA::''+QUOTENAME(S.name)            
			WHEN ''OBJECT_OR_COLUMN'' THEN ''OBJECT::''+QUOTENAME(OS.name)+''.''+QUOTENAME(O.name)+              
				CASE WHEN P.minor_id <> 0 THEN ''(''+QUOTENAME(C.name)+'')'' ELSE '''' END           
			WHEN ''DATABASE_PRINCIPAL'' THEN              
				CASE PR.type_desc                 
					WHEN ''SQL_USER'' THEN ''USER''               
					WHEN ''DATABASE_ROLE'' THEN ''ROLE''               
					WHEN ''APPLICATION_ROLE'' THEN ''APPLICATION ROLE''             
				END +''::''+QUOTENAME(PR.name)            
			WHEN ''ASSEMBLY'' THEN ''ASSEMBLY::''+QUOTENAME(A.name)            
			WHEN ''TYPE'' THEN ''TYPE::''+QUOTENAME(TS.name)+''.''+QUOTENAME(T.name)            
			WHEN ''XML_SCHEMA_COLLECTION'' THEN ''XML SCHEMA COLLECTION::''+QUOTENAME(XSS.name)+''.''+QUOTENAME(XSC.name)            
			WHEN ''SERVICE_CONTRACT'' THEN ''CONTRACT::''+QUOTENAME(SC.name)            
			WHEN ''MESSAGE_TYPE'' THEN ''MESSAGE TYPE::''+QUOTENAME(SMT.name)            
			WHEN ''REMOTE_SERVICE_BINDING'' THEN ''REMOTE SERVICE BINDING::''+QUOTENAME(RSB.name)            
			WHEN ''ROUTE'' THEN ''ROUTE::''+QUOTENAME(R.name)            
			WHEN ''SERVICE'' THEN ''SERVICE::''+QUOTENAME(SBS.name)            
			WHEN ''FULLTEXT_CATALOG'' THEN ''FULLTEXT CATALOG::''+QUOTENAME(FC.name)            
			WHEN ''FULLTEXT_STOPLIST'' THEN ''FULLTEXT STOPLIST::''+QUOTENAME(FS.name)            
			--WHEN ''SEARCH_PROPERTY_LIST'' THEN ''SEARCH PROPERTY LIST::''+QUOTENAME(RSPL.name)            
			WHEN ''SYMMETRIC_KEYS'' THEN ''SYMMETRIC KEY::''+QUOTENAME(SK.name)            
			WHEN ''CERTIFICATE'' THEN ''CERTIFICATE::''+QUOTENAME(CER.name)            
			WHEN ''ASYMMETRIC_KEY'' THEN ''ASYMMETRIC KEY::''+QUOTENAME(AK.name)          
		END COLLATE Latin1_General_100_BIN AS securable,          
	''TO ''+QUOTENAME(DP.name) AS grantee,          
		CASE WHEN P.state_desc = ''GRANT_WITH_GRANT_OPTION'' THEN ''WITH GRANT OPTION'' ELSE '''' END AS grant_option,          
	''AS ''+QUOTENAME(G.name) AS grantor   
FROM 
[' + cast(@dbname as nvarchar(max)) + N'].sys.database_permissions AS P   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.schemas AS S  ON P.major_id = S.schema_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.all_objects AS O  
			 JOIN sys.schemas AS OS  ON O.schema_id = OS.schema_id     
		ON P.major_id = O.object_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.types AS T        
			JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.schemas AS TS  ON T.schema_id = TS.schema_id     
		ON P.major_id = T.user_type_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.xml_schema_collections AS XSC        
			JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.schemas AS XSS          
			ON XSC.schema_id = XSS.schema_id     
		ON P.major_id = XSC.xml_collection_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.columns AS C	ON O.object_id = C.object_id    AND P.minor_id = C.column_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.database_principals AS PR     ON P.major_id = PR.principal_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.assemblies AS A     ON P.major_id = A.assembly_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.service_contracts AS SC     ON P.major_id = SC.service_contract_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.service_message_types AS SMT     ON P.major_id = SMT.message_type_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.remote_service_bindings AS RSB     ON P.major_id = RSB.remote_service_binding_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.services AS SBS     ON P.major_id = SBS.service_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.routes AS R     ON P.major_id = R.route_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.fulltext_catalogs AS FC     ON P.major_id = FC.fulltext_catalog_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.fulltext_stoplists AS FS     ON P.major_id = FS.stoplist_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.asymmetric_keys AS AK     ON P.major_id = AK.asymmetric_key_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.certificates AS CER     ON P.major_id = CER.certificate_id   
	LEFT JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.symmetric_keys AS SK     ON P.major_id = SK.symmetric_key_id   
	JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.database_principals AS DP     ON P.grantee_principal_id = DP.principal_id   
	JOIN [' + cast(@dbname as nvarchar(max)) + N'].sys.database_principals AS G     ON P.grantor_principal_id = G.principal_id  
	left join sys.server_principals sp on DP.sid = sp.sid


WHERE
	DP.name != N''public''' + 
	CASE WHEN @excludeServeConnectPermission = 1 THEN  N' And p.permission_name != ''CONNECT''' ELSE N''  END  + N'
	AND P.grantee_principal_id = ' + CAST(@userid AS NVARCHAR(10)) + N'
ORDER BY
	DP.NAME
	,SECURABLE'

exec (@sql)



	
-- see if a principal has been granted permission on the user object
--REVOKE  VIEW DEFINITION ON USER :: [cfong] TO PUBLIC
Select 'Permissions on user object' as 'Permissions on user object'

SET @sql =N'SELECT 
	CASE WHEN p.state_desc In (''GRANT_WITH_GRANT_OPTION'',''GRANT'' ) Then N''Revoke'' Else p.state_desc End,
	 p.permission_name  + ''ON USER::['' + tor.name COLLATE database_default  + ''] to '' +
	tee.name COLLATE database_default + '';''
 from 
 ' +
	 + cast(@dbname as nvarchar(max)) + N'.sys.database_permissions p
	inner join ' +  cast(@dbname as nvarchar(max))  + N'.sys.database_principals tor on p.grantor_principal_id = tor.principal_id
	inner join '  + cast(@dbname as nvarchar(max)) + N'.sys.database_principals tee on p.grantee_principal_id = tee.principal_id
Where
	p.class_desc = N''DATABASE_PRINCIPAL''
	And p.grantor_principal_id = p.major_id 
	And p.grantor_principal_id = ' + CAST(@userid AS VARCHAR(10)) 

EXEC(@sql)


--database role ownership
If @ShowDefinedDatabaseRoles = 1
BEGIN
	SET @sql= N'SELECT 
		suser_sname(m.sid) as DBRole_OwnerName,
		r.*
	from 
		'  +  cast(@dbname as nvarchar(max))  + N'.sys.database_principals r
		left join '  +  cast(@dbname as nvarchar(max))  + N'.sys.database_principals m on r.owning_principal_id = m.principal_id
	where  
		r.Type_desc = ''DATABASE_ROLE'''
	exec (@sql)
END 
	                

	
/***	DATABASE ROLE MEMEBERSHIP	***/
SET @sql = N'SELECT 
	''DB Role Memebership'' as ''DB Role Memebership''
	,dprole.name
	,sp.name as LoginName
	,dpmem.name as UserName
	,''exec sp_droprolemember  @rolename = N''''''  + dprole.name + '''''', @membername =N'''''' + dpmem.name + '''''''' As DropStatement
	,''exec sp_addrolemember  @rolename = N''''''  + dprole.name + '''''', @membername =N'''''' + dpmem.name + '''''''' As AddStatement
 from 
	'  +  cast(@dbname as nvarchar(max))  + N'.sys.database_role_members drm 
	inner join '  +  cast(@dbname as nvarchar(max))  + N'.sys.database_principals dprole ON drm.role_principal_id = dprole.principal_id 
    inner join '  +  cast(@dbname as nvarchar(max))  + N'.sys.database_principals dpmem ON drm.member_principal_id = dpmem.principal_id 
	left join master.sys.server_principals sp on dpmem.sid = sp.sid
 Where
	dpmem.principal_id IN (' + CAST(@userid AS nvarchar(10)) +N')
order by 
	sp.name
	,dpmem.name;'

exec (@sql)
	

/***	ROLE OWNERSHIP	***/
SET @sql =N'SELECT 
	''Role Ownership'' AS ''Role Ownership''
	,rol.name
	,rol.principal_id
	, rol.type_desc
	,rol.default_schema_name
	,rol.owning_principal_id
	,rol.is_fixed_role
	,''ALTER AUTHORIZATION ON ROLE::['' + rol.name + N''] TO [dbo];'' as RoleAlterAuth
 FROM 
	' 	+  cast(@dbname as nvarchar(max))  + N'.sys.database_principals rol
WHERE
	rol.type = ''R''
	AND rol.owning_principal_id = '  + CAST(@userid AS nvarchar(10))

exec (@sql)


--SCHEMA Ownership
SET @sql=N';With cteSchemas as(
Select 

	o.schema_id, count(*) as ObjectCount
from
	'  +  cast(@dbname as nvarchar(max))  + N'.sys.objects o 
	inner join '  +  cast(@dbname as nvarchar(max))  + N'.sys.schemas s on o.schema_id = s.schema_id
	inner join '  +  cast(@dbname as nvarchar(max))  + N'.sys.database_principals dp ON s.principal_id = dp.principal_id 
 Where
	dp.principal_id = ' + CAST( @userid AS NVARCHAR(MAX)) +N'
Group By
	o.schema_id
)



Select 
	''Schema Ownership'' as ''Schema Ownership''
	,s.name as SchemaName
	,s.schema_id
	,s.principal_id
	,dp.name as SchemaOwner_UserName 
	,ISNULL(cte.ObjectCount,0) as ObjectsOwnedBySchemaCount
	,N''USE ['  +  cast(@dbname as nvarchar(max))  + N'];
	If EXISTS (SELECT 1 FROM sys.schemas WHERE name = N'''' + @username + '''')
	DROP SCHEMA ['' + s.name + N''];'' as SchemaDrop
	,N''USE ['' + DB_NAME() + N''];
If EXISTS (SELECT 1 FROM sys.schemas WHERE name = N'''' + s.name + '''')
	ALTER AUTHORIZATION ON SCHEMA::['' + s.name + N''] TO [dbo];'' as SchemaAlterAuth

from 
	'  +  cast(@dbname as nvarchar(max))  + N'.sys.schemas s	
	left join '  +  cast(@dbname as nvarchar(max))  + N'.sys.database_principals dp ON s.principal_id = dp.principal_id 
	left join cteSchemas cte on s.schema_id = cte.schema_id
 Where
	dp.principal_id =' + CAST( @userid AS NVARCHAR(MAX))

exec(@sql)

--List all the schemas the user has permissions to
SET @sql=N'
Select 
	''Schema Access'' as ''Schema Access''
	,p.grantee_principal_id
	,tee.name as grantee_principal_name
	,p.permission_name
	,s.name as SchemaName
	,s.schema_id
	,s.principal_id
	,dp.name as SchemaOwner_UserName 

from 
	['  +  cast(@dbname as nvarchar(max))  + N'].sys.schemas s	
	inner join ['  +  cast(@dbname as nvarchar(max))  + N'].sys.database_permissions p on s.schema_id  = p.major_id 
	inner join  ['  +  cast(@dbname as nvarchar(max))  + N'].sys.database_principals tee on p.grantee_principal_id = tee.principal_id
	left join['  +  cast(@dbname as nvarchar(max))  + N'].sys.database_principals dp ON s.principal_id = dp.principal_id 
 Where
	tee.principal_id = ' + CAST( @userid AS NVARCHAR(MAX)) +N'
	And s.name = ''' + @username + N'''
	And p.class_desc = N''SCHEMA''
Order by s.name, p.permission_name'


exec(@sql)

Select 'IF  EXISTS (SELECT 1 FROM sys.database_principals WHERE name = N''' + @username + ''')
	DROP USER [' + @username + ']' as DropUser
	
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pGetServiceAccounts]',10,1) WITH NOWAIT;
if object_id('dbo.pGetServiceAccounts') is null exec('create procedure [dbo].[pGetServiceAccounts] as select getdate() DT')
GO
  /******************************************************************************************************************************************
	dbo.pGetServiceAccounts
  Summary:  Attempts to read the registry and return the service accounts. Also returns  Lock Pages In Memory and 
			Perform Volume Maintenance settings.

  Date:  4/23/2019
  Versions: 2008 R2 and greater
  Parameters:	NONE
------------------------------------------------------------------------------
  Written by Keith Buck, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
******************************************************************************************************************************************/
alter procedure dbo.pGetServiceAccounts
WITH ENCRYPTION 
AS
DECLARE @ver	varchar(30)
DECLARE @dot1	int
DECLARE @dot2	int
DECLARE @verdec	decimal(18,2)

SET @ver = cast(SERVERPROPERTY('productversion') AS varchar(30))
SET @dot1 = CHARINDEX('.',@ver)
SET @dot2 = CHARINDEX('.',@ver,@dot1+1)
SET @verdec = cast(SUBSTRING(@ver,1,@dot2-1) AS decimal(18,2))




DECLARE @agtsvc			nvarchar(128)
DECLARE @sqlsvc			nvarchar(128)
DECLARE @lockedPages	varchar(20)
DECLARE @volMaint		varchar(20)


If @verdec < 10.5
BEGIN
	exec xp_instance_regread  N'HKEY_LOCAL_MACHINE', N'SYSTEM\CurrentControlSet\Services\MSSQLServer', N'ObjectName', @sqlsvc output
END
ELSE
BEGIN --if you have 2008 R2 you can use this dmv
	SELECT 
		@sqlsvc = service_account
	FROM 
		sys.dm_server_services WITH (NOLOCK) 
	WHERE 
		servicename like 'sql server (%' OPTION (RECOMPILE);
END



If Exists(select value_in_use  FROM sys.configurations where name = 'xp_cmdshell' and value_in_use =1)
BEGIN
	IF OBJECT_ID('tempdb..#xp_cmdshell_output') IS NOT NULL
		DROP TABLE #xp_cmdshell_output
	CREATE TABLE #xp_cmdshell_output (Output VARCHAR (8000)); 
	-- run whoami command via xp_cmdshell and writing into temp table
	INSERT INTO #xp_cmdshell_output EXEC ('xp_cmdshell ''whoami /priv'''); 
	--Looking at the output that we are interested
	IF EXISTS (SELECT 1 FROM #xp_cmdshell_output WHERE Output LIKE '%Lock pages in memory %') 
		SET @lockedPages = 'Yes'
	ELSE
		SET @lockedPages = 'No'
	
	IF EXISTS (SELECT 1 FROM #xp_cmdshell_output WHERE Output LIKE '%Perform volume maintenance tasks%') 
		SET @volMaint = 'Yes'
	ELSE 
		SET @volMaint = 'No'

	--drop temptable
	DROP TABLE #xp_cmdshell_output;
END
ELSE
	SELECT @lockedPages = 'Unknown', @volMaint = 'Unknown'


exec xp_instance_regread  N'HKEY_LOCAL_MACHINE', N'SYSTEM\CurrentControlSet\Services\SQLServerAgent', N'ObjectName', @agtsvc output
select @sqlsvc as 'SQL Server service account', @agtsvc as 'SQL Agent service account', 
		@lockedPages AS 'Lock Pages In Memory', @volMaint AS 'Perform Volume Maintenance'


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pLoad_Current_Activity_Adhoc]',10,1) WITH NOWAIT;
if object_id('dbo.pLoad_Current_Activity_Adhoc') is null exec('create procedure [dbo].[pLoad_Current_Activity_Adhoc] as select getdate() DT')
GO
  
/*============================================================================
  Summary:  Provides real time results for the current processes and stores
			in a table.

  Date:  3/22/2019
  exec usp_Load_Current_Activity_Adhoc 1, 0, 0
  Versions: 2005+
------------------------------------------------------------------------------
  Written by Ben DeBow, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
============================================================================*/

alter procedure  dbo.pLoad_Current_Activity_Adhoc(
	 @SaveCurrentActivityFlag BIT = 0
	 , @SaveOrphanedSessionsFlag BIT = 0
	 , @SaveProcessSchedulersFlag BIT = 0
)

 WITH ENCRYPTION
AS
-- CAPTURE CURRENT ACTIVTY AND ADHOC PROCECESS
IF @SaveCurrentActivityFlag = 1
BEGIN
	EXEC FDDBA..usp_Load_Process_Monitor_Adhoc 1
END

IF @SaveOrphanedSessionsFlag = 1
BEGIN
--//TODO:--
	--NEED TO ADD THIS PROC
	EXEC FDDBA..usp_Load_Orphaned_Transactions_Adhoc

END

IF @SaveProcessSchedulersFlag = 1
BEGIN

	EXEC FDDBA..usp_Process_Schedulers_Adhoc

END

-- DISPLAY ORPHANED SESSIONS
SELECT GETDATE() RecordDate
	, dt.database_transaction_begin_time
	, DB_NAME(dt.database_id) DBName
	, st.session_id,
    CASE WHEN EXISTS (SELECT *
                FROM sys.dm_exec_requests er
                WHERE er.session_id = st.session_id) THEN 0 ELSE 1 END IsOrphan,
    es.[Host_Name] Host
	, es.Login_Name [Login]
	, es.[Program_Name] Program
	, es.last_request_END_time
	, BlockedSessionsCOUNT
	, lh.LocksHeld
FROM sys.dm_tran_session_transactions st
    JOIN sys.dm_tran_database_transactions dt on st.transaction_id = dt.transaction_id
    left JOIN sys.dm_exec_sessions es on es.session_id = st.session_id
    OUTER APPLY (SELECT COUNT(*) BlockedSessionsCOUNT
                    FROM sys.dm_exec_requests erb
                    WHERE erb.blocking_session_id = st.session_id) erb
    OUTER APPLY (SELECT STUFF((SELECT ', ' + resource_type +  ':' + RTRIM(LTRIM(resource_description)) + ':' + CAST(resource_associated_entity_id as VARCHAR(100))
                    FROM sys.dm_tran_locks tl
                    WHERE request_session_id = st.session_id
                        AND resource_type <> 'DATABASE'
                    FOR XML PATH('')
                    ), 1, 2, '') LocksHeld) lh
WHERE dt.database_id <> 32767 
	AND database_transaction_begin_time IS NOT NULL

-- DISPLAY CURRENT ACTIVITY
SELECT
    x.session_id,
    CAST(DATEDIFF(mi, x.start_time, GETDATE()) AS BIGINT) 'run_time',
	status,
    x.host_name,
    x.login_name,
	x.wait_type,
	x.wait_resource,
	x.wait_time,
    x.start_time,
    x.totallogical_reads ,
    x.totalWrites,
    x.totalCPU,
	x.CPUSession,
	x.ScheduleTimeSession,
	x.TotalElapsedTimeSession,
	x.granted_query_memory,
    x.writes_in_tempdb,
	parallelquery,
	[DBName]
	, COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
    (
        SELECT          
			substring(text, (statement_start_offset/2)+1
                , ((case statement_END_offset
                      when -1 THEN datalength(text)
                      ELSE statement_END_offset
                   END - statement_start_offset)/2) + 1)
        FROM sys.dm_exec_sql_text(x.sql_hANDle)
    ) AS [stmt_text],
    (
        SELECT
            p.text
        FROM
        (
            SELECT
                MIN(sql_hANDle) AS sql_hANDle
            FROM sys.dm_exec_requests r2
            WHERE
                r2.session_id = x.blocking_session_id
        ) AS r_blocking
        CROSS APPLY
        (
            SELECT
                text AS [text()]
            FROM sys.dm_exec_sql_text(r_blocking.sql_hANDle)
        ) p (text)
    ) AS [blocking_text],
    x.program_name,
	transaction_id,
	percent_complete,
	estimated_completion_time,
	scheduler_id,
	x.transaction_isolation_level,
	x.open_transaction_COUNT,
	open_resultset_COUNT, 
    plan_hANDle
	, (SELECT query_plan 
	FROM sys.dm_exec_query_plan (plan_hANDle)) execution_plan
	
FROM
(
    SELECT
        r.session_id,
		r.status,
        s.host_name,
        s.login_name,
        r.start_time,
        r.sql_hANDle,
		wait_type,
		wait_resource,
		CAST(wait_time AS BIGINT) AS wait_time,
		statement_start_offset,
		statement_END_offset,
        r.blocking_session_id,
		transaction_id,
		percent_complete,
		estimated_completion_time,
		scheduler_id,
		r.transaction_isolation_level,
		db_name(r.database_id) [DBName],
		last_request_start_time,
		open_resultset_COUNT, 
		COUNT(*) AS parallelquery,
        SUM(CAST(r.logical_reads AS BIGINT)) AS totallogical_reads ,
        SUM(CAST(r.writes AS BIGINT)) AS totalWrites,
        SUM(CAST(r.cpu_time AS BIGINT)) AS totalCPU,
		SUM(CAST(s.cpu_time AS BIGINT)) AS CPUSession,
		SUM(CAST(s.total_scheduled_time AS BIGINT)) AS ScheduleTimeSession,
		SUM(CAST(s.total_elapsed_time AS BIGINT)) AS TotalElapsedTimeSession,
        SUM(CAST(tsu.user_objects_alloc_page_COUNT + tsu.internal_objects_alloc_page_COUNT AS BIGINT)) AS writes_in_tempdb,
        plan_hANDle,
        CAST(granted_query_memory AS BIGINT) AS granted_query_memory,
        program_name,
		r.open_transaction_COUNT,
		text AS [SQL_Text],
		OBJECT_NAME(objectid, dbid) AS [ObjectName]
    FROM sys.dm_exec_sessions s
    JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
    JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id AND r.request_id = tsu.request_id
	CROSS APPLY sys.dm_exec_sql_text (r.sql_hANDle)
    WHERE r.session_id != @@SPID

    GROUP BY
        r.session_id,
		r.status,
        s.host_name,
        s.login_name,
        r.start_time,
        r.sql_hANDle,
		wait_type,
		wait_resource,
		wait_time,
		statement_start_offset,
		statement_END_offset,
        r.blocking_session_id,
		transaction_id,
		percent_complete,
		estimated_completion_time,
		scheduler_id,
		r.transaction_isolation_level,
		r.open_transaction_COUNT,
		r.database_id,
		last_request_start_time,
		open_resultset_COUNT, 
        plan_hANDle,
        granted_query_memory,
        program_name,
		text,
		OBJECT_NAME(objectid, dbid)
) x
ORDER BY 21



--	PENDING PROCESSES ON THE SCHEDULERS WAITING TO BE EXECUTED
SELECT scheduler_id
	, current_tasks_COUNT
	, runnable_tasks_COUNT
	, work_queue_COUNT
	, pENDing_disk_io_COUNT
	, current_workers_COUNT
	, active_workers_COUNT
	, pENDing_disk_io_COUNT
	, context_switches_COUNT
	, preemptive_switches_COUNT
	, status
	, load_factor
	, GETDATE() AS 'RunTime'
FROM sys.dm_os_schedulers
WHERE scheduler_id < 255
AND runnable_tasks_COUNT > 0
ORDER BY 3 DESC

-- DISPLAY TOP 5 WAITS IN PROGRESS GROUPED BY
SELECT TOP 5 wait_type,
      COUNT (*) as 'total #'
	, GETDATE() AS 'RunTime'
FROM sys.dm_os_waiting_tasks
WHERE [wait_type] NOT IN
('clr_semaphore','lazywriter_sleep','resource_queue','sleep_task','sleep_systemtask',
'sqltrace_buffer_flush','waitfor', 'broker_task_stop', 'DISPATCHER_QUEUE_SEMAPHORE',
'broker_receive_waitfor', 'oledb','clr_manual_event', 'clr_auto_event','DBMIRROR_SEND'
, 'DBMIRROR_DBM_MUTEX', 'DBMIRROR_EVENTS_QUEUE', 'BROKER_TRANSMITTER', 'DBMIRRORING_CMD'
,'FT_IFTS_SCHEDULER_IDLE_WAIT','WAIT_XTP_HOST_WAIT','SP_SERVER_DIAGNOSTICS_SLEEP',
'CHECKPOINT_QUEUE','BROKER_TO_FLUSH','LOGMGR_QUEUE','XE_TIMER_EVENT','XE_DISPATCHER_WAIT') 
group by wait_type
HAVING COUNT(*) > 1
ORDER BY COUNT (*) DESC


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pLogShipping_Monitor]',10,1) WITH NOWAIT;
if object_id('dbo.pLogShipping_Monitor') is null exec('create procedure [dbo].[pLogShipping_Monitor] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Monitor performance of log shipping copy and restore jobs on secondary to look into why LsAlert job was fired.
*
*	Inputs:	None
*
*	Notes:	
*	1. Currently all jobs with name pattern of LsCopy% or LsRestore% are parsed for data
*	2. This stored procedure is optimized to only scan msdb.dbo.sysjobhistory from where it left of the prior run
*	3. It is suggested that this procedure be run every 15 minutes or so to make sure that history is not lost before this is executed.
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2017-11-29			Mike Zawadzki			Created
*	
*********************************************************************************************************************/

alter procedure [dbo].[pLogShipping_Monitor]
WITH ENCRYPTION 
AS
BEGIN
	SET NOCOUNT ON
	DECLARE @max_id int
	DECLARE @max_restore_end_instance_id int
	DECLARE @instance_id int
	DECLARE @run_status int
	DECLARE @run_date int
	DECLARE @run_time int
	DECLARE @run_duration int
	DECLARE @message nvarchar(4000)
	DECLARE @msgcount int = 0
	DECLARE @p0 int
	DECLARE @p1 int
	DECLARE @p2 int
	DECLARE @p3 int
	DECLARE @p4 int
	DECLARE @p5 int
	DECLARE @p6 int
	DECLARE @p7 int
	DECLARE @p8 int
	DECLARE @len int
	DECLARE @opend int
	DECLARE @msgdt datetime
	DECLARE @file sysname
	DECLARE @source sysname
	DECLARE @is_copy tinyint
	DECLARE @is_restore int
	DECLARE @is_copyorrename tinyint
	DECLARE @temp nvarchar(4000)
	DECLARE @temp2 nvarchar(4000)
	DECLARE @CR CHAR(1) = CHAR(13)
	DECLARE @LF CHAR(1) = CHAR(10)
	DECLARE @CRLF CHAR(2)
	DECLARE @CRLFlen int
	DECLARE @strlen int
	DECLARE @strcnt int
	DECLARE @icount int = 0
	DECLARE @ucount int = 0
	DECLARE @copydelay int
	DECLARE @filedt datetime
	DECLARE @offset_hours int
	DECLARE @chardate varchar(23)
	DECLARE @dbname sysname
	DECLARE @x datetime
	DECLARE @ms bigint 
	DECLARE @last_backup_set_id_insert int

	SET @offset_hours = DATEDIFF(HOUR, GETDATE(), GETUTCDATE())

	--find where last scan ended to prevent full history scan
	SELECT @max_id = max(logshipping_performance_id) FROM dbo.logshipping_performance WHERE copy_start_instance_id IS NOT NULL
	IF @max_id IS NOT NULL
	BEGIN
		SELECT @max_id = coalesce(copy_end_instance_id, copy_start_instance_id, 1) FROM dbo.logshipping_performance WHERE logshipping_performance_id = @max_id
	END
	ELSE
	BEGIN
		SET @max_id = 1	
	END

	INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
		VALUES (@max_id, 'C', 'JobHistory cursor start', NULL, NULL, GETDATE())

	SET @x = GETDATE()
	DECLARE copy_job_hist_cur CURSOR FOR 
		SELECT h.instance_id, h.run_status, h.run_date, h.run_time, h.run_duration, h.[message] 
			FROM msdb.dbo.sysjobhistory h
				INNER JOIN msdb.dbo.sysjobs j
				ON h.job_id = j.job_id
			WHERE j.[name] LIKE 'LsCopy%'
				AND j.[enabled] = 1
				AND h.step_id = 1
				AND h.[message] like '% temporary work file.%'
				AND h.instance_id > @max_id
			ORDER BY h.instance_id

	OPEN copy_job_hist_cur

	FETCH NEXT FROM copy_job_hist_cur INTO @instance_id, @run_status, @run_date, @run_time, @run_duration, @message

--sample messages to shred from history 
--Copy start
--2017-08-15 03:00:10.21	Copying log backup file to temporary work file. Source: '\\dkp\core\DBTLFILES\PRDDBDK01\DK_DB_APPS\DK_DB_APPS_20170815065000.trn', Destination: 'D:\SQLBackups\DK_DB_APPS\DK_DB_APPS_20170815065000.wrk'
--Copy end
--2017-08-15 02:57:01.09	Renamed temporary work file. Source: 'D:\SQLBackups\DK_DB_APPS\DK_DB_APPS_20170815064502.wrk', Destination: 'D:\SQLBackups\DK_DB_APPS\DK_DB_APPS_20170815064502.trn'

	WHILE @@FETCH_STATUS != -1 AND @msgcount < 10000
	BEGIN
		SET @len = LEN(@message)
		SET @p0 = 1
		SET @p2 = 1

		WHILE @p0 < @len AND @p2 > 0 AND @msgcount < 10000
		BEGIN
			SET @p1 = CHARINDEX(char(9), @message, @p0) --tab

			IF @p1 > 0
			BEGIN
				IF @CRLF IS NULL
				BEGIN
					SET @p2 = CHARINDEX(@CR, @message, @p1 + 1)
					SET @p3 = CHARINDEX(@LF, @message, @p1 + 1)

					INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
						VALUES (@instance_id, 'C', 'CR', LTRIM(STR(@p2)), LTRIM(STR(@p3)), GETDATE())

					IF @p2 > 0 AND @p3 > 0 AND @p3 = @p2 + 1
					BEGIN
						SET @CRLF = @CR + @LF
						SET @CRLFlen = 2
					END
					ELSE
					BEGIN
						IF @p2 > 0 AND @p3 > 0 AND @p3 != @p2 + 1
						BEGIN
							INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
								VALUES (@instance_id, 'C', 'CRError1', LTRIM(STR(@p2)), LTRIM(STR(@p3)), GETDATE())
							SET @CRLFlen = 1000
						END
						ELSE
						BEGIN
							IF @p2 > 0 AND @p3 = 0
							BEGIN
								SET @CRLF = @CR
								SET @CRLFlen = 1
							END
							ELSE
							BEGIN
								IF @p2 = 0 AND @p3 > 0
								BEGIN
									SET @CRLF = @LF
									SET @CRLFlen = 1
								END
								ELSE
								BEGIN
									INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
										VALUES (@instance_id, 'C', 'CRError2', LTRIM(STR(@p2)), LTRIM(STR(@p3)), GETDATE())
									SET @CRLFlen = 2000
								END
							END
						END
					END
				END

				SET @p2 = CHARINDEX(@CRLF, @message, @p1 + 1) --line wrap

				IF @p2 > 0
				BEGIN
					SET @opend = @p2
				END
				ELSE
				BEGIN
					SET @opend = @len
				END

				SET @temp = substring(@message, @p0, @p1 - @p0)
				IF ISDATE(@temp) = 1
				BEGIN
					SET @msgdt = @temp

					SET @temp = substring(@message, @p1 + 1, @opend - @p1)

					SET @is_copyorrename = CHARINDEX(N'Copying', SUBSTRING(@temp, 1, 7)) + CHARINDEX(N'Renamed', SUBSTRING(@temp, 1, 7))

					IF @is_copyorrename = 1
					BEGIN

						SET @is_copy = CHARINDEX(N'Copying', SUBSTRING(@temp, 1, 7))

						SET @p3 = CHARINDEX(N'''', @temp)
						IF @p3 > 0
						BEGIN
							SET @p4 = CHARINDEX(N'.', @temp, @p3)

							IF @p4 > 0
							BEGIN
								SET @source = SUBSTRING(@temp, @p3 + 1, @p4 - @p3 - 1)

								--strip down to file name
								SET @p5 = 1
								SET @p6 = 1
								SET @strcnt = 1
								SET @strlen = LEN(@source)
								WHILE @p6 > 0 and @strcnt < @strlen
								BEGIN
									SET @p6 = CHARINDEX(N'\', @source, @p5)
									IF @p6 > 0
										SET @p5 = @p6 + 1
									SET @strcnt = @strcnt + 1
								END

								SET @file = SUBSTRING(@source, @p5, @strlen)
							
								--change to UTC time
								SET @msgdt = DATEADD(HOUR, @offset_hours, @msgdt)

								IF @is_copy = 1
								BEGIN
									SET @source = SUBSTRING(@source, 1, @p5 - 1)
									SET @dbname = SUBSTRING(@file, 1, LEN(@file) - 15) --15 bytes for '_' + datetime (i.e. _20171110215000)
									SET @chardate = SUBSTRING(@file, LEN(@file) - 13, LEN(@file))
									SET @chardate = SUBSTRING(@chardate, 1, 4) + '-' + SUBSTRING(@chardate, 5, 2)+ '-' + SUBSTRING(@chardate, 7, 2) + ' ' + SUBSTRING(@chardate, 9, 2) + ':' + SUBSTRING(@chardate, 11, 2)+ ':' + SUBSTRING(@chardate, 13, 2)

									IF ISDATE(@chardate) = 1
									BEGIN
										SET @filedt = @chardate
									END

									SET @copydelay = DATEDIFF(SECOND, @filedt, @msgdt)

									IF NOT EXISTS(SELECT 1 FROM dbo.logshipping_performance WHERE [filename] = @file)
									BEGIN
										INSERT dbo.logshipping_performance (copy_start_instance_id, copy_start_dt_UTC, copy_delay_seconds, [database_name], [filename], source_name, lineage)
											VALUES (@instance_id, @msgdt, @copydelay, @dbname, @file, @source, 1)
										SET @icount = @icount + 1
									END
								END

								IF @is_copy = 0
								BEGIN
									UPDATE dbo.logshipping_performance
										SET copy_end_instance_id = @instance_id,
											copy_end_dt_UTC = @msgdt,
											copy_duration_msec = case when DATEDIFF(MILLISECOND, copy_start_dt_UTC, @msgdt) = 0 then 1 else DATEDIFF(MILLISECOND, copy_start_dt_UTC, @msgdt) end,
											[filename] = @source + '.trn',
											lineage = lineage + 2
										WHERE [filename] = @file
									IF @@ROWCOUNT = 1
									BEGIN
										SET @ucount = @ucount + 1
									END
								END
							END
							ELSE
							BEGIN
								INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
									VALUES (@instance_id, 'C', 'Invalid FileEnd', LTRIM(STR(@is_copy)), @temp, GETDATE())
							END
						END
						ELSE
						BEGIN
							INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
								VALUES (@instance_id, 'C', 'Invalid FileStart', LTRIM(STR(@is_copy)), @temp, GETDATE())
						END
					END
					ELSE
					BEGIN
						/*
						--expected messages to suppress reporting
						Checking to see if any previously copied log backup files that are required by the restore operation are missing. Secondary ID: 'e29dd0ef-a9c2-4470-a14f-811c886fb742'
						The copy operation was successful. Secondary ID: 'e29dd0ef-a9c2-4470-a14f-811c886fb742', Number of log backup files copied: 3
						The backup file 'D:\SQLBackups\DK_DB_POSITION\DK_DB_POSITION_20171110170500.trn' already exists in the destination directory. Secondary ID: 'c3cd4956-2faa-45cc-aec7-256ff8baf27e'

						----- END OF TRANSACTION LOG COPY     -----
						*/

						IF CHARINDEX('Checking to see if any previously copied log backup files', @temp) + 
							CHARINDEX('The copy operation was successful. Secondary ID', @temp) + 
							CHARINDEX('Talready exists in the destination directory. Secondary ID', @temp) + 
							CHARINDEX('END OF TRANSACTION LOG COPY', @temp) = 0
						BEGIN
							INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
								VALUES (@instance_id, 'C', 'Invalid Command', @temp, NULL, GETDATE())
						END
					END
				END
				ELSE
				BEGIN
					SET @temp2 = REPLACE(REPLACE(SUBSTRING(@message, @p0, 200),CHAR(13),''), CHAR(10), '')
					INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
						VALUES (@instance_id, 'C', 'Invalid Date', '@p0='+LTRIM(STR(@p0)), @temp2, GETDATE())
				END
			END
			ELSE
			BEGIN
				SET @temp2 = REPLACE(REPLACE(SUBSTRING(@message, @p0, 200),CHAR(13),''), CHAR(10), '')
				/*
				--expected messages to suppress reporting
				Exit Status: 0 (Success)
				*/
				IF CHARINDEX('Exit Status: 0 (Success)', @temp2) = 0
				BEGIN
					INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
						VALUES (@instance_id, 'C', 'Missing tab', '@p0='+LTRIM(STR(@p0)) + ', @tlen =' + LTRIM(STR(LEN(@temp2))), @temp2, GETDATE())
				END

				IF @len <= @p0 + LEN(@temp2) + @CRLFlen + 1
				BEGIN
					SET @p2 = @p0 + LEN(@temp2) + 1
				END
			END
			

			SET @p0 = @p2 + @CRLFlen
			SET @msgcount = @msgcount + 1
		END

		SET @msgcount = @msgcount + 1
		FETCH NEXT FROM copy_job_hist_cur INTO @instance_id, @run_status, @run_date, @run_time, @run_duration, @message
	END
	
	DEALLOCATE copy_job_hist_cur
	SET @ms = DATEDIFF(MILLISECOND, @x, GETDATE())

	INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
		VALUES (@instance_id, 'C', 'JobHistory Summary','Ins='+LTRIM(STR(@icount)) + ', Upds='+LTRIM(STR(@ucount)), 'DURms=' + LTRIM(STR(@ms)), GETDATE())


	--set copy perf
	SET @x = GETDATE()
	UPDATE l
		SET backup_set_id = b.backup_set_id,
			backup_size = b.backup_size,
			compressed_backup_size = b.compressed_backup_size,
			copy_KB_per_sec = b.compressed_backup_size/1024./l.copy_duration_msec*1000.,
			restore_start_dt_UTC = DATEADD(HOUR, @offset_hours, restore_date),
			restore_history_id = r.restore_history_id,
			restore_delay_seconds = DATEDIFF(SECOND, copy_end_dt_UTC, restore_start_dt_UTC),
			lineage = lineage + 4
		FROM msdb.dbo.restorehistory r 
			INNER JOIN msdb.dbo.backupset b
				ON b.backup_set_id = r.backup_set_id
			INNER JOIN msdb.dbo.backupmediafamily f
				ON b.media_set_id = f.media_set_id
			INNER JOIN dbo.logshipping_performance l
				ON l.filename = f.physical_device_name
				AND r.destination_database_name = l.[database_name]
		WHERE restore_type = 'L' and l.backup_set_id IS NULL and l.copy_end_instance_id IS NOT NULL
	SET @ucount = @@ROWCOUNT
	SET @ms = DATEDIFF(MILLISECOND, @x, GETDATE())
	
	INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
		VALUES (NULL, 'U', 'RestoreHistory Summary','Upds='+LTRIM(STR(@ucount)), 'DURms=' + LTRIM(STR(@ms)), GETDATE())

	--insert restore only files
	SELECT TOP 1 @last_backup_set_id_insert = MAX(backup_set_id) FROM dbo.logshipping_performance WHERE copy_start_instance_id IS NULL
	IF @last_backup_set_id_insert IS NULL
	BEGIN
		SELECT TOP 1 @last_backup_set_id_insert = MAX(backup_set_id) FROM dbo.logshipping_performance WHERE copy_start_instance_id IS NOT NULL
		IF @last_backup_set_id_insert IS NULL
		BEGIN
			--this should only be done on initial start
			SET @last_backup_set_id_insert = 1
		END
	END

	INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
		VALUES (NULL, 'I', 'RestoreHistory Start',LTRIM(STR(@last_backup_set_id_insert)), NULL, GETDATE())

	SET @x = GETDATE()
	INSERT dbo.logshipping_performance (restore_history_id, restore_start_dt_UTC, backup_set_id, backup_size, compressed_backup_size, [database_name], [filename],source_name, lineage)
		SELECT 
			r.restore_history_id, 
			DATEADD(HOUR, @offset_hours, r.restore_date), 
			b.backup_set_id, b.backup_size, b.compressed_backup_size, r.destination_database_name, --f.physical_device_name,''
			SUBSTRING(f.physical_device_name, CHARINDEX('\'+ r.destination_database_name + '_', f.physical_device_name) + 1, LEN(f.physical_device_name)), --filename
			SUBSTRING(f.physical_device_name,1, CHARINDEX('\'+ r.destination_database_name + '_', f.physical_device_name)), --source_name
			16
		FROM msdb.dbo.restorehistory r 
			INNER JOIN msdb.dbo.backupset b
				ON b.backup_set_id = r.backup_set_id
				AND r.restore_type = 'L'
				AND b.backup_set_id > @last_backup_set_id_insert
			INNER JOIN msdb.dbo.backupmediafamily f
				ON b.media_set_id = f.media_set_id
		WHERE b.backup_set_id > @last_backup_set_id_insert
			AND b.backup_set_id NOT IN 
			(
				SELECT backup_set_id FROM dbo.logshipping_performance WHERE backup_set_id > @last_backup_set_id_insert
			)
		ORDER BY restore_history_id

	SET @icount = @@ROWCOUNT
	SET @ms = DATEDIFF(MILLISECOND, @x, GETDATE())

	INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
		VALUES (NULL, 'I', 'RestoreHistory Summary','Ins='+LTRIM(STR(@icount)), 'DURms=' + LTRIM(STR(@ms)), GETDATE())

	--find where last scan ended to prevent full history scan
	SET @x = GETDATE()
	SELECT @max_restore_end_instance_id = MAX(restore_end_instance_id) FROM dbo.logshipping_performance

	SET @ms = DATEDIFF(MILLISECOND, @x, GETDATE())

	IF @max_restore_end_instance_id IS NULL
	BEGIN
		SET @max_restore_end_instance_id = @max_id
	END

	INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
		VALUES (@max_restore_end_instance_id, 'R', 'Restore cursor start', NULL, 'DURms=' + LTRIM(STR(@ms)), GETDATE())

	--update restore performance
	SET @x = GETDATE()
	SET @ucount = 0

	DECLARE restore_job_hist_cur CURSOR FOR
		SELECT h.instance_id, h.run_status, h.run_date, h.run_time, h.run_duration, h.[message] 
			FROM msdb.dbo.sysjobhistory h
				INNER JOIN msdb.dbo.sysjobs j
				ON h.job_id = j.job_id
			WHERE j.[name] like 'LsRestore%'
				AND j.[enabled] = 1
				AND h.step_id = 1
				AND h.[message] like '%Restored log backup file.%'
				AND h.instance_id > @max_restore_end_instance_id
			ORDER BY h.instance_id

	OPEN restore_job_hist_cur

	FETCH NEXT FROM restore_job_hist_cur INTO @instance_id, @run_status, @run_date, @run_time, @run_duration, @message

--sample messages to shred from history 
--Restore end
--2017-11-09 09:01:20.47	Restored log backup file. Secondary DB: 'DK_DB_APPS', File: 'D:\SQLBackups\DK_DB_APPS\DK_DB_APPS_20171109134502.trn'

	WHILE @@FETCH_STATUS != -1 AND @msgcount < 10000
	BEGIN
		--print str(@instance_id)
		SET @len = LEN(@message)
		SET @p0 = 1
		SET @p2 = 1

		WHILE @p0 < @len AND @p2 > 0 AND @msgcount < 10000
		BEGIN
			SET @p1 = CHARINDEX(char(9), @message, @p0) --tab

			IF @p1 > 0
			BEGIN
				IF @CRLF IS NULL
				BEGIN
					SET @p2 = CHARINDEX(@CR, @message, @p1 + 1)
					SET @p3 = CHARINDEX(@LF, @message, @p1 + 1)

					INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
						VALUES (@instance_id, 'R', 'CR', LTRIM(STR(@p2)), LTRIM(STR(@p3)), GETDATE())

					IF @p2 > 0 AND @p3 > 0 AND @p3 = @p2 + 1
					BEGIN
						SET @CRLF = @CR + @LF
						SET @CRLFlen = 2
					END
					ELSE
					BEGIN
						IF @p2 > 0 AND @p3 > 0 AND @p3 != @p2 + 1
						BEGIN
							INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
								VALUES (@instance_id, 'R', 'CRError1', LTRIM(STR(@p2)), LTRIM(STR(@p3)), GETDATE())
							SET @CRLFlen = 1000
						END
						ELSE
						BEGIN
							IF @p2 > 0 AND @p3 = 0
							BEGIN
								SET @CRLF = @CR
								SET @CRLFlen = 1
							END
							ELSE
							BEGIN
								IF @p2 = 0 AND @p3 > 0
								BEGIN
									SET @CRLF = @LF
									SET @CRLFlen = 1
								END
								ELSE
								BEGIN
									INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
										VALUES (@instance_id, 'R', 'CRError2', LTRIM(STR(@p2)), LTRIM(STR(@p3)), GETDATE())

									SET @CRLFlen = 2000
								END
							END
						END
					END
				END

				SET @p2 = CHARINDEX(@CRLF, @message, @p1 + 1) --line wrap

				IF @p2 > 0
				BEGIN
					SET @opend = @p2
				END
				ELSE
				BEGIN
					SET @opend = @len
				END

				SET @temp = SUBSTRING(@message, @p0, @p1 - @p0)
				IF ISDATE(@temp) = 1
				BEGIN
					SET @msgdt = @temp

					SET @temp = SUBSTRING(@message, @p1 + 1, @opend - @p1)

					SET @is_restore = CHARINDEX(N'Restored log backup file.', @temp)

					IF @is_restore = 1
					BEGIN
						--print 'X'+@temp

						SET @p3 = CHARINDEX(N'''', @temp)
						IF @p3 > 0
						BEGIN
							SET @p4 = CHARINDEX(N'''', @temp, @p3 + 1)

							IF @p4 > 0
							BEGIN
								SET @p5 = CHARINDEX(N'''', @temp, @p4 + 1)

								IF @p5 > 0
								BEGIN
									SET @p6 = CHARINDEX(N'''', @temp, @p5 + 1)

									IF @p6 > 0
									BEGIN
										SET @source = SUBSTRING(@temp, @p5 + 1, @p6 - @p5 - 1)

										--strip down to file name
										SET @p7 = 1
										SET @p8 = 1
										SET @strcnt = 1
										SET @strlen = LEN(@source)
										WHILE @p8 > 0 and @strcnt < @strlen
										BEGIN
											SET @p8 = CHARINDEX(N'\', @source, @p7)
											IF @p8 > 0
												SET @p7 = @p8 + 1
											SET @strcnt = @strcnt + 1
										END

										SET @file = SUBSTRING(@source, @p7, @strlen)
										--print @file + str(@instance_id)
										SET @dbname = SUBSTRING(@temp, @p3 + 1, @p4 - @p3 - 1)
										--print @dbname + str(@instance_id)

										SET @chardate = SUBSTRING(@file, LEN(@file) - 13, LEN(@file))
										SET @chardate = SUBSTRING(@chardate, 1, 4) + '-' + SUBSTRING(@chardate, 5, 2)+ '-' + SUBSTRING(@chardate, 7, 2) + ' ' + SUBSTRING(@chardate, 9, 2) + ':' + SUBSTRING(@chardate, 11, 2)+ ':' + SUBSTRING(@chardate, 13, 2)

										IF ISDATE(@chardate) = 1
										BEGIN
											SET @filedt = @chardate
										END

										--convert to UTC
										SET @msgdt = DATEADD(HOUR, @offset_hours, @msgdt)

										--update non copy files
										IF EXISTS(SELECT 1 FROM dbo.logshipping_performance WHERE [filename] = @file and [database_name] = @dbname)
										BEGIN
											UPDATE dbo.logshipping_performance 
												SET 
													restore_end_instance_id = @instance_id,
													restore_end_dt_UTC = @msgdt,
													restore_duration_msec = DATEDIFF(MILLISECOND, restore_start_dt_UTC, @msgdt),
													restore_delay_seconds = DATEDIFF(SECOND, copy_end_dt_UTC, restore_start_dt_UTC),
													lineage = lineage + 32
												WHERE [filename] = @file and [database_name] = @dbname
											IF @@ROWCOUNT = 1
											BEGIN
												SET @ucount = @ucount + 1
											END
										END
										ELSE
										BEGIN
											--update copy files
											IF EXISTS(SELECT 1 FROM dbo.logshipping_performance WHERE [filename] = @source and [database_name] = @dbname)
											BEGIN
												UPDATE dbo.logshipping_performance 
													SET 
														restore_end_instance_id = @instance_id,
														restore_end_dt_UTC = @msgdt,
														restore_duration_msec = DATEDIFF(MILLISECOND, restore_start_dt_UTC, @msgdt),
														restore_delay_seconds = DATEDIFF(SECOND, copy_end_dt_UTC, restore_start_dt_UTC),
														lineage = lineage + 8
													WHERE [filename] = @source and [database_name] = @dbname
												IF @@ROWCOUNT = 1
												BEGIN
													SET @ucount = @ucount + 1
												END
											END
											ELSE
											BEGIN
												INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
													VALUES (@instance_id, 'R', 'File not found', @file, @source, GETDATE())
											END
										END
									END
									ELSE
									BEGIN
										INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
											VALUES (@instance_id, 'R', 'Invalid FileEnd', @temp, NULL, GETDATE())
									END
								END
								ELSE
								BEGIN
									INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
										VALUES (@instance_id, 'R', 'Invalid FileStart', @temp, NULL, GETDATE())
								END
							END
							ELSE
							BEGIN
								INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
									VALUES (@instance_id, 'R', 'Invalid DBEnd', @temp, NULL, GETDATE())
							END
						END
						ELSE
						BEGIN
							INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
								VALUES (@instance_id, 'R', 'Invalid DBStart', @temp, NULL, GETDATE())
						END

					END
					ELSE
					BEGIN


						/*
						--expected messages to suppress reporting
						The restore operation was successful. Secondary Database: 'ODS', Number of log backup files restored: 1
						The restore operation was successful. Secondary ID: 'e29dd0ef-a9c2-4470-a14f-811c886fb742'
						Deleting old log backup files. Primary Database: 'ODS'
						Deleting log backup file. File: 'D:\SQLBackups\DK_DB_APPS\DK_DB_APPS_20171108131502.trn', Last Write Time (UTC): '11/8/2017 1:15:13 PM'
						----- END OF TRANSACTION LOG RESTORE     -----
						*/
						IF CHARINDEX('The restore operation was successful. Secondary', @temp) + 
							CHARINDEX('Deleting old log backup files. Primary Database:', @temp) + 
							CHARINDEX('Deleting log backup file. File:', @temp) + 
							CHARINDEX('END OF TRANSACTION LOG RESTORE', @temp) = 0
						BEGIN
							INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
								VALUES (@instance_id, 'R', 'Invalid Command', @temp, NULL, GETDATE())
						END
					END
				END
				ELSE
				BEGIN
					SET @temp2 = REPLACE(REPLACE(SUBSTRING(@message, @p0, 200),CHAR(13),''), CHAR(10), '')

					INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
						VALUES (@instance_id, 'R', 'Invalid Date', '@p0='+LTRIM(STR(@p0)), @temp2, GETDATE())
				END
			END
			ELSE
			BEGIN
				SET @temp2 = REPLACE(REPLACE(SUBSTRING(@message, @p0, 200),CHAR(13),''), CHAR(10), '')

				/*
				--expected messages to suppress reporting
				Exit Status: 0 (Success)
				*/
				IF CHARINDEX('Exit Status: 0 (Success)', @temp2) = 0
				BEGIN
					INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
						VALUES (@instance_id, 'R', 'Missing tab', '@p0='+LTRIM(STR(@p0)) + ', @tlen =' + LTRIM(STR(LEN(@temp2))), @temp2, GETDATE())
				END

				IF @len <= @p0 + LEN(@temp2) + @CRLFlen + 1
				BEGIN
					SET @p2 = @p0 + LEN(@temp2) + 1
				END
			END
			
			SET @p0 = @p2 + @CRLFlen
			SET @msgcount = @msgcount + 1
		END

		SET @msgcount = @msgcount + 1
		FETCH NEXT FROM restore_job_hist_cur INTO @instance_id, @run_status, @run_date, @run_time, @run_duration, @message
	END

	DEALLOCATE restore_job_hist_cur

	SET @ms = DATEDIFF(MILLISECOND, @x, GETDATE())

	INSERT [dbo].[logshipping_performance_mesages] (instance_id, [type], [message], string1, string2, dt)
		VALUES (@instance_id, 'R', 'JobHistory Summary','Upds='+LTRIM(STR(@ucount)), 'DURms=' + LTRIM(STR(@ms)), GETDATE())
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pMigrateTraceFlags]',10,1) WITH NOWAIT;
if object_id('dbo.pMigrateTraceFlags') is null exec('create procedure [dbo].[pMigrateTraceFlags] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[pMigrateTraceFlags]
*
*	Purpose: Sets dynamic trace flags using config_fddba2 table based on current trace flags and FD suggested trace flags
*
*	Inputs:	None
*
*	Notes:	
*		1. This will set trace flags not running but suggested as disabled assuming that current configuration is correct
*		2. List of trace flags will be comma separated with a trailing comma (for ease of searching)
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-05			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*	2018-02-09			Mike Zawadzki			Changing to TF3 format
*
*********************************************************************************************************************/
alter procedure [dbo].[pMigrateTraceFlags]
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @trace_flags_suggested varchar(3950)
	DECLARE @trace_flags_existing varchar(3950)
	DECLARE @trace_flags_config_old varchar(3950)
	DECLARE @trace_flags_config_new varchar(3950)
	DECLARE @name varchar(50)
	DECLARE @domain varchar(100)
	DECLARE @suggested varchar(6)
	DECLARE @existing varchar(6)
	DECLARE @setting varchar(1)
	DECLARE @global tinyint
	DECLARE @fInsertRow bit = 0
	DECLARE @msg varchar(400)
	DECLARE @dt datetime --FDDBA setup time in UTC

	SET @trace_flags_config_new = ''
	SET @trace_flags_existing = ''
	SET @name = 'trace_flags'
	SET @domain = 'fddba\usp_EnableTraceFlags3'

	CREATE TABLE #trace_flags_existing
	(
		traceflag varchar(5) NOT NULL,
		[status] tinyint NOT NULL,
		[global] tinyint NOT NULL,
		[session] tinyint NOT NULL,
	)

	SELECT TOP 1 @trace_flags_config_old = [value] FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @domain

	IF @trace_flags_config_old IS NULL
	BEGIN
		SET @fInsertRow = 1
	END

	INSERT #trace_flags_existing EXEC ('dbcc tracestatus(-1)')

	--value contains comma separated list of trace flags to enable
	SELECT TOP 1 @trace_flags_suggested = [value] FROM dbo.config_fddba2 WHERE [name] = 'trace_flags_suggested' and [domain] = 'fddba\pMigrateTraceFlags'

	IF @trace_flags_suggested IS NOT NULL
	BEGIN
		DECLARE tfconfig_cursor CURSOR FOR
			SELECT traceflag, [global], a, b
				FROM #trace_flags_existing e
					FULL OUTER JOIN dbo.fSplit2columns(@trace_flags_suggested, '=', ',') s
						ON e.traceflag = s.a

		OPEN tfconfig_cursor
		FETCH NEXT FROM tfconfig_cursor INTO @existing, @global, @suggested, @setting
		WHILE @@FETCH_STATUS != -1
		BEGIN
			--check if running FD suggested trace flag
			IF @existing = @suggested AND @global = 1 AND @setting = '1'
			BEGIN
				SET @trace_flags_config_new = @trace_flags_config_new + @suggested + '=1,'
			END

			--check if running non-FD suggested trace flag
			IF @suggested IS NULL AND @global = 1
			BEGIN
				SET @msg = 'pMigrateTraceFlags: Currently Running NON-FD Suggested Trace Flag ' + @existing + '. Please confirm trace flag is correct.'
				RAISERROR(@msg, 11, 1)
				--do not add to trace flag configuration
			END

			--check if not running FD suggested trace flag
			IF @existing IS NULL AND @suggested IS NOT NULL
			BEGIN
				--@TODO=1 -- check if this condition is working properly
				--IF CHARINDEX('-' + @suggested + ',', @trace_flags_config_old) = 0
				IF EXISTS (SELECT 1 FROM dbo.fSplit2columns(@trace_flags_config_old, '=', ',') WHERE a = @suggested AND b = 1)
				BEGIN
					SET @msg = 'pMigrateTraceFlags: Missing FD Suggested Trace Flag ' + @suggested + '. Please confirm trace flag should not be set and update configuration if it should.'
					RAISERROR(@msg, 11, 1)
				END
				--add trace flag to configuration as disabled
				SET @trace_flags_config_new = @trace_flags_config_new + @suggested + '=0,'
			END

			--record current global trace flags
			IF @global = 1
			BEGIN
				SET @trace_flags_existing = @trace_flags_existing + @existing + ','
			END

			FETCH NEXT FROM tfconfig_cursor INTO @existing, @global, @suggested, @setting
		END
		DEALLOCATE tfconfig_cursor

		IF @fInsertRow = 1
		BEGIN
			INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@name, @domain, @trace_flags_config_new)
			SET @msg = '	pMigrateTraceFlags: Adding trace flag configuration: ' + @trace_flags_config_new
			RAISERROR(@msg, 10, 1)
		END
		--ELSE
		--BEGIN
		--	IF @trace_flags_config_old != @trace_flags_config_new
		--	BEGIN
		--		UPDATE dbo.config_fddba2 
		--			SET [value] = @trace_flags_config_new
		--			WHERE [name] = @name AND [domain] = @domain

		--		SET @msg = '	pMigrateTraceFlags: Updating trace flag configuration: ' + @trace_flags_config_new
		--		RAISERROR(@msg, 10, 1)
		--	END
		--	ELSE
		--	BEGIN
		--		SET @msg = '	pMigrateTraceFlags: SKIPPING trace flag configuration since already exists: ' + @trace_flags_config_new
		--		RAISERROR(@msg, 10, 1)
		--	END
		--END

		SELECT @dt = MAX(CONVERT(datetime,[domain])) FROM dbo.config_fddba2_history WHERE [name] LIKE 'fddba\%'
		INSERT dbo.config_fddba2_history ([name], [domain], [value]) VALUES ('trace_flags_existing', CONVERT(varchar(23), @dt, 126), @trace_flags_existing)
	END
	ELSE --IF @trace_flags_suggested IS NOT NULL
	BEGIN
		--following should NEVER be expected
		RAISERROR('pMigrateTraceFlags: Missing Suggested Trace Flag configuration row', 11, 1) WITH NOWAIT
	END
END

GO


--pPerfExecRequests 2012 and higher only
IF (select VerDec from #FDVER) >= 11
BEGIN
	RAISERROR ('	CREATING OR ALTERING PROCEDURE dbo.pPerfExecRequests',10,1) WITH NOWAIT;
	IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pPerfExecRequests]') AND TYPE in (N'P', N'PC'))
	BEGIN
		EXEC dbo.sp_executesql @statement =  N'CREATE PROCEDURE [dbo].[pPerfExecRequests] AS SELECT getdate()';
	END
	EXEC dbo.sp_executesql @statement = N'ALTER PROCEDURE [dbo].[pPerfExecRequests](
		@CheckThreadPoolAndSchedulers				BIT = 0,		-- Check ThreadPool waits and if any are found also checks Schedulers
		@CheckOsWaitingTasks_CxPacket				BIT = 0,		-- check Os waiting task DMV for sessions waiting on CXPacket
		@WaitingTasksIncludeAllForDBName			SYSNAME = NULL, --Include any waiting task on this specfic database even if not a cxpacket
		@IncludePlan								bit = 1,		--Include the execution plan
		@IncludeStmtandTextAsXML					bit = 1,		--Include the SQL statement and SQLText as XML
		@IncludeStmtandTextAndBlockText				bit = 1			-- Include the SQL statement and SQLText
	)
	WITH ENCRYPTION
	AS
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
	SET NOCOUNT ON

	if not exists (select * from Licensing.fn_ValidateLicense()) return
	SELECT
			getdate() as CurrentDate,
			x.session_id,
			CAST(DATEDIFF(mi, x.start_time, GETDATE()) AS BIGINT) ''Run Time min'',
				 RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 86400 AS VARCHAR),2) + '':'' +
			  RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 3600 AS VARCHAR),2) + '':'' +
				RIGHT(''0'' + CAST(( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 60) % 60 AS VARCHAR),2) + '':'' +
				RIGHT(''0'' + CAST(DATEDIFF(SECOND, x.start_time,  GETDATE()) % 60 AS VARCHAR),2) as ''RunTime DD:HH:MM:SS"'',
			DatabaseName,
			COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
			status,
			x.open_transaction_count,
			x.host_name,
			x.login_name,
			x.program_name,
			x.wait_type,
			x.wait_resource,
			x.wait_time,
			x.start_time,
			x.totallogical_reads ,
			FDDBA.[dbo].[fFormatIntReadable]( x.totallogical_reads) AS Reads ,
			x.totalWrites,
			x.totalCPU,
			x.writes_in_tempdb,
			parallelquery,
			CASE WHEN @IncludeStmtandTextAndBlockText = 1 THEN 
			(
				SELECT          
					substring(text, (statement_start_offset/2)+1
						, ((case statement_end_offset
							  when -1 then datalength(text)
							  else statement_end_offset
						   end - statement_start_offset)/2) + 1)
				FROM sys.dm_exec_sql_text(x.sql_handle)
			) ELSE NULL END AS statement_text,
			CASE WHEN @IncludeStmtandTextAndBlockText = 1 THEN 
			(
				SELECT
					p.text
				FROM
				(
					SELECT
						MIN(sql_handle) AS sql_handle
					FROM sys.dm_exec_requests r2
					WHERE
						r2.session_id = x.blocking_session_id
				) AS r_blocking
				CROSS APPLY
				(
					SELECT
						text AS [text()]
					FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
				) p (text)
			) ELSE NULL END AS blocking_text,
			CASE WHEN @IncludeStmtandTextAndBlockText = 1 THEN 
			(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(x.sql_handle)
			)ELSE NULL END  AS sql_text,
			transaction_id,
			percent_complete,
			estimated_completion_time,
			scheduler_id,
			plan_handle,
			x.granted_query_memory
			,  CASE WHEN @IncludePlan = 1 THEN 
			(SELECT query_plan 
			FROM sys.dm_exec_query_plan (plan_handle)) ELSE NULL END AS execution_plan,
			CASE WHEN @IncludeStmtandTextAsXML =1 THEN	
			(
				SELECT          
					substring(text, (statement_start_offset/2)+1
						, ((case statement_end_offset
							  when -1 then datalength(text)
							  else statement_end_offset
						   end - statement_start_offset)/2) + 1)
				FROM sys.dm_exec_sql_text(x.sql_handle)
				FOR XML PATH(''''), TYPE
			) ELSE NULL END AS statement_text_xml,
			CASE WHEN @IncludeStmtandTextAsXML =1 THEN	
			(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(x.sql_handle)
				FOR XML PATH(''''), TYPE
			) ELSE NULL END  AS sql_text_xml
			,x.last_request_start_time
			,x.last_request_end_time
			
		FROM
		(
			SELECT
				s.session_id,
				DB_NAME(s.database_id) AS DatabaseName,
				s.status,
				s.host_name,
				s.login_name,
				r.start_time,
				s.open_transaction_count,
				r.sql_handle,
				wait_type,
				wait_resource,
				CAST(wait_time AS BIGINT) AS wait_time,
				statement_start_offset,
				statement_end_offset,
				r.blocking_session_id,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				--r.row_count,
				count(*) AS parallelquery,
				SUM(CAST(r.logical_reads AS BIGINT)) AS totallogical_reads ,
				SUM(CAST(r.writes AS BIGINT)) AS totalWrites,
				SUM(CAST(r.cpu_time AS BIGINT)) AS totalCPU,
				SUM(CAST(tsu.user_objects_alloc_page_count + tsu.internal_objects_alloc_page_count AS BIGINT)) AS writes_in_tempdb,
				plan_handle,
				CAST(granted_query_memory AS BIGINT) AS granted_query_memory,
				program_name,
				s.last_request_start_time,
				s.last_request_end_time
			FROM 
				sys.dm_exec_sessions s
				LEFT JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
				LEFT JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id and r.request_id = tsu.request_id
			WHERE (s.status IN (''running'', ''runnable'', ''suspended'',''rollback'') or s.open_transaction_count > 0)
			--AND r.session_id > 50
			AND s.session_id != @@spid
			--and  s.login_name = ''sql_etl''
			GROUP BY
				s.session_id,
				s.database_id,
				s.status,
				s.host_name,
				s.login_name,
				r.start_time,
				r.sql_handle,
				wait_type,
				s.open_transaction_count,
				wait_resource,
				wait_time,
				statement_start_offset,
				statement_end_offset,
				r.blocking_session_id,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				--, r.row_count
				last_request_start_time,
				plan_handle,
				granted_query_memory,
				program_name,
				s.last_request_end_time
		) x

		ORDER BY 3 desc , session_id--16

	IF @CheckThreadPoolAndSchedulers = 1
	BEGIN
		select ''THREADPOOL WAIT'' AS ''THREADPOOL WAITS'', * from sys.dm_os_waiting_tasks WHere wait_type = ''THREADPOOL''
		IF @@ROWCOUNT > 0
			SELECT ''dm_os_schedulers'' AS ''dm_os_schedulers'', * FROM sys.dm_os_schedulers	WHERE scheduler_id < 255 and status =N''VISIBLE ONLINE''
	END

	IF @CheckOsWaitingTasks_CxPacket = 1
	BEGIN
		IF @WaitingTasksIncludeAllForDBName IS NULL
		BEGIN
			SELECT 
				''dm_os_waiting_tasks'' AS ''dm_os_waiting_tasks'', 
				* 
			 FROM 
				sys.dm_os_waiting_tasks 
			WHERE 
				wait_type = ''CXPACKET'' 
			ORDER BY 
				session_id
		END
		ELSE
		BEGIN
			SELECT 
				''dm_os_waiting_tasks'' AS ''dm_os_waiting_tasks'', 
				* 
			 FROM 
				sys.dm_os_waiting_tasks 
			WHERE 
				wait_type = ''CXPACKET'' 
				OR session_id IN (SELECT session_id FROM sys.dm_exec_requests WHERE database_id = DB_ID(@WaitingTasksIncludeAllForDBName))
			ORDER BY session_id
		END
	END' 
END


IF (select VerDec from #FDVER) >= 10.5
BEGIN
RAISERROR ('	CREATING OR ALTERING PROCEDURE dbo.pPerformanceMonitor',10,1) WITH NOWAIT;
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pPerformanceMonitor]') AND TYPE in (N'P', N'PC'))
BEGIN
	EXEC dbo.sp_executesql @statement =  N'CREATE PROCEDURE [dbo].[pPerformanceMonitor] AS SELECT getdate()';
END

	EXEC sp_executesql @stmt =N'
ALTER PROCEDURE [dbo].[pPerformanceMonitor]
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET ANSI_WARNINGS OFF

DECLARE @lastbatchbasecount		BIGINT
DECLARE @currentbatchbasecount	BIGINT
DECLARE @lastrunts				DATETIME2(3)

EXEC dbo.usp_UpdateVersionStatics
BEGIN TRY 

-- Get the last batch Req/Sec base count to use later
SET @lastbatchbasecount = 
		(select top 1 Batch_Requests_Sec_Base 
			from [dbo].Performance_Counter
			where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
			ORDER BY CreatedOn DESC)
set @lastrunts = (select top 1 CreatedOn 
			from [dbo].Performance_Counter
			where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
			ORDER BY CreatedOn DESC)

set @currentbatchbasecount = (select cntr_value
								from sys.dm_os_performance_counters
								where counter_name in (''Batch Requests/sec'')
								and instance_name = '''') 

INSERT dbo.Performance_Counter
select cast(serverproperty(''machinename'') as varchar(40)) as ''servername''
	, getdate() as ''CreatedOn''
	, cntr_value as ''User Connections''
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''page life expectancy'')
		and instance_name = '''') as ''page life expectancy''
		
	/********************************************************************
	* Updated this code to check to see if previous base count is greater
	* than the current base count. If so the instance probably restarted
	* and the counter started over, so insert the current base count as 
	* the new count
	********************************************************************/
	
	, Case When @lastbatchbasecount > @currentbatchbasecount Then @currentbatchbasecount / 
								datediff (ss , @lastrunts, getdate())
			Else
			(@currentbatchbasecount - @lastbatchbasecount) / 
								datediff (ss , @lastrunts, getdate())
		END as ''batch requests/sec''
		
	,@currentbatchbasecount as  ''batch requests/sec base''


	, (select cast(((cast(sum(case ltrim(rtrim(counter_name)) when ''buffer cache hit ratio'' 
					then cast(cntr_value as integer) else null END) as float) /
				cast(sum(case ltrim(rtrim(counter_name)) when ''buffer cache hit ratio base'' 
					then cast(cntr_value as integer) else null END) as float)) * 100) as dec(5,2))
				as buffercachehitratio
		from 
				sys.dm_os_performance_counters) as ''buffer cache hit ratio''
	
	,(select (((select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''logins/sec'')
		and instance_name = '''') - (select top 1 isnull(Logins_Sec_Base,0) from Performance_Counter
									where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
									ORDER BY CreatedOn DESC) ) / 
												(select datediff (ss , (select top 1 CreatedOn from Performance_Counter
												where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
												ORDER BY CreatedOn DESC ), getdate())))
		) as ''logins/sec''
					  
	--Logins_Sec_Base
	,(select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''logins/sec'')
		and instance_name = '''') ''logins/sec Base''
		
	,(select (((select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''SQL Compilations/sec'')
		and instance_name = '''') - (select top 1 isnull(SQL_Compiles_Sec_Base,0) from Performance_Counter
									where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
									ORDER BY CreatedOn DESC) ) / 
												(select datediff (ss , (select top 1 CreatedOn from Performance_Counter
												where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
												ORDER BY CreatedOn DESC ), getdate())))
		) as ''SQL Compilations/sec''	  
		
	--SQL_Compiles_Sec_Base
	,(select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''SQL Compilations/sec'')
		and instance_name = '''') ''SQL Compilations/sec Base''
				
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Active Temp Tables'')
		and instance_name = '''') ''Active Temp Tables''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Processes blocked'')
		and instance_name = '''') ''Processes blocked''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Memory Grants Outstanding'')
		and instance_name = '''') ''Memory Grants Outstanding''

	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Connection Memory (KB)'')
		and instance_name = '''') ''Connection Memory (KB)''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Granted Workspace Memory (KB)'')
		and instance_name = '''') ''Granted Workspace Memory (KB)''
				
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Optimizer Memory (KB)'')
		and instance_name = '''') ''Optimizer Memory (KB)''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''SQL Cache Memory (KB)'')
		and instance_name = '''') ''SQL Cache Memory (KB)''                                                                                                           
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Target Server Memory (KB)'')
		and instance_name = '''') ''Target Server Memory (KB)''                                                                                                       
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Total Server Memory (KB)'')
		and instance_name = '''') ''Total Server Memory (KB)'' 
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Lock waits'')
		and instance_name = ''Average wait time (ms)'') ''Lock waits\Avg Wait Time''
                                                                                                                
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Memory grant queue waits'')
		and instance_name = ''Average wait time (ms)'') ''Memory grant queue waits\Avg Wait Time''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Thread-safe memory objects waits'')
		and instance_name = ''Average wait time (ms)'') ''Thread-safe memory objects waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Log write waits'')
		and instance_name = ''Average wait time (ms)'') ''Log write waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Log buffer waits'')
		and instance_name = ''Average wait time (ms)'') ''Log buffer waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Network IO waits'')
		and instance_name = ''Average wait time (ms)'') ''Network IO waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Page IO latch waits'')
		and instance_name = ''Average wait time (ms)'') ''Page IO latch waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Page latch waits'')
		and instance_name = ''Average wait time (ms)'') ''Page latch waits\Avg Wait Time''

	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Non-Page latch waits'')
		and instance_name = ''Average wait time (ms)'') ''Non-Page latch waits\Avg Wait Time''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Wait for the worker'')
		and instance_name = ''Average wait time (ms)'') ''Wait for the worker\Avg Wait Time''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Workspace synchronization waits'')
		and instance_name = ''Average wait time (ms)'') ''Workspace synchronization waits\Avg Wait Time''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Transaction ownership waits'')
		and instance_name = ''Average wait time (ms)'') ''Transaction ownership waits\Avg Wait Time''
		
			
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Lock waits'')
		and instance_name = ''Waits in progress'') ''Lock waits\Waits in progress''
                                                                                                                
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Memory grant queue waits'')
		and instance_name = ''Waits in progress'') ''Memory grant queue waits\Waits in progress''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Thread-safe memory objects waits'')
		and instance_name = ''Waits in progress'') ''Thread-safe memory objects waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Log write waits'')
		and instance_name = ''Waits in progress'') ''Log write waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Log buffer waits'')
		and instance_name = ''Waits in progress'') ''Log buffer waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Network IO waits'')
		and instance_name = ''Waits in progress'') ''Network IO waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Page IO latch waits'')
		and instance_name = ''Waits in progress'') ''Page IO latch waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Page latch waits'')
		and instance_name = ''Waits in progress'') ''Page latch waits\Waits in progress''

	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Non-Page latch waits'')
		and instance_name = ''Waits in progress'') ''Non-Page latch waits\Waits in progress''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Wait for the worker'')
		and instance_name = ''Waits in progress'') ''Wait for the worker\Waits in progress''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Workspace synchronization waits'')
		and instance_name = ''Waits in progress'') ''Workspace synchronization waits\Waits in progress''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Transaction ownership waits'')
		and instance_name = ''Waits in progress'') ''Transaction ownership waits\Waits in progress''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Memory Grants PENDing'')
		and instance_name = '''')
from sys.dm_os_performance_counters
where counter_name in (''user connections'')
and instance_name = ''''

END TRY 
BEGIN catch 
select ''USP_PERFMON_MONITOR - Main'' as ''Section''
,       ERROR_NUMBER() as ''Error_Number''
,       ERROR_SEVERITY() as ''Error_Severity'' 
,       ERROR_STATE() as ''Error_State'' 
,       ERROR_MESSAGE() as ''Error_Msg'' 
END catch
'
END
ELSE
BEGIN
	EXEC sp_executesql @stmt =N'ALTER PROCEDURE [dbo].[pPerformanceMonitor]
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET ANSI_WARNINGS OFF

EXEC dbo.usp_UpdateVersionStatics
DECLARE @lastbatchbasecount		BIGINT
DECLARE @currentbatchbasecount	BIGINT
DECLARE @lastrunts				DATETIME

BEGIN TRY 

-- Get the last batch Req/Sec base count to use later
SET @lastbatchbasecount = 
		(select top 1 Batch_Requests_Sec_Base 
			from [dbo].Performance_Counter
			where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
			ORDER BY CreatedOn DESC)
set @lastrunts = (select top 1 CreatedOn 
			from [dbo].Performance_Counter
			where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
			ORDER BY CreatedOn DESC)

set @currentbatchbasecount = (select cntr_value
								from sys.dm_os_performance_counters
								where counter_name in (''Batch Requests/sec'')
								and instance_name = '''') 

INSERT dbo.Performance_Counter
select cast(serverproperty(''machinename'') as varchar(40)) as ''servername''
	, getdate() as ''CreatedOn''
	, cntr_value as ''User Connections''
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''page life expectancy'')
		and instance_name = '''') as ''page life expectancy''
		
	/********************************************************************
	* Updated this code to check to see if previous base count is greater
	* than the current base count. If so the instance probably restarted
	* and the counter started over, so insert the current base count as 
	* the new count
	********************************************************************/
	
	, Case When @lastbatchbasecount > @currentbatchbasecount Then @currentbatchbasecount / 
								datediff (ss , @lastrunts, getdate())
			Else
			(@currentbatchbasecount - @lastbatchbasecount) / 
								datediff (ss , @lastrunts, getdate())
		END as ''batch requests/sec''
		
	,@currentbatchbasecount as  ''batch requests/sec base''


	, (select cast(((cast(sum(case ltrim(rtrim(counter_name)) when ''buffer cache hit ratio'' 
					then cast(cntr_value as integer) else null END) as float) /
				cast(sum(case ltrim(rtrim(counter_name)) when ''buffer cache hit ratio base'' 
					then cast(cntr_value as integer) else null END) as float)) * 100) as dec(5,2))
				as buffercachehitratio
		from 
				sys.dm_os_performance_counters) as ''buffer cache hit ratio''
	
	,(select (((select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''logins/sec'')
		and instance_name = '''') - (select top 1 isnull(Logins_Sec_Base,0) from Performance_Counter
									where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
									ORDER BY CreatedOn DESC) ) / 
												(select datediff (ss , (select top 1 CreatedOn from Performance_Counter
												where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
												ORDER BY CreatedOn DESC ), getdate())))
		) as ''logins/sec''
					  
	--Logins_Sec_Base
	,(select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''logins/sec'')
		and instance_name = '''') ''logins/sec Base''
		
	,(select (((select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''SQL Compilations/sec'')
		and instance_name = '''') - (select top 1 isnull(SQL_Compiles_Sec_Base,0) from Performance_Counter
									where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
									ORDER BY CreatedOn DESC) ) / 
												(select datediff (ss , (select top 1 CreatedOn from Performance_Counter
												where SQL_Server_Name = CAST(SERVERPROPERTY(''MachineName'') AS VARCHAR(40))
												ORDER BY CreatedOn DESC ), getdate())))
		) as ''SQL Compilations/sec''	  
		
	--SQL_Compiles_Sec_Base
	,(select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''SQL Compilations/sec'')
		and instance_name = '''') ''SQL Compilations/sec Base''
				
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Active Temp Tables'')
		and instance_name = '''') ''Active Temp Tables''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Processes blocked'')
		and instance_name = '''') ''Processes blocked''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Memory Grants Outstanding'')
		and instance_name = '''') ''Memory Grants Outstanding''

	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Connection Memory (KB)'')
		and instance_name = '''') ''Connection Memory (KB)''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Granted Workspace Memory (KB)'')
		and instance_name = '''') ''Granted Workspace Memory (KB)''
				
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Optimizer Memory (KB)'')
		and instance_name = '''') ''Optimizer Memory (KB)''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''SQL Cache Memory (KB)'')
		and instance_name = '''') ''SQL Cache Memory (KB)''                                                                                                           
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Target Server Memory (KB)'')
		and instance_name = '''') ''Target Server Memory (KB)''                                                                                                       
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Total Server Memory (KB)'')
		and instance_name = '''') ''Total Server Memory (KB)'' 
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Lock waits'')
		and instance_name = ''Average wait time (ms)'') ''Lock waits\Avg Wait Time''
                                                                                                                
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Memory grant queue waits'')
		and instance_name = ''Average wait time (ms)'') ''Memory grant queue waits\Avg Wait Time''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Thread-safe memory objects waits'')
		and instance_name = ''Average wait time (ms)'') ''Thread-safe memory objects waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Log write waits'')
		and instance_name = ''Average wait time (ms)'') ''Log write waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Log buffer waits'')
		and instance_name = ''Average wait time (ms)'') ''Log buffer waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Network IO waits'')
		and instance_name = ''Average wait time (ms)'') ''Network IO waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Page IO latch waits'')
		and instance_name = ''Average wait time (ms)'') ''Page IO latch waits\Avg Wait Time''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Page latch waits'')
		and instance_name = ''Average wait time (ms)'') ''Page latch waits\Avg Wait Time''

	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Non-Page latch waits'')
		and instance_name = ''Average wait time (ms)'') ''Non-Page latch waits\Avg Wait Time''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Wait for the worker'')
		and instance_name = ''Average wait time (ms)'') ''Wait for the worker\Avg Wait Time''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Workspace synchronization waits'')
		and instance_name = ''Average wait time (ms)'') ''Workspace synchronization waits\Avg Wait Time''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Transaction ownership waits'')
		and instance_name = ''Average wait time (ms)'') ''Transaction ownership waits\Avg Wait Time''
		
			
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Lock waits'')
		and instance_name = ''Waits in progress'') ''Lock waits\Waits in progress''
                                                                                                                
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Memory grant queue waits'')
		and instance_name = ''Waits in progress'') ''Memory grant queue waits\Waits in progress''
		
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Thread-safe memory objects waits'')
		and instance_name = ''Waits in progress'') ''Thread-safe memory objects waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Log write waits'')
		and instance_name = ''Waits in progress'') ''Log write waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Log buffer waits'')
		and instance_name = ''Waits in progress'') ''Log buffer waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Network IO waits'')
		and instance_name = ''Waits in progress'') ''Network IO waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Page IO latch waits'')
		and instance_name = ''Waits in progress'') ''Page IO latch waits\Waits in progress''
	
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Page latch waits'')
		and instance_name = ''Waits in progress'') ''Page latch waits\Waits in progress''

	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Non-Page latch waits'')
		and instance_name = ''Waits in progress'') ''Non-Page latch waits\Waits in progress''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Wait for the worker'')
		and instance_name = ''Waits in progress'') ''Wait for the worker\Waits in progress''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Workspace synchronization waits'')
		and instance_name = ''Waits in progress'') ''Workspace synchronization waits\Waits in progress''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Transaction ownership waits'')
		and instance_name = ''Waits in progress'') ''Transaction ownership waits\Waits in progress''
							  
	, (select cntr_value
		from sys.dm_os_performance_counters
		where counter_name in (''Memory Grants PENDing'')
		and instance_name = '''')
from sys.dm_os_performance_counters
where counter_name in (''user connections'')
and instance_name = ''''

END TRY 
BEGIN catch 
select ''USP_PERFMON_MONITOR - Main'' as ''Section''
,       ERROR_NUMBER() as ''Error_Number''
,       ERROR_SEVERITY() as ''Error_Severity'' 
,       ERROR_STATE() as ''Error_State'' 
,       ERROR_MESSAGE() as ''Error_Msg'' 
END catch'
END
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pPerfQuickCheck]',10,1) WITH NOWAIT;
if object_id('dbo.pPerfQuickCheck') is null exec('create procedure [dbo].[pPerfQuickCheck] as select getdate() DT')
GO
  

alter procedure dbo.pPerfQuickCheck
	@ShowSpaceReport			bit = 0,
	@ShowCachePerDB				bit = 0,
	@ShowBackupReport			bit = 0,
	@ShowASPState				bit = 0
WITH ENCRYPTION										       
AS

SET NOCOUNT ON
set TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
--params that can be changed to change the output of this script

declare @start				datetime
declare @end				datetime
declare @cntStart			bigint
declare @cntEnd				bigint
declare @runtime			int
declare @avgbatches			int
--objects for cpu waits
declare @signal_wait1		bigint
declare @signal_wait2		bigint
declare @wait_time1			bigint
declare @wait_time2			bigint
declare @signal_total		bigint
declare @wait_total			bigint
declare @version			money
declare @sql				nvarchar(3000)
declare @paramDefinition	nvarchar(500)

IF NOT EXISTS (SELECT * FROM Licensing.fn_ValidateLicense()) RETURN;
--first thing is to start to gather batch requests
select @start = GETDATE(), @cntStart = cntr_value 
from sys.dm_os_performance_counters 
where counter_name = 'Batch Requests/sec'

--lets also get Transactions/sec, use a temp table to hold that information by instance
IF OBJECT_ID('tempdb..#trans') IS NOT NULL
	DROP TABLE #trans 
select 
	object_name, cntr_value
into #trans
from 
	sys.dm_os_performance_counters 
where 
	counter_name = 'Transactions/sec'
	and instance_name ='_Total'


select @signal_wait1 = SUM(signal_wait_time_ms),
		@wait_time1 = SUM (wait_time_ms) 
FROM sys.dm_os_wait_stats 


declare @crdate				DATETIME
declare @min				VARCHAR(5)
declare @iday				int
declare @ihr				int
declare @imin				bigint
declare @msg				varchar(100)
declare @agentstatus		varchar(20)
declare @cpucount			int
declare @schedulercount		int
declare @physicalmemorykb	bigint
declare @ver	varchar(30)
declare @dot1	int
declare @dot2	int
declare @verdec	decimal(18,2)

select @ver = cast(SERVERPROPERTY('productversion') as varchar(30))
select @dot1 = CHARINDEX('.',@ver)
select @dot2 = CHARINDEX('.',@ver,@dot1+1)
select @verdec = cast(SUBSTRING(@ver,1,@dot2-1) as decimal(18,2))


--QGENEVADEV
If @verdec < 10
	set @sql = N'select @rtnvalOUT = create_date  FROM sys.databases where name =''tempdb'''
Else
	set @sql = N'select @rtnvalOUT = sqlserver_start_time FROM sys.dm_os_sys_info'

set @paramDefinition =N'@rtnvalOUT datetime OUTPUT'
exec sp_executesql @sql, @paramDefinition, @rtnvalOUT = @crdate OUTPUT;

select @version = CAST( SUBSTRING(cast(SERVERPROPERTY('productversion') as varchar(30)),1,CHARINDEX('.',cast(SERVERPROPERTY('productversion') as varchar(30))) - 1) as tinyint)



set @imin = DATEDIFF(MINUTE ,@crdate, getdate())
set @iday = 0
if @imin > 60 AND @imin < 1440
begin
	set @ihr = @imin / 60
	set @min = cast(@imin - (@ihr * 60) as varchar)
end
Else
begin
	if @imin > 1440
		set @iday = @imin /1440
	set @ihr = (@imin - (1440 * @iday) )/60
	set @min = cast(@imin - (1440 * @iday) - (60 * @ihr) as varchar)
end	


IF NOT EXISTS (SELECT 1 FROM master.dbo.sysprocesses WHERE program_name = N'SQLAgent - Generic Refresher')
	set @agentstatus =  'NOT RUNNING'
Else
	set @agentstatus = 'Running' 

	
select @@servername as 'Server Name', @crdate  as 'sqlserver_start_time', GETDATE() as 'CurrentDateTime', Cast(@iday as varchar) + ' days ' +
	cast(@ihr as varchar) + ' hour(s) and ' +  @min + ' minute(s).' as 'SQL Up Time', 
	@agentstatus 'SQL Agent Status'
	,cast(SERVERPROPERTY('ComputerNamePhysicalNetBIOS') as sysname) as HostSystem
	,@verdec as '@verdec'
	, CASE WHEN CAST(SERVERPROPERTY('IsClustered') AS BIT) = 1 THEN 'Yes' Else 'No' End As IsClustered


IF CAST(SERVERPROPERTY('IsClustered') AS BIT) = 1
	execute sp_executesql  N'select ''sys.dm_os_cluster_nodes'' as ''sys.dm_os_cluster_nodes'' ,* from sys.dm_os_cluster_nodes'

If @verdec < 11.00
Begin
	Exec ( 'select cpu_count, 
		hyperthread_ratio,
		scheduler_count, 
		cpu_count/cast(hyperthread_ratio as money) as [Physical CPU Count],
		physical_memory_in_bytes, 
		physical_memory_in_bytes/1024/1024   as physical_memory_mb
	from sys.dm_os_sys_info')
End
Else --If @verdec >= 11.00
Begin
	Exec ('select cpu_count, 
		scheduler_count, 
		hyperthread_ratio,
		cpu_count/cast(hyperthread_ratio as money) as [Physical CPU Count],
		physical_memory_kb, 
		physical_memory_kb/1024 as physical_memory_mb
	from sys.dm_os_sys_info')
End

/**************************************************
	SCHEDULER CHECK
 **************************************************/
SELECT *
FROM sys.dm_os_schedulers
WHERE scheduler_id < 255 
select 'THREADPOOL WAIT' AS 'THREADPOOL WAITS', * from sys.dm_os_waiting_tasks WHere wait_type = 'THREADPOOL'
---------------------------------------------------------------------------------------------------------------

If @agentstatus = 'NOT RUNNING'
	RAISERROR('SQL Agent is NOT RUNNING',15,199)with nowait;

--Get SQL and Server Settings
declare @serverRAM		bigint
declare @desc			nvarchar(256)
If @verdec < 10
	set @sql = N'Select @rtnRamOUT = physical_memory_in_bytes/1024/1024, @rtnDescOut = NULL  from sys.dm_os_sys_info;'
Else
	set @sql = N'Select @rtnRamOUT =  total_physical_memory_kb/1024, @rtnDescOut = system_memory_state_desc From sys.dm_os_sys_memory OPTION (RECOMPILE);'

set @paramDefinition = N'@rtnRamOUT bigint OUTPUT,  @rtnDescOut nvarchar(256) OUTPUT'

Exec sp_executesql @sql, @paramDefinition, @rtnRamOUT  = @serverRAM OUTPUT, @rtnDescOut = @desc output


declare @windows_release	nvarchar(256)
declare @osLanguage			int
declare @windowssku			int


If @verdec >=10.0
begin
	set @sql = N'select @rtnWindows_release = windows_release
	, @rtnOslanguage = os_language_version
	,@rtnWndowssku = windows_sku
 from 
	sys.dm_os_windows_info'
	set @paramDefinition = N'@rtnWindows_release nvarchar(256) OUTPUT,  @rtnOslanguage int OUTPUT, @rtnWndowssku  int OUTPUT'
	Exec sp_executesql @sql, @paramDefinition, @rtnWindows_release  = @windows_release OUTPUT, 
		@rtnOslanguage = @osLanguage output, @rtnWndowssku = @windowssku OUTPUT
end

Select  SERVERPROPERTY('productversion') as 'Product Version' 
	, SERVERPROPERTY('productlevel') as 'Product Level'  
	, SERVERPROPERTY('edition') as 'Product Edition'
	, [ProductVersionDesc] = CASE SERVERPROPERTY('ProductVersion') 



	WHEN '13.0.5426.0' Then 'SQL Server 2016 SP2 CU8'
	WHEN '13.0.5382.0' Then 'SQL Server 2016 SP2 + On-demand hotfix update package for SQL Server 2016 SP2 CU7 (KB4510807)'
	WHEN '13.0.5366.0' Then 'SQL Server 2016 SP2 CU7 + Security update for SQL Server 2016 SP2 CU7 GDR (KB4505222)'
	WHEN '13.0.5343.1' Then 'SQL Server 2016 SP2 CU7 + On-demand hotfix update package for SQL Server 2016 SP2 CU7 (KB4508636)'
	WHEN '13.0.5337.0' Then 'SQL Server 2016 SP2 CU7'
	WHEN '13.0.5292.0' Then 'SQL Server 2016 SP2 CU6'
	WHEN '13.0.5270.0' Then 'SQL Server 2016 SP2 CU5 + FIX: Restoring backup to SQL Server 2016 from SQL Server 2008 or 2008 R2 takes a long time (KB4490237)'
	WHEN '13.0.5264.1' Then 'SQL Server 2016 SP2 CU5'
	WHEN '13.0.5239.0' Then 'SQL Server 2016 SP2 + FIX: On-demand hotfix update package 2 for SQL Server 2016 SP2 CU4 (KB4482972)'
	WHEN '13.0.5233.0' Then 'SQL Server 2016 SP2 CU4'
	WHEN '13.0.5216.0' Then 'SQL Server 2016 SP2 CU3'
	WHEN '13.0.5201.1' Then 'SQL Server 2016 SP2 + Security update for the remote code execution vulnerability in SQL Server 2016 SP2 (CU) (KB4458621)'
	WHEN '13.0.5161.0' Then 'SQL Server 2016 SP2 CU2 + (Replaced) Security update for the remote code execution vulnerability in 2016 SP2 (CU) (KB4293807)'
	WHEN '13.0.5153.0' Then 'SQL Server 2016 SP2 CU2'
	WHEN '13.0.5149.0' Then 'SQL Server 2016 SP2 CU1'
	WHEN '13.0.5101.9' Then 'SQL Server 2016 SP2 +	Security update for SP2 GDR (KB4505220)'
	WHEN '13.0.5081.1' Then 'SQL Server 2016 SP2  + Security update for the remote code execution vulnerability in SP2 (GDR) (KB4293802)'
	WHEN '13.0.5026.0' Then 'SQL Server 2016 SP2'
	WHEN '13.0.4604.0' Then 'SQL Server 2016 SP1 CU15 + Security update for SQL Server 2016 SP1 CU15 GDR (KB4505221)'
	WHEN '13.0.4577.0' Then 'SQL Server 2016 SP1 CU15 + On-demand hotfix update package for SQL Server 2016 SP1 CU15 (KB4508471)'
	WHEN '13.0.4574.0' Then 'SQL Server 2016 SP1 CU15'
	WHEN '13.0.4560.0' Then 'SQL Server 2016 SP1 CU14'
	WHEN '13.0.4550.1' Then 'SQL Server 2016 SP1 CU13'
	WHEN '13.0.4541.0' Then 'SQL Server 2016 SP1 CU12'
	WHEN '13.0.4531.0' Then 'SQL Server 2016 SP1 CU11 + FIX: The ?modification_counter? in DMV sys.dm_db_stats_properties shows incorrect value when partitions are merged through ALTER PARTITION in SQL Server 2016 (KB4465443)'
	WHEN '13.0.4528.0' Then 'SQL Server 2016 SP1 CU11'
	WHEN '13.0.4522.0' Then 'SQL Server 2016 SP1 CU10 + Security update for the remote code execution vulnerability in SP1 (CU) (KB4293808)'
	WHEN '13.0.4514.0' Then 'SQL Server 2016 SP1 CU10'
	WHEN '13.0.4502.0' Then 'SQL Server 2016 SP1 CU9'
	WHEN '13.0.4474.0' Then 'SQL Server 2016 SP1 CU8'
	WHEN '13.0.4466.4' Then 'SQL Server 2016 SP1 CU7'
	WHEN '13.0.4457.0' Then 'SQL Server 2016 SP1 CU6'
	WHEN '13.0.4451.0' Then 'SQL Server 2016 SP1 CU5'
	WHEN '13.0.4446.0' Then 'SQL Server 2016 SP1 CU4'
	WHEN '13.0.4435.0' Then 'SQL Server 2016 SP1 CU3'
	WHEN '13.0.4422.0' Then 'SQL Server 2016 SP1 CU2'
	WHEN '13.0.4411.0' Then 'SQL Server 2016 SP1 CU1'
	WHEN '13.0.4259.0' Then 'SQL Server 2016 SP1 +	Security update for SQL Server 2016 SP1 GDR (KB4505219)'
	WHEN '13.0.4224.16' Then 'SQL Server 2016 SP1 +	Security update for the remote code execution vulnerability in SP1 (GDR) (KB4458842)'
	WHEN '13.0.4223.10' Then 'SQL Server 2016 SP1  + (Replaced) Security update for the remote code execution vulnerability in SP1 (GDR) (KB4293801)'
	WHEN '13.0.4210.6' Then 'SQL Server 2016 SP1 +	Security Update for SQL Server 2016 Service Pack 1 GDR (KB4057118)'
	WHEN '13.0.4206.0' Then 'SQL Server 2016 SP1 + Security Update for SP1  GDR (KB4019089)'
	WHEN '13.0.4202.2' Then 'SQL Server 2016 SP1 + GDR update package for SP1 (KB3210089)'
	WHEN '13.0.4199.0' Then 'SQL Server 2016 SP1 + FIX: Important update for SP1 Reporting Services (KB3207512)'
	WHEN '13.0.4001.0' Then 'SQL Server 2016 Service Pack 1 (SP1)'
	WHEN '13.0.2218.0' Then 'SQL Server 2016 RTM  CU9 + Security Update for (KB4058559)'
	WHEN '13.0.2216.0' Then 'SQL Server 2016 RTM CU9'
	WHEN '13.0.2213.0' Then 'SQL Server 2016 RTM CU8'
	WHEN '13.0.2210.0' Then 'SQL Server 2016 RTM CU7'
	WHEN '13.0.2204.0' Then 'SQL Server 2016 RTM CU6'
	WHEN '13.0.2197.0' Then 'SQL Server 2016 RTM CU5'
	WHEN '13.0.2193.0' Then 'SQL Server 2016 RTM CU4'
	WHEN '13.0.2186.6' Then 'SQL Server 2016 RTM CU3'
	WHEN '13.0.2170.0' Then 'SQL Server 2016 RTM + FIX: On-demand hotfix update package for CU2 RTM (KB3199171)'
	WHEN '13.0.2169.0' Then 'SQL Server 2016 RTM CU2 + 	FIX: On-demand hotfix update package for CU2 RTM (KB3195813)'
	WHEN '13.0.2164.0' Then 'SQL Server 2016 RTM CU2'
	WHEN '13.0.2149.0' Then 'SQL Server 2016 RTM CU1'
	WHEN '13.0.1745.2' Then 'SQL Server 2016 RTM +	Security Update for SQL Server 2016 RTM GDR (KB4058560)	'
	WHEN '13.0.1742.0' Then 'SQL Server 2016 RTM + Security Update for SQL Server 2016 RTM GDR (KB4019088)'
	WHEN '13.0.1728.2' Then 'SQL Server 2016 RTM + GDR update package for SQL Server 2016 RTM (KB3210111)'
	WHEN '13.0.1722.0' Then 'SQL Server 2016 RTM + MS16-136: Security Update for SQL Server 2016 GDR (KB3194716)'
	WHEN '13.0.1711.0' Then 'SQL Server 2016 RTM + FIX: Processing a partition causes data loss on other partitions after the database is restored in SQL Server 2016 (1200) (KB3179258)'
	WHEN '13.0.1708.0' Then 'SQL Server 2016 RTM + 	Critical update for SQL Server 2016 MSVCRT prerequisite'
	WHEN '13.0.1601.5' Then 'SQL Server 2016 RTM'
	WHEN '13.00.500.53' Then 'Microsoft SQL Server 2016 Community Technology Preview 2.3 (CTP2.3)'
	WHEN '13.00.407.1' Then 'Microsoft SQL Server 2016 Community Technology Preview 2.2 (CTP2.2)'
	WHEN '13.00.400.91' Then 'Microsoft SQL Server 2016 Community Technology Preview 2.2 (CTP2.2) [withdrawn]'
	WHEN '13.00.300.44' Then 'Microsoft SQL Server 2016 Community Technology Preview 2.1 (CTP2.1)'
	WHEN '13.00.200.172' Then 'Microsoft SQL Server 2016 Community Technology Preview 2 (CTP2)'


	WHEN '12.0.6329.1' Then 'SQL Server 2014 Service Pack 3 CU4'
	WHEN '12.0.6293.0' Then 'SQL Server 2014 Service Pack 3 CU3 + Security Update for SP3 CU3 GDR (KB4505422)'
	WHEN '12.0.6259.0' Then 'SQL Server 2014 Service Pack 3 CU3'
	WHEN '12.0.6214.1' Then 'SQL Server 2014 Service Pack 3 CU2'
	WHEN '12.0.6205.1' Then 'SQL Server 2014 Service Pack 3 CU1'
	WHEN '12.0.6108.1' Then 'SQL Server 2014 Service Pack 3 + Security update for SP3 GDR (KB4505218)'
	WHEN '12.0.6024.0' Then 'SQL Server 2014 Service Pack 3'
	WHEN '12.0.5687.1' Then 'SQL Server 2014 Service Pack 2 CU18'
	WHEN '12.0.5659.1' Then 'SQL Server 2014 Security update for SP2 CU17 GDR (KB4505419)'
	WHEN '12.0.5632.1' Then 'SQL Server 2014 Service Pack 2 CU17'
	WHEN '12.0.5626.1' Then 'SQL Server 2014 Service Pack 2 CU16'
	WHEN '12.0.5605.1' Then 'SQL Server 2014 Service Pack 2 CU15'
	WHEN '12.0.5600.1' Then 'SQL Server 2014 Service Pack 2 CU14'
	WHEN '12.0.5590.1' Then 'SQL Server 2014 Service Pack 2 CU13'
	WHEN '12.0.5589.7' Then 'SQL Server 2014 Service Pack 2 CU12'
	WHEN '12.0.5579.0' Then 'SQL Server 2014 Service Pack 2 CU11'
	WHEN '12.0.5571.0' Then 'SQL Server 2014 Service Pack 2 CU10'
	WHEN '12.0.5563.0' Then 'SQL Server 2014 Service Pack 2 CU9'
	WHEN '12.0.5557.0' Then 'SQL Server 2014 Service Pack 2 CU8'
	WHEN '12.0.5556.0' Then 'SQL Server 2014 Service Pack 2 CU7'
	WHEN '12.0.5553.0' Then 'SQL Server 2014 Service Pack 2 CU6'
	WHEN '12.0.5546.0' Then 'SQL Server 2014 Service Pack 2 CU5'
	WHEN '12.0.5540.0' Then 'SQL Server 2014 Service Pack 2 CU4'
	WHEN '12.0.5538.0' Then 'SQL Server 2014 Service Pack 2 CU3'
	WHEN '12.0.5532.0' Then 'SQL Server 2014 Service Pack 2  + Security Update for SP2 CU2 (KB3194718)'
	WHEN '12.0.5522.0' Then 'SQL Server 2014 Service Pack 2 CU2'
	WHEN '12.0.5511.0' Then 'SQL Server 2014 Service Pack 2 CU1'
	WHEN '12.0.5223.6' Then 'SQL Server 2014 Service Pack 2 + 	Security update for SP2 GDR (KB4505419)'
	WHEN '12.0.5214.6' Then 'SQL Server 2014 Service Pack 2 + 	Security Update SP2 GDR (KB4057120)'
	WHEN '12.0.5207.0' Then 'SQL Server 2014 Service Pack 2 +	Security Update SP2 GDR (KB4019093)'
	WHEN '12.0.5203.0' Then 'SQL Server 2014 Service Pack 2 + Security Update SP2 GDR (KB3194714)'
	WHEN '12.0.5000.0' Then 'SQL Server 2014 Service Pack 2'
	WHEN '12.0.4522.0' Then 'SQL Server 2014 Service Pack 1 CU13'
	WHEN '12.0.4511.0' Then 'SQL Server 2014 Service Pack 1 CU12'
	WHEN '12.0.4502.0' Then 'SQL Server 2014 Service Pack 1 CU11'
	WHEN '12.0.4491.0' Then 'SQL Server 2014 Service Pack 1 CU10'
	WHEN '12.0.4487.0' Then 'SQL Server 2014 Service Pack 1 CU9 + Security Update (KB3194722)'
	WHEN '12.0.4474.0' Then 'SQL Server 2014 Service Pack 1 CU9'
	WHEN '12.0.4468.0' Then 'SQL Server 2014 Service Pack 1 CU8'
	WHEN '12.0.4463.0' Then 'SQL Server 2014 Service Pack 1 CU7 + FIX: A memory leak occurs when you use Azure Storage in SQL Server 2014 (KB3174370)'
	WHEN '12.0.4459.0' Then 'SQL Server 2014 Service Pack 1 CU7'
	WHEN '12.0.4457.0' Then 'SQL Server 2014 Service Pack 1 CU6 (re-released) for Microsoft SQL Server 2014 SP1 (KB3167392)'
	WHEN '12.0.4449.0' Then 'SQL Server 2014 Service Pack 1 CU6 (replaced) for Microsoft SQL Server 2014 SP1 (KB3144524)'
	WHEN '12.0.4439.1' Then 'SQL Server 2014 Service Pack 1 CU5'
	WHEN '12.0.4437.0' Then 'SQL Server 2014 Service Pack 1 CU4 + update package for SQL Server 2014 SP1 CU4 (KB3130999)'
	WHEN '12.0.4436.0' Then 'SQL Server 2014 Service Pack 1 CU4'
	WHEN '12.0.4427.24' Then 'SQL Server 2014 Service Pack 1 CU3'
	WHEN '12.00.4427' Then 'SQL Server 2014 Service Pack 1 CU3'
	WHEN '12.00.4422' Then 'SQL Server 2014 Service Pack 1 CU2 '
	WHEN '12.00.4416' Then 'SQL Server 2014 Service Pack 1 CU1'
	WHEN '12.00.4213' Then 'SQL Server 2014 Service Pack 1 GDR'
	WHEN '12.00.4100' Then 'SQL Server 2014 Service Pack 1 (SP1)'
	WHEN '12.00.4050' Then 'SQL Server 2014 Service Pack 1 (SP1) [withdrawn]'
	WHEN '12.00.2556' Then 'SQL Server 2014 CU10'
	WHEN '12.00.2553' Then ' SQL Server 2014 CU9'
	WHEN '12.00.2548' Then 'SQL Server 2014 CU8 QFE'
	WHEN '12.00.2546' Then 'SQL Server 2014 CU8'
	WHEN '12.00.2506' Then '3063054 Update enables Premium Storage support for Data files on Azure Storage and resolves backup failures SQL Server 2014 CU7'
	WHEN '12.00.2505' Then '3052167 FIX: Error 1205 when you execute parallel query that contains outer join operators in SQL Server 2014 CU7'
	WHEN '12.00.2504' Then '2999809 FIX: Poor performance when a query contains table joins in SQL Server 2014 CU7'
	WHEN '12.00.2504' Then '3058512 FIX: Unpivot Transformation task changes null to zero or empty strings in SSIS 2014 SQL Server 2014 CU7'
	WHEN '12.00.2495' Then 'SQL Server 2014 CU7'
	WHEN '12.00.2488' Then '3048751 FIX: Deadlock cannot be resolved automatically when you run a SELECT query that can result in a parallel batch-mode scan  SQL Server 2014  CU6'
	WHEN '12.00.2485' Then '3043788 An on-demand hotfix update package is available for SQL Server 2014  CU6'
	WHEN '12.00.2480' Then 'SQL Server 2014 CU6'
	WHEN '12.00.2474' Then '3034679 FIX: AlwaysOn availability groups are reported as NOT SYNCHRONIZING SQl server 2014 cu5'
	WHEN '12.00.2472' Then '3032087 FIX: Cannot show requested dialog after you connect to the latest SQL Database Update V12 (preview) with SQL Server 2014  CU5'
	WHEN '12.00.2464' Then '3024815 Large query compilation waits on RESOURCE_SEMAPHORE_QUERY_COMPILE in SQL Server 2014  CU5'
	WHEN '12.00.2456' Then 'SQL Server 2014  CU5'
	WHEN '12.00.2436' Then '3014867 FIX: "Remote hardening failure" exception cannot be caught and a potential data loss when you use SQL Server 2014  CU4'
	WHEN '12.00.2430' Then 'SQL Server 2014  CU4'
	WHEN '12.00.2423' Then '3007050 FIX: RTDATA_LIST waits when you run natively stored procedures that encounter expected failures in SQL Server 2014 CU3'
	WHEN '12.00.2405' Then '2999809 FIX: Poor performance when a query contains table joins in SQL Server 2014  CU3'
	WHEN '12.00.2402' Then 'SQL Server 2014 CU3'
	WHEN '12.00.2381' Then 'SQL Server 2014  CU2 (QFE) - 2977316 '
	WHEN '12.00.2370' Then 'SQL Server 2014 CU2'
	WHEN '12.00.2342' Then 'SQL Server 2014 CU1'
	WHEN '12.00.2269' Then 'SQL Server 2014 RTM -3045324 MS15-058: Description of the security update for SQL Server 2014 GDR: July 14, 2015'
	WHEN '12.0.2269.0' Then 'SQL Server 2014 RTM - 3045324 MS15-058: Description of the security update for SQL Server 2014 GDR: July 14, 2015'
	WHEN '12.00.2254' Then 'SQL Server 2014 RTM - 2977315 MS14-044: Description of the security update for SQL Server 2014 (GDR)'
	WHEN '12.00.2000' Then 'SQL Server 2014 RTM'
	WHEN '12.00.1524' Then 'Microsoft SQL Server 2014 Community Technology Preview 2 (CTP2)'

	

	WHEN '11.0.7469.6' Then 'SQL Server 2012 SP4 +On-demand hotfix update package for SQL Server 2012 SP4 (KB4091266)'
	WHEN '11.0.7462.6' Then 'SQL Server 2012 SP4 GDR (KB4057116)'
	WHEN '11.0.7001.0' Then 'SQL Server 2012 SP4'
	WHEN '11.0.6615.2' Then 'SQL Server 2012 SP3 CU10 + CU (KB4057121)'
	WHEN '11.0.6607.3' Then 'SQL Server 2012 SP3 CU10'
	WHEN '11.0.6598.0' Then 'SQL Server 2012 SP3 CU9'
	WHEN '11.0.6594.0' Then 'SQL Server 2012 SP3 CU8'
	WHEN '11.0.6579.0' Then 'SQL Server 2012 SP3 CU7'
	WHEN '11.0.6567.0' Then 'SQL Server 2012 SP3 CU6'
	WHEN '11.0.6544.0' Then 'SQL Server 2012 SP3 CU5'
	WHEN '11.0.6540.0' Then 'SQL Server 2012 SP3 CU4'
	WHEN '11.0.6537.0' Then 'SQL Server 2012 SP3 CU3'
	WHEN '11.0.6523.0' Then 'SQL Server 2012 SP3 CU2'
	WHEN '11.0.6518.0' Then 'SQL Server 2012 SP3 CU1'
	WHEN '11.0.6260.1' Then 'SQL Server 2012 SP3 GDR (KB4057115)'
	WHEN '11.0.6251.0' Then 'SQL Server 2012 SP3 GDR (KB4019092)'
	WHEN '11.0.6248.0' Then 'SQL Server 2012 SP3 SP3 GDR (KB3194721)'
	WHEN '11.0.6216.27' Then 'SQL Server 2012 SP3 SP3 GDR (KB4019092'
	WHEN '11.0.6020'	Then 'SQL Server 2012 SP3'
	WHEN '11.0.5678.0' Then 'SQL Server 2012 SP2 CU16'
	WHEN '11.0.5676.0' Then 'SQL Server 2012 SP2 CU15'
	WHEN '11.0.5657.0' Then 'SQL Server 2012 SP2 CU14'
	WHEN '11.0.5655.0' Then 'SQL Server 2012 SP2 CU13'
	WHEN '11.0.5649.0' Then 'SQL Server 2012 SP2 CU12'
	WHEN '11.0.5646.0' Then 'SQL Server 2012 SP2 CU11'
	WHEN '11.0.5644.2' Then 'SQL Server 2012 SP2 CU10'
	WHEN '11.0.5641' Then 'SQL Server 2012 SP2 CU9'
	WHEN '11.0.5634.1' Then 'SQL Server 2012 SP2 CU8'

	WHEN '11.0.5623.0' Then 'SQL Server 2012 SP2 CU7'
	WHEN '11.0.5592.0' Then 'SQL Server 2012 SP2 CU6'
	WHEN '11.0.5582.0' Then 'SQL Server 2012 SP2 CU5'
	WHEN '11.0.5569.0' Then 'SQL Server 2012 SP2 CU4'
	WHEN '11.0.5556.0' Then 'SQL Server 2012 SP2 CU3'
	WHEN '11.0.5548.0' Then 'SQL Server 2012 SP2 CU2'
	WHEN '11.0.5532.0' Then 'SQL Server 2012 SP2 CU1'
	WHEN '11.0.5058.0' THEN 'SQL Server 2012 SP2'
	WHEN '11.0.3431.0' THEN 'SQL Server 2012 SP1 CU10'
	WHEN '11.0.3412.0' THEN 'SQL Server 2012 SP1 CU9'
	WHEN '11.0.3401.0' THEN 'SQL Server 2012 SP1 CU8'
	WHEN '11.0.3393.0' THEN 'SQL Server 2012 SP1 CU7'
	WHEN '11.0.3381.0' THEN 'SQL Server 2012 SP1 CU6'
	WHEN '11.0.3373.0' THEN 'SQL Server 2012 SP1 CU5'
	WHEN '11.0.3368.0' THEN 'SQL Server 2012 SP1 CU4'
	WHEN '11.0.3349.0' THEN 'SQL Server 2012 SP1 CU3'
	WHEN '11.0.3339.0' THEN 'SQL Server 2012 SP1 CU2'
	WHEN '11.0.3321.0' THEN 'SQL Server 2012 SP1 CU1'
	WHEN '11.0.3000.0' THEN 'SQL Server 2012 SP1'
	WHEN '11.0.2424.0' THEN 'SQL Server 2012 CU11'
	WHEN '11.0.2420.0' THEN 'SQL Server 2012 CU10'
	WHEN '11.0.2419.0' THEN 'SQL Server 2012 CU9'
	WHEN '11.0.2410.0' THEN 'SQL Server 2012 CU8'
	WHEN '11.0.2405.0' THEN 'SQL Server 2012 CU7'
	WHEN '11.0.2401.0' THEN 'SQL Server 2012 CU6'
	WHEN '11.0.2395.0' THEN 'SQL Server 2012 CU5'
	WHEN '11.0.3350.0' THEN 'SQL Server 2012 CU4'
	WHEN '11.0.2383.0' THEN 'SQL Server 2012 CU4'
	WHEN '11.0.2332.0' THEN 'SQL Server 2012 CU3'
	WHEN '11.0.2325.0' THEN 'SQL Server 2012 CU2'
	WHEN '11.0.2316.0' THEN 'SQL Server 2012 CU1'
	WHEN '10.0.1600.22' THEN 'SQL Server 2012 RTM'


	WHEN '10.50.6529' THEN 'SQL Server 2008 R2 	SP3 QFE'
	WHEN '10.50.6525' THEN 'SQL Server 2008 R2 	SP3 (KB3033860)'
	WHEN '10.50.6220' THEN 'SQL Server 2008 R2 	SP3 GDR'
	WHEN '10.50.6000' THEN 'SQL Server 2008 R2 	Service Pack 3'
	WHEN '10.50.4339' THEN 'SQL Server 2008 R2 	SP2 CU13 QFE (KB3045312)'
	WHEN '10.50.4339.0' THEN 'SQL Server 2008 R2 	SP2 CU13 QFE (KB3045312)'
	WHEN '10.50.4331' THEN 'SQL Server 2008 R2 	SP2 CU13 QFE (KB2977319)'
	WHEN '10.50.4319' THEN 'SQL Server 2008 R2 	SP2 CU13' 
	WHEN '10.50.4305' THEN 'SQL Server 2008 R2 	SP2 CU12'
	WHEN '10.50.4302' THEN 'SQL Server 2008 R2 	SP2 CU11'
	WHEN '10.50.4297' THEN 'SQL Server 2008 R2 	SP2 CU10' 
	WHEN '10.50.4295' THEN 'SQL Server 2008 R2 	SP2 CU9' 
	WHEN '10.50.4290' THEN 'SQL Server 2008 R2 	SP2 CU8' 
	WHEN '10.50.4286' THEN 'SQL Server 2008 R2 	SP2 CU7' 
	WHEN '10.50.4285' THEN 'SQL Server 2008 R2 	SP2 CU6 re-released (KB2830140)'
	WHEN '10.50.4279' THEN 'SQL Server 2008 R2 	SP2 CU6 (replaced)'
	WHEN '10.50.4276' THEN 'SQL Server 2008 R2 	SP2 CU5' 
	WHEN '10.50.4270' THEN 'SQL Server 2008 R2 	SP2 CU4'
	WHEN '10.50.4266' THEN 'SQL Server 2008 R2 	SP2 CU3' 
	WHEN '10.50.4263' THEN 'SQL Server 2008 R2 	SP2 CU2'
	WHEN '10.50.4260' THEN 'SQL Server 2008 R2 	SP2 CU1'
	WHEN '10.50.4042' THEN 'SQL Server 2008 R2 	SP2 GDR (KB3045313)'
	WHEN '10.50.4033' THEN 'SQL Server 2008 R2 	SP2 GDR (KB2977320)'
	WHEN '10.50.2811.0' THEN 'SQL Server 2008 R2 SP1 CU6'
	WHEN '10.50.2806.0' THEN 'SQL Server 2008 R2 SP1 CU5'
	WHEN '10.50.2796.0' THEN 'SQL Server 2008 R2 SP1 CU4'
	WHEN '10.50.2789.0' THEN 'SQL Server 2008 R2 SP1 CU3'
	WHEN '10.50.2772.0' THEN 'SQL Server 2008 R2 SP1 CU2'
	WHEN '10.50.2769.0' THEN 'SQL Server 2008 R2 SP1 CU1'
	WHEN '10.50.2500.0' THEN 'SQL Server 2008 R2 SP1'
	WHEN '10.50.1815' THEN 'SQL Server 2008 R2 CU13'
	WHEN '10.50.1810' THEN 'SQL Server 2008 R2 CU12'
	WHEN '10.50.1809' THEN 'SQL Server 2008 R2 CU11'
	WHEN '10.50.1807.0' THEN 'SQL Server 2008 R2 CU10'
	WHEN '10.50.1804.0' THEN 'SQL Server 2008 R2 CU9'
	WHEN '10.50.1797.0' THEN 'SQL Server 2008 R2 CU8'
	WHEN '10.50.1777.0' THEN 'SQL Server 2008 R2 CU7'
	WHEN '10.50.1765.0' THEN 'SQL Server 2008 R2 CU6'
	WHEN '10.50.1753.0' THEN 'SQL Server 2008 R2 CU5'
	WHEN '10.50.1746.0' THEN 'SQL Server 2008 R2 CU4'
	WHEN '10.50.1734.0' THEN 'SQL Server 2008 R2 CU3'
	WHEN '10.50.1720.0' THEN 'SQL Server 2008 R2 CU2'
	WHEN '10.50.1702.0' THEN 'SQL Server 2008 R2 CU1'
	WHEN '10.50.1600.1' THEN 'SQL Server 2008 R2 RTM'
	WHEN '10.00.5775' THEN 'SQL Server 2008 SP3 CU4'
	WHEN '10.00.5770' THEN 'SQL Server 2008 SP3 CU3'
	WHEN '10.00.5768' THEN 'SQL Server 2008 SP3 CU2'
	WHEN '10.00.5766' THEN 'SQL Server 2008 SP3 CU1'
	WHEN '10.00.5500' THEN 'SQL Server 2008 SP3'
	when '10.0.4064.0' THEN'SQL Server 2008 SP2 CU9 - 2494089 MS11-049: Description of the security update for SQL Server 2008 Service Pack 2 GDR: June 14, 2011'
	WHEN '10.00.4330' THEN 'SQL Server 2008 SP2 CU9'
	WHEN '10.00.4326' THEN 'SQL Server 2008 SP2 CU8'
	WHEN '10.00.4323' THEN 'SQL Server 2008 SP2 CU7'
	WHEN '10.00.4321' THEN 'SQL Server 2008 SP2 CU6'
	WHEN '10.00.4316' THEN 'SQL Server 2008 SP2 CU5'
	WHEN '10.00.4285' THEN 'SQL Server 2008 SP2 CU4'
	WHEN '10.00.4279' THEN 'SQL Server 2008 SP2 CU3'
	WHEN '10.00.4272' THEN 'SQL Server 2008 SP2 CU2'
	WHEN '10.00.4266' THEN 'SQL Server 2008 SP2 CU1'
	WHEN '10.00.4000' THEN 'SQL Server 2008 SP2'
	WHEN '10.00.2850' THEN 'SQL Server 2008 SP1 CU16'
	WHEN '10.00.2847' THEN 'SQL Server 2008 SP1 CU15'
	WHEN '10.00.2816' THEN 'SQL Server 2008 SP1 CU13'
	WHEN '10.00.2812' THEN 'SQL Server 2008 SP1 CU14'
	WHEN '10.00.2808' THEN 'SQL Server 2008 SP1 CU12'
	WHEN '10.00.2804' THEN 'SQL Server 2008 SP1 CU11'
	WHEN '10.00.2799' THEN 'SQL Server 2008 SP1 CU10'
	WHEN '10.00.2789' THEN 'SQL Server 2008 SP1 CU9'
	WHEN '10.00.2775' THEN 'SQL Server 2008 SP1 CU8'
	WHEN '10.00.2766' THEN 'SQL Server 2008 SP1 CU7'
	WHEN '10.00.27.57.00' THEN 'SQL Server 2008 SP1 CU6'
	WHEN '10.00.2746.00' THEN 'SQL Server 2008 SP1 CU5'
	WHEN '10.00.2734.00' THEN 'SQL Server 2008 SP1 CU4'
	WHEN '10.00.2723.00' THEN 'SQL Server 2008 SP1 CU3'
	WHEN '10.00.2714.00' THEN 'SQL Server 2008 SP1 CU2'
	WHEN '10.00.2710.00' THEN 'SQL Server 2008 SP1 CU1'
	WHEN '10.00.2531.00' THEN 'SQL Server 2008 SP1'
	WHEN '10.00.1828.00' THEN 'SQL Server 2008 RTM CU9'
	WHEN '10.00.1823.00' THEN 'SQL Server 2008 RTM CU8'
	WHEN '10.00.1818.00' THEN 'SQL Server 2008 RTM CU7'
	WHEN '10.00.1812.00' THEN 'SQL Server 2008 RTM CU6'
	WHEN '10.00.1806.00' THEN 'SQL Server 2008 RTM CU5'
	WHEN '10.00.1798.00' THEN 'SQL Server 2008 RTM CU4'
	WHEN '10.00.1787.00' THEN 'SQL Server 2008 RTM CU3'
	WHEN '10.00.1779.00' THEN 'SQL Server 2008 RTM CU2'
	WHEN '10.00.1763.00' THEN 'SQL Server 2008 RTM CU1'
	WHEN '10.00.1600.00' THEN 'SQL Server 2008 RTM'

	WHEN '9.00.4285.00' THEN 'SQL Server 2005 SP3 CU8'
	WHEN '9.00.4273.00' THEN 'SQL Server 2005 SP3 CU7'
	WHEN '9.00.4266.00' THEN 'SQL Server 2005 SP3 CU6'
	WHEN '9.00.4230.00' THEN 'SQL Server 2005 SP3 CU5'
	WHEN '9.00.4226.00' THEN 'SQL Server 2005 SP3 CU4'
	WHEN '9.00.4220.00' THEN 'SQL Server 2005 SP3 CU3'
	WHEN '9.00.4211.00' THEN 'SQL Server 2005 SP3 CU2'
	WHEN '9.00.4207.00' THEN 'SQL Server 2005 SP3 CU1'
	WHEN '9.00.4053.00' THEN 'SQL Server 2005 SP3 GDR (Security Update)'
	WHEN '9.00.4035.00' THEN 'SQL Server 2005 SP3'
	WHEN '9.00.3356.00' THEN 'SQL Server 2005 SP2 CU17'
	WHEN '9.00.3355.00' THEN 'SQL Server 2005 SP2 CU16'
	WHEN '9.00.3330.00' THEN 'SQL Server 2005 SP2 CU15'
	WHEN '9.00.3328.00' THEN 'SQL Server 2005 SP2 CU14'
	WHEN '9.00.3225.00' THEN 'SQL Server 2005 SP2 CU13'
	WHEN '9.00.3315.00' THEN 'SQL Server 2005 SP2 CU12'
	WHEN '9.00.3310.00' THEN 'SQL Server 2005 Security Update'
	WHEN '9.00.3301.00' THEN 'SQL Server 2005 SP2 CU11'
	WHEN '9.00.3294.00' THEN 'SQL Server 2005 SP2 CU10'
	WHEN '9.00.3282.00' THEN 'SQL Server 2005 SP2 CU9'
	WHEN '9.00.3257.00' THEN 'SQL Server 2005 SP2 CU8'
	WHEN '9.00.3239.00' THEN 'SQL Server 2005 SP2 CU7'
	WHEN '9.00.3233.00' THEN 'SQL Server 2005 QFE Security Update'
	WHEN '9.00.3228.00' THEN 'SQL Server 2005 SP2 CU6'
	WHEN '9.00.3215.00' THEN 'SQL Server 2005 SP2 CU5'
	WHEN '9.00.3200.00' THEN 'SQL Server 2005 SP2 CU4'
	WHEN '9.00.3186.00' THEN 'SQL Server 2005 SP2 CU3'
	WHEN '9.00.3175.00' THEN 'SQL Server 2005 SP2 CU2'
	WHEN '9.00.3161.00' THEN 'SQL Server 2005 SP2 Cumulative Update 1 (CU1)'
	WHEN '9.00.3152.00' THEN 'SQL Server 2005 SP2 Cumulative Hotfix'
	WHEN '9.00.3077.00' THEN 'SQL Server 2005 Security Update'
	WHEN '9.00.3054.00' THEN 'KB934458 - Also read Bob Ward''s post on SP2.'
	WHEN '9.00.3042.01.00' THEN 'SQL Server 2005 "SP2a"'
	WHEN '9.00.3042.00' THEN 'SQL Server 2005 SP2'
	WHEN '9.00.2047.00' THEN 'SQL Server 2005 SP1'
	WHEN '9.00.1399.00' THEN 'SQL Server 2005 RTM'

	WHEN '8.00.2039.00' THEN 'SQL Server 2000 SP4'
	WHEN '8.00.760.00' THEN 'SQL Server 2000 SP3'
	WHEN '8.00.534.00' THEN 'SQL Server 2000 SP2'
	WHEN '8.00.384.00' THEN 'SQL Server 2000 SP1'
	WHEN '8.00.194.00' THEN 'SQL Server 2000 RTM'

	WHEN '7.00.1063.00' THEN 'SQL Server 7.0 SP4'
	WHEN '7.00.961.00' THEN 'SQL Server 7.0 SP3'
	WHEN '7.00.842.00' THEN 'SQL Server 7.0 SP2'
	WHEN '7.00.699.00' THEN 'SQL Server 7.0 SP1'
	WHEN '7.00.623.00' THEN 'SQL Server 7.0 / MSDE 1.0 RTM'

	WHEN '6.50.416.00' THEN 'SQL Server 6.5 with Service Pack 5a'
	WHEN '6.50.415.00' THEN 'SQL Server 6.5 with Service Pack 5'
	WHEN '6.50.281.00' THEN 'SQL Server 6.5 with Service Pack 4'
	WHEN '6.50.258.00' THEN 'SQL Server 6.5 with Service Pack 3'
	WHEN '6.50.240.00' THEN 'SQL Server 6.5 with Service Pack 2'
	WHEN '6.50.213.00' THEN 'SQL Server 6.5 with Service Pack 1'
	WHEN '6.50.201.00' THEN 'SQL Server 6.5 RTM'
	ELSE 'Other'
	END
	,[OS Version] = Case ISNULL(@windows_release,N'')
		When N'10.0*' Then 'Windows 10 or Windows Server Technical Preview'
		--When N'10.0*' Then 'Windows Server Technical Preview'
		--When N'6.3*' Then 'Windows 8.1'
		When N'6.3*' Then 'Windows 8.1 or Windows Server 2012 R2'
		When N'6.3' Then 'Windows 8.1 or Windows Server 2012 R2'
		--When N'6.2' Then 'Windows 8'
		When N'6.2' Then 'Windows 8 or Windows Server 2012'
		--When N'6.1' Then 'Windows 7'
		When N'6.1' Then 'Windows 7 or Windows Server 2008 R2'
		When N'6' Then 'Windows Vista or Windows Server 2008'
		--When N'6' Then 'Windows Vista'
		When N'5.2' Then 'Windows Server 2003 or Windows Server 2003 R2 or Windows XP 64-Bit Edition'
		--When N'5.2' Then 'Windows Server 2003'
		--When N'5.2' Then 'Windows XP 64-Bit Edition'
		When N'5.1' Then 'Windows XP'
		When N'5' Then 'Windows 2000'
		Else 'Unknown' End
	,@serverRAM as 'RAM_MB'
	,cast(cast(@serverRAM as decimal (18,2))/1024 as decimal (18,2))as 'RAM_GB'
	,@desc as system_memory_state_desc
	,@windows_release as windows_release
	,@osLanguage as os_language_version
	,@windowssku as windows_sku
	,@@VERSION AS '@@VERSION'







--get tempdb objects, including version store info
SELECT	SUM (user_object_reserved_page_count)*8 as Tempdb_usr_obj_kb,
		SUM (internal_object_reserved_page_count)*8 as Tempdb_internal_obj_kb,
		(SUM (internal_object_reserved_page_count)*8)/1024 as Tempdb_internal_obj_mb,
		SUM (version_store_reserved_page_count)*8 as Tempdb_version_store_kb
FROM  tempdb.sys.dm_db_file_space_usage

/************************************************************************************
	BACKUP REPORT
************************************************************************************/
IF @ShowBackupReport = 1
BEGIN
	SELECT 'Backup Report' as 'Backup Report'
	SELECT 
		d.name as [Database]
		,d.recovery_model_desc As [Recovery Model]
		,d.state_desc
		,MAX(CASE WHEN b.type = 'D' THEN b.backup_finish_date ELSE NULL END) AS [Last Full Backup]
		,DATEDIFF(HOUR,MAX(CASE WHEN b.type = 'D' THEN b.backup_finish_date ELSE NULL END), GETDATE())AS [Hours Since Full] 
		,MAX(CASE WHEN b.type = 'I' THEN b.backup_finish_date ELSE NULL END) AS[ Last Differential Backup]
		,DATEDIFF(HOUR,MAX(CASE WHEN b.type = 'I' THEN b.backup_finish_date ELSE NULL END), GETDATE())AS [Hours Since Diff] 
		,MAX(CASE WHEN b.type = 'L' THEN b.backup_finish_date ELSE NULL END) AS [Last Log Backup]
		,DATEDIFF(MINUTE,MAX(CASE WHEN b.type = 'L' THEN b.backup_finish_date ELSE NULL END), GETDATE())AS [Minutes Since Log] 
		,d.is_read_only
		,d.is_in_standby
	 FROM	
		master.sys.databases d
		left join msdb.dbo.backupset b on d.name = b.database_name
	WHERE
		d.name != 'tempdb'
		AND b.machine_name = cast(SERVERPROPERTY('ComputerNamePhysicalNetBIOS') as sysname)

	GROUP BY
		d.name 
		,d.recovery_model_desc
		,d.state_desc
		,d.is_read_only
		,d.is_in_standby
	ORDER BY 
		d.name
END
/**********************************************
		SPACE REPORT
***********************************************/
If @ShowSpaceReport = 1
Begin
	If Exists(select value_in_use  FROM sys.configurations where name = 'xp_cmdshell' and value_in_use =1)
	Begin

		--declare @pformat			varchar(10) = 'SERVER' --OR INSTANCE
		--declare @vOutput			varchar(10) = 'SCREEN';
		declare @vSQL				NVARCHAR(1000);
		declare @tDrvLetter			TABLE (drive VARCHAR(500));
		declare @vMsg				varchar(1000);
		declare @vCurrentRuntime	datetime
		DECLARE @toutput1 TABLE (Col1 VARCHAR(2048));
		
		SET @vCurrentRuntime = getdate();

		SET ARITHIGNORE ON
		SET NOCOUNT ON

		DECLARE @tDrvInfo TABLE(
			drive VARCHAR(500) null,
			[MB free] DECIMAL(20,2),
			[MB TotalSize] DECIMAL(20,2),
			[Volume Name] VARCHAR(64),
			[Pct Free] DECIMAL(20,2)
			);

		INSERT INTO @tDrvLetter
		EXEC xp_cmdshell 'wmic volume where drivetype="3" get caption, freespace, capacity, label';

		DELETE FROM @tDrvLetter
		WHERE drive IS NULL OR len(drive) < 4 OR drive LIKE '%Capacity%' OR drive LIKE  '%\\%\Volume%';


		DECLARE @STRLine VARCHAR(max);
		DECLARE @drive varchar(500);
		DECLARE @TotalSize REAL;
		DECLARE @Freesize REAL;
		DECLARE @VolumeName VARCHAR(64);

		WHILE EXISTS(SELECT 1 FROM @tDrvLetter)
		BEGIN
			SET ROWCOUNT 1;
			SELECT @STRLine = drive FROM @tDrvLetter;

			-- Get TotalSize
			SET @TotalSize= CAST(LEFT(@STRLine,CHARINDEX(' ',@STRLine)) AS REAL)/1024/1024;
			--SELECT @TotalSize

			-- Remove Total Size
			SET @STRLine = REPLACE(@STRLine, LEFT(@STRLine,CHARINDEX(' ',@STRLine)),'');
			-- Get drive

			SET @drive = LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine)));
			--SELECT @drive

			SET @STRLine = RTRIM(LTRIM(REPLACE(LTRIM(@STRLine), LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))),'')));

			SET @Freesize = CAST(LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))) as REAL)/1024/1024;
			--SELECT @Freesize/1024/1024

			SET @STRLine = RTRIM(LTRIM(REPLACE(LTRIM(@STRLine), LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))),'')));
			SET @VolumeName = @STRLine;
			-- 

			INSERT INTO @tDrvInfo SELECT @drive, @Freesize, @TotalSize, @VolumeName,@Freesize/@TotalSize*100;

			DELETE FROM @tDrvLetter;
		END

		SET ROWCOUNT 0

		-- POPULATE TEMP TABLE WITH LOGICAL DISKS
		-- This is FIX/Workaround for Windows 2003 bug that WMIC doesn't return volume name that is over X number of charactors.
		SET @vSQL ='wmic /FailFast:ON logicaldisk where (drivetype ="3" and volumename!="RECOVERY" AND volumename!="System Reserved") get deviceid,volumename  /Format:csv'


		INSERT INTO @toutput1
		EXEC master..xp_cmdshell @vSQL;
		--select '@toutput1' as  'DEBUGGING 1', * from @toutput1
		DELETE @toutput1 where ltrim(Col1) is null or len(Col1) = 1 or Col1 like 'Node,DeviceID,VolumeName%'
		or Col1 Like 'Node%' or Col1 like '%RPC Server not available.%';
		--select '@toutput1' as  'DEBUGGING 2', * from @toutput1
		DECLARE @tlogicaldisk TABLE (DeviceID varchar(128),VolumeName varchar(256));
		DECLARE @NodeName varchar(128);
		SET @NodeName = (SELECT TOP 1 LEFT(Col1, CHARINDEX(',',Col1)) FROM @toutput1);

		-- Clean up server name
		UPDATE @toutput1 SET Col1 = REPLACE(Col1, @NodeName, '');


		INSERT INTO @tlogicaldisk
		SELECT LEFT(Col1, CHARINDEX(',',Col1)-2),  SUBSTRING(Col1, CHARINDEX(',',Col1)+1, LEN(Col1))
		FROM @toutput1;


		UPDATE dr
		SET dr.[Volume Name] = ld.VolumeName
			FROM @tDrvInfo dr RIGHT OUTER JOIN @tlogicaldisk ld ON left(dr.drive,1) = ld.DeviceID
		WHERE LEN([Volume Name]) = 1


			SELECT CASE
					WHEN LEN(drive) = 3 THEN LEFT(drive,1)
					ELSE drive
				END AS drive
				,[MB free]
				,[MB TotalSize]
				,[Volume Name]
				,[Pct Free]
				,cast([MB TotalSize]/1024 AS DECIMAL(18,2)) as GB_TotalSize
				,cast([MB free]/1024 as DECIMAL(18,2)) as GB_Free
			FROM @tDrvInfo
			ORDER BY 1;


		IF OBJECT_ID('tempdb..#Results') is not null
			DROP TABLE #Results   
	
		CREATE TABLE #Results (
			[Database Name] sysname
			,[File Name] sysname
			,[Physical Name] NVARCHAR(260)
			,[Type_Desc] VARCHAR(60)
			,[Total Size in Mb] INT
			,[Available Space in Mb] INT
		)  

		SELECT @sql =   
			N'USE [?] 
			INSERT INTO #Results([Database Name], [File Name], [Physical Name],   
				[Type_desc]
				, [Total Size in Mb]
				, [Available Space in Mb])   
			SELECT DB_NAME(),  
				[name] AS [File Name],   
				physical_name AS [Physical Name],   
				[Type_Desc],  
				CASE ceiling([size]/128)   
					WHEN 0 THEN 1  
					ELSE ceiling([size]/128)  
				END,  
				CASE ceiling([size]/128)  
				WHEN 0 THEN (1 - CAST(FILEPROPERTY([name], ''SpaceUsed''' + ') as int) /128)  
				ELSE (([size]/128) - CAST(FILEPROPERTY([name], ''SpaceUsed''' + ') as int) /128)  
				END  
			FROM sys.database_files '  

		execute sp_MSforeachdb @sql


		Select 
			 [Database Name]
			,cast(SUM([Total Size in Mb]) as money)/1024 as Size_Gb
			,Cast(sum([Available Space in Mb])as money)/1024 as Free_Gb
			,SUM([Total Size in Mb] )as Size_Mb
			,sum([Available Space in Mb]) as Free_Mb
		  From
			#Results
		Group By
			[Database Name]
		ORDER BY
			2 desc


		Select 
			 [Database Name]
			,[File Name]
			,[Physical Name]
			,[type_Desc]
			,[Total Size in Mb] 
			,[Available Space in Mb]
		  From
			#Results
		ORDER BY
			1 , 4

		IF OBJECT_ID('tempdb..#Results') is not null
			DROP TABLE #Results 
	End
	Else
	BEGIN
		RAISERROR('XP_CMDSHELL is not enabled on this instance therefore the space report will not be run.',10,1);
		EXEC xp_fixeddrives
	END
End
---- End of Space Report	--
	
select top 5 wait_type,
      count (*) 'Count'
from sys.dm_os_waiting_tasks
WHERE wait_type NOT IN (select WaitStatTypeName from dbo.WaitStats_Benign)
   
group by wait_type
	ORDER BY count (*) desc

SELECT COUNT(*) as BlockProcessCount FROM sys.dm_exec_requests where blocking_session_id != 0 ;

Select 'Currently Running Queries'
IF EXISTS(SELECT 1 FROM sys.databases WHERE name = N'FDDBA')
BEGIN
	IF  EXISTS (SELECT * FROM FDDBA.sys.objects WHERE object_id = OBJECT_ID(N'FDDBA.[dbo].[sp_WhoIsActive]') AND type in (N'P', N'PC'))
	BEGIN
		Execute FDDBA.dbo.sp_WhoIsActive @get_outer_command = 1
	END
END


	SELECT
		getdate() as CurrentDate,
		x.session_id,
		CAST(DATEDIFF(mi, x.start_time, GETDATE()) AS BIGINT) 'Run Time min',
		  RIGHT('0' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 3600 AS VARCHAR),2) + ':' +
			RIGHT('0' + CAST(( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 60) % 60 AS VARCHAR),2) + ':' +
			RIGHT('0' + CAST(DATEDIFF(SECOND, x.start_time,  GETDATE()) % 60 AS VARCHAR),2) as 'RunTime HH:MM:SS"',
		DatabaseName,
		status,
		x.host_name,
		x.login_name,
		x.wait_type,
		x.wait_resource,
		x.wait_time,
		x.start_time,
		x.totallogical_reads ,
		FDDBA.[dbo].[fFormatIntReadable]( x.totallogical_reads) AS Reads ,
		x.totalWrites,
		x.totalCPU,
		x.writes_in_tempdb,
		parallelquery
		, COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
		(
			SELECT          
				substring(text, (statement_start_offset/2)+1
					, ((case statement_end_offset
						  when -1 then datalength(text)
						  else statement_end_offset
					   end - statement_start_offset)/2) + 1)
			FROM sys.dm_exec_sql_text(x.sql_handle)
		) AS statement_text,
		(
			SELECT
				p.text
			FROM
			(
				SELECT
					MIN(sql_handle) AS sql_handle
				FROM sys.dm_exec_requests r2
				WHERE
					r2.session_id = x.blocking_session_id
			) AS r_blocking
			CROSS APPLY
			(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
			) p (text)
		) AS blocking_text,
		(
			SELECT
				text AS [text()]
			FROM sys.dm_exec_sql_text(x.sql_handle)
		) AS sql_text,
		x.program_name,
		transaction_id,
		percent_complete,
		estimated_completion_time,
		scheduler_id,
		plan_handle,
		x.granted_query_memory
		, (SELECT query_plan 
		FROM sys.dm_exec_query_plan (plan_handle)) execution_plan,
				(
			SELECT          
				substring(text, (statement_start_offset/2)+1
					, ((case statement_end_offset
						  when -1 then datalength(text)
						  else statement_end_offset
					   end - statement_start_offset)/2) + 1)
			FROM sys.dm_exec_sql_text(x.sql_handle)
			FOR XML PATH(''), TYPE
		) AS statement_text,
			(
			SELECT
				text AS [text()]
			FROM sys.dm_exec_sql_text(x.sql_handle)
			FOR XML PATH(''), TYPE
		) AS sql_text,
			(
			SELECT
				p.text
			FROM
			(
				SELECT
					MIN(sql_handle) AS sql_handle
				FROM sys.dm_exec_requests r2
				WHERE
					r2.session_id = x.blocking_session_id
			) AS r_blocking
			CROSS APPLY
			(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
				FOR XML PATH(''), TYPE
			) p (text)
		) AS blocking_text
	FROM
	(
		SELECT
			r.session_id,
			DB_NAME(r.database_id) AS DatabaseName,
			r.status,
			s.host_name,
			s.login_name,
			r.start_time,
			r.sql_handle,
			wait_type,
			wait_resource,
			CAST(wait_time AS BIGINT) AS wait_time,
			statement_start_offset,
			statement_end_offset,
			r.blocking_session_id,
			transaction_id,
			percent_complete,
			estimated_completion_time,
			scheduler_id,
			--r.row_count,
			last_request_start_time,
			count(*) AS parallelquery,
			SUM(CAST(r.logical_reads AS BIGINT)) AS totallogical_reads ,
			SUM(CAST(r.writes AS BIGINT)) AS totalWrites,
			SUM(CAST(r.cpu_time AS BIGINT)) AS totalCPU,
			SUM(CAST(tsu.user_objects_alloc_page_count + tsu.internal_objects_alloc_page_count AS BIGINT)) AS writes_in_tempdb,
			plan_handle,
			CAST(granted_query_memory AS BIGINT) AS granted_query_memory,
			program_name
		FROM sys.dm_exec_requests r
		JOIN sys.dm_exec_sessions s ON s.session_id = r.session_id
		JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id and r.request_id = tsu.request_id
		WHERE r.status IN ('running', 'runnable', 'suspended','rollback')
		--AND r.session_id > 50
		GROUP BY
			r.session_id,
			r.database_id,
			r.status,
			s.host_name,
			s.login_name,
			r.start_time,
			r.sql_handle,
			wait_type,
			wait_resource,
			wait_time,
			statement_start_offset,
			statement_end_offset,
			r.blocking_session_id,
			transaction_id,
			percent_complete,
			estimated_completion_time,
			scheduler_id,
			--, r.row_count
			last_request_start_time,
			plan_handle,
			granted_query_memory,
			program_name
	) x
	ORDER BY 3 desc 



select 'Pending IO requests'
select 
		DB_Name(vfs.database_id) as dbName,
		mf.physical_name,
		io.*
  from 
	sys.dm_io_pending_io_requests io
	inner join sys.dm_io_virtual_file_stats(NULL,NULL) as vfs On io.io_handle = vfs.file_handle
	inner join sys.master_files mf ON (mf.database_id = vfs.database_id) and (mf.file_id = vfs.file_id)


/**************************************************************************
* Lets look at the current database connections
**************************************************************************/
IF OBJECT_ID('tempdb..#tbl_spwho2') IS NOT NULL
	DROP TABLE #tbl_spwho2;
	
CREATE TABLE #tbl_spwho2 (
  spid INT 
 ,status sysname 
 ,Login sysname
 ,hostname sysname
 ,BlkBy sysname
 ,DBName sysname NULL
 ,cmd sysname
 ,cpu sysname
 ,physical_io sysname
 ,last_batch_char sysname
 ,program_name sysname
 ,spid1 int
 ,RequestID int );

insert INTO    #tbl_spwho2
exec sp_who2 
declare @totalconn		int
declare @userconn		int

select @totalconn = count(*)  from #tbl_spwho2;
select @userconn = count(*)  from #tbl_spwho2 WHERE spid1 > 50;
SELECT @totalconn as total_connections, @userconn as total_UserConnections
select DBName, count(*) total_connections from #tbl_spwho2 Where DBName IS NOT NULL group by DBName ORDER BY 1;
select [Login], count(*) total_Logins from #tbl_spwho2 group by Login ORDER BY Login;

select hostname, count(*) as ConnectionTotal from #tbl_spwho2 WHERE spid1 > 50
group by hostname ORDER BY 2 desc;

drop table #tbl_spwho2;
/***	End of ConnectionInfo section		***/

/***********************************************************************
Get Database Mirroring State for any Mirrored Databases
***********************************************************************/
If Exists (select 1 from sys.database_mirroring where mirroring_guid is not null)
Begin
	Select 'Database Mirroring State' as 'Database Mirroring State'
	select s.name as DbName, m.mirroring_role_desc, m.mirroring_state_desc,m.mirroring_partner_instance
	from sys.database_mirroring m (nolock)
		inner join sys.databases s (nolock) on m.database_id = s.database_id 
	where m.mirroring_guid is not null
End
Else 
	Select 'Database Mirroring Not Configured' as 'Database Mirroring Not Configured'

/***********************************************************************
Get last 5 entries from the database mirroring perf proc
  sp_dbmmonitorresults for each db that is being mirrored
***********************************************************************/
declare @name	sysname

create table #dbnames  (DbName sysname not null)

insert into #dbnames (DbName)
select s.name 
from sys.database_mirroring m (nolock)
	inner join sys.databases s (nolock) on m.database_id = s.database_id 
where m.mirroring_guid is not null 


declare @resultsint	table(
database_name  sysname ,
role  int ,
mirroring_state  int ,
witness_status  int,
log_generation_rate  int ,
unsent_log  int ,
send_rate  int ,
unrestored_log  int ,
recovery_rate  int ,
transaction_delay  int,
transactions_per_sec  int ,
average_delay  int ,
time_recorded  datetime ,
time_behind  datetime , 
local_time  datetime);


while (select COUNT(*) from #dbnames )>0
begin
	delete @resultsint
	select top 1 @name =  DbName  from #dbnames 
	insert into @resultsint 
	EXEC msdb..sp_dbmmonitorresults @name, 6, 0 ;
	select top 5 database_name, 
				Case [role]  
					When 1 Then 'Principal'
					When 2 Then 'Mirror' Else 'Unknown' End as [Role],
				Case mirroring_state 
					When 0 then 'Suspended'
					When 1 then 'Disconnected'
					When 2 Then 'Synchronizing'
					When 3 Then 'Pending Failover'
					When 4 Then 'Synchronized' Else 'Unknow' End as mirroring_state,
				Case witness_status
					When 0 Then 'Unknown'
					When 1 Then 'Connected'
					When 2 Then 'Disconnected' Else 'Unknown' End as witness_status
	, log_generation_rate, unsent_log, send_rate, unrestored_log, recovery_rate,
	transaction_delay, transactions_per_sec, average_delay, time_recorded, time_behind, local_time 
	from @resultsint 
	
	delete from #dbnames where DbName = @name 
end
drop table #dbnames 

IF @ShowASPState = 1
BEGIN
	If EXISTS(SELECT  1 from sys.databases (nolock) where name = 'ASPState' and state_desc ='Online')
	Begin
	declare @sessioncount				int
	declare @shortcount					int
	declare @longcount					int
	declare @avglongbytes				bigint
	declare @avgshortbytes				int
	declare @NonEmptyshortcount			int
	declare @avgNonEmptyshortbytes		int

	select @sessioncount = count(*) from ASPState.dbo.ASPStateTempSessions with (nolock);
	select @shortcount = count(*) from ASPState.dbo.ASPStateTempSessions with (nolock) 
	Where SessionItemShort is not null;

	select @NonEmptyshortcount = count(*) from ASPState.dbo.ASPStateTempSessions with (nolock)
	where SessionItemShort <> 0x140000000000FF;

	select @longcount = count(*) from ASPState.dbo.ASPStateTempSessions with (nolock)
	 where SessionItemShort is null;
 
	select @avglongbytes = avg(datalength(sessionItemLong)) from ASPState.dbo.ASPStateTempSessions with (nolock)
	 where SessionItemShort is null;

	select @avgshortbytes = avg(len(sessionItemShort)) from ASPState.dbo.ASPStateTempSessions with (nolock)
	 where SessionItemShort is not null --AND SessionItemShort <> 0x140000000000FF ;

	select @avgNonEmptyshortbytes = avg(len(sessionItemShort)) from ASPState.dbo.ASPStateTempSessions with (nolock)
	 where SessionItemShort is not null AND SessionItemShort <> 0x140000000000FF ;
  
	SELECT  @sessioncount as ASPState_Session_Count, @shortcount as Short_Count, @avgshortbytes AS AvgShortBytes,
			@longcount as Long_Count, @avglongbytes as AvgLongBytes, @NonEmptyshortcount as 'Non-Empty Short Count', 
			@avgNonEmptyshortbytes as AvgNonEmptyShortyBytes;
 
	End;
END
/***	End Of Session State Info	***/

--GO
/********************************************
				WAIT STATS		
*********************************************/
SELECT  @crdate as 'SQL Server Start Date' ,
        DATEADD(SS, -[wait_time_ms] / 1000, GETDATE()) AS "Date Wait Stats last cleared" ,
        CASE WHEN [wait_time_ms] < 1000
             THEN CAST([wait_time_ms] AS VARCHAR(15)) + ' ms'
             WHEN [wait_time_ms] BETWEEN 1000 AND 60000
             THEN CAST(( [wait_time_ms] / 1000 ) AS VARCHAR(15)) + ' seconds'
             WHEN [wait_time_ms] BETWEEN 60001 AND 3600000
             THEN CAST(( [wait_time_ms] / 60000 ) AS VARCHAR(15)) + ' minutes'
             WHEN [wait_time_ms] BETWEEN 3600001 AND 86400000
             THEN CAST(( [wait_time_ms] / 3600000 ) AS VARCHAR(15)) + ' hours'
             WHEN [wait_time_ms] > 86400000
             THEN CAST(( [wait_time_ms] / 86400000 ) AS VARCHAR(15)) + ' days'
        END AS "Time Since Cleared"
FROM    [sys].[dm_os_wait_stats]
WHERE   [wait_type] = 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP';


WITH Waits AS
(SELECT wait_type, wait_time_ms / 1000. AS wait_time_s,
100. * wait_time_ms / SUM(wait_time_ms) OVER() AS pct,
ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS rn
FROM sys.dm_os_wait_stats
WHERE wait_type NOT IN (select WaitStatTypeName from dbo.WaitStats_Benign)
)
SELECT W1.wait_type, 
CAST(W1.wait_time_s AS DECIMAL(12, 2)) AS wait_time_s,
CAST(W1.pct AS DECIMAL(12, 2)) AS pct,
CAST(SUM(W2.pct) AS DECIMAL(12, 2)) AS running_pct
FROM Waits AS W1
INNER JOIN Waits AS W2
ON W2.rn <= W1.rn
GROUP BY W1.rn, W1.wait_type, W1.wait_time_s, W1.pct
HAVING SUM(W2.pct) - W1.pct < 99 OPTION (RECOMPILE);
--GO

/************************************************************************
  Availability Group Information
*************************************************************************/
IF SERVERPROPERTY ('IsHadrEnabled') = 1
BEGIN
Select
	AGC.name As AGName -- Availability Group
	,RCS.replica_server_name -- SQL cluster node name
	,ARS.role_desc  -- Replica Role
	,Case When ARS.role_desc = 'Primary' Then agstate.primary_recovery_health_desc Else agstate.secondary_recovery_health_desc End as recovery_health_desc
	,Case When ARS.role_desc = 'Primary' Then agstate.synchronization_health_desc Else 'Only available on Primary' End as synchronization_health_desc
	,AGL.dns_name  as [dns_name(listener)]-- Listener Name
	,ag.health_check_timeout
	,AGL.ip_configuration_string_from_cluster
	,AGL.port
	,AGC.automated_backup_preference_desc
	,AGC.failure_condition_level
	,Case AGC.failure_condition_level
	When 1 Then  'Specifies that an automatic failover should be initiated when any of the following occurs: 1. The SQL Server service is down.  2. The lease of the availability group for connecting to the WSFC failover cluster expires because no ACK is received from the server instance'
	When 2 Then  'Specifies that an automatic failover should be initiated when any of the following occurs: 1. The instance of SQL Server does not connect to cluster, and the user-specified health_check_timeout threshold of the availability group is exceeded. 2.The availability replica is in failed state.'
	When 3 Then  'Specifies that an automatic failover should be initiated on critical SQL Server internal errors, such as orphaned spinlocks, serious write-access violations, or too much dumping. This is the default value.'
	When 4 Then  'Specifies that an automatic failover should be initiated on moderate SQL Server internal errors, such as a persistent out-of-memory condition in the SQL Server internal resource pool'
	When 5 Then  'Specifies that an automatic failover should be initiated on any qualified failure conditions, including: 1. Exhaustion of SQL Engine worker-threads.  2. Detection of an unsolvable deadlock.'
Else 'Unknown' End as failure_condition_level_desc
 
  From
	sys.availability_groups_cluster AS AGC
	INNER JOIN sys.dm_hadr_availability_replica_cluster_states AS RCS ON RCS.group_id = AGC.group_id
	INNER JOIN sys.dm_hadr_availability_replica_states AS ARS ON ARS.replica_id = RCS.replica_id
	inner join sys.dm_hadr_availability_group_states agstate on AGC.group_id = agstate.group_id
	left JOIN sys.availability_group_listeners AS AGL  ON AGL.group_id = ARS.group_id
	left join sys.availability_groups ag on AGC.group_id = ag.group_id
 Where
	1=1
	and RCS.replica_server_name = @@SERVERNAME

select 
	arc.replica_server_name
	, agc.name as AGName
	,drc.database_name
	,drc.is_failover_ready
	,Case drc.is_failover_ready
		When 0 Then 'The database is not marked as synchronized in the cluster. The database is not ready for a failover.'
		When 1 Then 'The database is marked as synchronized in the cluster. The database is ready for a failover.'
		Else 'Unknown' 
	 End  as is_filover_ready_desc
	,drc.is_database_joined
	,Case drc.is_database_joined
		When 0 Then ' Database is not joined to the availability group on this availability replica.'
		When 1 Then 'Database is joined to the availability group on this availability replica.'
		When NULL Then 'unknown (The availability replica lacks quorum.)'
		Else 'Unknown'
	 End as  is_database_joined_desc
	,drc.is_pending_secondary_suspend
	,Case drc.is_pending_secondary_suspend
		When 0 Then 'Any states except for HADR_SYNCHRONIZED_ SUSPENDED.'
		When 1 Then ' HADR_SYNCHRONIZED_ SUSPENDED. When a forced failover completes, each of the secondary databases is set to HADR_SYNCHONIZED_SUSPENDED and remains in this state until the new primary replica receives an acknowledgement from that secondary database to the SUSPEND message.'
		When NULL Then 'Unknown (no quorum)'
		Else 'Unknown'
	 End as  is_pending_secondary_suspend_desc
from 
	sys.dm_hadr_database_replica_cluster_states drc 
	inner join sys.dm_hadr_availability_replica_cluster_states arc on(drc.replica_id = arc.replica_id) 
	inner join sys.availability_groups_cluster agc on arc.group_id = agc.group_id
where 
	arc.replica_server_name = @@servername
ORDER BY
	agc.name
	,drc.database_name
	,drc.is_failover_ready
END
Else
	Select 'No Availability Groups configured' as 'No Availability Groups configured'








/***	CPU		***/
DECLARE @ts_now bigint 
SELECT @ts_now = cpu_ticks/(cpu_ticks/ms_ticks)FROM sys.dm_os_sys_info; 
If @verdec >= 10.00
Begin

SELECT TOP(256) SQLProcessUtilization AS [SQL Server Process CPU Utilization], 
               SystemIdle AS [System Idle Process], 
               100 - SystemIdle - SQLProcessUtilization AS [Other Process CPU Utilization], 
               DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) AS [Event Time] 
FROM ( 
	  SELECT record.value('(./Record/@id)[1]', 'int') AS record_id, 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') 
			AS [SystemIdle], 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 
			'int') 
			AS [SQLProcessUtilization], [timestamp] 
	  FROM ( 
			SELECT [timestamp], CONVERT(xml, record) AS [record] 
			FROM sys.dm_os_ring_buffers 
			WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
			AND record LIKE N'%<SystemHealth>%') AS x 
	  ) AS y 
ORDER BY record_id DESC OPTION (RECOMPILE);
End

-- Signal Waits for instance
SELECT 'Waits above 10-15 - 25% is usually a sign of CPU pressure' AS 'Signal Waits'
SELECT CAST(100.0 * SUM(signal_wait_time_ms) / SUM (wait_time_ms) AS NUMERIC(20,2)) 
AS [%signal (cpu) waits],
CAST(100.0 * SUM(wait_time_ms - signal_wait_time_ms) / SUM (wait_time_ms) AS NUMERIC(20,2)) 
AS [%resource waits]
FROM sys.dm_os_wait_stats OPTION (RECOMPILE);

-- Signal Waits above 10-15 - 25% is usually a sign of CPU pressure

/***	MEMORY AND STATE - want to see "Available physical memory is high"	***/

If @verdec >= 10.0
exec ('SELECT total_physical_memory_kb/1024 total_physical_memory_mb, 
	   available_physical_memory_kb/1024 available_physical_memory_mb,
       total_page_file_kb/1024 AS ''Commit Limit'', 
       available_page_file_kb/1024 available_page_file_mb, 
       system_memory_state_desc
FROM sys.dm_os_sys_memory OPTION (RECOMPILE);');



DECLARE @Instances TABLE
		( Value NVARCHAR(100),
		 InstanceNames NVARCHAR(100),
		 Data NVARCHAR(100))

INSERT INTO @Instances
EXECUTE xp_regread
	@rootkey = 'HKEY_LOCAL_MACHINE',
	@key = 'SOFTWARE\Microsoft\Microsoft SQL Server',
	@value_name = 'InstalledInstances'

SELECT 
	'Instance Info' as 'Instance Info', * 
	FROM
	@Instances 

/***	PLE		***/




declare @recPLE	bigint	
select @recPLE = (cast(cntr_value as decimal(18,2))/128/1024/4) *300
FROM sys.dm_os_performance_counters
WHERE  [object_name] like N'%:Buffer Manager%'
AND counter_name = N'Database pages'   

If @recPLE < 300
	set @recPLE = 300
--select @recPLE = cntr_value 
--FROM sys.dm_os_performance_counters
--WHERE  1=1
--and [object_name] like N'%:Buffer Manager%' -- Modify this if you have named instances
--AND counter_name = N'Database pages'  


SELECT cntr_value AS [Page Life Expectancy], @recPLE as [Recommended Min PLE], convert(varchar(30), cast(cntr_value - @recPLE as money),1) as 'PLE Variance'
FROM sys.dm_os_performance_counters
WHERE [object_name] like N'%:Buffer Manager%' -- Modify this if you have named instances
AND counter_name = N'Page life expectancy' OPTION (RECOMPILE);

-- Get the values per Numa Node
declare @avg	bigint
SELECT @avg =  avg(cntr_value)
FROM sys.dm_os_performance_counters
WHERE [object_name] like N'%:Buffer Node%' -- Modify this if you have named instances
And counter_name = N'Page life expectancy'
OPTION (RECOMPILE);

SELECT instance_name as NumaNode, cntr_value as PLE, @avg as avgPLE, convert(varchar(30), cast(cntr_value - @recPLE as money),1) as 'Node PLE Variance From Recommended'
FROM sys.dm_os_performance_counters
WHERE [object_name] like N'%:Buffer Node%' -- Modify this if you have named instances
And counter_name = N'Page life expectancy'
OPTION (RECOMPILE);


/***	MEMORY CLERKS	***/
--21040214
--http://dbcouncil.net/2011/12/14/troubleshoot-high-cpu-issue-without-using-profile-traces/
--Look for high value for CACHESTORE_SQLCP (Ad-hoc query plans)
If @version >= 11
Begin  -- SQL 2012 and higher
	Set @sql =
	N'SELECT 
		Case When [type] IS NULL Then N''Total'' Else [type] End AS [Memory Clerk Type], 
		SUM(pages_kb) AS [SPA Mem, Kb] ,  
		SUM(pages_kb)/1024 as [SPA Mem Mb],
		cast(cast(SUM(pages_kb)as decimal(18,3))/1024/1024 as decimal(18,2) )as [SPA Mem Gb]
		,Case [type]
			When N''MEMORYCLERK_SQLBUFFERPOOL'' Then ''BUFFERPOOL''
			When N''CACHESTORE_SQLCP'' Then ''Plans for adhoc cached plans, autoparameterized plans, and prepared plans''
			When N''CACHESTORE_OBJCP'' Then ''Plans for stored procedures, functions, and triggers''
			When N''CACHESTORE_PHDR'' Then ''Bound Trees''
			When N''MEMORYCLERK_SQLQERESERVATIONS'' Then ''This memory clerk is use for hashing and sorting by SQL server and if the memory seems less the resultsets are spilled over to tempdb while executing query. ''
			Else'''' 		End as [TYPE_DESC]
	FROM 
		sys.dm_os_memory_clerks 
	GROUP BY  
		[type]  

		with ROLLUP
	ORDER BY 
		SUM(pages_kb) DESC OPTION (RECOMPILE);'
End
Else
Begin -- SQL 2008 R2 and lowever
	Set @sql = 
	N'SELECT 
	Case When [type] is null then N''Rollup'' Else [type] End AS [Memory Clerk Type]
	,SUM(single_pages_kb) AS [SPA Mem, Kb] 
	,(SUM(single_pages_kb))/1024 as [SPA Mem Mb]
	,Case [type]
			When N''MEMORYCLERK_SQLBUFFERPOOL'' Then ''BUFFERPOOL''
			When N''CACHESTORE_SQLCP'' Then ''Plans for adhoc cached plans, autoparameterized plans, and prepared plans''
			When N''CACHESTORE_OBJCP'' Then ''Plans for stored procedures, functions, and triggers''
			When N''CACHESTORE_PHDR'' Then ''Bound Trees''
			When N''MEMORYCLERK_SQLQERESERVATIONS'' Then ''This memory clerk is use for hashing and sorting by SQL server and if the memory seems less the resultsets are spilled over to tempdb while executing query. ''
			Else'''' 		End as [TYPE_DESC]
FROM 
	sys.dm_os_memory_clerks 
GROUP BY 
	[type]  
	With Rollup
ORDER BY 
SUM(single_pages_kb) DESC OPTION (RECOMPILE);'
End

exec sp_executesql @sql 

set @sql = N''
If @version >= 11
Begin
	Set @sql = 
N'SELECT
	LEFT([name], 20) AS [Name],
	LEFT([type], 20) as [Type],
	pages_kb,
	pages_kb / 1024 AS cache_size_MB,
	entries_count,
	avg_size_kb = pages_kb / entries_count
	,Case  [type] 
			When N''CACHESTORE_SQLCP'' Then ''Plans for adhoc cached plans, autoparameterized plans, and prepared plans''
			When N''CACHESTORE_OBJCP'' Then ''Plans for stored procedures, functions, and triggers''
			When N''CACHESTORE_PHDR'' Then ''Bound Trees are the structures produced by SQL Server?s algebrizer for views, constraints, and defaults''
			When N''MEMORYCLERK_SQLQERESERVATIONS'' Then ''This memory clerk is use for hashing and sorting by SQL server and if the memory seems less the resultsets are spilled over to tempdb while executing query. If the result sets spill to tempdb, we check in  perfmon  for  object ? Access methodsWorktables/sec (for sorting)  and  Access methodsWork files/sec(hashing). If this memory clerk is consuming lots of memory then run this query  select * from sys.dm_os_memory_clerks where type=''''MEMORYCLERK_SQLQERESERVATIONS''''''
			Else N''''
		End as [Description]
FROM
	sys.dm_os_memory_cache_counters
WHERE 
	[type] in (''CACHESTORE_SQLCP'', ''CACHESTORE_OBJCP'', ''CACHESTORE_PHDR'')
AND
	entries_count <> 0
ORDER BY
	pages_kb DESC'
End
Else
Begin
		Set @sql = 
N'SELECT
	LEFT([name], 20) AS [Name],
	LEFT([type], 20) as [Type],
	single_pages_kb,
	single_pages_kb / 1024 AS cache_size_MB,
	entries_count,
	avg_size_kb = single_pages_kb / entries_count
	,Case  [type] 
			When N''CACHESTORE_SQLCP'' Then ''Plans for adhoc cached plans, autoparameterized plans, and prepared plans''
			When N''CACHESTORE_OBJCP'' Then ''Plans for stored procedures, functions, and triggers''
			When N''CACHESTORE_PHDR'' Then ''Bound Trees are the structures produced by SQL Server?s algebrizer for views, constraints, and defaults''
			When N''MEMORYCLERK_SQLQERESERVATIONS'' Then ''This memory clerk is use for hashing and sorting by SQL server and if the memory seems less the resultsets are spilled over to tempdb while executing query. If the result sets spill to tempdb, we check in  perfmon  for  object ? Access methodsWorktables/sec (for sorting)  and  Access methodsWork files/sec(hashing). If this memory clerk is consuming lots of memory then run this query  select * from sys.dm_os_memory_clerks where type=''''MEMORYCLERK_SQLQERESERVATIONS''''''
			Else N''''
		End as [Description]
FROM
	sys.dm_os_memory_cache_counters
WHERE 
	[type] in (''CACHESTORE_SQLCP'', ''CACHESTORE_OBJCP'', ''CACHESTORE_PHDR'')
AND
	entries_count <> 0
ORDER BY
	single_pages_kb DESC'
End
exec sp_executesql @sql 

/***	Check for PlanCache bloat with single use adhoc queries	***/
--declare @totalplansize	money
--select 	@totalplansize = SUM(cast(size_in_bytes as money))/1024/1024 from sys.dm_exec_cached_plans
--select COUNT(*) as PlanCount, @totalplansize as PlanSize_Mb	
--from sys.dm_exec_cached_plans
--select COUNT(*) as PlanCountSingle, SUM(cast(size_in_bytes as money))/1024/1024 as PlanSizeSingle_Mb,
--		((SUM(cast(size_in_bytes as money))/1024/1024)/@totalplansize) * 100 as PercentSingleUseQuery
--from sys.dm_exec_cached_plans  
--where usecounts = 1

declare @totalplansize_mb			money
declare @plansinglesize_mb			money
declare @planstubsize_mb			money
declare @plancountsingle			int
declare @plancountstub				int
declare @plancount					int

select 	@totalplansize_mb = SUM(cast(size_in_bytes as money))/1024/1024, @plancount = COUNT(*) from sys.dm_exec_cached_plans
--select @plancountsingle = COUNT(*), @plansinglesize_mb = SUM(cast(size_in_bytes as money))/1024/1024   from sys.dm_exec_cached_plans  where usecounts = 1 and cacheobjtype != 'Compiled Plan Stub' 
select @plancountsingle = COUNT(*), @plansinglesize_mb = SUM(cast(size_in_bytes as money))/1024/1024   from sys.dm_exec_cached_plans  where cacheobjtype != 'Compiled Plan Stub' 
--select @plancountstub  = COUNT(*) ,  @planstubsize_mb  = SUM(cast(size_in_bytes as money))/1024/1024  from sys.dm_exec_cached_plans  where usecounts = 1 and cacheobjtype = 'Compiled Plan Stub'
select @plancountstub  = COUNT(*) ,  @planstubsize_mb  = SUM(cast(size_in_bytes as money))/1024/1024  from sys.dm_exec_cached_plans  where cacheobjtype = 'Compiled Plan Stub'

select @plancount 'PlanCount', @totalplansize_mb 'Plan Size MB'
SELECT @plancountsingle As 'Compiled Plans', @plansinglesize_mb as PlanSizeSingle_Mb, (@plansinglesize_mb/@totalplansize_mb) * 100 as PercentCompilePlans
SELECT @plancountstub as 'Compiled Stubs', @planstubsize_mb as PlanSizeStub_mb,(@planstubsize_mb/@totalplansize_mb) * 100 as PrecentPlanStub

select count(*) as SingleUseCount
, sum(cast(p.size_in_bytes as decimal(18,0)))/1024.00/1024 as Size_MB
 from sys.dm_exec_cached_plans p where p.usecounts = 1
/**********************************************************************************************************************
	Database cache information
************************************************************************************************************************/
DECLARE @total_buffer INT;
If @ShowCachePerDB = 1
BEGIN
	SELECT 
		@total_buffer = cntr_value
	  FROM 
		sys.dm_os_performance_counters 
	 WHERE 
		RTRIM([object_name]) LIKE '%Buffer Manager'
		AND counter_name = 'Database Pages';

	;WITH src AS
	(
	SELECT 
		database_id, 
		db_buffer_pages = COUNT_BIG(*)
	  FROM 
		sys.dm_os_buffer_descriptors
	 WHERE 
		1=1
		--AND database_id BETWEEN 5 AND 32766
	GROUP BY 
		database_id
	)

	SELECT
		[db_name] = CASE [database_id] WHEN 32767 THEN 'Resource DB' 
					ELSE DB_NAME([database_id]) END,
		db_buffer_pages,
		db_buffer_MB = db_buffer_pages / 128,
		db_buffer_GB = cast(db_buffer_pages / 128/1024.00 as money),
		db_buffer_percent = CONVERT(DECIMAL(6,3), 
		db_buffer_pages * 100.0 / @total_buffer)
	  FROM 
		src
	ORDER BY 
		db_buffer_MB DESC; 
END
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------




/*** CHECK TRANSACTION LOG SPACE	***/
--GO
CREATE TABLE #log ([DbName] sysname, [LogSizeMB] decimal (9,2), [LogSpaceUsed(%)] Decimal(5,2), [status] int)

Insert into #log
	exec ('dbcc SQLPERF(LOGSPACE)')
SELECT DbName, LogSizeMB, [LogSpaceUsed(%)],  recovery_model_desc 
from #log INNER JOIN sys.databases ON 
		DbName = DB_NAME(database_id)
ORDER BY  [LogSpaceUsed(%)] desc
DROP TABLE #log


SELECT 'Database Info' as 'Database Info'
select 
	d.name, 
	d.create_date,
	d.state_desc, 
	d.recovery_model_desc,
	d.is_in_standby,
	d.log_reuse_wait_desc,
	m.mirroring_role_desc,
	m.mirroring_partner_instance,
	m.mirroring_partner_name,
	m.mirroring_state_desc,
	CASE WHEN lsp.primary_database IS NOT NULL THEN 'Yes' Else 'No' End as IsLogShippingSource,
	prisec.secondary_server ,
	prisec.secondary_database,
	CASE WHEN lss.secondary_database IS NOT NULL THEN 'Yes' Else 'No' End as IsLogShippingTarget
from 
	sys.databases  d
	left join sys.database_mirroring m on d.database_id = m.database_id 
	left join msdb.dbo.log_shipping_primary_databases lsp on d.name = lsp.primary_database
	left join msdb.dbo.log_shipping_primary_secondaries prisec on lsp.primary_id = prisec.primary_id
	left join msdb.dbo.log_shipping_secondary_databases lss on d.name = lss.secondary_database
	
where 
	d.database_id > 4

ORDER BY d.name

--GO

SELECT 'IO Numbers By Database' as 'Consider avg_io_stall_ms > 20 as slow IO'
/***	take a quick look at IO	***/
-- Calculates average stalls per read, per write, and per total input/output for each database file. 
SELECT DB_NAME(fs.database_id) AS [Database Name], 
		mf.physical_name, 
		CAST((io_stall_read_ms + io_stall_write_ms)/(1.0 + num_of_reads + num_of_writes) AS NUMERIC(10,1)) AS [avg_io_stall_ms],
		io_stall_read_ms, 
		num_of_reads,
		CAST(io_stall_read_ms/(1.0 + num_of_reads) AS NUMERIC(10,1)) AS [avg_read_stall_ms],
		io_stall_write_ms, 
		num_of_writes,
		CAST(io_stall_write_ms/(1.0+num_of_writes) AS NUMERIC(10,1)) AS [avg_write_stall_ms],
		io_stall_read_ms + io_stall_write_ms AS [io_stalls], 
		num_of_reads + num_of_writes AS [total_io]
FROM sys.dm_io_virtual_file_stats(null,null) AS fs
INNER JOIN sys.master_files AS mf
ON fs.database_id = mf.database_id
AND fs.[file_id] = mf.[file_id]
ORDER BY avg_io_stall_ms DESC OPTION (RECOMPILE);

SELECT 'value_in_use is what the system is currently using.' AS 'Some System Configuration items'
--Lets look at system configuration items too
select name, value, minimum, maximum , value_in_use  FROM sys.configurations 
where name in ('max server memory (MB)', 'min server memory (MB)',
	'backup compression default', 'clr enabled', 'default trace enabled',
	'remote admin connections','cost threshold for parallelism', 'lightweight pooling',
	'max degree of parallelism','optimize for ad hoc workloads','priority boost',
	'Database Mail XPs');


/**********************************************************************************
	GET OTHER SETTINGS
**********************************************************************************/
declare @lognum			int 
declare @agtsvc			nvarchar(128)
declare @sqlsvc			nvarchar(128)
declare @lockedPages	VARCHAR(20)
DECLARE @volMaint		VARCHAR(20)


If @verdec < 10.5
BEGIN
	exec xp_instance_regread  N'HKEY_LOCAL_MACHINE', N'SYSTEM\CurrentControlSet\Services\MSSQLServer', N'ObjectName', @sqlsvc output
END
ELSE
BEGIN --if you have 2008 R2 you can use this dmv
	SELECT 
		@sqlsvc = service_account
	FROM 
		sys.dm_server_services WITH (NOLOCK) 
	WHERE 
		servicename like 'sql server (%' OPTION (RECOMPILE);
END



If Exists(select value_in_use  FROM sys.configurations where name = 'xp_cmdshell' and value_in_use =1)
BEGIN
	IF OBJECT_ID('tempdb..#xp_cmdshell_output') IS NOT NULL
		DROP TABLE #xp_cmdshell_output
	CREATE TABLE #xp_cmdshell_output (Output VARCHAR (8000)); 
	-- run whoami command via xp_cmdshell and writing into temp table
	INSERT INTO #xp_cmdshell_output EXEC ('xp_cmdshell ''whoami /priv'''); 
	--Looking at the output that we are interested
	IF EXISTS (SELECT 1 FROM #xp_cmdshell_output WHERE Output LIKE '%Lock pages in memory %') 
		SET @lockedPages = 'Yes'
	ELSE
		SET @lockedPages = 'No'
	
	IF EXISTS (SELECT 1 FROM #xp_cmdshell_output WHERE Output LIKE '%Perform volume maintenance tasks%') 
		SET @volMaint = 'Yes'
	ELSE 
		SET @volMaint = 'No'

	--drop temptable
	DROP TABLE #xp_cmdshell_output;
END
ELSE
	SELECT @lockedPages = 'Unknown', @volMaint = 'Unknown'


exec xp_instance_regread  N'HKEY_LOCAL_MACHINE', N'Software\Microsoft\MSSQLServer\MSSQLServer', N'NumErrorLogs', @lognum output

exec xp_instance_regread  N'HKEY_LOCAL_MACHINE', N'SYSTEM\CurrentControlSet\Services\SQLServerAgent', N'ObjectName', @agtsvc output
select ISNULL(@lognum,6) AS ConfiguredErrorLogCount, @sqlsvc as 'SQL Server service account', @agtsvc as 'SQL Agent service account', 
		@lockedPages AS 'Lock Pages In Memory', @volMaint AS 'Perform Volume Maintenance'

-- Get Suggested Max Memory Setting
DECLARE @freemem		int
DECLARE @totalmem		int

DECLARE @maxmem			int
DECLARE @minmem			int
DECLARE @numinstances	int
DECLARE @curMaxMem		int

SET @freemem			= 1


DECLARE @GetInstances TABLE
( Value NVARCHAR(100),
 InstanceNames NVARCHAR(100),
 Data NVARCHAR(100))

INSERT INTO @GetInstances
EXECUTE xp_regread
  @rootkey = 'HKEY_LOCAL_MACHINE',
  @key = 'SOFTWARE\Microsoft\Microsoft SQL Server',
  @value_name = 'InstalledInstances'

SELECT 
	@numinstances = count(*) 
 FROM
	@GetInstances 

IF @numinstances < 1 
	SET @numinstances = 1

IF @@MICROSOFTVERSION >= 167773760 --10.0.1600
BEGIN
  SET @sql = N'SELECT @totalmem = ROUND(Cast(total_physical_memory_kb as float) /1024/1024,0) FROM sys.dm_os_sys_memory;'
END
ELSE
BEGIN
	SET @sql = N'select @totalmem = ROUND(Cast(physical_memory_in_bytes as float) /1024/1024/1024,0) from sys.dm_os_sys_info;'
END
EXECUTE sp_executesql @sql, N'@totalmem int OUTPUT', @totalmem=@totalmem OUTPUT

IF @totalmem > 4
BEGIN
	IF @totalmem <= 16
		SET @freemem = @freemem + (@totalmem - 4)/4
	ELSE
		SET @freemem = @freemem + 3 + ((@totalmem-16)/8)
END

SET @maxmem = ((@totalmem - @freemem)*1024 )/@numinstances
SET @minmem = ((@totalmem /2) * 1024)/@numinstances

SET @msg = '--	Total Memory:	' + CAST(@totalmem AS VARCHAR(30)) + '
--	Required Free Memory:	' + CAST (@freemem  AS VARCHAR(30)) + '
--	Max Memory GB:	' + CAST (@totalmem - @freemem AS VARCHAR(30)) +' 
--	Current Max Memory Setting:	' + CAST (@curMaxMem AS VARCHAR(30)) +' 
--	Recommended Max Memory Setting MB:	' + CAST (@maxmem AS VARCHAR(30)) +' 
--	Number of SQL instances found:	' + CAST (@numinstances AS VARCHAR(30)) 



select @totalmem  as [Total Memory],  value_in_use  as 'Current Max Memory Setting', @maxmem as  [Suggested Setting],@freemem as [Required Free Memory], @totalmem - @freemem as [Max Memory GB], @numinstances as [Number of SQL instances found]

FROM sys.configurations 
where name = 'max server memory (MB)';


/****************************************************************************
  READ DEFAULT TRACE FILE -  get file growth and shrinks
****************************************************************************/

If Exists(select 1 from sys.configurations where name = N'default trace enabled' and value_in_use = 1)
Begin
	declare @path		nvarchar(256)
	declare @curnum		smallint
	declare @newnum		smallint
	declare @i			tinyint	
	
	SET @i = 1
	select 
		@path =[PATH]
	 from 
		sys.traces
	where 
		Id = 1

	If @path IS NOT NULL
	begin
		Select 'File Growth/Shrinks from trace file' as 'File Growth/Shrinks from trace file'
		If OBJECT_ID('tempdb..#TraceTemp') IS NOT NULL
			Drop table #TraceTemp

		SELECT 
			* 
			INTO #TraceTemp
		 FROM 
			::fn_trace_gettable(@path, 1)
		-- fn_trace_gettable passing in DEFAULT for number of files is not working, so loop through up to 5 files
		While @i < 5
		Begin
			begin try
				--set @curnum =  CAST(REPLACE(SUBSTRING(@path,CHARINDEX('.trc',@path,1)-3,3),'_','') AS INT)
				set @curnum = CAST(REPLACE(SUBSTRING(@path,CHARINDEX('_',@path,1),CHARINDEX('.trc',@path,1)- CHARINDEX('_',@path,1)),'_','') AS INT)
				set @newnum = @curnum - 1
				set @path = REPLACE(@path, Cast(@curnum as nvarchar), cast(@newnum as nvarchar))
				INSERT INTO #TraceTemp
				SELECT * FROM ::fn_trace_gettable(@path, 1)
			set @i = @i + 1
			end try
			begin catch
				DECLARE @errmsg	nvarchar(2048)
				set @errmsg = 'Error Line: ' + CAST(ERROR_LINE() AS VARCHAR(10)) + ', Error: ' +  ERROR_MESSAGE()
				If @errmsg NOT like '%@either does not exist or there was an error opening the file%'
				begin
					RAISERROR(@errmsg,10,1) WITH NOWAIT;
				end
				SET @i = 100
			end catch
		end 
		SELECT 
			CASE EVENTCLASS
				When  92 Then 'Data File Auto Grow'
				When  93 Then 'Log File Auto Grow'
				When  94 Then 'Data File Auto Shrink'
				When  95 Then 'Log File Auto Shrink'
			END AS Event
			,duration/1000 as duration_ms
			,databaseID
			,DatabaseName
			,[FileName]
			,StartTime
			,ISNULL(IntegerData,0)/128 as Growth_MB
			,NTDomainName
			,HostName
			,ClientProcessID
			,ApplicationName
			,SPID
			,Duration
			,EndTime
			,IntegerData
			,ServerName
			,EventClass
			,LoginSid
			,SessionLoginName
		FROM  
			#TraceTemp
		WHERE 
			EventClass between 92 and 95 --Data/Log File Auto Grow/Shrink
		ORDER BY
			StartTime desc
	end
End
Else
	Select 'Unable to get path to log files, cannot process auto grow/shrink check.' as 'WARNING'

--------------------------------------------------------




--kbuck added code below
--get the batch requests per second but wait for 10 more secnds first, No one is reading these
--resutls in under 10 seconds so the wait shoudl have no impact
-- added signal waits (CPU) too
If DATEDIFF(second,@start,GETDATE()) < 10
	waitfor delay '00:00:10'

select @end = GETDATE(), @cntEnd  = cntr_value 
from sys.dm_os_performance_counters 
where counter_name = 'Batch Requests/sec'
	
select @signal_wait2 = SUM(signal_wait_time_ms),
		@wait_time2 = SUM (wait_time_ms) 
FROM sys.dm_os_wait_stats 

set @runtime = DATEDIFF (millisecond,@start, @end)
set @avgbatches = (@cntEnd - @cntStart) / (@runtime/1000.0)


select @runtime 'runtime_ms',@avgbatches 'batches/sec'

set @signal_total= @signal_wait2 - @signal_wait1 
set @wait_total = @wait_time2 - @wait_time1 

SELECT CAST(100.0 * @signal_total / @wait_total AS NUMERIC(20,2)) 
AS '%signal (cpu) waits Last x sec'

SET @end = GETDATE()
set @runtime = DATEDIFF (millisecond,@start, @end)
select 
	t.object_name
	,@runtime as RunTime_millsec
	,c.cntr_value - t.cntr_value as TotalTransactions
	,CAST((c.cntr_value - t.cntr_value)/ (@runtime/1000.0) AS BIGINT)AS AvgTransactionsSec
from 
	sys.dm_os_performance_counters c
	inner join #trans t on c.object_name = t.object_name
where 
	counter_name = 'Transactions/sec'
	and instance_name ='_Total'



GO


/******************************************************************************************************************************************
  dbo.pPerfWhatsRunning
  Summary:  Returns what is running, the Adi view.

  Date:  5/9/2019
  Versions: 2008 and greater
  Parameters:
	NONE
------------------------------------------------------------------------------
  Written by Adi Cohen, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com

  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
******************************************************************************************************************************************/
IF (select VerDec from #FDVER) >= 11
BEGIN
RAISERROR ('	CREATING OR ALTERING PROCEDURE dbo.pPerfWhatsRunning',10,1) WITH NOWAIT;
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pPerfWhatsRunning]') AND TYPE in (N'P', N'PC'))
BEGIN
	EXEC dbo.sp_executesql @statement =  N'CREATE PROCEDURE [dbo].[pPerfWhatsRunning] AS SELECT getdate()';
END

DECLARE @sql	nvarchar(max)
SET @sql = N'
ALTER PROCEDURE dbo.pPerfWhatsRunning
WITH ENCRYPTION
AS
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

declare	@SPID int = null

select 
	er.session_id SPID, 
	Threads, 
	datediff(second, start_time, getdate()) Seconds, 
	er.Percent_Complete [%_Complete],
	cast(mg.query_cost as decimal(38, 2)) Cost, 
	er.status, 
	er.Wait_Type, 
	er.Wait_Time, 
	WaitFor_Resources,
	db_name(er.database_id) [Database], 
	er.blocking_session_id Blocked_by,
	substring(text, case when statement_start_offset >= datalength(text)
       then 1
       else (statement_start_offset/2)+1
      end,
      case when statement_end_offset < 1
       then datalength(text)
       else statement_end_offset end
      - case when statement_start_offset >= datalength(text)
       then 1
       else (statement_start_offset/2)+1
      end + 1) [Statement],
	object_schema_name(st.objectid, er.database_id) + ''.'' + object_name(st.objectid, er.database_id) [Object], 
	cast(p.Query_Plan as xml) [Plan],
	er.Cpu_Time, 
	er.Logical_Reads, 
	er.scheduler_id, 
	es.[Host_Name] Host, 
	es.Login_Name [Login], 
	es.[Program_Name] Program,
	mg.granted_memory_kb/1024 Granted_Memory_MB, 
	Scheduler_Pending_IO_Tasks, 
	Scheduler_Pending_IO_ms
from 
	sys.dm_exec_requests er 
	inner join sys.dm_os_schedulers sc on er.scheduler_id = sc.scheduler_id
	outer apply sys.dm_exec_sql_text(er.sql_handle) st 
	outer apply sys.dm_exec_text_query_plan(er.plan_handle, er.statement_start_offset, er.statement_end_offset) p 
	left join sys.dm_exec_sessions es ON es.session_id = er.session_id 
	left join sys.dm_exec_query_memory_grants mg on mg.session_id = er.session_id 
	cross apply (select count(*) Threads from master..sysprocesses where spid = er.session_id) sp 
	outer apply (select STUFF((select '',('' + wt.resource_description + '')''
							from sys.dm_os_waiting_tasks wt
							where wt.session_id = er.session_id
								and wt.resource_description not like ''exchangeEvent id=%''
								and wt.resource_description not like ''ACCESS_METHODS_DATASET_PARENT%''
							for xml path('''')), 1, 1,'''') WaitFor_Resources) wt
	outer apply (select COUNT(*) Scheduler_Pending_IO_Tasks, SUM(pir.io_pending_ms_ticks) Scheduler_Pending_IO_ms
				from sys.dm_io_pending_io_requests pir
				where pir.scheduler_address = sc.scheduler_address) pir
where 
	er.session_id <> @@spid
	and es.[status] = ''Running''
	and (er.session_id = @SPID or @SPID is null)
order by 
	case when er.wait_type = ''WAITFOR'' then 1 else 0 end, 
	Threads desc, 
	Seconds desc, 
	SPID

select 
	getdate() RecordDate, 
	dt.database_transaction_begin_time, 
	DB_NAME(dt.database_id) DBName, 
	st.session_id,
	iif(exists (select *
				from sys.dm_exec_requests er
				where er.session_id = st.session_id), 1, 0) IsOrphan,
	es.[Host_Name] Host, 
	es.Login_Name [Login], 
	es.[Program_Name] Program, 
	ib.event_info LastStatement, 
	es.last_request_end_time,
	BlockedSessionsCount, 
	lh.LocksHeld
from 
	sys.dm_tran_session_transactions st
	inner join sys.dm_tran_database_transactions dt on st.transaction_id = dt.transaction_id
	left join sys.dm_exec_sessions es on es.session_id = st.session_id
	outer apply sys.dm_exec_input_buffer(st.session_id, null) ib
	outer apply (select count(*) BlockedSessionsCount
					from sys.dm_exec_requests erb
					where erb.blocking_session_id = st.session_id) erb
	outer apply (select stuff((select concat('', '', resource_type, '':'', ltrim(rtrim(resource_description)), '':'', resource_associated_entity_id)
					from sys.dm_tran_locks tl
					where request_session_id = st.session_id
						and resource_type <> ''DATABASE''
					for xml path('''')
					), 1, 2, '''') LocksHeld) lh
where 
	dt.database_id <> 32767 
	and database_transaction_begin_time is not null'

	execute sp_executesql @sql
END 
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pRefreshDatabase]',10,1) WITH NOWAIT;
if object_id('dbo.pRefreshDatabase') is null exec('create procedure [dbo].[pRefreshDatabase] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*	Written By:	Fortified Data
*	Purpose: 	Refresh Lower Level Environments or Clone Databases with Backup
*	Inputs:		
*
*	ASSIGN VARIABLES
*
*	Notes:	This procedure will restore over or create a new database as specified by DestinationDBName
*
*	Returns:	Errors
*	Prerequisite: 
*				
*	History:	
*
*	10/01/2015 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	10/01/2015			Nicole Harrington		Created
*	6/8/2016			Keith Buck				Updated setting of @OpenRowSetQuery to exclude backups created by vm backups, those with { (curly braces). 
*												Added two optional parameters to just print and or run the command. Optimed cursors
	06/09/2016			Amy Herold				updated to exclude backups from NY AUTHORITY\SYSTEM
	06/09/2016			Keith Buck				Changed alter database to start from current db and then go into master to avoid locking the db file before the restore.
	06/24/2016			Keith Buck				Updated query for creating the set single_user statement to only generate if the db is ONLINE. Also added with "stats"
	7/26/2016			Keith Buck				Added param @BackupFileList which when supplied will use it as the backup file source. Added BufferCount and MaxTransferSize too
												Also fixed up print output so it does not truncate the output at 4000 bytes. It does however split text over lines every 4000 chars but can easily be edited by end user.
	4/21/2017			Keith Buck				Added parameters for sql login and password to connect to remote server, added a replace statement in the RESTORE Command
	5/2/2018			Keith Buck				Updated initial single/multi user setting to instead set the database offline. This ensure no constant connections can sneak in and cause a refresh failure
	1/16/2019			Keith Buck				Added @DriverName so we could specify what provider to use in the OPENROWSET call.
	4/17/2019			Keith Buck				Updated to check for differenital backups too
	9/23/2019			Keith Buck				Added @exists to check for existing database and if true skips the section on doing the move as it moves to the default file location, 
												not where the database actually exists. Also increased the @debug logging in that section
*
*********************************************************************************************************************/
alter procedure [dbo].[pRefreshDatabase] 
(	
		@DestinationDBName		SYSNAME
		,@SourceDBName			SYSNAME
		,@SourceInstanceName	VARCHAR(100)
		,@OutputText			BIT = 0
		,@ExecuteText			BIT = 1
		,@BackupFileList		VARCHAR(MAX) = NULL  --- Must be in the format 'DISK=N'',DISK=N''... and local machine must have access to location, use UNC if remote
		,@BufferCount			INT = NULL  --specify to set, leave null to not set expicitly
		,@MaxTransferSize		INT = 4194304	--specify null to let system choose, default is max size
		,@UserId				VARCHAR(128) = NULL -- specify a sql login to use to connect
		,@Password				VARCHAR(128) = NULL -- specify a password for the sql login 
		,@DriverName			SYSNAME	= N'SQLNCLI11'		--name of provider used in the OPENROWSET Call
		,@debug					BIT = 0
)
WITH ENCRYPTION
AS
SET NOCOUNT ON

DECLARE  @DefaultDestDataLoc		VARCHAR(256)
		, @DefaultDestLogLoc		VARCHAR(256)
		, @ReturnBackupPath			VARCHAR(MAX)
		, @OpenRowSetConnection		NVARCHAR(MAX)
		, @OpenRowSetQuery			NVARCHAR(MAX)
		, @RestorePrefix			NVARCHAR(MAX)
		, @RestoreBackupFiles		NVARCHAR(MAX) 
		, @RestoreSql				VARCHAR(MAX) 
		, @RestoreSuffix			NVARCHAR(MAX)
		, @Sql						NVARCHAR(MAX)
		, @BackupItems				INT
		, @ParmDefinition			NVARCHAR(500)
		, @ErrorMessage				NVARCHAR(max)
		, @RestoreFile				NVARCHAR(max)
		, @RestoreFiles				NVARCHAR(max)
		, @DataFileLoc				NVARCHAR(256)
		, @LogFileLoc				NVARCHAR(256)
		, @SourceLN					NVARCHAR(256)
		, @SourcePN					NVARCHAR(256)
		, @DestLN					NVARCHAR(256)
		, @DestPN					NVARCHAR(256)
		, @SourceData				NVARCHAR(256)
		, @FileEx					NVARCHAR(4)
		, @ver						varchar(30)
		, @dot1						INT
		, @dot2						INT
		, @verdec					DECIMAL(18,2)
		, @CompleteSQL				NVARCHAR(max)
		, @msg						VARCHAR(2048)
		, @exists						bit = 0
SET @RestoreBackupFiles		 = ''
SET @RestoreSql				= ''
SET @RestoreSuffix			= ''
	
IF EXISTS(SELECT * FROM SYS.databases where name = @DestinationDBName)
	set @exists = 1

select @ver = cast(SERVERPROPERTY('productversion') as varchar(30))
select @dot1 = CHARINDEX('.',@ver)
select @dot2 = CHARINDEX('.',@ver,@dot1+1)
select @verdec = cast(SUBSTRING(@ver,1,@dot2-1) as decimal(18,2))

/* test for a database name */
IF @DestinationDBName IS NULL OR LTRIM(RTRIM(@DestinationDBName)) = ''
BEGIN
		SET @ErrorMessage = 'The value for parameter @DestinationDBName is not supported.' + CHAR(13) + CHAR(10) + ' ';
		RAISERROR(@ErrorMessage,16,1) WITH NOWAIT;
		RETURN;
END;

IF @SourceDBName IS NULL OR LTRIM(RTRIM(@SourceDBName)) = ''
BEGIN
		SET @ErrorMessage = 'Parameter @SourceDBName can not be NULL or empty.' + CHAR(13) + CHAR(10) + ' ';
		RAISERROR(@ErrorMessage,16,1) WITH NOWAIT;
		RETURN;
END;
/*************************************************************************************************************
	Set default location for data and log files using the FDDBA database. If it does not exist then if
	SQL version is 2012 or greater get the information from SERVERPROPERTY otherwise base it on model
*************************************************************************************************************/
IF EXISTS (SELECT 1 FROM sys.databases WHERE name = N'FDDBA')
BEGIN
	SELECT @DefaultDestDataLoc = left(physical_name,(len(physical_name)-(charindex('\',REVERSE(physical_name)))+1))
	FROM sys.master_files mf where DB_NAME(mf.database_id) = 'FDDBA'
	and type_desc = 'ROWS'

	SELECT @DefaultDestLogLoc = left(physical_name,(len(physical_name)-(charindex('\',REVERSE(physical_name)))+1))
	FROM sys.master_files mf where DB_NAME(mf.database_id) = 'FDDBA'
	and type_desc = 'LOG'
END
ELSE
BEGIN
	IF @verdec >= 12
	BEGIN
		SELECT @DefaultDestDataLoc = CAST(SERVERPROPERTY('InstanceDefaultDataPath') AS VARCHAR(256)), 
			@DefaultDestLogLoc = CAST(SERVERPROPERTY('InstanceDefaultLogPath') AS VARCHAR(256))
	END
	ELSE
	BEGIN  -- get the location of MODEL
		SELECT 
			@DefaultDestDataLoc = left(physical_name,(len(physical_name)-(charindex('\',REVERSE(physical_name)))+1))
		FROM 
			sys.master_files mf 
		where 
			DB_NAME(mf.database_id) = 'model'
			AND type_desc = 'ROWS'

		SELECT 
			@DefaultDestLogLoc = left(physical_name,(len(physical_name)-(charindex('\',REVERSE(physical_name)))+1))
		 FROM 
			sys.master_files mf 
		 WHERE DB_NAME(mf.database_id) = 'FDDBA'
			AND type_desc = 'LOG'
	END

END

IF @debug = 1
BEGIN
	BEGIN TRY
		SET @msg = '@DefaultDestDataLoc : ' + @DefaultDestDataLoc
		RAISERROR(@msg,10,1) WITH NOWAIT;
		SET @msg = '@DefaultDestLogLoc : ' + @DefaultDestLogLoc
		RAISERROR(@msg,10,1) WITH NOWAIT;
		SET @msg = CHAR(10) + CHAR(13)
		RAISERROR(@msg,10,1) WITH NOWAIT;
	END TRY
	BEGIN CATCH
		SET @msg = 'Error occurred in debug section for @DefaultDestDataLoc, message is: ' + ERROR_MESSAGE()
		RAISERROR(@msg,10,1) WITH NOWAIT;
	END CATCH
END


/* begin creation of the restore command and set single user mode if existing database 
	--Added CAST to varchar max in order to scope the variable as it gets cut off on very long statemntents with lots of files
*/
if exists (select 1 from sys.databases Where name = @DestinationDBName AND state_desc = N'ONLINE')
	BEGIN
		set @RestorePrefix = CAST('USE [MASTER]
ALTER DATABASE [' + @DestinationDBName + '] SET  OFFLINE WITH ROLLBACK IMMEDIATE;

RESTORE DATABASE [' + @DestinationDBName + '] FROM ' AS VARCHAR(MAX))
	END
else
	BEGIN
		set @RestorePrefix = CAST('use master;
		RESTORE DATABASE [' + @DestinationDBName + '] FROM ' AS VARCHAR(MAX))
	END

/* get backup file information from the source instance and saves to temporary table for processing */
If @BackupFileList IS NULL
BEGIN
	IF EXISTS(SELECT [name] FROM tempdb.sys.tables WHERE [name] = '##TempBackupListing') BEGIN
	   drop table ##TempBackupListing;
	END;

		--SELECT @OpenRowSetConnection = 'Server=' + @SourceInstanceName + ';Trusted_Connection=yes;'				
		SELECT @OpenRowSetConnection = 'Server=' + @SourceInstanceName + 
					CASE WHEN @UserId IS NOT NULL AND @Password IS NOT NULL Then 
								';UID=' + @UserId +';PWD=' + @Password +';'
						ELSE	
							';Trusted_Connection=yes;'
						END
			,@OpenRowSetQuery = 'SELECT m.physical_device_name as DeviceName, b.Type, b.BACKUP_START_DATE FROM   msdb.dbo.backupmediafamily m '
							   + 'INNER JOIN msdb.dbo.backupset b ON m.media_set_id = b.media_set_id  where b.type=''''D'''' '
							   + 'and b.database_name = ''''' + @SourceDBName + ''''' and b.backup_finish_date = '
							   + '( select max(backup_finish_date) from msdb.dbo.backupset x inner join  msdb.dbo.backupmediafamily y on x.media_set_id = y.media_set_id where database_name = ''''' + @SourceDBName + 
							   '''''  AND y.PHYSICAL_DEVICE_NAME NOT LIKE ''''%{%''''   and type=''''D'''' and user_name !=''''NT AUTHORITY\SYSTEM'''' )'
	
		SELECT @Sql = 'select * into ##TempBackupListing from OPENROWSET(''' + @DriverName + ''',''' + @OpenRowSetConnection + ''',''' + @OpenRowSetQuery + ''')'

		IF @debug = 1
		BEGIN
			BEGIN TRY
				SET @msg = '@OpenRowSetConnection: ' + @OpenRowSetConnection
				RAISERROR(@msg,10,1) WITH NOWAIT;
				SET @msg = CHAR(10) + CHAR(13)
				RAISERROR(@msg,10,1) WITH NOWAIT;
				
				
				SET @msg = '@OpenRowSetQuery: ' + REPLACE(cast(@OpenRowSetQuery as varchar(2048)),'%','%%')
				RAISERROR(@msg,10,1) WITH NOWAIT;
				SET @msg = CHAR(10) + CHAR(13)
				RAISERROR(@msg,10,1) WITH NOWAIT;

				RAISERROR('-----------------------------------------------------------------------------',10,1) WITH NOWAIT;
				SET @msg = '@Sql for backup info: ' + REPLACE(SUBSTRING(ISNULL(cast(@Sql as VARCHAR(2048)),'isnull'),1,2020),'%','%%')
				RAISERROR(@msg,10,1) WITH NOWAIT;
				RAISERROR('-----------------------------------------------------------------------------',10,1) WITH NOWAIT;
				SET @msg = CHAR(10) + CHAR(13)
				RAISERROR(@msg,10,1) WITH NOWAIT;
			END TRY
			BEGIN CATCH
				SET @msg = 'Error occurred in debug section for @OpenRowSetConnection, message is: ' + ERROR_MESSAGE()
				RAISERROR(@msg,10,1) WITH NOWAIT;
			END CATCH
		END
		EXEC(@Sql)
		IF @debug = 1
			SELECT * from ##TempBackupListing

		--now grab any differenential backups
		SELECT @OpenRowSetQuery = 'SELECT m.physical_device_name as DeviceName, b.Type, b.BACKUP_START_DATE FROM   msdb.dbo.backupmediafamily m '
							   + 'INNER JOIN msdb.dbo.backupset b ON m.media_set_id = b.media_set_id  where b.type=''''I'''' '
							   + 'and b.database_name = ''''' + @SourceDBName + ''''' and b.backup_finish_date = '
							   + '( select max(backup_finish_date) from msdb.dbo.backupset x inner join  msdb.dbo.backupmediafamily y on x.media_set_id = y.media_set_id where database_name = ''''' + @SourceDBName + 
							   '''''  AND y.PHYSICAL_DEVICE_NAME NOT LIKE ''''%{%''''   and type=''''I'''' and user_name !=''''NT AUTHORITY\SYSTEM'''')
							    AND b.BACKUP_START_DATE >
								( select max(backup_finish_date) from msdb.dbo.backupset x inner join  msdb.dbo.backupmediafamily y on x.media_set_id = y.media_set_id where database_name = ''''' + @SourceDBName + 
							   '''''  AND y.PHYSICAL_DEVICE_NAME NOT LIKE ''''%{%''''   and type=''''D'''' and user_name !=''''NT AUTHORITY\SYSTEM'''' )
							   '

		SELECT @Sql = 'INSERT INTO  ##TempBackupListing(DeviceName, Type,BACKUP_START_DATE) SELECT   DeviceName, Type,BACKUP_START_DATE 
				from OPENROWSET(''' + @DriverName + ''',''' + @OpenRowSetConnection + ''',''' + @OpenRowSetQuery + ''')'

		IF @debug = 1
		BEGIN
			BEGIN TRY
				SET @msg = 'Differential @OpenRowSetQuery: ' + REPLACE(cast(@OpenRowSetQuery as varchar(2048)),'%','%%')
				RAISERROR(@msg,10,1) WITH NOWAIT;
				SET @msg = CHAR(10) + CHAR(13)
				RAISERROR(@msg,10,1) WITH NOWAIT;

				RAISERROR('-----------------------------------------------------------------------------',10,1) WITH NOWAIT;
				SET @msg = '@Sql for Diff backup info: ' + REPLACE(SUBSTRING(ISNULL(cast(@Sql as VARCHAR(2048)),'isnull'),1,2010),'%','%%')
				RAISERROR(@msg,10,1) WITH NOWAIT;
				RAISERROR('-----------------------------------------------------------------------------',10,1) WITH NOWAIT;
				SET @msg = CHAR(10) + CHAR(13)
				RAISERROR(@msg,10,1) WITH NOWAIT;
			END TRY
			BEGIN CATCH
				SET @msg = 'Error occurred in debug section for DIFF @OpenRowSetConnection, message is: ' + ERROR_MESSAGE()
				RAISERROR(@msg,10,1) WITH NOWAIT;
			END CATCH
		END
		
		exec(@Sql)

		IF @debug = 1
			SELECT * from ##TempBackupListing
	/* checks the number of backup files in the temporary table and sets the variable BackupItems to it */

		SELECT @BackupItems = count(*) from ##TempBackupListing WHERE  [Type] = 'D'

	/* if 0 BackupItems, then there must not be any backups */

		if @BackupItems = 0
			BEGIN
			 SET @ErrorMessage = 'There are no current backups for ' + @SourceDBName + CHAR(13) + CHAR(10) + ' ';
			 RAISERROR(@ErrorMessage,16,1) WITH NOWAIT;
			 RETURN;
			END;


	/* Building backup information into the restore script by pulling from the temporary previously created */

		SET @RestoreFiles = @BackupItems

		DECLARE _RestoreScript
		CURSOR LOCAL FAST_FORWARD
		FOR
		select DeviceName from ##TempBackupListing WHERE Type = 'D'

		OPEN _RestoreScript FETCH NEXT FROM _RestoreScript INTO @RestoreFile
		WHILE @@FETCH_STATUS=0
		BEGIN
		if @BackupItems = 1
			SET @RestoreBackupFiles = @RestoreBackupFiles + CHAR(13)+CHAR(10)+'DISK='''+@RestoreFile+''''
		else if @RestoreFiles = @BackupItems
			SET @RestoreBackupFiles = @RestoreBackupFiles + CHAR(13)+CHAR(10) + 'DISK='''+ @RestoreFile+''''
		else
			SET @RestoreBackupFiles = @RestoreBackupFiles + CHAR(13)+CHAR(10)+',' + 'DISK='''+@RestoreFile+''''
	/* this is only done to format the backup script */

		SET @RestoreFiles = @RestoreFiles - 1

		FETCH NEXT FROM _RestoreScript INTO @RestoreFile
		END

		CLOSE _RestoreScript
		DEALLOCATE _RestoreScript --cleanup cursor
END
ELSE
BEGIN -- user supplied a backup file list so use that
	SET @RestoreBackupFiles = @BackupFileList

END

SELECT 
	@RestoreBackupFiles = @RestoreBackupFiles + CHAR(13)+CHAR(10) + ' With Replace, stats, ' +
	Case When @BufferCount IS NULL Then '' Else ' BUFFERCOUNT = '	+ CAST(@BufferCount AS VARCHAR(MAX)) + ',' END + 
	Case When @MaxTransferSize IS NULL Then '' Else ' MAXTRANSFERSIZE = '	+ CAST(@MaxTransferSize AS VARCHAR(MAX)) + ',' END 

/* Moving the data/log files to their proper home */

set @Sql = @SourceDBName +'%'

IF OBJECT_ID('tempdb..RestoreFileListOnly') IS NOT NULL
	DROP TABLE #RestoreFileListOnly

CREATE TABLE #RestoreFileListOnly (
	LogicalName nvarchar(128) 
	,PhysicalName nvarchar(260) 
	,Type char(1) 
	,FileGroupName nvarchar(128) 
	,Size numeric(20,0) 
	,MaxSize numeric(20,0),
	Fileid tinyint,
	CreateLSN numeric(25,0),
	DropLSN numeric(25, 0),
	UniqueID uniqueidentifier,
	ReadOnlyLSN numeric(25,0),
	ReadWriteLSN numeric(25,0),
	BackupSizeInBytes bigint,
	SourceBlockSize int,
	FileGroupId int,
	LogGroupGUID uniqueidentifier,
	DifferentialBaseLSN numeric(25,0),
	DifferentialBaseGUID uniqueidentifier,
	IsReadOnly bit,
	IsPresent bit,
	TDEThumbprint varbinary(32)
);


IF @verdec >= 13 --(SQL 2016)
BEGIN
	--Add new column for 2016 and later
	ALTER TABLE #RestoreFileListOnly ADD SnapshotUrl nvarchar(360) null
END


IF @debug =1 
BEGIN
	PRINT ' '
	PRINT ' '
	IF @BackupFileList IS NULL  
	BEGIN
		PRINT '***********************************************************'
		PRINT '      @BackupFileList IS NULL							  '
		PRINT '      using @RestoreFile							  '
		print @RestoreFile
	END
	ELSE
	BEGIN
		PRINT '***********************************************************'
		PRINT '      @BackupFileList 							  '
		PRINT  @BackupFileList
	END	
	PRINT '***********************************************************'
	PRINT ' '
	PRINT ' '
END 

IF @exists = 0
BEGIN

	DECLARE @spxSQL		NVARCHAR(MAX)
	SELECT @spxSQL = 'RESTORE FILELISTONLY FROM ' +
		CASE WHEN @BackupFileList IS NULL THEN	
			' DISK = ''' + @RestoreFile + ''''
		ELSE	@BackupFileList END 
		
	INSERT INTO #RestoreFileListOnly EXEC (@spxSQL);
	if @DestinationDBName = @SourceDBName
		begin
			declare dbfiles_cursor CURSOR FAST_FORWARD LOCAL FOR
			select @SourceDBName, LogicalName as SourceLN, PhysicalName as SourcePN, @DestinationDBName, mf.name as DestLN, mf.physical_name as DestPN
			from #RestoreFileListOnly left outer join sys.master_files mf on @DestinationDBName = db_name(mf.database_id) and LogicalName = mf.name

			open dbfiles_cursor;
			fetch NEXT FROM dbfiles_cursor INTO @SourceDBName,@SourceLN, @SourcePN, @DestinationDBName, @DestLN, @DestPN;
			WHILE @@FETCH_STATUS = 0
			BEGIN
				if @debug = 1
				BEGIN
					PRINT '@SourceLN = ' + @SourceLN
					PRINT '@SourcePN = ' + @SourcePN
					PRINT '@DestLN = ' + @DestLN
					PRINT '@DestPN = ' + @DestPN
				END
				SET @SourceData = substring(@SourcePN,len(@SourcePN)-charindex('\',REVERSE(@SourcePN))+2, (charindex('\',REVERSE(@SourcePN))-charindex('.',REVERSE(@SourcePN)))-1)
				SET @FileEx = substring(@SourcePN,len(@SourcePN)-charindex('.',REVERSE(@SourcePN))+1, charindex('.',REVERSE(@SourcePN)))

				if @debug = 1
				BEGIN
					PRINT '@SourceData = ' + @SourceData
					PRINT '@FileEx = ' + @FileEx
					PRINT '-------------------------------------------------------------------------------------'

				END

				If @FileEx = '.ldf'
					SET @DestPN = @DefaultDestLogLoc + @SourceData + @FileEx	
				else 
					SET @DestPN = @DefaultDestDataLoc + @SourceData + @FileEx

				SET @DataFileLoc = 'MOVE N''' + @SourceLN + ''' TO N''' +@DestPN + ''',' + CHAR(13)+CHAR(10)
				
				SET @RestoreSql = @RestoreSql + @DataFileLoc
	
				FETCH NEXT FROM dbfiles_cursor INTO @SourceDBName,@SourceLN, @SourcePN, @DestinationDBName, @DestLN, @DestPN;
			END;
			close  dbfiles_cursor;
			DEALLOCATE dbfiles_cursor;
		end
	else
		Begin
			declare dbfiles_cursor CURSOR FAST_FORWARD LOCAL FOR
			select @SourceDBName, LogicalName as SourceLN, PhysicalName as SourcePN, @DestinationDBName, mf.name as DestLN, mf.physical_name as DestPN
			from #RestoreFileListOnly left outer join sys.master_files mf on @DestinationDBName = @SourceDBName and LogicalName = mf.name

			open dbfiles_cursor;
			fetch NEXT FROM dbfiles_cursor INTO @SourceDBName,@SourceLN, @SourcePN, @DestinationDBName, @DestLN, @DestPN;
			WHILE @@FETCH_STATUS = 0
			BEGIN
				if @debug = 1
				BEGIN
					PRINT '@SourceLN = ' + @SourceLN
					PRINT '@SourcePN = ' + @SourcePN
					PRINT '@DestLN = ' + @DestLN
					PRINT '@DestPN = ' + @DestPN
				END
				SET @SourceData = substring(@SourcePN,len(@SourcePN)-charindex('\',REVERSE(@SourcePN))+2, (charindex('\',REVERSE(@SourcePN))-charindex('.',REVERSE(@SourcePN)))-1)
				SET @FileEx = substring(@SourcePN,len(@SourcePN)-charindex('.',REVERSE(@SourcePN))+1, charindex('.',REVERSE(@SourcePN)))
			
				BEGIN
					PRINT '@SourceData = ' + @SourceData
					PRINT '@FileEx = ' + @FileEx
					PRINT '-------------------------------------------------------------------------------------'

				END

				If @FileEx = '.ldf'
					SET  @DestPN = @DefaultDestLogLoc + @DestinationDBName +'_' + @SourceData + @FileEx	
				else 
					SET  @DestPN = @DefaultDestDataLoc + @DestinationDBName +'_' + @SourceData + @FileEx
							
				SET @DataFileLoc = 'MOVE N''' + @SourceLN + ''' TO N''' +@DestPN + ''',' + CHAR(13)+CHAR(10)

				SET @RestoreSql = @RestoreSql + @DataFileLoc
	
				FETCH NEXT FROM dbfiles_cursor INTO @SourceDBName,@SourceLN, @SourcePN, @DestinationDBName, @DestLN, @DestPN;
			END;
			close  dbfiles_cursor;
			DEALLOCATE dbfiles_cursor;
		end
END

IF NOT EXISTS(SELECT DeviceName from ##TempBackupListing WHERE [Type] = 'I')
BEGIN
	SET @RestoreSql = @RestoreSql + ' RECOVERY;';
	SELECT  @CompleteSQL =  CAST(@RestorePrefix AS NVARCHAR(MAX)) + @RestoreBackupFiles + @RestoreSql 
	IF @debug = 1
	BEGIN
		RAISERROR('RESTORE script done, there are no differentials',10,1) WITH NOWAIT
	END
END
ELSE
BEGIN --NOW ADD IN THE DIFFERENTIAL RESTORE
	IF @debug = 1
	BEGIN
		RAISERROR('FULL RESTORE script complete, working on differential now.',10,1) WITH NOWAIT
		SELECT DeviceName from ##TempBackupListing WHERE Type = 'I'
		AND BACKUP_START_DATE = (SELECT MAX(BACKUP_START_DATE) FROM ##TempBackupListing WHERE Type = 'I')

	END
	SELECT  @CompleteSQL =  CAST(@RestorePrefix AS NVARCHAR(MAX)) + @RestoreBackupFiles + @RestoreSql + ' NORECOVERY;'  + CHAR(13)+CHAR(10) + CHAR(13)+CHAR(10)
	
	
	SELECT @BackupItems = count(*) from ##TempBackupListing WHERE  [Type] = 'I'
				AND BACKUP_START_DATE = (SELECT MAX(BACKUP_START_DATE) FROM ##TempBackupListing WHERE Type = 'I')
	SET @RestoreFiles = @BackupItems

	SET @CompleteSQL = @CompleteSQL + 'RESTORE DATABASE [' + @DestinationDBName + '] FROM ' 
	
	DECLARE curDiff CURSOR LOCAL FAST_FORWARD FOR
		SELECT DeviceName from ##TempBackupListing WHERE Type = 'I'
		AND BACKUP_START_DATE = (SELECT MAX(BACKUP_START_DATE) FROM ##TempBackupListing WHERE Type = 'I')

		OPEN curDiff 
		FETCH NEXT FROM curDiff INTO @RestoreFile
		WHILE @@FETCH_STATUS=0
		BEGIN
		if @BackupItems = 1
			SET @CompleteSQL = @CompleteSQL + CHAR(13)+CHAR(10)+'DISK='''+ @RestoreFile+''''
		else if @RestoreFiles = @BackupItems
			SET @CompleteSQL = @CompleteSQL + CHAR(13)+CHAR(10) + 'DISK='''+ @RestoreFile+''''
		else
			SET @CompleteSQL = @CompleteSQL + CHAR(13)+CHAR(10)+',' + 'DISK='''+ @RestoreFile+''''
	/* this is only done to format the backup script */

		SET @RestoreFiles = @RestoreFiles - 1

		FETCH NEXT FROM curDiff INTO @RestoreFile
		END
		CLOSE curDiff
		DEALLOCATE curDiff--cleanup cursor

		--now create the rest of the statement
		 SET @CompleteSQL = @CompleteSQL +  CHAR(13)+CHAR(10) + ' WITH  STATS, ' +
		Case When @BufferCount IS NULL Then '' Else ' BUFFERCOUNT = '	+ CAST(@BufferCount AS VARCHAR(MAX)) + ',' END + 
		Case When @MaxTransferSize IS NULL Then '' Else ' MAXTRANSFERSIZE = '	+ CAST(@MaxTransferSize AS VARCHAR(MAX)) + ',' END 

		SET @CompleteSQL = @CompleteSQL + ' RECOVERY;'
END

--NOW LETS OUTPUT THE SCRIPT
If OBJECT_ID('tempdb..##TempBackupListing') IS NOT NULL
	drop table ##TempBackupListing; --cleaning up temp table

If ISNULL(@OutputText,0) = 1
BEGIN
	-- To avoid the truncating of text larger than 8000 loop through the statement and print in 4000 char chunks
	DECLARE @Counter INT
	DECLARE @Counter1 INT
	SET @Counter = 0
	SET @Counter1 = 0
	DECLARE @TotalPrints INT
	SET @TotalPrints = (LEN(@CompleteSQL) / 4000) + 1
	WHILE @Counter < @TotalPrints 
	BEGIN
		PRINT(SUBSTRING(@CompleteSQL,@Counter1,@Counter1+4000))
		SET @Counter1 = @Counter1+4000
		SET @Counter = @Counter + 1
	END
END
ELSE
BEGIN
	--Select  @CompleteSQL =  CAST(@RestorePrefix AS NVARCHAR(MAX)) + @RestoreBackupFiles + @RestoreSql + @RestoreSuffix;
	PRINT @CompleteSQL 
END

If ISNULL(@ExecuteText,0) = 1
	Exec(@CompleteSQL)   --@RestorePrefix + @RestoreBackupFiles + @RestoreSql + @RestoreSuffix)

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pRefreshDatabaseFromFiles]',10,1) WITH NOWAIT;

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pRefreshDatabaseFromFiles]') AND type in (N'P', N'PC'))
BEGIN
	EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [dbo].[pRefreshDatabaseFromFiles] AS select getdate() as DT' 
END

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


ALTER PROCEDURE [dbo].[pRefreshDatabaseFromFiles] 
(
	@dbName											SYSNAME 
	,@NewdBName										SYSNAME = NULL -- USE THIS IF YOU WANT TO RESTORE WITH NEW NAME, DB MUST EXISTS CURRENTLY AS WITH MOVE IS NOT DONE HERE
	,@FullbackupPath								NVARCHAR(300) = NULL
	,@SecondaryFullbackupPath						NVARCHAR(300) = NULL 
	,@DiffbackupPath								NVARCHAR(300) = NULL
	,@SecondaryDiffbackupPath						NVARCHAR(300) = NULL
	,@buffercount									INT = 50
	,@maxTransferSize								INT = 4194304
	,@SkipFull										BIT = 0
	,@SkipDiff										BIT = 0
	,@ForceReadHeaderonly							BIT = 0
	,@Debug											TINYINT = 0
	,@PrintOnly										BIT = 0 -- use this to see all restore commands that would be run, implicitly implies @debug = 1
)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON 

	-- Variable declaration 
	DECLARE @cmd											NVARCHAR(300) 
	DECLARE @lastFullBackup									NVARCHAR(300) 
	DECLARE @lastFullBackupDate								DATETIME
	DECLARE @lastFullLSN									NUMERIC(25,0)
	DECLARE @lastDiffBackup									NVARCHAR(300) 
	DECLARE @lastDiffBackupDate								DATETIME
	DECLARE @lastDiffLSN									NUMERIC(25,0)
	DECLARE @BackupType										CHAR(1)
	DECLARE @BackupDate										DATETIME
	DECLARE @BackupLSN										NUMERIC(25,0)
	DECLARE @lastDiffBackupPath								NVARCHAR(300)
	DECLARE @lastFullBackupPath								NVARCHAR(300)
	DECLARE @backupFile										NVARCHAR(300)
	DECLARE @sql											NVARCHAR(MAX)
	DECLARE @msg											NVARCHAR(2048)

	IF @PrintOnly = 1 AND (@Debug = 0 OR @Debug IS NULL)
	BEGIN
		SET @Debug = 1
	END

	IF @Debug > 0
	BEGIN
		PRINT '/*** pRefreshDatabaseFromFiles parameters ***********************************************'
		PRINT '@dbname=[' + ISNULL(@dbname,'null') + ']'
		PRINT '@NewdBName=[' + ISNULL(@NewdBName,'null') + ']'
		PRINT '@FullbackupPath=' + ISNULL(@FullbackupPath,'null')
		PRINT '@SecondaryFullbackupPath=' + ISNULL(@SecondaryFullbackupPath,'null')
		PRINT '@DiffbackupPath=' + ISNULL(@DiffbackupPath,'null')
		PRINT '@SecondaryDiffbackupPath=' + ISNULL(@SecondaryDiffbackupPath,'null')
		PRINT '@buffercount=' + ISNULL(LTRIM(STR(@buffercount)),'null')
		PRINT '@maxTransferSize=' + ISNULL(LTRIM(STR(@maxTransferSize)),'null')
		PRINT '****************************************************************************************/'
		PRINT ' '
		--RAISERROR('',10,1) WITH NOWAIT;
	END

	IF @SkipFull = 1 OR @SkipDiff = 1
	BEGIN
		PRINT '/*** Skip parameters ********************************************************************'
		PRINT '@SkipFull=' + ISNULL(LTRIM(STR(@SkipFull)),'null')
		PRINT '@SkipDiff=' + ISNULL(LTRIM(STR(@SkipDiff)),'null')
		PRINT '****************************************************************************************/'
		PRINT ' '
		--RAISERROR('',10,1) WITH NOWAIT;
	END

	IF OBJECT_ID('tempdb..#filelist') IS NOT NULL
		DROP TABLE #filelist
	CREATE TABLE #filelist (backupfile  NVARCHAR(255), DatabaseName NVARCHAR(256), BackupType VARCHAR(20), CreatedOn DATETIME, BackupPath nvarchar(300), LSN NUMERIC(25,0))

	IF OBJECT_ID('tempdb..#headers') IS NOT NULL
		DROP TABLE #headers
	CREATE TABLE #headers
		( 
			BackupName varchar(256),
			BackupDescription varchar(256),
			BackupType varchar(256),        
			ExpirationDate varchar(256),
			Compressed varchar(256),
			Position varchar(256),
			DeviceType varchar(256),        
			UserName varchar(256),
			ServerName varchar(256),
			DatabaseName varchar(256),
			DatabaseVersion varchar(256),        
			DatabaseCreationDate varchar(256),
			BackupSize varchar(256),
			FirstLSN varchar(256),
			LastLSN varchar(256),        
			CheckpointLSN varchar(256),
			DatabaseBackupLSN varchar(256),
			BackupStartDate varchar(256),
			BackupFinishDate varchar(256),        
			SortOrder varchar(256),
			[CodePage] varchar(256),
			UnicodeLocaleId varchar(256),
			UnicodeComparisonStyle varchar(256),        
			CompatibilityLevel varchar(256),
			SoftwareVendorId varchar(256),
			SoftwareVersionMajor varchar(256),        
			SoftwareVersionMinor varchar(256),
			SoftwareVersionBuild varchar(256),
			MachineName varchar(256),
			Flags varchar(256),        
			BindingID varchar(256),
			RecoveryForkID varchar(256),
			Collation varchar(256),
			FamilyGUID varchar(256),        
			HasBulkLoggedData varchar(256),
			IsSnapshot varchar(256),
			IsReadOnly varchar(256),
			IsSingleUser varchar(256),        
			HasBackupChecksums varchar(256),
			IsDamaged varchar(256),
			BeginsLogChain varchar(256),
			HasIncompleteMetaData varchar(256),        
			IsForceOffline varchar(256),
			IsCopyOnly varchar(256),
			FirstRecoveryForkID varchar(256),
			ForkPointLSN varchar(256),        
			RecoveryModel varchar(256),
			DifferentialBaseLSN varchar(256),
			DifferentialBaseGUID varchar(256),        
			BackupTypeDescription varchar(256),
			BackupSetGUID varchar(256),
			CompressedBackupSize varchar(256)
		);
		
	IF @@MICROSOFTVERSION >= 184551476 --11.0.2100 (2012 RTM)
	BEGIN
		ALTER TABLE #headers ADD Containment varchar(256)
	END
		
	IF @@MICROSOFTVERSION >= 201328592 --12.0.2000 (2014 RTM)
	BEGIN
		ALTER TABLE #headers ADD KeyAlgorithm nvarchar(32), EncryptorThumbprint varbinary(20), EncryptorType nvarchar(32)
	END

	ALTER TABLE #headers ADD Seq int NOT NULL identity(1,1)

	/**************************************************
		verify the trailing slash exists, if not add it
	**************************************************/
	If SUBSTRING(@FullbackupPath,LEN(@FullbackupPath),1) != N'\'
		SET @FullbackupPath = @FullbackupPath + N'\'
	
	IF @DiffbackupPath IS NOT NULL
		If SUBSTRING(@DiffbackupPath,LEN(@DiffbackupPath),1) != N'\'
			SET @DiffbackupPath = @DiffbackupPath + N'\'

	If @SecondaryFullbackupPath IS NOT NULL
		If SUBSTRING(@SecondaryFullbackupPath,LEN(@SecondaryFullbackupPath),1) != N'\'
			SET @SecondaryFullbackupPath = @SecondaryFullbackupPath + N'\'

	If @SecondaryDiffbackupPath IS NOT NULL
		If SUBSTRING(@SecondaryDiffbackupPath,LEN(@SecondaryDiffbackupPath),1) != N'\'
			SET @SecondaryDiffbackupPath = @SecondaryDiffbackupPath + N'\'

	/**************************************************
		get list of files 
	**************************************************/
	--Primary Full Path
	SET @cmd = 'DIR /A:-D /b "' + @FullbackupPath + '"'
	INSERT INTO #filelist(backupFile) EXEC master.sys.xp_cmdshell @cmd 
	UPDATE #filelist set BackupPath = @FullbackupPath where BackupPath is null

	--Secondary Full Path
	If @SecondaryFullbackupPath IS NOT NULL
	BEGIN
		SET @cmd = 'DIR /A:-D /b "' + @SecondaryFullbackupPath + '"'
		INSERT INTO #filelist(backupFile) EXEC master.sys.xp_cmdshell @cmd 
		UPDATE #filelist set BackupPath = @SecondaryFullbackupPath where BackupPath is null
	END

	--Primary Diff Path
	If @DiffbackupPath IS NOT NULL
	BEGIN
		SET @cmd = 'DIR /A:-D /b "' + @DiffbackupPath + '"'
		INSERT INTO #filelist(backupFile) EXEC master.sys.xp_cmdshell @cmd 
		UPDATE #filelist set BackupPath = @DiffbackupPath where BackupPath is null
	END

	--Secondary Diff Path
	If @SecondaryDiffbackupPath IS NOT NULL
	BEGIN
		SET @cmd = 'DIR /A:-D /b "' + @SecondaryDiffbackupPath + '"'
		INSERT INTO #filelist(backupFile) EXEC master.sys.xp_cmdshell @cmd 
		UPDATE #filelist set BackupPath = @SecondaryDiffbackupPath where BackupPath is null
	END

	DELETE FROM #filelist WHERE backupFile IS NULL OR backupFile LIKE '%The system cannot find the%'



	--Get the file dates from the files
	DECLARE @f NVARCHAR(256)
	DECLARE @p NVARCHAR(256)

	IF @Debug > 2
	BEGIN
		PRINT '/*** #filelist rows1 ********************************************************************'
		SELECT * FROM #filelist 
		PRINT '****************************************************************************************/'
		PRINT ' '
		--RAISERROR('',10,1) WITH NOWAIT;
	END

	DECLARE c CURSOR FOR
	SELECT backupFile, BackupPath from #filelist 
	OPEN c
	FETCH c INTO @f, @p
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @BackupType = NULL

		IF @ForceReadHeaderonly = 0
		BEGIN
			SELECT TOP 1 @BackupType = b.[type], @BackupDate = b.backup_start_date, @BackupLSN = COALESCE(b.differential_base_lsn, b.checkpoint_lsn)
				FROM msdb.dbo.backupmediafamily f
					INNER JOIN msdb.dbo.backupset b
					ON f.media_set_id = b.media_set_id
				WHERE f.physical_device_name = @p + @f
					AND b.database_name = @dbname
		END

		IF @BackupType IS NULL
		BEGIN
			--SET @cmd = 'for %F in (' + @FullbackupPath + + @f +') do @echo %~tF'
			SET @cmd = 'restore headeronly from disk = ''' + @p + @f +''''

			IF @Debug > 1
			BEGIN
				PRINT @cmd
			END

			BEGIN TRY
				INSERT INTO #headers
					exec (@cmd)
			END TRY
			BEGIN CATCH
				PRINT '--Error reading header of file with following command:'
				SET @cmd = '--' + @cmd
				PRINT @cmd 
				PRINT ' '
		--RAISERROR(@cmd,10,1) WITH NOWAIT;
			END CATCH
			UPDATE f SET
					CreatedOn = h.BackupStartDate  
					,DatabaseName = h.DatabaseName
					,BackupType = CASE h.BackupType WHEN 1 THEN 'D' WHEN 5 THEN 'I' ELSE LTRIM(STR(h.BackupType)) END
					,LSN = COALESCE(h.DifferentialBaseLSN, h.CheckpointLSN)
				FROM #filelist f
				CROSS JOIN #headers h
				WHERE f.backupfile = @f 
			TRUNCATE TABLE  #headers
		END
		ELSE
		BEGIN
			UPDATE #filelist
				SET
					CreatedOn = @BackupDate
					,DatabaseName = @dbname
					,BackupType = @BackupType
					,LSN = @BackupLSN
				WHERE backupfile = @f 			
		END
		FETCH c INTO @f, @p
	END
	CLOSE c
	DEALLOCATE c

	/******************************************************************************************************************************************************/

	-- If the db exists add the single user code
	--cmm changed to taking the database offline to mitigate failures due to non-exclusive access
	SET @sql = N''
	IF EXISTS(SELECT 1 FROM sys.databases where name = COALESCE(@NewdBName,@dbName) AND state_desc = N'ONLINE')
	BEGIN
		SET @sql = 'USE MASTER; 
ALTER DATABASE [' + COALESCE(@NewdBName,@dbName) + '] SET OFFLINE WITH ROLLBACK IMMEDIATE;
USE MASTER;'

	END

	--Find latest full backup 
	SELECT 
		 @lastFullBackup = backupfile 
		,@lastFullBackupDate = CreatedOn
		,@lastFullBackupPath = BackupPath
		,@lastFullLSN = LSN
	FROM 
		#filelist  
	 WHERE	
		BackupType = 'D'
		AND DatabaseName = @dbName  
		AND CreatedOn = (SELECT MAX(CreatedOn)
							FROM  #filelist
							WHERE DatabaseName = @dbName
							   AND BackupType = 'D'
						)

	IF @Debug > 0
	BEGIN
		PRINT ''
		PRINT '/*** backup info *************************************************************************'
		PRINT '@lastFullBackup=' + ISNULL(@lastFullBackup,'null')
		PRINT '@lastFullBackupDate=' + ISNULL(CONVERT(NVARCHAR(60),@lastFullBackupDate,109),'null')
		PRINT '@lastFullLSN=' + ISNULL(CONVERT(varchar(25), @lastFullLSN),'null')
		PRINT ' '
		--RAISERROR('',10,1) WITH NOWAIT;
	END

	IF @SkipFull = 1
	BEGIN
		SET @sql = @sql + CHAR(13) + CHAR(10) + '/*'
	END

	SET @sql = @sql + CHAR(13) + CHAR(10) + 'RESTORE DATABASE [' + COALESCE(@NewdBName,@dbName) + '] FROM DISK = '''  
		   + @lastFullBackupPath + @lastFullBackup + ''' WITH NORECOVERY, REPLACE, STATS=10' 
		   + CASE WHEN @buffercount IS NOT NULL THEN ', BUFFERCOUNT = ' + CAST(@buffercount AS VARCHAR(10)) ELSE '' END
		   + CASE WHEN @maxTransferSize IS NOT NULL THEN ', MAXTRANSFERSIZE  = ' + CAST(@maxTransferSize AS VARCHAR(10)) ELSE '' END
		   + ';'

	IF @SkipFull = 1
	BEGIN
		SET @sql = @sql + CHAR(13) + CHAR(10) + '*/'
	END

	--Find latest diff backup 
	SELECT 
		@lastDiffBackup = backupFile
		,@lastDiffBackupPath = BackupPath
		,@lastDiffBackupDate = CreatedOn
		,@lastDiffLSN = LSN
	FROM 
		#fileList  
	WHERE 
		BackupType = 'I'
		AND DatabaseName = @dbName  
		AND CreatedOn = (SELECT MAX(CreatedOn)
							FROM  #filelist
							WHERE  DatabaseName = @dbName 
							   AND BackupType = 'I'
						)
		AND CreatedOn > @lastFullBackupDate

	IF @Debug > 0
	BEGIN
		PRINT '@lastDiffBackup=' + ISNULL(@lastDiffBackup,'null')
		PRINT '@lastDiffBackupDate=' + ISNULL(CONVERT(NVARCHAR(60),@lastDiffBackupDate,109),'null')
		PRINT '@lastDiffLSN=' + ISNULL(CONVERT(varchar(25), @lastDiffLSN),'null')
		PRINT '****************************************************************************************/'

		IF @Debug > 1
		BEGIN
			PRINT ''
			PRINT '/*** #filelist rows2 ********************************************************************'
			PRINT ''
			SELECT * from #fileList
			PRINT '****************************************************************************************/'
		END
		PRINT ' '
		--RAISERROR('',10,1) WITH NOWAIT;
	END


	-- check to make sure there is a diff backup 
	IF @lastDiffBackup IS NOT NULL 
	BEGIN 
		IF @SkipDiff = 1
		BEGIN
			SET @sql = REPLACE(@sql,' NORECOVERY',' RECOVERY')
			SET @sql = @sql + CHAR(13) + CHAR(10) + '/*' 
		END

		--mjz changed order to 0x0d0a 
		SET @sql = @sql + + CHAR(13) + CHAR(10) + 'RESTORE DATABASE [' + @dbName + '] FROM DISK = '''  
				+ @lastDiffBackupPath + @lastDiffBackup + ''' WITH RECOVERY , STATS=10' 
				+ CASE WHEN @buffercount IS NOT NULL THEN ', BUFFERCOUNT = ' + CAST(@buffercount AS VARCHAR(10)) ELSE '' END
				+ CASE WHEN @maxTransferSize IS NOT NULL THEN ', MAXTRANSFERSIZE  = ' + CAST(@maxTransferSize AS VARCHAR(10)) ELSE '' END
				+ ';'

	   	IF @SkipDiff = 1
		BEGIN
			SET @sql = @sql + CHAR(13) + CHAR(10) + '*/'
		END
	END 
	ELSE
	BEGIN
		--NEED TO CHANGE THE NORECOVERY OPTION TO RECOVERY, IF ADDING TRAN LOG BACKUP THEN THIS CODE HAS TO MOVE TO THE END
		SET @sql = REPLACE(@sql,' NORECOVERY',' RECOVERY')
		SET @sql = @sql + CHAR(13) + CHAR(10) + '--Could not find a differential backup'
		RAISERROR('--Could not find a differential backup' ,10,1);
	END

	--cmm added the below to bring database online in case restore errors out and database left offline, mjz changed order to 0x0d0a 
	SET @sql = @sql + CHAR(13) + CHAR(10) + 'ALTER DATABASE [' + COALESCE(@NewdBName,@dbName) + '] SET ONLINE;'

	PRINT ''
	PRINT '--SQL Statement:'
	PRINT @sql


	/**************************************************
		Execute the restore
	**************************************************/
	IF @PrintOnly = 0
	BEGIN
		PRINT ''
		PRINT ''
		RAISERROR('--About to execute statement.' ,10,1) WITH NOWAIT;
		IF @lastDiffBackup IS NULL
		BEGIN
			IF EXISTS (SELECT 1 FROM dbo.CommandLog)
			BEGIN
				INSERT dbo.CommandLog (DatabaseName, Command, CommandType, StartTime)
					VALUES (@dbname, @sql, 'RESTORE_DATABASE', GETDATE())
			END
			EXECUTE sp_executesql @sql
			PRINT '--Statement execution completed.'
		END
		ELSE
		BEGIN
			IF @lastFullLSN = @lastDiffLSN
			BEGIN
				IF EXISTS (SELECT 1 FROM dbo.CommandLog)
				BEGIN
					INSERT dbo.CommandLog (DatabaseName, Command, CommandType, StartTime)
						VALUES (@dbname, @sql, 'RESTORE_DATABASE', GETDATE())
				END
				EXECUTE sp_executesql @sql
				PRINT '--Statement execution completed.'
			END
			ELSE
			BEGIN
				IF @SkipFull = 1 OR @SkipDiff = 1
				BEGIN
					SET @sql = @sql + CHAR(13) + CHAR(10) + '--WARNING: Differential backup not based on full backup.'
					RAISERROR('--WARNING: Differential backup not based on full backup.' ,10,1) WITH NOWAIT;
					IF EXISTS (SELECT 1 FROM dbo.CommandLog)
					BEGIN
						INSERT dbo.CommandLog (DatabaseName, Command, CommandType, StartTime)
							VALUES (@dbname, @sql, 'RESTORE_DATABASE', GETDATE())
					END
					EXECUTE sp_executesql @sql
					PRINT '--Statement execution completed.'
				END
				ELSE
				BEGIN
					SET @sql = @sql + CHAR(13) + CHAR(10) + '--ERROR: Differential backup not based on full backup. Command not executed'
					RAISERROR('ERROR: Differential backup not based on full backup. Command not executed' ,16,1) WITH NOWAIT;
					IF EXISTS (SELECT 1 FROM dbo.CommandLog)
					BEGIN
						INSERT dbo.CommandLog (DatabaseName, Command, CommandType, StartTime, ErrorNumber)
							VALUES (@dbname, @sql, 'RESTORE_DATABASE', GETDATE(), 3136)
					END
				END
			END
		END
	END
	ELSE
	BEGIN
		IF @lastDiffBackup IS NOT NULL
		BEGIN
			IF @lastFullLSN != @lastDiffLSN
			BEGIN
				RAISERROR('--WARNING: Differential backup not based on full backup.' ,10,1) WITH NOWAIT;
			END
		END
	END
	
	PRINT ' '
		--RAISERROR('',10,1) WITH NOWAIT;
END
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[Process_Monitor_Adhoc_Purge]',10,1) WITH NOWAIT;
if object_id('dbo.Process_Monitor_Adhoc_Purge') is null exec('create procedure [dbo].[Process_Monitor_Adhoc_Purge] as select getdate() DT')
GO
  
alter procedure dbo.Process_Monitor_Adhoc_Purge
(
	@days					int = -90,
	@batchsize				int = 5000,
	@debug					bit = 1
)
WITH ENCRYPTION
AS
SET NOCOUNT ON

declare @recsaffected			int
declare @mindate				datetime
declare @start					datetime
declare @end					datetime
declare @msg					nvarchar(1000)
declare @errMsg					nvarchar(2048)
declare @errorCount				int 

SET @errorCount = 0
If @days > 0 
	set @days = @days * -1

set @mindate = DATEADD(day,@days,getdate())

set @recsaffected = 1
While @recsaffected > 0
Begin
	Begin try
		set @recsaffected = 0
		set @start = SYSDATETIME()
		Begin Tran
		DELETE 
			TOP (@batchsize) 
		  FROM	
			dbo.Process_Monitor_Adhoc
		 WHERE
			inserted_dt < @mindate

		set @recsaffected = @@ROWCOUNT
		Commit

		If @debug = 1
		begin
			set @end = SYSDATETIME()
			set @msg = N'Deleted ' + cast(@recsaffected as nvarchar(20)) + N' records from dbo.Process_Monitor_Adhoc table in ' + 
					cast(DATEDIFF(ms,@start, @end) as nvarchar(20)) + N' milliseconds (' +
					cast(DATEDIFF(second,@start, @end) as nvarchar(20)) + N' seconds).'
			RAISERROR(@msg, 10,1) with nowait;
		end

	End Try
	Begin Catch
		--get the error information and print it out, we are not going to stop the process we will continue on
		Select @errMsg = N' Error number ' + cast(ERROR_NUMBER() as nvarchar(20)) + N' occurred on line ' + cast(ERROR_LINE() as nvarchar(10)) + N', with message: ' +
			substring(ERROR_MESSAGE(),1,1975) 
		
		RAISERROR(@errMsg, 15,1) with nowait;
		--Transaction is not committable and must be rolled back
		If (XACT_STATE()) = -1
		begin
			Set @msg = 	N'The transaction is in an uncommittable state. Rolling back transaction with ' +
				cast(@recsaffected as nvarchar(20)) + N' records.'
			RAISERROR(@msg, 10,1) with nowait;
			ROLLBACK TRANSACTION;
		end
		-- Transaction is committable, so just do it!
		Else If (XACT_STATE()) = 1
		begin
			Set @msg = 	N'The transaction is in a committable state. Committing transaction.'
			RAISERROR(@msg, 10,1) with nowait;
			COMMIT TRANSACTION;   
		end
		set @errorCount = @errorCount + 1
		If @errorCount >= 3
			break;
	End Catch
End


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pSecurity]',10,1) WITH NOWAIT;
if object_id('dbo.pSecurity') is null exec('create procedure [dbo].[pSecurity] as select getdate() DT')
GO
  /*******************************************************************************
Created By: Nicole Harrington
Created On: 06/26/2018

Purpose: Procedure to apply or drop security from Restore/Drop Security tables for the database selected.

Requirements: Tables - Security_Drop, Security_Restore; Procedures - pSecurityDropCreate, pSecurityExtract

Parameters:		
	@DebugOverride	BIT = 0 :	Real parameter accepted by Procedure that will override the Debug setting in the table of parameters, makes it easier to debugz
								** not yet available.
	@DB_in       		:      Database name of the database to apply or drop security from. If NULL, it will be the current database context.

	@Action				:	   ADD/DELETE/EXTRACT/MIGRATE (restore timings are not considered when adding new permissions)
    @UserExclude_Flag	:		used only for DELETE; 1 - standard will exclude 'SYS','dbo','guest','INFORMATION_SCHEMA','CDC'
	@CreatedOn			:		NULL is default - What run would you like to use?	
------------------------------------------------------------------------------------------------------------------------------------------
Changes 
Date:	
By:		
Notes:
*******************************************************************************/
alter procedure [dbo].[pSecurity](
@DB_in						sysname 
   ,@Action					    nvarchar(8) = 'ADD' -- OR DELETE
   ,@UserExclude_Flag			INT = 1 -- only for DELETE; 1 is default mode
   ,@CreatedOn					datetime = NULL-- how many days back?
)
WITH ENCRYPTION
AS
SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON

DECLARE  @StmtMax INT 
        ,@StmtMin INT
        ,@CurrentRun INT 
        ,@SQLStatement NVARCHAR(MAX)
		,@DatabaseName sysname
		,@TableName NVARCHAR(30)
		,@ObjCnt INT
		,@MaxCreatedOn datetime
		,@HasError	BIT
		,@LastRestore datetime

		DECLARE @msg	VARCHAR(2048)

SET @DatabaseName = @DB_in
SET @HasError = 0

Print @Action

IF @Action = 'DELETE'
	BEGIN
	SELECT @TableName = 'Security_Drop'
	EXEC	[FDDBA].[dbo].[pSecurityDropCreate]
		@DB_in = @DB_in,
		@UserExclude_Flag = @UserExclude_Flag

	SET @SQLStatement = 'SELECT Top 1 @MaxDate = CreatedOn
		FROM FDDBA..' + @TableName +
		' where DatabaseName = ''' + @DatabaseName +''''

	EXECUTE sp_ExecuteSQL @SQLStatement, N'@MaxDate datetime OUTPUT', @MaxDate=@MaxCreatedOn OUTPUT

	END	
ELSE IF @Action = 'ADD'
	BEGIN
		IF @CreatedOn IS NOT NULL
			BEGIN
			Print 'Using permissions up from ' + convert(nvarchar(20),@CreatedOn)
			Print ''
			SET @MaxCreatedOn = @CreatedOn
			END
	SELECT @TableName = 'Security_Restore'

	;WITH LastRestores AS
	(
	SELECT
	DatabaseName = [d].[name] ,
	RestoreDate = r.restore_date,
	RowNum = ROW_NUMBER() OVER (PARTITION BY d.Name ORDER BY r.[restore_date] DESC)
	FROM master.sys.databases d
	LEFT OUTER JOIN msdb.dbo.[restorehistory] r ON r.[destination_database_name] = d.Name
	)
	SELECT @LastRestore = 
		RestoreDate
	FROM [LastRestores]
	WHERE [RowNum] = 1
	and DatabaseName = @DatabaseName
	END
ELSE IF @Action = 'MIGRATE'
	BEGIN
		IF @CreatedOn IS NOT NULL
			BEGIN
			Print 'Using permissions up from ' + convert(nvarchar(20),@CreatedOn)
			Print ''
			SET @MaxCreatedOn = @CreatedOn
			END
	SELECT @TableName = 'Security_Restore'
	END
ELSE IF @Action = 'EXTRACT'
	BEGIN
	EXEC	[FDDBA].[dbo].[pSecurityExtract]
		@DB_in = @DB_in
	RETURN;
	END	
ELSE
	BEGIN
	SET @HasError = 1
	SELECT @msg = CHAR(9) +  CHAR(9) +  ERROR_MESSAGE()
	RAISERROR('		CRITICAL CRITICAL - Use either ADD, DELETE or EXTRACT',10,1) WITH NOWAIT;
	RAISERROR(@msg, 10,1) WITH NOWAIT;
	RETURN;
	END

IF @CreatedOn IS NULL and @Action = 'ADD'
BEGIN
	SET @SQLStatement = 'SELECT Top 1 @MaxDate = CreatedOn
	FROM FDDBA..' + @TableName +
	' where DatabaseName = ''' + @DatabaseName +''' and CreatedOn < ''' + Convert(nvarchar(20),@LastRestore) +''' 
	Group by DatabaseName, CreatedOn 
	order by CreatedOn desc'

	EXECUTE sp_ExecuteSQL @SQLStatement, N'@MaxDate datetime OUTPUT', @MaxDate=@MaxCreatedOn OUTPUT

	IF @@rowcount = 0
	BEGIN
		SET @HasError = 1
		SELECT @msg = CHAR(9) +  CHAR(9) +  ERROR_MESSAGE()
		RAISERROR('		CRITICAL CRITICAL - Permission Count too low!!!!',10,1) WITH NOWAIT;
		RAISERROR(@msg, 10,1) WITH NOWAIT;
		RETURN;
	END

	Print 'Using permissions from ' + convert(nvarchar(20),@MaxCreatedOn)
	Print ''
END

IF @CreatedOn IS NULL and @Action = 'MIGRATE'
BEGIN
	SET @SQLStatement = 'SELECT Top 1 @MaxDate = CreatedOn
	FROM FDDBA..' + @TableName +
	' where DatabaseName = ''' + @DatabaseName +''' 
	Group by DatabaseName, CreatedOn 
	order by CreatedOn desc'

	EXECUTE sp_ExecuteSQL @SQLStatement, N'@MaxDate datetime OUTPUT', @MaxDate=@MaxCreatedOn OUTPUT
/*
	IF @@rowcount = 0
	BEGIN
		SET @HasError = 1
		SELECT @msg = CHAR(9) +  CHAR(9) +  ERROR_MESSAGE()
		RAISERROR('		CRITICAL CRITICAL - Permission Count too low!!!!',10,1) WITH NOWAIT;
		RAISERROR(@msg, 10,1) WITH NOWAIT;
		RETURN;
	END
*/
	Print 'Using permissions from ' + convert(nvarchar(20),@MaxCreatedOn)
	Print ''
END

-- Min Max values from the table
SET @SQLStatement = 'SELECT @StmentMax = MAX(Command_ID) FROM FDDBA..' + @TableName +
' where DatabaseName = ''' + @DatabaseName + ''' and CreatedOn = ''' + convert(nvarchar(30),@MaxCreatedOn,121) + ''''

EXECUTE sp_ExecuteSQL @SQLStatement, N'@StmentMax INT OUTPUT', @StmentMax=@StmtMax OUTPUT

SET @SQLStatement = 'SELECT @StmentMin = MIN(Command_ID) FROM FDDBA..' + @TableName +
' where DatabaseName = ''' + @DatabaseName + ''' and CreatedOn = ''' + convert(nvarchar(30),@MaxCreatedOn,121) + ''''

EXECUTE sp_ExecuteSQL @SQLStatement, N'@StmentMin INT OUTPUT', @StmentMin=@StmtMin OUTPUT

-- Start the Loop
SET @CurrentRun = @StmtMin

WHILE @StmtMax >= @CurrentRun
BEGIN
	
	SET @SQLStatement = 'SELECT @SQLStmt = Command FROM FDDBA..' + @TableName + ' WHERE Command_ID = ' + convert(nvarchar(8),@CurrentRun) +
		' and Command not like ''%%sysrowsets%%'' and CreatedOn = ''' + convert(nvarchar(30),@MaxCreatedOn,121) + ''''

	EXECUTE sp_ExecuteSQL @SQLStatement, N'@SQLStmt NVARCHAR(MAX) OUTPUT', @SQLStmt=@SQLStatement OUTPUT  
	  -- Get the SQL from the table 

	IF @SQLStatement NOT LIKE 'USE%'
		Print ''
		SET @SQLStatement = 'USE ' + @DatabaseName + ' ' + @SQLStatement
    
	RAISERROR(@SQLStatement,10,1) WITH NOWAIT;
	BEGIN TRY
		
		--PRINT @SQLStatement + ' ' + convert(nvarchar(6),@CurrentRun) + ' ' + convert(nvarchar(6),@StmtMax)
		EXEC sp_ExecuteSQL @SQLStatement;                  -- Execute the SQL 

    END TRY
	BEGIN CATCH
		SET @HasError = 1
		SELECT @msg = CHAR(9) +  CHAR(9) +  ERROR_MESSAGE()
		RAISERROR('		CRITICAL CRITICAL - The permission statement failed, error follows:',10,1) WITH NOWAIT;
		RAISERROR(@msg, 10,1) WITH NOWAIT;
	END CATCH

	SET @CurrentRun = @CurrentRun + 1

END

--IF @HasError = 1
--	RAISERROR('Job had errors with some permissions, please check the log file for the errors.',15,1) WITH LOG;*/


 

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pSecurityDropCreate]',10,1) WITH NOWAIT;
if object_id('dbo.pSecurityDropCreate') is null exec('create procedure [dbo].[pSecurityDropCreate] as select getdate() DT')
GO
  /*******************************************************************************
Created By: Nicole Harrington
Created On: 06/26/2018

Purpose: Procedure to create the script to drop security which will drop users from database given.
    	 Additionally, a user name can be provided to be excluded.

Requirements: Tables - Security_Drop

Parameters:		
	@DebugOverride	BIT = 0 :	Real parameter accepted by Procedure that will override the Debug setting in the table of parameters, makes it easier to debugz
								** not yet available.
	@DB_in       		: Database name of the database to drop security from. If NULL, it will be the current database context.
	
	@UserExclude_Flag	: 1 - default will exclude 'SYS','dbo','guest','INFORMATION_SCHEMA','CDC'
                          2 - custom will exclude only items in list in field 3 **not yet available

------------------------------------------------------------------------------------------------------------------------------------------
Changes 
Date:	
By:		
Notes:
*******************************************************************************/
alter procedure [dbo].[pSecurityDropCreate](
	@DB_in						sysname = NULL
	,@UserExclude_Flag				INT = 1
	,@DebugOverride	BIT = 0
)
WITH ENCRYPTION
AS
SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON

DECLARE 
	@msgStatement [varchar](8000),
	@Objects INT,
    @ObjName [nvarchar] (100),
	@ObjType [nvarchar] (100),
	@ObjOwner [nvarchar] (100),
	@InstName [nvarchar] (100),
	@SchemaName [varchar](100),
	@UserExclude [nvarchar] (100),
	@RoleExclude [nvarchar] (100),
	@DatabaseName [nvarchar] (100),
	@DatabaseUser [varchar] (100),
	@ApplicationRole [varchar] (100),
	@DatabaseRole [varchar] (100),
	@Acctnm [nvarchar] (40),
    @ActiveInd [smallint],
	@SqlCommand [nvarchar] (1000),
	@ObjCnt INT,
	@CurrentRunTime [DateTime],
	@Permission [nvarchar] (100),
	@Grantor [nvarchar] (100),
	@Grantee [nvarchar] (100)
-- QUERY VARIABLES
DECLARE @query as varchar(2000)
DECLARE @subquery as varchar(500)
DECLARE @subquery2 as varchar(500)
DECLARE @subquery3 as varchar(500)
DECLARE @subquery4 as varchar(500)

SET @CurrentRunTime = GETDATE()

SET NOCOUNT ON

--***************************************************
-- Get current executing db name 
-- Get current instance name 
--***************************************************
SELECT @InstName = LEFT(@@SERVERNAME,3);

IF @DB_in IS NULL
	SET @DatabaseName = db_name()
ELSE
	SET @DatabaseName = @DB_in

IF OBJECT_ID('tempdb..#userexclude') IS NOT NULL
	DROP TABLE #userexclude 
	
CREATE TABLE #userexclude (username nvarchar(100))

IF @UserExclude_Flag = 1 -- THIS IS THE DEFAULT SETTING AND WILL EXCLUDE THESE STANDARD USERS
INSERT INTO #userexclude(username) VALUES  ('SYS'),('dbo'),('guest'),('INFORMATION_SCHEMA'),('CDC')

select @ObjCnt = count(*) FROM FDDBA..Security_Drop
where DatabaseName = @DatabaseName

IF @ObjCnt > 1
	delete from  FDDBA..Security_Drop
	where DatabaseName = @DatabaseName

IF OBJECT_ID(N'[TempDB].[dbo].[##SchemaList]', N'U') IS NOT NULL
BEGIN
	DROP TABLE ##SchemaList
END

SET @query = 'SELECT SS.name as Name
into ##SchemaList 
FROM ['+ @DatabaseName + '].sys.schemas SS 
where SS.name not in (select username from #userexclude)
and SS.name not IN (''db_owner'',''db_securityadmin'',''db_accessadmin'',''db_backupoperator'',''db_ddladmin'',''db_datareader'',''db_datawriter'',''db_denydatareader'',''db_denydatawriter'')'

exec (@query)

SELECT @Objects = count(*)
from ##SchemaList

IF (@Objects >= 1)
	BEGIN
	PRINT ' '
	PRINT '-- Schema Owned objects moved to dbo' 

	DECLARE _ObjOwnr CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR 
	SELECT DISTINCT Name from ##SchemaList

	OPEN _ObjOwnr 
	FETCH NEXT FROM  _ObjOwnr INTO @ObjOwner
	WHILE @@FETCH_STATUS = 0
		BEGIN
		SET @msgStatement =
		'USE [' + @DatabaseName + ']' + CHAR(13) +
		'ALTER AUTHORIZATION ON SCHEMA::[' + @ObjOwner + '] to [dbo];'
		PRINT @msgStatement
		INSERT INTO FDDBA..Security_Drop (command,CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
		FETCH NEXT FROM  _ObjOwnr INTO @ObjOwner
	END
	CLOSE  _ObjOwnr 
	DEALLOCATE  _ObjOwnr --cleanup cursor
END


IF OBJECT_ID(N'[TempDB].[dbo].[##RoleList]', N'U') IS NOT NULL
BEGIN
	DROP TABLE ##RoleList
END

SET @query =N'select dp1.Name as Name, dp2.Name as Owner
	into ##RoleList
	from ['+ @DatabaseName + '].[sys].[database_principals] dp1 
	JOIN ['+ @DatabaseName + '].sys.database_principals AS DP2
	ON DP1.owning_principal_id = DP2.principal_id
	where dp1.type=''R'' and dp1.is_fixed_role != 1 and dp1.name not like ''public''
	and dp2.Name <> ''dbo'''

	exec (@query)

SELECT @Objects = count(*)
from ##RoleList

IF (@Objects >= 1)
	BEGIN
	PRINT ' '
	PRINT '-- User Owned roles moved to dbo' 

	DECLARE _ObjOwnr CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR 
	SELECT DISTINCT Name from ##RoleList

	OPEN _ObjOwnr 
	FETCH NEXT FROM  _ObjOwnr INTO @ObjOwner
	WHILE @@FETCH_STATUS = 0
		BEGIN
		SET @msgStatement =
		'USE [' + @DatabaseName + ']' + CHAR(13) +
		'ALTER AUTHORIZATION ON ROLE::[' + @ObjOwner + '] to [dbo];'
		PRINT @msgStatement
		INSERT INTO FDDBA..Security_Drop (command,CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
		FETCH NEXT FROM  _ObjOwnr INTO @ObjOwner
	END
	CLOSE  _ObjOwnr 
	DEALLOCATE  _ObjOwnr --cleanup cursor
END

--***************************************************
-- Begin cursor to loop through db roles and drop members
--***************************************************

IF OBJECT_ID(N'[TempDB].[dbo].[##MemberList]', N'U') IS NOT NULL
BEGIN
	DROP TABLE ##MemberList
END

SET @query = 'SELECT Y.name as Role, Z.name as UserName
into ##MemberList 
FROM ['+ @DatabaseName + '].sys.database_role_members M
	RIGHT OUTER JOIN ['+ @DatabaseName + '].sys.database_principals Y on M.role_principal_id = Y.principal_id
	INNER JOIN ['+ @DatabaseName + '].sys.database_principals P on Y.sid = P.sid
	FULL OUTER JOIN (select * from ['+ @DatabaseName + '].sys.database_principals) Z on Z.principal_id = M.member_principal_id
	WHERE p.principal_id NOT IN (0,1,2,3,4,16384,16385,16386,16387,16389,16390,16391,16392,16393)
	and P.type = ''R'' '
print ''
--print @query
exec (@query)

SELECT @Objects = count(*)
	FROM ##MemberList

IF (@Objects >= 1)
BEGIN
	PRINT ' '
	PRINT '-- Dropping members of non-default Roles and Roles' 

	DECLARE dbrole_sql CURSOR fast_forward FOR

	SELECT * from ##MemberList

	OPEN dbrole_sql

	FETCH NEXT FROM dbrole_sql INTO @DatabaseRole, @DatabaseUser

	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF ( @DatabaseUser is not NULL)
			BEGIN
			SET @msgStatement = 
			'USE [' + @DatabaseName + ']' + CHAR(13) +
			'ALTER ROLE [' + @DatabaseRole + '] DROP MEMBER [' + @DatabaseUser + ']'
			
			PRINT @msgStatement	
			INSERT INTO FDDBA..Security_Drop (command,CreatedOn,DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
			END	
	
		FETCH NEXT FROM dbrole_sql INTO @DatabaseRole, @DatabaseUser
	END 

    CLOSE dbrole_sql

    DEALLOCATE dbrole_sql

END

--***************************************************
-- Begin cursor to revoke any granted permissions
--***************************************************
IF OBJECT_ID(N'[TempDB].[dbo].[##PermList]', N'U') IS NOT NULL
BEGIN
	DROP TABLE ##PermList
END

SET @query = 'USE ['+ @DatabaseName + '] 
SELECT perm.permission_name, user_name(grantor_principal_id) as Grantor, user_name(grantee_principal_id) as Grantee
into ##PermList 
FROM [sys].[database_principals] princ
	LEFT JOIN [sys].[database_permissions] perm
	ON perm.grantee_principal_id = princ.principal_id
    WHERE user_name(grantee_principal_id) = ''public''
and user_name(grantor_principal_id) <> ''dbo'''
print ''
--print @query
exec (@query)

SELECT @Objects = count(*)
		from ##PermList

IF (@Objects >= 1)
BEGIN
	PRINT ' '
	PRINT '-- Revoking permissions granted by users' 

	DECLARE user_sql CURSOR fast_forward FOR

	SELECT * from ##PermList

	OPEN user_sql

	FETCH NEXT FROM user_sql INTO @Permission, @Grantor, @Grantee

	WHILE @@FETCH_STATUS = 0
	BEGIN
        SET @msgStatement = 
        'USE [' + @DatabaseName + ']' + CHAR(13) +
		'REVOKE '+ @Permission +' ON USER::[' + @Grantor +'] TO ['+ @Grantee + '] AS [' + + @Grantor +']'+ CHAR(13)
		PRINT @msgStatement
		INSERT INTO FDDBA..Security_Drop (command,CreatedOn,DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
		FETCH NEXT FROM user_sql INTO @Permission, @Grantor, @Grantee
	END
END

CLOSE user_sql

DEALLOCATE user_sql

--***************************************************
-- Begin cursor to loop through sql users and drop them
--***************************************************
IF OBJECT_ID(N'[TempDB].[dbo].[##UserList]', N'U') IS NOT NULL
BEGIN
	DROP TABLE ##UserList
END

SET @query = 'SELECT Y.[name]
into ##UserList 
FROM ['+ @DatabaseName + '].[dbo].[sysusers] Y
	INNER JOIN ['+ @DatabaseName + '].sys.database_principals P
	ON Y.[sid] = P.[sid]
    WHERE P.[principal_id] NOT IN (0,1,2,3,4,16384,16385,16386,16387,16389,16390,16391,16392,16393)
	and  P.[type] NOT IN (''R'',''A'')
	and Y.name not in (select * from #userexclude)'
print ''
--print @query
exec (@query)

SELECT @Objects = count(*)
		from ##UserList

IF (@Objects >= 1)
BEGIN
	PRINT ' '
	PRINT '-- Dropping non-default Users' 

	DECLARE user_sql CURSOR fast_forward FOR

	SELECT * from ##UserList

	OPEN user_sql

	FETCH NEXT FROM user_sql INTO @DatabaseUser

	WHILE @@FETCH_STATUS = 0
	BEGIN
        SET @msgStatement = 
        'USE [' + @DatabaseName + ']' + CHAR(13) +
		'DROP USER ['+ @DatabaseUser + ']' + CHAR(13)

		PRINT @msgStatement
		INSERT INTO FDDBA..Security_Drop (command,CreatedOn,DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
		FETCH NEXT FROM user_sql INTO @DatabaseUser
	END

CLOSE user_sql

DEALLOCATE user_sql

END

--***************************************************
-- Begin cursor to loop through app roles and drop them
--***************************************************
	IF OBJECT_ID(N'[TempDB].[dbo].[##AppRoleList]', N'U') IS NOT NULL
BEGIN
	DROP TABLE ##AppRoleList
END

SET @query = 'SELECT Y.[name]
into ##AppRoleList 
FROM ['+ @DatabaseName + '].[dbo].[sysusers] Y
	INNER JOIN ['+ @DatabaseName + '].sys.database_principals P
	ON Y.[sid] = P.[sid]
    WHERE P.[principal_id] NOT IN (0,1,2,3,4,16384,16385,16386,16387,16389,16390,16391,16392,16393)
	and  P.[type] = (''A'')'

print ''
--print @query 
exec (@query)
	
SELECT @Objects = count(*)
		FROM ##AppRoleList

IF (@Objects >= 1)
BEGIN
	PRINT ' '
	PRINT '-- Dropping application roles' 

	DECLARE user_sql CURSOR fast_forward FOR

	SELECT *
	FROM ##AppRoleList

	OPEN user_sql

	FETCH NEXT FROM user_sql INTO @ApplicationRole

	WHILE @@FETCH_STATUS = 0
	BEGIN
        SET @msgStatement = 
        'USE [' + @DatabaseName + ']' + CHAR(13) +
		'DROP APPLICATION ROLE['+  @ApplicationRole + ']' + CHAR(13)
		
		PRINT @msgStatement
		INSERT INTO FDDBA..Security_Drop (command,CreatedOn,DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
		FETCH NEXT FROM user_sql INTO @ApplicationRole
	END

CLOSE user_sql

DEALLOCATE user_sql

END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pSecurityExtract]',10,1) WITH NOWAIT;
if object_id('dbo.pSecurityExtract') is null exec('create procedure [dbo].[pSecurityExtract] as select getdate() DT')
GO
  /*******************************************************************************
Created By: Nicole Harrington
Created On: 12/15/2017

Purpose: Procedure to get current security from database given or all databases if no database is provided.
		 Additionally, a user name can be provided and security will be extracted for that individual only.

Requirements: Tables - Security_Restore

Parameters:		
	@DebugOverride	BIT = 0 :	Real parameter accepted by Procedure that will override the Debug setting in the table of parameters, makes it easier to debugz
								** not yet available.
	@DB_in       		: Database name of the database to drop security from. If NULL, it will be the current database context.

    @User_Build			: User to be extracted. NULL is default and will extract security for all users.

------------------------------------------------------------------------------------------------------------------------------------------
Changes 
Date:	
By:		
Notes:
*******************************************************************************/
alter procedure [dbo].[pSecurityExtract](
	@DB_in						sysname = NULL
	,@User_Build				varchar(256) = NULL
)
WITH ENCRYPTION
AS
SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
SET NOCOUNT ON
-- FOR OUTPUT
DECLARE @errStatement [varchar](8000)
DECLARE @msgStatement [varchar](8000)
DECLARE @CurrentRunTime DateTime
DECLARE @flag int
DECLARE @DatabaseName [sysname]
-- USER AND LOGIN VARIABLES
DECLARE @DatabaseUserName [sysname]
DECLARE @ServerLogin [sysname]
DECLARE @DefaultSchema [varchar] (256)
DECLARE @binpwd varbinary (256)
DECLARE @SID_varbinary varbinary(85)
DECLARE @SID_string varchar(256)
DECLARE @login_expired varchar(256)
DECLARE @login_policy varchar(256)
DECLARE @login_name varchar (256)
DECLARE @user_name varchar (256)
DECLARE @schema_name varchar (256)
DECLARE @txtpwd sysname
DECLARE @default_database varchar (256)
DECLARE @default_lang varchar (256)
DECLARE @login_type varchar (256)
-- ROLE VARIABLES
DECLARE @RoleName [varchar](256)
DECLARE @RoleOwner [varchar] (256)
DECLARE @MemberName [varchar](256)
-- PRIVILEGE VARIABLES
DECLARE @PrivState [varchar] (256)
DECLARE @PrivGrantee [varchar] (256)
DECLARE @PrivType [varchar] (256)
DECLARE @PrivWG [varchar] (256)
-- SCHEMA VARIABLES
DECLARE @SchState [varchar] (256)
DECLARE @SchType [varchar] (256)
DECLARE @SchName [varchar] (256)
DECLARE @SchWG [varchar] (256)
DECLARE @SchGrantee [varchar] (256)
-- OBJECT VARIABLES
DECLARE @ObjState [varchar] (256)
DECLARE @ObjType [varchar] (256)
DECLARE @ObjSchema [varchar] (256)
DECLARE @ObjName [varchar] (256)
DECLARE @ObjGrantee [varchar] (256)
DECLARE @ObjWG [varchar] (256)
-- QUERY VARIABLES
DECLARE @query as varchar(2000)
DECLARE @subquery as varchar(500)
DECLARE @subquery2 as varchar(500)
DECLARE @subquery3 as varchar(500)
DECLARE @subquery4 as varchar(500)

print '-- This report is running with the following parameters:'
print '--' + @DB_in
print '--' + @User_Build
print ''

SET @CurrentRunTime = GETDATE()

PRINT '-- SERVER LEVEL'

PRINT '-- CREATE LOGINS'

IF OBJECT_ID(N'[TempDB].[dbo].[##logins]', N'U') IS NOT NULL
BEGIN
	DROP TABLE ##logins
END

IF (@DB_in IS NOT NULL)
	BEGIN
	SET @subquery3 = N'RIGHT OUTER JOIN ['+ @DB_in + '].[sys].[database_principals] 
on ['+ @DB_in + '].[sys].[database_principals].[name]=[master].[sys].[server_principals].[name] COLLATE LATIN1_General_CI_AI'
	SET @subquery4 = N'AND [' + @DB_in +'].[sys].[database_principals].[name] IS NOT NULL'
	END
ELSE
	BEGIN
	SET @subquery3 = ''
	SET @subquery4 = ''
	print @DatabaseName
	END
		
IF (@User_Build IS NULL)
	SET @subquery = N'AND [master].[sys].[server_principals].name NOT LIKE ''##%''
AND [master].[sys].[server_principals].name NOT LIKE ''NT%''
AND [master].[sys].[server_principals].name <> ''sa'''
	ELSE 
		SET @subquery = N'AND [master].[sys].[server_principals].name = '+ '''' + @User_Build + ''''

SET @query =N'select [master].[sys].[server_principals].[name] COLLATE LATIN1_General_CI_AI  as login_name,
[master].[sys].[server_principals].[default_database_name] as default_database,
[master].[sys].[server_principals].[default_language_name] as default_lang,
[master].[sys].[server_principals].[type] as login_type,
[master].[sys].[sql_logins].[password_hash] as binpwd,
[master].[sys].[sql_logins].[sid] as login_sid,
[master].[sys].[sql_logins].[is_disabled] as login_expired,
[master].[sys].[sql_logins].[is_policy_checked] as login_policy
into ##logins
from [master].[sys].[server_principals] ' + @subquery3 +'
LEFT OUTER JOIN [master].[sys].[sql_logins] 
on [master].[sys].[server_principals].[name] = [master].[sys].[sql_logins].[name] COLLATE LATIN1_General_CI_AI
where [master].[sys].[server_principals].[type] in (''U'', ''G'', ''S'')'+ CHAR(13)
+ @subquery + @subquery4 +''

exec (@query)
DECLARE _logins CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR 
select * from ##logins
order by 1
 
OPEN _logins 
FETCH NEXT FROM _logins INTO @login_name, @default_database, @default_lang, @login_type, @binpwd, @SID_varbinary, @login_expired, @login_policy
WHILE @@FETCH_STATUS = 0
	BEGIN	
		EXEC sp_hexadecimal @SID_varbinary, @SID_string OUT
		SET @SID_string = ', SID=' + @SID_string
					
		IF (@binpwd IS NOT NULL)
			-- Non-null password
			EXEC FDDBA.dbo.sp_hexadecimal @binpwd, @txtpwd OUT
		ELSE
			-- Null password
			SET @txtpwd = ''	
		
		IF (@login_expired IS NOT NULL)
			IF (@login_expired = 0)
				SET @login_expired = ', CHECK_EXPIRATION=OFF'	
			ELSE
				SET @login_expired = ', CHECK_EXPIRATION=ON'
		ELSE
			SET @login_expired = ''

		IF (@login_policy IS NOT NULL)			
			IF (@login_policy = 0)
				SET @login_policy = ', CHECK_POLICY=OFF'
			ELSE
				SET @login_policy = ', CHECK_POLICY=ON'
		ELSE
			SET @login_policy = ''
						
		SET @msgStatement =
		(CASE 
			WHEN @login_type = 'U' OR @login_type = 'G'
				THEN 'IF NOT EXISTS(SELECT * FROM sys.server_principals WHERE [name] = ''' + @login_name + ''')' + CHAR(13) +
				'BEGIN' + CHAR(13) +
				'CREATE LOGIN [' + @login_name + '] FROM WINDOWS WITH DEFAULT_DATABASE=' + @default_database + ', DEFAULT_LANGUAGE=' + @default_lang + @login_expired + @login_policy + CHAR(13) +
				'END'+ CHAR(13) 
			WHEN @login_type = 'S' 
				THEN 'IF NOT EXISTS(SELECT * FROM sys.server_principals WHERE [name] = ''' + @login_name + ''')' + CHAR(13) +
				'BEGIN' + CHAR(13) +
				'CREATE LOGIN [' + @login_name + '] WITH PASSWORD=' + @txtpwd + ' HASHED, DEFAULT_LANGUAGE=' + @default_lang + @login_expired + @login_policy + @SID_string + CHAR(13) +
				'END'+ CHAR(13) 
			ELSE
			'None available'
		END)

		IF (@DB_in IS NULL)
			SET @DatabaseName = @default_database
		ELSE
			SET @DatabaseName = @DB_in

	PRINT @msgStatement
	INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
	FETCH NEXT FROM _logins INTO @login_name, @default_database, @default_lang, @login_type, @binpwd, @SID_varbinary, @login_expired, @login_policy
END
CLOSE _logins 
DEALLOCATE _logins --cleanup cursor

PRINT ' '
PRINT '-- ADD SERVER ROLE MEMBERS'
CREATE TABLE ##srvrole_membrs (
	ServerLogin nvarchar (max),
	RoleName nvarchar(max))

SET @query = N'SELECT a.name , b.name
from sys.server_principals a
JOIN sys.server_role_members  d on a.principal_id=d.member_principal_id
LEFT JOIN sys.server_principals  b on d.role_principal_id=b.principal_id
join ##logins c on a.name=c.login_name collate Latin1_General_CI_AI
order by 1,2'
						    
delete from ##srvrole_membrs						    
INSERT INTO ##srvrole_membrs Exec (@query)

DECLARE _role_members CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR 
SELECT * from ##srvrole_membrs
 
OPEN _role_members FETCH NEXT FROM _role_members INTO @ServerLogin,@RoleName
WHILE @@FETCH_STATUS = 0
BEGIN
	SET @msgStatement = 'EXEC [sp_addsrvrolemember] ' + '@loginame = [' + @ServerLogin + '], ' + '@rolename = [' + @RoleName + ']'+ CHAR(13) 
	
	PRINT @msgStatement
	INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
	FETCH NEXT FROM _role_members INTO @ServerLogin,@RoleName
END
CLOSE _role_members 
DEALLOCATE _role_members --cleanup cursor

drop table ##srvrole_membrs
drop table ##logins

-- SET UP FOR DATABASE NAME(S)

IF OBJECT_ID(N'[TempDB].[dbo].[##dbs]', N'U') IS NOT NULL
BEGIN
	DROP TABLE ##dbs
END

IF (@DB_in IS NULL)
BEGIN
	IF SERVERPROPERTY ('IsHadrEnabled') = 1
	BEGIN

		IF OBJECT_ID(N'[TempDB].[dbo].[##AGs]', N'U') IS NOT NULL
		BEGIN
			DROP TABLE ##AGs
		END
		-- CHECKING IF PRIMARY
		SELECT
			AGC.name -- Availability Group
			, ARS.role_desc  -- Replica Role
		into ##AGs
		FROM
			sys.availability_groups_cluster AS AGC
			INNER JOIN sys.dm_hadr_availability_replica_cluster_states AS RCS
			ON
			RCS.group_id = AGC.group_id
			INNER JOIN sys.dm_hadr_availability_replica_states AS ARS
			ON
			ARS.replica_id = RCS.replica_id
		WHERE
			ARS.role_desc = 'PRIMARY'

		;with DatabaseName_CTE (DatabaseName) as (
			SELECT
			dbcs.database_name AS [DatabaseName]
			FROM master.sys.availability_groups AS AG
			LEFT OUTER JOIN master.sys.dm_hadr_availability_group_states as agstates
				ON AG.group_id = agstates.group_id
			INNER JOIN master.sys.availability_replicas AS AR
				ON AG.group_id = AR.group_id
			INNER JOIN master.sys.dm_hadr_availability_replica_states AS arstates
				ON AR.replica_id = arstates.replica_id AND arstates.is_local = 1
			INNER JOIN master.sys.dm_hadr_database_replica_cluster_states AS dbcs
				ON arstates.replica_id = dbcs.replica_id
			LEFT OUTER JOIN master.sys.dm_hadr_database_replica_states AS dbrs
				ON dbcs.replica_id = dbrs.replica_id AND dbcs.group_database_id = dbrs.group_database_id
			where 
				Ag.Name in (select name from ##AGs)
			UNION
			SELECT name From sys.databases WHERE group_database_id IS NULL
			and state=0)
			select DatabaseName
			into ##dbs
			from DatabaseName_CTE
	END
	ELSE --NO AG
	BEGIN
		SET @query = 'select name as DatabaseName into ##dbs from sys.databases where state=0;'
		exec (@query)
		SET @msgStatement = '/* Database Name was not supplied.' + char(10)+
		'Extracting all permissions on '+ @@SERVERNAME +'.*/'
		PRINT @msgStatement
	END
END		

IF (@DB_in IS NOT NULL)
BEGIN
	SET @query = 'select ''' +@DB_in +''' as DatabaseName into ##dbs;'
	exec (@query)
END
		
IF (@User_Build IS NULL)
	SET @subquery = N'AND [master].[sys].[server_principals].name NOT LIKE ''##%''
	AND [master].[sys].[server_principals].name NOT LIKE ''NT%''
	AND [master].[sys].[server_principals].name <> ''sa'''
ELSE 
	SET @subquery = N'AND [master].[sys].[server_principals].name = '+ '''' + @User_Build + ''''

SET @query =N'select [master].[sys].[server_principals].[name] COLLATE LATIN1_General_CI_AI  as login_name,
[master].[sys].[server_principals].[default_database_name] as default_database,
[master].[sys].[server_principals].[default_language_name] as default_lang,
[master].[sys].[server_principals].[type] as login_type,
[master].[sys].[sql_logins].[password_hash] as binpwd,
[master].[sys].[sql_logins].[sid] as login_sid,
[master].[sys].[sql_logins].[is_disabled] as login_expired,
[master].[sys].[sql_logins].[is_policy_checked] as login_policy
into ##logins
from [master].[sys].[server_principals] ' + @subquery3 +'
LEFT OUTER JOIN [master].[sys].[sql_logins] 
on [master].[sys].[server_principals].[name] = [master].[sys].[sql_logins].[name] COLLATE LATIN1_General_CI_AI
where [master].[sys].[server_principals].[type] in (''U'', ''G'', ''S'')'+ CHAR(13)
+ @subquery + @subquery4 +''

exec (@query)

DECLARE _dbs CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR 
select DatabaseName from ##dbs

OPEN _dbs 
FETCH NEXT FROM _dbs INTO @DatabaseName
WHILE @@FETCH_STATUS = 0
BEGIN	
	PRINT ''
	SET @msgStatement = 'USE ['+ @DatabaseName + ']'  + CHAR(13)
	PRINT @msgStatement 
	--
	-- SET UP
	IF OBJECT_ID(N'[TempDB].[dbo].[##users]', N'U') IS NOT NULL
	BEGIN
		DROP TABLE ##users
	END

	IF (@User_Build IS NULL)
		SET @subquery = N'AND ['+ @DatabaseName + '].[sys].[database_principals].[name] not in (''guest'', ''INFORMATION_SCHEMA'',''sys'')
		AND ['+ @DatabaseName + '].[sys].[database_principals].[type] not in (''R'',''U'')'
		ELSE 
			SET @subquery = N'AND [master].[sys].[server_principals].name = '+ '''' + @User_Build + ''''

	SET @query =N'select [master].[sys].[server_principals].[name] COLLATE LATIN1_General_CI_AI  as login_name,
	[' + @DatabaseName + '].[sys].[database_principals].[name] as user_name, ISNULL (['+ @DatabaseName +'].[sys].[database_principals].[default_schema_name],'''') as schema_name,
	[master].[sys].[server_principals].[default_database_name] as default_database,
	[master].[sys].[server_principals].[default_language_name] as default_lang,
	[master].[sys].[server_principals].[type] as login_type,
	[master].[sys].[sql_logins].[password_hash] as binpwd,
	[master].[sys].[sql_logins].[sid] as login_sid,
	[master].[sys].[sql_logins].[is_disabled] as login_expired,
	[master].[sys].[sql_logins].[is_policy_checked] as login_policy
	into ##users
	from ['+ @DatabaseName + '].[sys].[database_principals] LEFT JOIN [master].[sys].[server_principals] 
	on ['+ @DatabaseName + '].[sys].[database_principals].[name]=[master].[sys].[server_principals].[name] COLLATE LATIN1_General_CI_AI
	LEFT JOIN [master].[sys].[sql_logins] 
	on [master].[sys].[server_principals].[name] = [master].[sys].[sql_logins].[name] COLLATE LATIN1_General_CI_AI
	where ['+ @DatabaseName + '].[sys].[database_principals].[principal_id] <> 1'
	+ @subquery + ''

	exec (@query)

	--Script CREATE USERS for current database
	PRINT ' '
	PRINT '-- CREATE USERS'
	DECLARE _users CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR 
	select login_name, user_name, schema_name from ##users
	order by user_name

	OPEN _users 
	FETCH NEXT FROM _users INTO @ServerLogin, @DatabaseUserName, @DefaultSchema
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF (@ServerLogin IS NULL)
			BEGIN
				SET @msgStatement = 'IF NOT EXISTS(SELECT * FROM sys.database_principals WHERE [name] = ''' + @DatabaseUserName + ''')' + CHAR(13) +
						'BEGIN' + CHAR(13) +
						'CREATE USER ['        ---example: CREATE USER [mlapenna] FOR LOGIN [mlapenna]
						+ @DatabaseUserName + ']' + ' WITHOUT LOGIN' + CHAR(13) +
						'END'+ CHAR(13) 
			END
		ELSE
			BEGIN
				If (@DefaultSchema = '')
					SET @DefaultSchema = ''
				ELSE
					SET @DefaultSchema = ' WITH DEFAULT_SCHEMA=[' + @DefaultSchema + ']'

				SET @msgStatement = 'IF NOT EXISTS(SELECT * FROM sys.database_principals WHERE [name] = ''' + @ServerLogin + ''')' + CHAR(13) +
									'BEGIN' + CHAR(13) +
									'CREATE USER ['        ---example: CREATE USER [mlapenna] FOR LOGIN [mlapenna]
									+ @DatabaseUserName + ']' + ' FOR LOGIN [' + @ServerLogin + ']' + @DefaultSchema + CHAR(13) +
									'END'+ CHAR(13) 
			END

	PRINT @msgStatement 
	INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
	FETCH NEXT FROM _users INTO @ServerLogin, @DatabaseUserName, @DefaultSchema
	END
	CLOSE _users 
	DEALLOCATE _users --cleanup cursor

	--Script MAP SERVER ROLE for current database


	-- Script GRANTS for Database Role Privileges on current database
			-- SET UP
	IF OBJECT_ID(N'[TempDB].[dbo].[##dbroles]', N'U') IS NOT NULL
	BEGIN
		DROP TABLE ##dbroles
	END

	SET @query =N'select dp1.Name as Name, dp2.Name as Owner
	into ##dbroles
	from ['+ @DatabaseName + '].[sys].[database_principals] dp1 
	JOIN ['+ @DatabaseName + '].sys.database_principals AS DP2
	ON DP1.owning_principal_id = DP2.principal_id
	where dp1.type=''R'' and dp1.is_fixed_role != 1 and dp1.name not like ''public'''

	exec (@query)

	PRINT ' '
	PRINT '-- GRANTS for Database Roles'
	DECLARE _roles CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR
	select Name, Owner  from ##dbroles
	OPEN _roles 
	FETCH NEXT FROM _roles INTO @RoleName, @RoleOwner
	WHILE @@FETCH_STATUS=0
	BEGIN
		SET @msgStatement ='if not exists(SELECT 1 from sys.database_principals where type=''R'' and name ='''
		+@RoleName+''' ) '+ CHAR(13) +
		'BEGIN '+ CHAR(13) +
		'CREATE ROLE  ['+ @RoleName + '] AUTHORIZATION [' + @RoleOwner + ']' + CHAR(13) +
		'END'+ CHAR(13) 
		PRINT @msgStatement
	INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);

	IF OBJECT_ID(N'[TempDB].[dbo].[##dbrolegrants]', N'U') IS NOT NULL
	BEGIN
		DROP TABLE ##dbrolegrants
	END

	SET @query =N'SELECT a.state_desc, a.state, permission_name, c.name WG, d.name Type, b.name COLLATE LATIN1_General_CI_AI SchGrantee
		into ##dbrolegrants
		FROM ['+ @DatabaseName + '].sys.database_permissions  a 
		LEFT JOIN ['+ @DatabaseName + '].[sys].[objects] d ON a.[major_id] = d.[object_id]
		LEFT JOIN ['+ @DatabaseName + '].[sys].[database_principals] b ON a.[grantee_principal_id] = b.[principal_id]
		LEFT JOIN ['+ @DatabaseName + '].[sys].[database_principals] c ON a.[grantor_principal_id] = c.[principal_id]
		where b.name = ''' + @RoleName + ''''

	exec (@query)

		DECLARE _grant_dbrprivs	CURSOR LOCAL FORWARD_ONLY READ_ONLY	FOR 
		SELECT *
		FROM ##dbrolegrants

		OPEN _grant_dbrprivs
		FETCH NEXT FROM _grant_dbrprivs INTO @PrivState,@PrivWG,@PrivType,@ObjSchema,@ObjName,@SchGrantee
		WHILE @@FETCH_STATUS = 0
		BEGIN
			If (@PrivWG = 'W')
				BEGIN
					SET @PrivWG = 'WITH GRANT OPTION'
					SET @PrivState = 'GRANT'
				END
			ELSE
				BEGIN
					SET @PrivWG = ''
					SET @PrivState = 'GRANT'
				END
				
			If (@ObjName is NULL)
				SET @msgStatement = @PrivState +' ' + @PrivType +' TO [' + @SchGrantee + '] ' + @PrivWG
			ELSE
				SET @msgStatement = @PrivState +' ' + @PrivType +' ON  '+ @ObjSchema + '.['+ @ObjName +'] TO [' + @SchGrantee + '] ' + @PrivWG
				
			PRINT @msgStatement 

		INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
	
			FETCH NEXT FROM _grant_dbrprivs INTO @PrivState,@PrivWG,@PrivType,@ObjSchema,@ObjName,@SchGrantee
		END
		CLOSE _grant_dbrprivs
		DEALLOCATE _grant_dbrprivs --cleanup cursor 
	
		FETCH NEXT FROM _roles INTO @RoleName, @RoleOwner
	END
	CLOSE _roles
	DEALLOCATE _roles --cleanup cursor

	-- Script to Add Role Members to Users for current database
	PRINT ' '
	PRINT '-- ADD ROLE MEMBERS'

	IF OBJECT_ID(N'[TempDB].[dbo].[##dbrolemembr]', N'U') IS NOT NULL
	BEGIN
		DROP TABLE ##dbrolemembr
	END

	SET @query =N'select a.name RoleName, b.name MemberName
	into ##dbrolemembr
	from ['+ @DatabaseName + '].sys.database_role_members d 
	INNER JOIN ['+ @DatabaseName + '].sys.database_principals  a on  d.role_principal_id=a.principal_id 
	INNER JOIN ['+ @DatabaseName + '].sys.database_principals  b on d.member_principal_id=b.principal_id
	join ##users c on b.name=c.login_name collate Latin1_General_CI_AI
	where    b.name <> ''dbo'''

	exec (@query)

	DECLARE _role_members CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR 
	SELECT *
	from ##dbrolemembr
	order by 1,2
 
	OPEN _role_members
	FETCH NEXT FROM _role_members INTO @RoleName, @MemberName
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @msgStatement = 'EXEC [sp_addrolemember] ' + '@rolename = [' + @RoleName + '], ' + '@membername = [' + @MemberName + ']'
		PRINT @msgStatement
	INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
		FETCH NEXT FROM _role_members INTO @RoleName, @MemberName
	END
	CLOSE _role_members 
	DEALLOCATE _role_members --cleanup cursor

	-- Script GRANTS for Database Privileges on current database
	PRINT ' '
	PRINT '-- GRANTS for Database Privileges'

		IF OBJECT_ID(N'[TempDB].[dbo].[##dbprivs]', N'U') IS NOT NULL
	BEGIN
		DROP TABLE ##dbprivs
	END

	SET @query =N'select a.state_desc,a.permission_name, b.name, a.state COLLATE LATIN1_General_CI_AI WG
	into ##dbprivs
	FROM ['+ @DatabaseName + '].sys.database_permissions a 
	inner join ['+ @DatabaseName + '].sys.database_principals b ON a.grantee_principal_id = b.principal_id 
	WHERE b.principal_id not in (0,1,2) and a.type not in (''CO'') and a.class = 0'
	
	exec (@query)

	DECLARE _grant_privs CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR 
	SELECT *
	FROM ##dbprivs
                                
	OPEN _grant_privs
	FETCH NEXT FROM _grant_privs INTO @PrivState,@PrivType,@PrivGrantee,@PrivWG
	WHILE @@FETCH_STATUS = 0
	BEGIN
		BEGIN
		If (@PrivWG = 'W')
			BEGIN
				SET @PrivWG = 'WITH GRANT OPTION'
				SET @PrivState = 'GRANT'
			END
		ELSE
			BEGIN
				SET @PrivWG = ''
			END
		END
	
		SET @msgStatement = @PrivState +' ' + @PrivType + ' to [' + @PrivGrantee +'] '+@PrivWG
		PRINT @msgStatement
	INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
		FETCH NEXT FROM _grant_privs INTO @PrivState,@PrivType,@PrivGrantee,@PrivWG
	END
	CLOSE _grant_privs 
	DEALLOCATE _grant_privs --cleanup cursor
                              
	-- Script GRANTS for Schema Privileges on current database
	PRINT ' '
	PRINT '-- GRANTS for Schema Privileges'

		IF OBJECT_ID(N'[TempDB].[dbo].[##schemaprivs]', N'U') IS NOT NULL
	BEGIN
		DROP TABLE ##schemaprivs
	END

	SET @query =N'select a.state_desc, permission_name, b.name, a.state, c.name COLLATE LATIN1_General_CI_AI SchGrantee
	into ##schemaprivs
	FROM ['+ @DatabaseName + '].sys.database_permissions  a 
	INNER JOIN ['+ @DatabaseName + '].sys.schemas b ON  a.major_id = b.schema_id 
	INNER JOIN ['+ @DatabaseName + '].sys.database_principals c ON a.grantee_principal_id = c.principal_id'

	exec (@query)

	DECLARE _grant_schprivs CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR 
	SELECT *
	FROM ##schemaprivs

	OPEN _grant_schprivs 
	FETCH NEXT FROM _grant_schprivs INTO @SchState,@SchType,@SchName,@SchWG, @SchGrantee
	WHILE @@FETCH_STATUS = 0
	BEGIN
		BEGIN
		If (@SchWG = 'W')
			BEGIN
				SET @SchWG = 'WITH GRANT OPTION'
				SET @SchState = 'GRANT'
			END
		ELSE
			BEGIN
				SET @SchWG = ''
			END
		END

		SET @msgStatement = @SchState +' ' + @SchType +' ON SCHEMA::[' + @SchName+ '] TO [' + @SchGrantee + '] ' + @SchWG
		PRINT @msgStatement
	INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
		FETCH NEXT FROM _grant_schprivs INTO @SchState,@SchType,@SchName,@SchWG,@SchGrantee
	END
	CLOSE _grant_schprivs
	DEALLOCATE _grant_schprivs --cleanup cursor

	--Script GRANTS for Objects Level Privilegs
	PRINT ' '
	PRINT '-- GRANTS for Object Privileges'

			IF OBJECT_ID(N'[TempDB].[dbo].[##objprivs]', N'U') IS NOT NULL
	BEGIN
		DROP TABLE ##objprivs
	END

	SET @query =N'select a.state_desc, a.permission_name, c.name ObjSchema, b.name ObjName ,e.name ObjGrantee, a.state COLLATE LATIN1_General_CI_AI WG
	into ##objprivs
	from ['+ @DatabaseName + '].sys.database_permissions a
	join ['+ @DatabaseName + '].sys.objects b on a.major_id = b.object_id
	join ['+ @DatabaseName + '].sys.schemas c on b.schema_id = c.schema_id
	join ['+ @DatabaseName + '].sys.database_principals e on a.grantee_principal_id = e.principal_id
	where e.name not in ( ''public'', ''guest'') and b.name <> ''sysclones'''

	exec (@query)

	DECLARE _grant_objprivs CURSOR LOCAL FORWARD_ONLY READ_ONLY FOR
	SELECT * from ##objprivs
	
	OPEN _grant_objprivs
	FETCH NEXT FROM _grant_objprivs INTO @ObjState,@ObjType,@ObjSchema,@ObjName, @ObjGrantee,@ObjWG
	WHILE @@FETCH_STATUS = 0
	BEGIN
		BEGIN
		If (@ObjWG = 'W')
			BEGIN
				SET @ObjWG = 'WITH GRANT OPTION'
				SET @ObjState = 'GRANT'
			END
		ELSE
			BEGIN
				SET @ObjWG = ''
			END
		END
	
		SET @msgStatement = @ObjState +' ' + @ObjType +' ON ' + @ObjSchema + '.['+ @ObjName + '] TO [' + @ObjGrantee + '] ' + @ObjWG
		PRINT @msgStatement
	INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);
		FETCH NEXT FROM _grant_objprivs INTO @ObjState,@ObjType,@ObjSchema,@ObjName, @ObjGrantee,@ObjWG
	END
	CLOSE _grant_objprivs
	DEALLOCATE _grant_objprivs --cleanup cursor

	
	--***************************************************
	-- Fix orphaned users
	--***************************************************
	PRINT ' '
	PRINT '--Fixing orphaned sql users' 

	SET @msgStatement = 
	'DECLARE @username varchar(128)'+ CHAR(13) +
	'DECLARE fixOrphanusers CURSOR'+ CHAR(13) +
	'FOR'+ CHAR(13) +
	'SELECT UserName = name FROM sysusers ' +
	'WHERE issqluser = 1 and (sid is not null and sid <> 0x00) and' + 
	'(sid is not null and sid <> 0x01)'+ CHAR(13) + 
	'ORDER BY name'+ CHAR(13) +
	'OPEN fixOrphanusers'+ CHAR(13) +
	'FETCH NEXT FROM fixOrphanusers'+ CHAR(13) +
	'INTO @username'+ CHAR(13) +
	'WHILE @@FETCH_STATUS = 0'+ CHAR(13) +
	'BEGIN'+ CHAR(13) +
	'EXEC sp_change_users_login ''update_one'', @username, @username'+ CHAR(13) +
	'FETCH NEXT FROM fixOrphanusers'+ CHAR(13) +
	'INTO @username'+ CHAR(13) +
	'END'+ CHAR(13) +
	'CLOSE fixOrphanusers'+ CHAR(13) +
	'DEALLOCATE fixOrphanusers'

	PRINT @msgStatement
	INSERT INTO FDDBA..Security_Restore (command, CreatedOn, DatabaseName) VALUES (@msgStatement,@CurrentRunTime,@DatabaseName);

FETCH NEXT FROM _dbs INTO @DatabaseName
END
CLOSE _dbs
DEALLOCATE _dbs --cleanup cursor

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pStartJobAndWait]',10,1) WITH NOWAIT;
if object_id('dbo.pStartJobAndWait') is null exec('create procedure [dbo].[pStartJobAndWait] as select getdate() DT')
GO
  
 
/*
http://www.mssqltips.com/sqlservertip/2167/custom-spstartjob-to-delay-next-task-until-sql-agent-job-has-completed/
Created: 1/30/2009
Author: Kun Lee
Description: 

	Checks IF the given job name is running and IF runing, waits for 
	given 'WaitTime' and checks again, in a loop.
	IF the job is not running, this proc will start it!

	Once the given job completes execution, this stored procedure will exit
	with a RETURN code for the the status of the job being watched

	RETURN Codes
	Failed		= 0
	Successful	= 1
	Cancelled	= 3


Modifications: 
9/30/2009 Srikant Tadimalla: 
	Originial script INTO store procedure and add RETURN code to provide the status of the job

10/26/2010 Kun Lee
	Modified to add raiseerror to fail IF the job failed and also add raise error to print out 
	status of the job by using "WITH NOWAIT" option.
	Also modify the parameter not to 

11/7/2010 Sourav Biswas
		INSERT INTO TABLE Variable FROM EXEC any SP is not allowed in SQL 2000. 
		Hence createing temporary table #xp_results instead of TABLE variable @xp_results
	
Example 1> 
DECLARE @RetStatus INT
exec dbo.sp_sp_start_job_wait 'DBA - Test Job','00:00:01',@RetStatus OUTPUT
SELECT @RetStatus

Example 2>
exec dbo.sp_sp_start_job_wait 'zzzDBATest'
*/ 
alter procedure [dbo].[pStartJobAndWait]
(
@par_JobName SYSNAME,
@par_waitinterval VARCHAR(16) = '00:00:30',  -- this is parameter for check frequency
@JobCompletionStatus INT = null OUTPUT
)
AS

SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
SET NOCOUNT ON

--Validate the job name, if we cannot find it then throw an error
IF NOT EXISTS(SELECT 1 FROM msdb.dbo.sysjobs WHERE name = @par_JobName)
BEGIN
	DECLARE @msg		varchar(1000)
	SET @msg = 'Unable to find job with name: ' + @par_JobName + '.'
	RAISERROR(@msg,11,1) WITH NOWAIT;
	RETURN;
END

-- DECLARE @par_JobName	sysname
DECLARE @job_id		UNIQUEIDENTIFIER
DECLARE @job_owner	sysname

--Createing TEMP TABLE
CREATE TABLE #xp_results (job_id             UNIQUEIDENTIFIER NOT NULL,
                        last_run_date         INT              NOT NULL,
                        last_run_time         INT              NOT NULL,
                        next_run_date         INT              NOT NULL,
                        next_run_time         INT              NOT NULL,
                        next_run_schedule_id  INT              NOT NULL,
                        requested_to_run      INT              NOT NULL, -- BOOL
                        request_source        INT              NOT NULL,
                        request_source_id     sysname          COLLATE database_default NULL,
                        running               INT              NOT NULL, -- BOOL
                        current_step          INT              NOT NULL,
                        current_retry_attempt INT              NOT NULL,
                        job_state             INT              NOT NULL)

SELECT @job_id = job_id FROM msdb.dbo.sysjobs
WHERE name = @par_JobName

SELECT @job_owner = SUSER_SNAME()

INSERT INTO #xp_results
EXECUTE master.dbo.xp_sqlagent_enum_jobs  1, @job_owner, @job_id 

-- Start the job IF the job is not running
IF NOT EXISTS(SELECT TOP 1 * FROM #xp_results WHERE running = 1)
	EXEC msdb.dbo.sp_start_job @job_name = @par_JobName

-- Give 2 sec for think time.
WAITFOR DELAY '00:00:02'

DELETE FROM #xp_results
INSERT INTO #xp_results
EXECUTE master.dbo.xp_sqlagent_enum_jobs  1, @job_owner, @job_id 

WHILE EXISTS(SELECT TOP 1 * FROM #xp_results WHERE running = 1)
BEGIN

	WAITFOR DELAY @par_waitinterval

	-- Information 
	raiserror('JOB IS RUNNING', 0, 1 ) WITH NOWAIT	

	DELETE FROM #xp_results

	INSERT INTO #xp_results
	EXECUTE master.dbo.xp_sqlagent_enum_jobs  1, @job_owner, @job_id 

END

SELECT 
	TOP 1 @JobCompletionStatus = run_status 
  FROM 
	msdb.dbo.sysjobhistory
  WHERE 
	job_id = @job_id
	And step_id = 0
ORDER BY 
	run_date DESC 
	,run_time DESC

IF @JobCompletionStatus = 1
	PRINT 'The job ran Successful' 
ELSE 
BEGIN
	RAISERROR ('[ERROR]:%s job is either failed or not in good state. Please check',16, 1, @par_JobName) WITH LOG
END

RETURN @JobCompletionStatus

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pStartUpValidation]',10,1) WITH NOWAIT;
if object_id('dbo.pStartUpValidation') is null exec('create procedure [dbo].[pStartUpValidation] as select getdate() DT')
GO
  



/************************************************************************
Changes:
	2017-09-29 by Keith Buck: Added Space report and new optional parameters for it
		 @IncludeSpaceReport BIT = 0:	Do you want to call the space report. If 1 and xp_cmdshell is disabled it will enable it, run and then disable it
		 @FreeSpaceWarningPercent = 10: Percentage at which Free Pct will show up RED on the report. This is a tiny int so use 1 to 100

	2019-01-17 Keith Buck : changed select for  getting @sname  to use server property if @@servername is null
************************************************************************/
alter procedure dbo.pStartUpValidation (@HTML VARCHAR(max) OUTPUT, @IncludeSpaceReport BIT = 0, @FreeSpaceWarningPercent TINYINT = 10)
WITH ENCRYPTION
AS
BEGIN
SET NOCOUNT ON
IF EXISTS(SELECT 1 FROM tempdb..sysobjects where name ='##sqlservice')
DROP TABLE ##sqlservice
CREATE TABLE ##sqlservice (details VARCHAR(100))
IF EXISTS(SELECT 1 FROM tempdb..sysobjects where name ='##agentservice')
DROP TABLE ##agentservice
CREATE TABLE ##agentservice (details VARCHAR(100))
--WAITFOR DELAY '00:02'
DECLARE @sname VARCHAR(128), @starttime VARCHAR(30), @stopTime VARCHAR(30)
DECLARE @authmode VARCHAR(25), @subject VARCHAR(250)
DECLARE @SQLVersion	 NVARCHAR(500)
DECLARE @insname VARCHAR(50),@agentname VARCHAR(50)
DECLARE @sqlstatus VARCHAR(100), @agentstatus VARCHAR(100), @clusterstatus VARCHAR(100)
DECLARE @dbstatus VARCHAR(100), @dbdetail VARCHAR(max), @clusterdetail VARCHAR(max)
DECLARE @hostname NVARCHAR(256)
DECLARE @fIsSFCI BIT
DECLARE @sqlservername NVARCHAR(256)
DECLARE @sctsql VARCHAR(200)--, @HTML VARCHAR(max)
DECLARE @style VARCHAR(max)
DECLARE @headertab VARCHAR(MAX)
set ansi_warnings off;
declare @curr_trc_file varchar(256), @prev_trc_file varchar(256);
declare @trc_file_name varchar(128), @trc_file_folder varchar(256);
declare @trc_num int, @slash_pos int;
declare @stopTime_dt datetime, @startTime_dt datetime, @crlf char(2)
declare @downtime int
declare @downtime_char varchar(50)
declare @IsAgEnabled bit
DECLARE @fddba_ver varchar(20)
EXEC FDDBA.dbo.FDDBA_Get_Version @fddba_ver OUTPUT
IF @fddba_ver IS NULL
	SET @fddba_ver = 'UNKNOWN'

IF ISNULL(@FreeSpaceWarningPercent,0) < 1 OR @FreeSpaceWarningPercent > 100
	SET @FreeSpaceWarningPercent = 100


SET @style = 
'<style type="text/css">

  table.t1 {
    
    font-family: Arial, Helvetica, sans-serif;
  }
  .t1 th, .t1 td {
    padding: 2px 8px;
  }
  .t1 thead th {
    background: #4f81bd;
    text-transform: lowercase;
    text-align: left;
    font-size: 12px;
    color: #fff;
  }
  .t1 tr {
    border-right: 1px solid #95b3d7;
  }
  .t1 tbody tr {
    border-bottom: 1px solid #95b3d7;
	font-size: 12px;
  }
  .t1 tr *:nth-child(3), .t1 tr *:nth-child(4) {
    text-align: left;
  }

</style>'

IF SERVERPROPERTY('IsHadrEnabled') = 1 
	SET @IsAgEnabled = 1
ELSE
	SET @IsAgEnabled = 0

--Build header table
SELECT @sname = ISNULL(@@SERVERNAME, CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128)))
SELECT @SQLVersion	 = @@VERSION
SELECT @authmode=case SERVERPROPERTY('IsIntegratedSecurityOnly') when 1 then 'Windows' else 'Mixed' end
SELECT @starttime=CONVERT(VARCHAR(30),create_date,109) from sys.databases where database_id=2
SET @hostname = CONVERT(NVARCHAR(256),SERVERPROPERTY('ComputerNamePhysicalNetBIOS'))
SET @fIsSFCI = CONVERT(bit,SERVERPROPERTY('IsClustered'))
IF CHARINDEX('\',@@SERVERNAME) > 0
BEGIN
	SET @sqlservername = SUBSTRING(@@SERVERNAME, 1, CHARINDEX('\',@@SERVERNAME) - 1)
END
ELSE
BEGIN
	SET @sqlservername = @@SERVERNAME
END

set @crlf = nchar(0x0d) + nchar(0x0a);
 select @curr_trc_file = ''

 -- check downtime window details
 select @curr_trc_file = [path] from sys.traces
 where id =1 and status =1;

 if @curr_trc_file <> ''
 begin
	BEGIN TRY
	 -- the following is to try to get the number in the current default trace file name,
	 -- default trace file has a naming convention like <path>\log_<num>.trc
	  set @curr_trc_file = REVERSE(@curr_trc_file);
	  set @slash_pos = CHARINDEX('\', @curr_trc_file);
	  set @trc_file_folder = reverse(SUBSTRING(@curr_trc_file, @slash_pos, 256));
	  set @trc_file_name = reverse(SUBSTRING(@curr_trc_file, 1, @slash_pos-1));
 
	  set @trc_num = cast(SUBSTRING(@trc_file_name, 5, len(@trc_file_name)-8) as int) -- 8 = length of "log_" plus ".trc"

	  set @curr_trc_file = REVERSE(@curr_trc_file);
	  set @prev_trc_file = @trc_file_folder + 'log_' + CAST((@trc_num-1) as varchar(12)) + '.trc'
  
	  select @stopTime_dt=max(starttime) from fn_trace_gettable(@prev_trc_file, 1) -- get the last StartTime of the previous trace 
	  select @startTime_dt=min(starttime) from fn_trace_gettable(@curr_trc_file, 1) -- get the first StartTime of the current trace

	  select @starttime=CONVERT(VARCHAR(30),max(@startTime_dt),109)
	  select @stopTime=CONVERT(VARCHAR(30),max(@stopTime_dt),109)

	  select @downtime = DATEDIFF(second, @stopTime_dt, @startTime_dt)
	  select @downtime_char = cast(@downtime/60 as varchar(20)) + ' mins, '  
	  + cast(@downtime%60 as varchar(20)) + ' secs'

	  IF  EXISTS (SELECT 1 FROM sys.objects WHERE object_id = object_id ( N'[FDDBA].[dbo].[restartlog]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
	  INSERT INTO [FDDBA].[dbo].[restartlog] (InstanceName, StartupTime, ShutdownTime) VALUES (@@SERVERNAME, @startTime_dt, @stopTime_dt)

  END TRY 
  BEGIN CATCH
	RAISERROR('There was an issue getting data from the trace file, skipping that portion.',10,1) WITH NOWAIT;
  END CATCH
end

-- Checking Agent status
IF EXISTS (SELECT 1 FROM master.dbo.sysprocesses where program_name=N'SQLAgent - Generic Refresher')
	insert into ##agentservice values ('RUNNING') 


IF @SQLVersion LIKE '%EXPRESS%'
BEGIN
	SET @agentstatus = 'Not Installed'
END
ELSE 
BEGIN
	IF EXISTS(SELECT 1 FROM ##agentservice WHERE details LIKE '%RUNNING%')
	SET @agentstatus = 'Running'
	ELSE
	SET @agentstatus = '<font color="red">Not Running</font>'
END



-- Database status check
IF EXISTS (SELECT TOP 1 1 FROM sys.databases WHERE state_desc in('SUSPECT','EMERGENCY'))
	SET @dbstatus= '<font color="red">Database(s) in SUSPECT/EMERGENCY</font>'
ELSE
	SET @dbstatus='All databases are online'

declare @dbstatustable table (
dbname sysname, statedesc varchar(40), mirrorrole varchar(30), mirrorstate varchar(30), isinstandby varchar(1), dbid varchar(12), ls_latency int, restore_threshold int
,dbstateflag bit, drstateflag bit, lsstateflag bit
)

-- Database details
SELECT @dbdetail = '<table class="t1"><thead><tr><th>ID</th><th>Database Name</th><th>Database Status</th><th>HA/DR Role</th><th>HA/DR State</th><th>Log Shipping Latency (mins)</th></tr></thead><tbody>'
declare @dbname sysname, @statedesc varchar(40), @mirrorrole varchar(30), @mirrorstate varchar(30), @isinstandby varchar(1), @dbid varchar(12), @ls_latency int, @restore_threshold int
,@dbstateflag bit, @drstateflag bit, @lsstateflag bit


IF @IsAgEnabled = 1 
BEGIN
insert into @dbstatustable
SELECT 
   d.name as DatabaseName
   ,case 
		when d.is_in_standby = 1 then 'STANDBY' 
		else d.state_desc 
	end + case when d.user_access > 0 then ' ('+d.user_access_desc+')' else '' end  as DatabaseStatus
   ,case
		when agstate.primary_replica is not null and agstate.primary_replica = @@SERVERNAME THEN 'AG Primary'
		when agstate.primary_replica is not null and agstate.primary_replica <> @@SERVERNAME THEN 'AG Replica'
		when m.mirroring_role_desc is not null then m.mirroring_role_desc 
		when l.secondary_database is not null then 'LS Secondary'
		when p.primary_database is not null then 'LS Primary'
		else NULL
	end as HADRRole
   ,COALESCE (drs.synchronization_health_desc collate SQL_Latin1_General_CP1_CI_AS, m.mirroring_state_desc, NULL) 
		+  case when drs.is_suspended = 1 then '('+drs.suspend_reason_desc+')' else '' end as HADRState
   ,case(d.is_in_standby) when 1 then 'Yes' else 'No' end as IsStandby
   , d.database_id
   , l.last_restored_latency + datediff(mi,l.last_restored_date_utc, getutcdate()) as LSLatency
   , l.restore_threshold as LSThreshold
   , 0,0,0
FROM   
	sys.databases d 
	LEFT JOIN sys.database_mirroring m ON d.database_id = m.database_id	
	LEFT JOIN msdb.dbo.log_shipping_monitor_secondary l on l.secondary_database = d.name
	LEFT JOIN msdb.dbo.log_shipping_primary_databases p on p.primary_database = d.name
	LEFT JOIN sys.dm_hadr_database_replica_states drs on d.group_database_id = drs.group_database_id AND d.replica_id = drs.replica_id
	LEFT JOIN sys.availability_groups ag on drs.group_id = ag.group_id
	LEFT JOIN sys.availability_replicas r on drs.group_id = r.group_id and drs.replica_id = r.replica_id
	LEFT JOIN sys.dm_hadr_availability_group_states agstate on ag.group_id = agstate.group_id
	LEFT JOIN  sys.availability_group_listeners agl on ag.group_id = agl.group_id
END
ELSE
BEGIN
insert into @dbstatustable
SELECT 
   d.name as DatabaseName
   ,case 
		when d.is_in_standby = 1 then 'STANDBY' 
		else d.state_desc 
	end + case when d.user_access > 0 then ' ('+d.user_access_desc+')' else '' end as DatabaseStatus
	,case
		when m.mirroring_role_desc is not null then m.mirroring_role_desc 
		when l.secondary_database is not null then 'LS Secondary'
		when p.primary_database is not null then 'LS Primary'
		else NULL
	end as HADRRole
   ,m.mirroring_state_desc as MirroringState
   ,case(d.is_in_standby) when 1 then 'Yes' else 'No' end as IsStandby
   , d.database_id
   , l.last_restored_latency + datediff(mi,l.last_restored_date_utc, getutcdate()) as LSLatency
   , l.restore_threshold as LSThreshold
   , 0,0,0
FROM   
	sys.databases d 
	LEFT JOIN sys.database_mirroring m ON d.database_id = m.database_id	
	LEFT JOIN msdb.dbo.log_shipping_monitor_secondary l on l.secondary_database = d.name
	LEFT JOIN msdb.dbo.log_shipping_primary_databases p on p.primary_database = d.name
END

update @dbstatustable set dbstateflag = 1 
where NOT (statedesc in ('ONLINE', 'STANDBY')
or (statedesc = 'RESTORING' AND isnull(mirrorrole,'') IN ('LS Secondary', 'MIRROR')))

update @dbstatustable set drstateflag = 1
WHERE mirrorstate is not null and mirrorstate NOT IN('SYNCHRONIZED', 'HEALTHY')

update @dbstatustable set lsstateflag = 1
where ls_latency > restore_threshold

--SELECT * from @dbstatustable

declare dbs cursor for 
SELECT * from @dbstatustable
   
open dbs
fetch dbs into @dbname, @statedesc, @mirrorrole, @mirrorstate, @isinstandby, @dbid, @ls_latency, @restore_threshold, @dbstateflag , @drstateflag , @lsstateflag 
while @@FETCH_STATUS = 0
begin
	SELECT @dbdetail = @dbdetail + '<tr>'
		+ '<th>' + @dbid + '</th>'
		+ '<td  align="Left">' + @dbname + '</td>'
		+ '<td  align="Left">' + case when @dbstateflag = 1 then '<font color="red">' else '' end 	+ isnull(@statedesc,'') + case when @dbstateflag = 1 then '</font>' else '' end + '</td>'
		+ '<td  align="Left">' + isnull(@mirrorrole,'') + '</td>'
		+ '<td  align="Left">' + case when @drstateflag = 1 then '<font color="red">' else '' end + isnull(@mirrorstate,'') + case when @drstateflag = 1 then '</font>' else '' end + '</td>'
		+ '<td  align="Center">' + case when @lsstateflag = 1 then '<font color="red">' else '' end + coalesce(cast(@ls_latency as varchar(20)),'') + case when @lsstateflag = 1 then '</font>' else '' end + '</td>'
		+ '</tr>' 

	SELECT @dbstatus = case when @dbstateflag = 1 or @drstateflag = 1 then '<font color="red">Database(s) require attention!</font>' else @dbstatus end

	fetch dbs into @dbname, @statedesc, @mirrorrole, @mirrorstate, @isinstandby, @dbid, @ls_latency, @restore_threshold, @dbstateflag , @drstateflag , @lsstateflag 
end
close dbs
deallocate dbs
select @dbdetail = @dbdetail + '</tbody></table>'

--Checking Cluster

IF @IsAgEnabled = 1
BEGIN

SELECT @clusterstatus = c.quorum_state_desc from sys.dm_hadr_cluster c

SELECT @clusterdetail = '<table class="t1"><thead><tr><th>Member Name</th><th>Member Type</th><th>Member State</th><th>Quorum Votes</th></tr></thead><tbody>'

SELECT @clusterdetail = @clusterdetail + '<tr>'
		+ '<td  align="Left">' + member_name + '</td>'
		+ '<td  align="Left">' + member_type_desc + '</td>'
		+ '<td  align="Left">' + isnull(member_state_desc,'') + '</td>'
		+ '<td  align="Left">' + cast(number_of_quorum_votes as varchar) + '</td>'
		+ '</tr>' 
from sys.dm_hadr_cluster_members
select @clusterdetail = @clusterdetail + '</tbody></table>'
END
ELSE
BEGIN
SET @clusterdetail = ''
SET @clusterstatus = 'n/a'
END

/******************************************************************************
							DISK SPACE REPORT
	Only run if parameter @IncludeSpaceReport = 1. It defaults to 0 because
	this report will make system configuration changes for xp_cmdshell. If it 
	is disabled it will enable it, execute it and set it back.
******************************************************************************/
--declare and set the variable for the space report so that if it is not run we just have a space
DECLARE @spacedetail				VARCHAR(MAX)
SET @spacedetail = ''
IF @IncludeSpaceReport = 1
BEGIN

		SET ARITHIGNORE ON
		DECLARE @vSQL						NVARCHAR(1000);
		DECLARE @tDrvLetter					TABLE (Drive VARCHAR(500));
		DECLARE @vMsg						VARCHAR(1000);
		DECLARE @vCurrentRuntime			DATETIME 
		DECLARE @STRLine					VARCHAR(max);
		DECLARE @Drive						VARCHAR(500);
		DECLARE @TotalSize					REAL;
		DECLARE @Freesize					REAL;
		DECLARE @VolumeName					VARCHAR(64);
		DECLARE @cmdshellEnabled			BIT


		DECLARE @DriveNm					VARCHAR(10) 
		DECLARE @Used_mb					DECIMAL(20, 2) 
		DECLARE @Free_mb					DECIMAL(20, 2) 
		DECLARE @TotalSize_mb				DECIMAL(20, 2) 
		DECLARE @VolName					VARCHAR(64) 
		DECLARE @Pct_Free					DECIMAL(20, 2) 


		set @vCurrentRuntime = getdate()
		SELECT @cmdshellEnabled = cast(value_in_use as bit) FROM sys.configurations Where name = 'xp_cmdshell'

		IF @cmdshellEnabled = 0
		BEGIN
			   --RAISERROR('xp_cmdshell is NOT enabled, will enable it for the report and then turn it off when completed.',10,1) WITH NOWAIT;
			   EXEC sp_configure 'xp_cmdshell',1;
			   RECONFIGURE
		END


		DECLARE @tDrvInfo TABLE(
			   Drive VARCHAR(500) null,
			   [MB free] DECIMAL(20,2),
			   [MB TotalSize] DECIMAL(20,2),
			   [Volume Name] VARCHAR(64),
			   [Pct Free] DECIMAL(20,2)
			   );

		INSERT INTO @tDrvLetter
		EXEC xp_cmdshell 'wmic volume where drivetype="3" get caption, freespace, capacity, label';

		DELETE FROM @tDrvLetter
		WHERE Drive IS NULL OR len(Drive) < 4 OR Drive LIKE '%Capacity%' OR Drive LIKE  '%\\%\Volume%';


		WHILE EXISTS(SELECT 1 FROM @tDrvLetter)
		BEGIN
			   SET ROWCOUNT 1;
			   SELECT @STRLine = Drive FROM @tDrvLetter;

			   -- Get TotalSize
			   SET @TotalSize= CAST(LEFT(@STRLine,CHARINDEX(' ',@STRLine)) AS REAL)/1024/1024;
			   --SELECT @TotalSize

			   -- Remove Total Size
			   SET @STRLine = REPLACE(@STRLine, LEFT(@STRLine,CHARINDEX(' ',@STRLine)),'');
			   -- Get Drive

			   SET @Drive = LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine)));
			   --SELECT @Drive

			   SET @STRLine = RTRIM(LTRIM(REPLACE(LTRIM(@STRLine), LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))),'')));

			   SET @Freesize = CAST(LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))) as REAL)/1024/1024;
			   --SELECT @Freesize/1024/1024

			   SET @STRLine = RTRIM(LTRIM(REPLACE(LTRIM(@STRLine), LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))),'')));
			   SET @VolumeName = @STRLine;
			   -- 

			   INSERT INTO @tDrvInfo SELECT @Drive, @Freesize, @TotalSize, @VolumeName,@Freesize/@TotalSize*100;

			   DELETE FROM @tDrvLetter;
		END

		SET ROWCOUNT 0

		-- POPULATE TEMP TABLE WITH LOGICAL DISKS
		-- This is FIX/Workaround for Windows 2003 bug that WMIC doesn't return volume name that is over X number of charactors.
		SET @vSQL ='wmic /FailFast:ON logicaldisk where (drivetype ="3" and volumename!="RECOVERY" AND volumename!="System Reserved") get deviceid,volumename  /Format:csv'

		DECLARE @toutput1 TABLE (Col1 VARCHAR(2048));
		INSERT INTO @toutput1
		EXEC master..xp_cmdshell @vSQL;
		DELETE @toutput1 where ltrim(Col1) is null or len(Col1) = 1 or Col1 like 'Node,DeviceID,VolumeName%';

		DECLARE @tlogicaldisk TABLE (DeviceID VARCHAR(128),VolumeName VARCHAR(256));
		DECLARE @NodeName VARCHAR(128);
		SET @NodeName = (SELECT TOP 1 LEFT(Col1, CHARINDEX(',',Col1)) FROM @toutput1);

		-- Clean up server name
		UPDATE @toutput1 SET Col1 = REPLACE(Col1, @NodeName, '');

		INSERT INTO @tlogicaldisk
		SELECT LEFT(Col1, CHARINDEX(',',Col1)-2),  SUBSTRING(Col1, CHARINDEX(',',Col1)+1, LEN(Col1))
		FROM @toutput1;


		UPDATE dr
		SET dr.[Volume Name] = ld.VolumeName
			   FROM @tDrvInfo dr RIGHT OUTER JOIN @tlogicaldisk ld ON left(dr.Drive,1) = ld.DeviceID
		WHERE LEN([Volume Name]) = 1

		SET @spacedetail = '<table class="t1"><thead><tr><th>Drive</th><th>Used mb</th><th>Free mb</th><th>Total Size mb</th><th>Volume Name </th><th>Percent Free</th><th>Total Size GB</th><th>Free GB</th><th>Used GB</th></tr></thead><tbody>'

		DECLARE curDisks CURSOR FAST_FORWARD LOCAL FOR 
		SELECT CASE
						WHEN LEN(Drive) = 3 THEN LEFT(Drive,1)
						ELSE Drive
				END AS drive
				,[MB TotalSize] - [MB free] as [MB Used] 
				,[MB free]
				,[MB TotalSize]
				,[Volume Name]
				,[Pct Free]
		FROM @tDrvInfo
		ORDER BY 1;
		OPEN curDisks
		FETCH NEXT FROM curDisks INTO @DriveNm, @Used_mb, @Free_mb, @TotalSize_mb, @VolName , @Pct_Free
		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT
				@spacedetail = @spacedetail + '<tr>'
				+ '<th>' + @DriveNm + '</th>'
				+ '<td  align="Left">' + CAST(dbo.fFormatIntReadable(@Used_mb) AS VARCHAR(30)) +'</td>'
				+'<td  align="Left">'  + CAST(dbo.fFormatIntReadable(@Free_mb)  AS VARCHAR(30)) +'</td>'
				+'<td  align="Left">'  + CAST(dbo.fFormatIntReadable(@TotalSize_mb)  AS VARCHAR(30)) +'</td>'
				+ '<td  align="Left">' + CAST(@VolName  AS VARCHAR(30)) +'</td>'
				+ '<td  align="Left"><b>' +
									 CASE WHEN @Pct_Free <= @FreeSpaceWarningPercent Then 
										'<font color="red">' +  CAST(@Pct_Free  AS VARCHAR(30)) + '</font>'
									ELSE CAST(@Pct_Free  AS VARCHAR(30)) END
									+'</b></td>'
				+ '<td  align="Left">' + CAST(CAST(@TotalSize_mb/1024 AS DECIMAL(18,2)) AS VARCHAR(30)) +'</td>'
				+ '<td  align="Left">' + CAST(CAST(@Free_mb/1024 as DECIMAL(18,2)) AS VARCHAR(30)) +'</td>'
				+ '<td  align="Left">' + CAST(CONVERT(MONEY ,(@TotalSize_mb - @Free_mb)/1024.0,1) AS VARCHAR(30)) +'</td>'
				+ '</tr>'

			FETCH NEXT FROM curDisks INTO @DriveNm, @Used_mb, @Free_mb, @TotalSize_mb, @VolName , @Pct_Free
		END 
		CLOSE curDisks
		DEALLOCATE curDisks
	
		IF @cmdshellEnabled = 0
		BEGIN
				If EXISTS(SELECT 1 FROM sys.configurations Where name = 'xp_cmdshell' AND value_in_use = CAST(1 AS sql_variant))
				BEGIN
						--RAISERROR('Disabling xp_cmdshell .',10,1) WITH NOWAIT;
						EXEC sp_configure 'xp_cmdshell',0;
						RECONFIGURE
				END
		END
		SET @spacedetail = @spacedetail +  '</tbody></table>'
END
/********************************************************************************************************************************************************************************************/

--Checking the errorlog
DECLARE @logsection varchar(max)
SELECT @logsection = '<p style="font-size:12px"> Checking log file for errors:</p><p style="font-size:12px">'

-- check for any failures in the log that are not login failures
-- Drop temp table if exists
IF OBJECT_ID('tempdb..#startuplogcheck') IS NOT NULL
	DROP TABLE #startuplogcheck
-- Create temp table
Create table #startuplogcheck (id int IDENTITY (1, 1), 
						logdate datetime, 
						processinfo nvarchar(50), 
						logtext nvarchar(max))

-- Load current alert log into temp table
insert into #startuplogcheck
exec sp_readerrorlog 0

DECLARE @errorlogdate datetime 
DECLARE @errorlogtext nvarchar(max)

-- Check Login failures
DECLARE curLOGINerror CURSOR FAST_FORWARD LOCAL FOR
select 
	logdate, logtext
 from 
	#startuplogcheck 
 Where processinfo != 'Backup'
   And (logtext like 'Login Failed%' or logtext like '%Error: 18456%')
   And logdate>=(select ISNULL(max(logdate),0) from #startuplogcheck where logtext like 'CHECKDB%')
ORDER BY
	logdate desc


OPEN curLOGINerror
FETCH NEXT FROM curLOGINerror INTO @errorlogdate, @errorlogtext
WHILE @@FETCH_STATUS = 0
BEGIN
	SET @logsection = @logsection + '<br />'+ 'WARNING: At ' + convert(varchar,@errorlogdate,21) + ' - '+@errorlogtext	
	FETCH NEXT FROM curLOGINerror INTO @errorlogdate, @errorlogtext
END
CLOSE curLOGINerror
DEAllocate curLOGINerror

DELETE
	#startuplogcheck
Where processinfo != 'Backup'
   And (logtext like 'Login Failed%'
		or
		logtext like '%Error: 18456%'
		)

-- Check SPN registration
DECLARE curSPNerror CURSOR FAST_FORWARD LOCAL FOR
SELECT	logdate, logtext
  FROM	#startuplogcheck 
 WHERE	processinfo != 'Backup'
   AND	logtext like '%SPN%Failure%'
ORDER BY logdate desc

OPEN curSPNerror
FETCH NEXT FROM curSPNerror INTO @errorlogdate, @errorlogtext
WHILE @@FETCH_STATUS = 0
BEGIN
	SET @logsection = @logsection + '<br />'+  'WARNING: At ' + convert(varchar,@errorlogdate,21) + ' - '+@errorlogtext
	FETCH NEXT FROM curSPNerror INTO @errorlogdate, @errorlogtext
END
CLOSE curSPNerror
DEAllocate curSPNerror

DELETE
	#startuplogcheck
 WHERE	processinfo != 'Backup'
   AND	logtext like '%SPN%Failure%'

DECLARE curOthererror CURSOR FAST_FORWARD LOCAL FOR
SELECT	logdate, logtext
  FROM	#startuplogcheck 
 WHERE	
	1=1
	AND (logtext LIKE '%Error%'
		or
		logtext LIKE '%fail%'
	)
	AND logtext NOT LIKE 'Logging SQL Server messages in file%'
	AND logtext != 'The error log has been reinitialized. See the previous log for older entries.'

OPEN curOthererror
FETCH NEXT FROM curOthererror INTO @errorlogdate, @errorlogtext
WHILE @@FETCH_STATUS = 0
BEGIN
	SET @logsection = @logsection + '<br />'+  'WARNING: At ' + convert(varchar,@errorlogdate,21) + ' - '+@errorlogtext
	FETCH NEXT FROM curOthererror INTO @errorlogdate, @errorlogtext
END
CLOSE curOthererror
DEAllocate curOthererror

-- Check SPN registration
DECLARE curSPNerror CURSOR FAST_FORWARD LOCAL FOR
SELECT	logdate, logtext
  FROM	#startuplogcheck 
 WHERE	processinfo != 'Backup'
   AND	logtext like '%SPN%Failure%'
ORDER BY logdate desc

OPEN curSPNerror
FETCH NEXT FROM curSPNerror INTO @errorlogdate, @errorlogtext
WHILE @@FETCH_STATUS = 0
BEGIN
	SET @logsection = @logsection + '<br />'+  'WARNING: At ' + convert(varchar,@errorlogdate,21) + ' - '+@errorlogtext
	FETCH NEXT FROM curSPNerror INTO @errorlogdate, @errorlogtext
END
CLOSE curSPNerror
DEAllocate curSPNerror

DELETE
	#startuplogcheck
 WHERE	processinfo != 'Backup'
   AND	logtext like '%SPN%Failure%'

DECLARE curOthererror CURSOR FAST_FORWARD LOCAL FOR
SELECT	logdate, logtext
  FROM	#startuplogcheck 
 WHERE	
	1=1
	AND (logtext LIKE '%Error%'
		or
		logtext LIKE '%fail%'
	)
	AND logtext NOT LIKE 'Logging SQL Server messages in file%'
	AND logtext != 'The error log has been reinitialized. See the previous log for older entries.'


OPEN curOthererror
FETCH NEXT FROM curOthererror INTO @errorlogdate, @errorlogtext
WHILE @@FETCH_STATUS = 0
BEGIN
	SET @logsection = @logsection + '<br />'+  'WARNING: At ' + convert(varchar,@errorlogdate,21) + ' - '+@errorlogtext
	FETCH NEXT FROM curOthererror INTO @errorlogdate, @errorlogtext
END
CLOSE curOthererror
DEAllocate curOthererror


SET @headertab = '<table class="t1"><thead><tr><th>SQL Server Shutdown time</th><th>SQL Server Startup time</th><th>SQL Server Down time</th><th>SQL Agent Service</th> <th>Database(s) Status</th><th>Cluster Status</th><th>FDDBA Version</th></tr></thead><tbody><tr>'
+'<td align="Center">'+@stopTime+'</td>'
+'<td align="Center">'+@starttime+'</td>'
+'<td align="Center">'+@downtime_char+'</td>'
+'<td align="Center">'+@agentstatus+'</td>'
+'<td align="Center">'+@dbstatus+'</td>'
+'<td align="Center">'+@clusterstatus+'</td>'
+'<td align="Center">'+@fddba_ver+'</td>'
--+'<td align="Center">'+@authmode+'</td>'
+'</tr></table><BR>
<table class="t1"><thead><tr><th>SQL Server Version</th></tr></thead><tbody><tr>'
+'<td align="Center">'+ @SQLVersion +'</td>

</tbody></table>'

SET @subject=@sname+' : SQL Server is restarted. Please Check'
--declare @HTML VARCHAR(max)
--SET @HTML=@style+'<body><font face="arial" size="10pt"><h3>'+@sname+'</h3><br>'+@headertab+'<br><br>'+@dbdetail+'<br><br>'+@clusterdetail+@logsection+'</body>'
SET @HTML=@style+'<body><font face="arial" size="10pt"><h3>'+@sname+'</h3>'

IF @hostname IS NOT NULL
BEGIN
	IF @fIsSFCI = 0
	BEGIN
		IF @hostname != @sqlservername
		BEGIN
			SET @HTML = @HTML +'<b><font color="orange">WARNING hostname is [' + @hostname + ']</font></b><br>'
		END
	END
END
ELSE
BEGIN
	SET @HTML = @HTML + '<b><font color="orange">WARNING hostname not verified</font></b><br>'
END 

SET @HTML = @HTML +'<br>'+@headertab+'<br><br>'+@dbdetail+'<br><br>' + @spacedetail  +'<br><br>' +@clusterdetail+@logsection+'<br><br><img src="cid:fdlogo.png" width="250"  border="0" alt="Generated by Fortified Data"></body>'

END

GO


if object_id('dbo.pStatistics2014Plus') is null exec('create procedure [dbo].[pStatistics2014Plus] as select getdate() DT')
GO
  
	/******************************************************************************************************************************************
		dbo.pStatistics2014Plus
	  Summary:  Provides statistics information for the supplied table

	  Date:  4/19/2019
	  Versions: 2014 and greater
	  Parameters:	
		 @dbName				sysname:	database to check 
		,@table					sysname:	Name of table to check
		,@schema				sysname:	Schema to check, default is dbo
		,@includeColumnStats	bit:		Include column stats
		,@includeIndexSize		bit:		Include total size of each index, default is 1 (Yes)
		,@includePartitionSize	bit:		Include total size of each Partition in each index if it is  = 1
		,@debug					bit:		Include debug outputs

		//TODO  - need to update this code and if the table is partitioned we still need to see if is_incremental 
		is set in sys.stats. May be able to do this instead of the checking the partition.
	------------------------------------------------------------------------------
	  Written by Keith Buck, Fortified Data

	  For more scripts AND sample code, check out 
		http://www.fortifieddata.com

	  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
	  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
	  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	  PARTICULAR PURPOSE.
	******************************************************************************************************************************************/
	alter procedure dbo.pStatistics2014Plus (
	  @dbName					sysname
	 ,@table					sysname
	 ,@schema					sysname = 'dbo'
	 ,@includeColumnStats		bit = 1
	 ,@includeIndexSize			bit = 1
	 ,@includePartitionSize		bit = 1
	 ,@debug					bit = 0
	)
	WITH ENCRYPTION
	AS
	set nocount on
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

	DECLARE @sql					nvarchar(MAX)
	DECLARE @ParmDefinition			nvarchar(500)
	DECLARE @IntVariable			int
	DECLARE @objid					int	
	DECLARE @count					int
	DECLARE @msg					varchar(2048)

	IF ISNULL(@dbName,'') = ''
	BEGIN
		RAISERROR('Parameter @dbName must be supplied',11,1) WITH NOWAIT;
		RETURN
	END

	IF ISNULL(@schema,'') = ''
	BEGIN
		RAISERROR('Parameter @schema must be supplied',11,1) WITH NOWAIT;
		RETURN
	END

	IF ISNULL(@table,'') = ''
	BEGIN
		RAISERROR('Parameter @table must be supplied',11,1) WITH NOWAIT;
		RETURN
	END


	IF @debug = 1
	BEGIN
		RAISERROR(' ',10,1) WITH NOWAIT;
		RAISERROR('Parameters passed in:',10,1) WITH NOWAIT;
		SET @msg = '@dbName	= ' + @dbName;
		RAISERROR(@msg,10,1) WITH NOWAIT;

		SET @msg = '@table	= ' + @table;
		RAISERROR(@msg,10,1) WITH NOWAIT;

		SET @msg = '@schema	= ' + @schema;
		RAISERROR(@msg,10,1) WITH NOWAIT;

		SET @msg = '@includeColumnStats	= ' + cast(@includeColumnStats as varchar(10));
		RAISERROR(@msg,10,1) WITH NOWAIT;

		SET @msg = '@includeIndexSize	= ' + cast(@includeIndexSize as varchar(10));
		RAISERROR(@msg,10,1) WITH NOWAIT;

		SET @msg = '@includePartitionSize	= ' + cast(@includePartitionSize as varchar(10));
		RAISERROR(@msg,10,1) WITH NOWAIT;

		RAISERROR(' ',10,1) WITH NOWAIT;
		RAISERROR('----------------------------------------------------------------------------------------------',10,1) WITH NOWAIT;
	END



	SET @ParmDefinition = N'@tablename sysname, @schemaname sysname, @objectid int OUTPUT'

	select @sql = N'SELECT @objectid = OBJECT_ID from [' + @dbName + '].sys.objects o INNER JOIN [' + @dbName + '].sys.schemas s on o.schema_id = s.schema_id WHERE s.name = @schemaname AND o.name = @tablename'
	EXECUTE sp_executesql @sql, @ParmDefinition, @tablename = @table, @schemaname = @schema,  @objectid = @objid OUTPUT


	If @objid IS NULL
	begin
		raiserror('Not a valid object name',15,1) with nowait;
		return;
	end

	/*******************************************************
				TOTAL SIZE OF EACH INDEX
	*******************************************************/
	SET @sql = N'SELECT 
		ix.name as [Index],
		ix.index_id,
		ix.type_desc,
		CASE WHEN SUM(ISNULL(allInRow.total_pages,0)) + 	SUM(ISNULL(allLob.total_pages,0)) + SUM(ISNULL(allOver.total_pages,0)) = 0 THEN ''0''
			ELSE FDDBA.dbo.fFormatIntReadable((SUM(ISNULL(allInRow.total_pages,0)) + 	
								SUM(ISNULL(allLob.total_pages,0)) + 
								SUM(ISNULL(allOver.total_pages,0)))/128.0) 
		END AS TotalSize_MB,
		FDDBA.dbo.fFormatIntReadable(SUM(ISNULL(allInRow.total_pages,0)) + 	SUM(ISNULL(allLob.total_pages,0)) + SUM(ISNULL(allOver.total_pages,0))) AS TotalPages,
		FDDBA.dbo.fFormatIntReadable(SUM(allInRow.total_pages)) AS InRowPages,
		FDDBA.dbo.fFormatIntReadable(SUM(allLob.total_pages)) AS LobPages,
		FDDBA.dbo.fFormatIntReadable(SUM(allOver.total_pages)) AS RowOverFlowPages  
	 FROM
		[' + @dbName + '].sys.objects o 
		INNER JOIN [' + @dbName + '].sys.schemas sch on o.schema_id = sch.schema_id
		LEFT JOIN [' + @dbName + '].sys.indexes ix on o.object_id = ix.object_id --and s.name = ix.name
		INNER JOIN [' + @dbName + '].sys.partitions p on ix.object_id = p.object_id And ix.index_id = p.index_id
		LEFT JOIN [' + @dbName + '].sys.allocation_units allInRow on p.hobt_id = allInRow.container_id and allInRow.type = 1
		LEFT JOIN [' + @dbName + '].sys.allocation_units allLob on p.partition_id = allLob.container_id and allLob.type = 2
		LEFT JOIN [' + @dbName + '].sys.allocation_units allOver on p.partition_id = allLob.container_id and allLob.type = 3
	WHERE
		o.object_id = @objectid 
	GROUP BY 
		ix.name ,
		ix.index_id,
		ix.type_desc
	ORDER BY
		CASE WHEN ix.type_desc =N''NONCLUSTERED'' THEN 2 ELSE 1 END
		,ix.name'

	SET @ParmDefinition = N'@objectid int'
	IF ISNULL(@includeIndexSize,1) = 1
		EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid

	/*******************************************************
				TOTAL SIZE OF EACH PARTITION
	*******************************************************/
	SET @sql = N'SELECT 
		ix.name as [Index],
		ix.type_desc,
		p.partition_number,
		CASE WHEN ISNULL(allInRow.total_pages,0) + 	ISNULL(allLob.total_pages,0) + ISNULL(allOver.total_pages,0) = 0 THEN ''0''
			ELSE FDDBA.dbo.fFormatIntReadable((ISNULL(allInRow.total_pages,0) + 	ISNULL(allLob.total_pages,0) + ISNULL(allOver.total_pages,0))/128) 
		END AS TotalSize_MB,
		ISNULL(allInRow.total_pages,0) + 	ISNULL(allLob.total_pages,0) + ISNULL(allOver.total_pages,0) as TotalPages,
		allInRow.total_pages as InRowPages,
		allLob.total_pages as LobPages,
		allOver.total_pages as RowOverFlowPages  
	 FROM
		[' + @dbName + '].sys.objects o 
		INNER JOIN  [' + @dbName + '].sys.schemas sch on o.schema_id = sch.schema_id
		LEFT JOIN [' + @dbName + '].sys.indexes ix on o.object_id = ix.object_id --and s.name = ix.name
		INNER JOIN [' + @dbName + '].sys.partitions p on ix.object_id = p.object_id And ix.index_id = p.index_id
		LEFT JOIN [' + @dbName + '].sys.allocation_units allInRow on p.hobt_id = allInRow.container_id and allInRow.type = 1
		LEFT JOIN [' + @dbName + '].sys.allocation_units allLob on p.partition_id = allLob.container_id and allLob.type = 2
		LEFT JOIN [' + @dbName + '].sys.allocation_units allOver on p.partition_id = allLob.container_id and allLob.type = 3
	WHERE
		o.object_id = @objectid 
	ORDER BY
		CASE WHEN ix.type_desc =N''NONCLUSTERED'' THEN 2 ELSE 1 END
		,ix.name 
		,p.partition_number'


	IF ISNULL(@includePartitionSize,1) = 1
		EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid


	/*******************************************************
	 Check the number of partitions by getting count
	 where partition number > 1
	*******************************************************/
	SET @ParmDefinition = N'@objectid int, @reccount int OUTPUT'

	select @sql = N'SELECT top 1 @reccount = 1 from [' + @dbName + '].sys.stats s WHERE  s.object_id = @objectid and is_incremental =1'
	IF @debug = 1 
	BEGIN
		set @msg = '@sql ='  + @sql
		RAISERROR(@msg,10,1) WITH NOWAIT;
	END

	EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid, @reccount = @count  OUTPUT
	IF @debug = 1 
	BEGIN
		set @msg = '@count ='  + cast(ISNULL(@count,-1)  as varchar(100))
		RAISERROR(@msg,10,1) WITH NOWAIT;
		RAISERROR(' ' ,10,1) WITH NOWAIT;
		RAISERROR(' ' ,10,1) WITH NOWAIT;
	END
	/*******************************************************
		Non incremental object queries
	*******************************************************/
	IF ISNULL(@count,0) < 1
	BEGIN
		IF @debug = 1 
		BEGIN
			RAISERROR('Executing non incremental query.',10,1) WITH NOWAIT;
			RAISERROR(' ' ,10,1) WITH NOWAIT;
		END
		SET @sql = N'use [' + @dbName + N']
		SELECT sch.name as SchemaName
		,obj.name AS [Table],
		[s].[name] AS [Statistic],
		[sp].[stats_id] AS [Statistic ID],
		[sp].[last_updated] AS [Last Updated],
		FDDBA.dbo.fFormatIntReadable([sp].[rows]) as StatRows,
		FDDBA.dbo.fFormatIntReadable([sp].[rows_sampled]) as rows_sampled,
		CASE WHEN ISNULL(sp.rows,0) < 1 THEN 0 ELSE
		CAST(([sp].[rows_sampled]/ cast(sp.rows as decimal(28,3)) ) * 100 AS DECIMAL(28,3)) END as SamplePercent,
		FDDBA.dbo.fFormatIntReadable([sp].[unfiltered_rows]) as unfiltered_rows,
		FDDBA.dbo.fFormatIntReadable([sp].[modification_counter]) AS [Modifications],
		CASE WHEN sp.rows = 0 Then NULL ELSE (sp.modification_counter/CAST(sp.rows AS MONEY))*100 END AS ModPercentage,
		sp.steps,
		sp.object_id 
	  FROM 
		[' + @dbName + '].[sys].[stats] AS [s]
		INNER JOIN [' + @dbName + '].sys.objects obj on s.object_id = obj.object_id and obj.type = N''U'' and obj.is_ms_shipped = 0
		OUTER APPLY [' + @dbName + '].sys.dm_db_stats_properties ([s].[object_id],[s].[stats_id]) AS [sp]
		--INNER JOIN [' + @dbName + '].sys.partitions p on sp.object_id = p.object_id And p.index_id < 2
		INNER JOIN [' + @dbName + '].sys.objects o on s.object_id = o.object_id
		LEFT JOIN [' + @dbName + '].sys.schemas sch on o.schema_id = sch.schema_id
		LEFT JOIN [' + @dbName + '].sys.indexes ix on s.object_id = ix.object_id and s.name = ix.name

	WHERE
		1=1 
		And s.object_id > 99
		And [s].[object_id] = @objectid
		and s.name not like ''_WA%''
	
	ORDER BY
		CASE WHEN  [sp].[stats_id] < 2 THEN 1 ELSE 2 END , 
		[s].[name]
		'

	END
	ELSE
	BEGIN 
		/*******************************************************
			Paritioned Object Queries
		*******************************************************/
		IF @debug = 1 
		BEGIN
			RAISERROR('Executing Incremental query.',10,1) WITH NOWAIT;
			RAISERROR(' ' ,10,1) WITH NOWAIT;
		END


		SET @sql = N'use [' + @dbName + N']
		SELECT sch.name as SchemaName,
		obj.name AS [Table],
		[s].[name] AS [Statistic],

		spi.stats_id AS [INCrementalStatistic ID],
		spi.[last_updated] AS [IncLast Updated],
		FDDBA.dbo.fFormatIntReadable(spi.[rows]) as IncStatRows,
		FDDBA.dbo.fFormatIntReadable(spi.[rows_sampled]) AS IncRowsSampled,
		CASE WHEN spi.rows = 0 THEN NULL	
			ELSE CAST(100 * (CAST(spi.rows_sampled/CAST(spi.rows AS DECIMAL(28,12)) AS decimal(28,12))) AS DECIMAL(28,4))
		END AS SamplePercent,
		
		FDDBA.dbo.fFormatIntReadable(spi.[unfiltered_rows]) As IncUnfilteredRows,
		FDDBA.dbo.fFormatIntReadable(spi.[modification_counter]) AS [IncModifications],
		spi.partition_number  AS ''IncPartition_number'',
		CASE WHEN spi.rows = 0 Then NULL ELSE (spi.modification_counter/CAST(spi.rows AS MONEY))*100 END AS IncModPercentage,
		spi.steps as IncSteps,
		spi.object_id 
	
	  FROM 
		[' + @dbName + N'].[sys].[stats] AS [s]
		INNER JOIN [' + @dbName + N'].sys.objects obj on s.object_id = obj.object_id and obj.type = N''U'' and obj.is_ms_shipped = 0
		OUTER APPLY [' + @dbName + N'].sys.dm_db_incremental_stats_properties (s.object_id,[s].[stats_id]) AS [spi]
	
		INNER JOIN [' + @dbName + N'].sys.objects o on s.object_id = o.object_id
		LEFT JOIN [' + @dbName + N'].sys.schemas sch on o.schema_id = sch.schema_id
		LEFT JOIN [' + @dbName + N'].sys.indexes ix on s.object_id = ix.object_id and s.name = ix.name

		WHERE
			1=1 
			And s.object_id > 99
			And [s].[object_id] = @objectid
			and s.name not like ''_WA%''
		Order by 
		CASE WHEN  [spi].[stats_id] < 2 THEN 1 ELSE 2 END , 
			s.name'
	END	


	IF @debug = 1 
	BEGIN
		PRINT '@Objectid = '  + CAST(@objid AS VARCHAR(50))
		PRINT @sql 
	END
	SET @ParmDefinition = N'@objectid int'
	EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid


	IF @includeColumnStats = 1
	BEGIN
		SET @sql = N'use [' + @dbName + N']
		SELECT 
			sch.name as SchemaName
			,o.name AS [Table],
			[sp].[stats_id] AS [Statistic ID],
			[s].[name] AS "Statistic",
			COL_NAME(statscol.object_id, statscol.column_id) as ColumnName,
			[sp].[last_updated] AS [Last Updated],
			FDDBA.dbo.fFormatIntReadable([sp].[rows]) as [rows],
			FDDBA.dbo.fFormatIntReadable([sp].[rows_sampled]) as rows_sampled,
			CASE WHEN ISNULL(sp.rows,0) < 1 THEN NULL ELSE
			CAST(([sp].[rows_sampled]/ cast(sp.rows as decimal(28,3)) ) * 100 AS DECIMAL(28,3)) END as SamplePercent,
			FDDBA.dbo.fFormatIntReadable([sp].[unfiltered_rows]) as unfiltered_rows,
			FDDBA.dbo.fFormatIntReadable([sp].[modification_counter]) AS [Modifications]
			,sp.steps 
			,CASE WHEN sp.rows = 0 Then NULL ELSE (sp.modification_counter/CAST(sp.rows AS MONEY))*100 END AS ModPercentage
			FROM 
			[' + @dbName + N'].[sys].[stats] AS [s]
			INNER JOIN [' + @dbName + N'].sys.objects obj on s.object_id = obj.object_id and obj.type = N''U'' and obj.is_ms_shipped = 0
			OUTER APPLY [' + @dbName + N'].sys.dm_db_stats_properties ([s].[object_id],[s].[stats_id]) AS [sp]
			INNER JOIN [' + @dbName + N'].sys.stats_columns statscol on s.stats_id = statscol.stats_id
							and s.object_id = statscol.object_id
			INNER JOIN [' + @dbName + N'].sys.objects o on s.object_id = o.object_id
			LEFT JOIN [' + @dbName + N'].sys.schemas sch on o.schema_id = sch.schema_id
		WHERE
			s.object_id = @objectid
			and s.name like ''_WA%'' 
		Order by 
			ColumnName;'
		IF @debug = 1 
			PRINT @sql 
		SET @ParmDefinition = N'@objectid int'
		EXECUTE sp_executesql @sql, @ParmDefinition, @objectid = @objid
	END 



GO

DECLARE @verdec		DECIMAL(18,2)
SELECT TOP 1 @verdec = VerDec FROM #FDVER
IF ISNULL(@verdec,0) < 12
	EXECUTE sp_executesql N'drop procedure dbo.pStatistics2014Plus'
go


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pWaitStatistics_Delete]',10,1) WITH NOWAIT;
if object_id('dbo.pWaitStatistics_Delete') is null exec('create procedure [dbo].[pWaitStatistics_Delete] as select getdate() DT')
GO
  


/*******************************************************
* Removes old records from the dbo.WaitStatistics table
*******************************************************/
alter procedure dbo.pWaitStatistics_Delete
(
	@NumMonthsOldToDelete	SMALLINT = -6
	,@batchsize				INT = 25000
	,@debug					BIT = 1
) 
WITH ENCRYPTION
AS
BEGIN
SET NOCOUNT ON
	exec dbo.usp_UpdateVersionStatics

	DECLARE @deldate				DATETIME
	DECLARE @msg					NVARCHAR(200)
	DECLARE @recsaffected			INT
	DECLARE	@total					INT
	DECLARE @start					DATETIME
	DECLARE @end					DATETIME	

	SET @deldate = DATEADD(MONTH,@NumMonthsOldToDelete,GETDATE()) 
	SET @recsaffected = 1
	SET @total = 0
	WHILE @recsaffected > 0
	BEGIN
		BEGIN TRAN
		SET @start = GETDATE()
		DELETE TOP (@batchsize) FROM dbo.WaitStatistics 
		WHERE CaptureDate <=@deldate
		SET @recsaffected = @@ROWCOUNT
		SET @total = @total + @recsaffected
		SET @end= GETDATE()
		COMMIT TRAN

		If @debug = 1
		BEGIN
			SET @end = GETDATE()
			SET @msg = N'Deleted ' + cast(@recsaffected as nvarchar(20)) + N' records from dbo.WaitStatistics  table in ' + 
					cast(DATEDIFF(ms,@start, @end) as nvarchar(20)) + N' milliseconds (' +
					cast(DATEDIFF(second,@start, @end) as nvarchar(20)) + N' seconds).'
			RAISERROR(@msg, 10,1) with nowait;
		END
	END

	SET @msg = N'Deleted a total of ' + CAST(@total AS nvarchar) + ' records from dbo.WaitStatistics.'
	RAISERROR('' , 10,1) WITH NOWAIT;
	RAISERROR(@msg , 10,1) WITH NOWAIT;
END


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pWaitStatistics_Load]',10,1) WITH NOWAIT;
if object_id('dbo.pWaitStatistics_Load') is null exec('create procedure [dbo].[pWaitStatistics_Load] as select getdate() DT')
GO
  
/*******************************************************
* Loads current wait stats into the dbo.WaitStatistics table
*******************************************************/
ALTER PROCEDURE dbo.pWaitStatistics_Load
WITH ENCRYPTION
AS
BEGIN
SET NOCOUNT ON
	DECLARE @dt DATETIME, @sysstartdt DATETIME
	SET @dt = GETDATE()
	select @sysstartdt = create_date from sys.databases where name = 'tempdb'
	
	INSERT INTO dbo.WaitStatistics (WaitStatTypeId, WaitingTaksCount, WaitTime_ms, MaxWaitTime_ms, SignalWaitTime_ms, CaptureDate, SystemStartDate)
    SELECT wst.Id , ws.waiting_tasks_count, ws.wait_time_ms, ws.max_wait_time_ms, ws.signal_wait_time_ms,@dt, @sysstartdt 
        FROM sys.dm_os_wait_stats ws INNER JOIN dbo.WaitStatType  wst on 
				ws.wait_type = wst.Name 
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pWaitStats_Report]',10,1) WITH NOWAIT;
if object_id('dbo.pWaitStats_Report') is null exec('create procedure [dbo].[pWaitStats_Report] as select getdate() DT')
GO
  

/*********************************************************************************************************
 dbo.pWaitStats_Report
 Summary:  Provides Wait Statistics report for the instance based on data from table dbo.WaitStatistics but
 uses view vWaitStatistics to get most of the data.
 Procedure will also update the dbo.WaitStatType table setting CanIgnore column to 1 for any statistic 
 name that is in the table  dbo.WaitStats_Benign

  Date:  4/19/2019		CreatedBy: Keith Buck
  Versions: 2008+
  Parameters:	
	@First_Time				datetime = NULL		--start date of sample
	@Last_Time				datetime = NULL		-- end date of sampe
	@UseOLEDB				int = 0				--  0 = Dont include OLEDB waits, 1 = Include OLEDB waits
	@SingleResultSet		bit = 0				--pass in a 1 if calling this proc to insert results into a table
------------------------------------------------------------------------------
  Written by Keith Buck, Fortified Data

  For more scripts AND sample code, check out 
    http://www.fortifieddata.com
  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
  INCLUDING BUT NOT LIMITED  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
**************************************************************************************************************/
alter procedure [dbo].[pWaitStats_Report]
(
	@First_Time				datetime = NULL	--start date of sample
	,@Last_Time				datetime = NULL		-- end date of sampe
	,@UseOLEDB				int = 0				--  0 = Dont include OLEDB waits, 1 = Include OLEDB waits
	,@SingleResultSet		bit = 0	--pass in a 1 if calling this proc to insert results into a table
) 
WITH ENCRYPTION
AS
SET NOCOUNT ON ;

IF OBJECT_ID( N'dbo.WaitStatistics',N'U') IS NULL
BEGIN
		RAISERROR('Error dbo.WaitStatistics table does not exist', 16, 1) WITH NOWAIT ;
		RETURN ;
END


--update waitstatstype table with benign waits
update w 
	set w.CanIgnore = 1
FROM 
	dbo.WaitStatType w
	INNER JOIN dbo.WaitStats_Benign b on w.Name = b.WaitStatTypeName
	AND w.CanIgnore = 0


DECLARE @start_SystemStartdt	DATETIME
DECLARE @end_SystemStartdt		DATETIME
DECLARE @Total_Wait				NUMERIC(20,1)
DECLARE @Total_SignalWait		NUMERIC(20,1)
DECLARE @Total_ResourceWait		NUMERIC(20,1)
DECLARE @EndTime				DATETIME
DECLARE @Total_Requests			BIGINT ;

DECLARE @Waits TABLE (
	[wait_type]				NVARCHAR(60) not null, 
    [waiting_tasks_count]	BIGINT not null,
    [wait_time_ms]			BIGINT not null,
    [max_wait_time_ms]		BIGINT not null,
    [signal_wait_time_ms]	BIGINT not null,
    [capture_time]			DATETIME not null,
    RecordType				NVARCHAR(10) NOT NULL) ;

--  If no First time was specified then use the First sample
IF @First_Time IS NULL
    SET @First_Time = (SELECT MIN(CaptureDate) FROM [dbo].[WaitStatistics]) ;  
ELSE
BEGIN  
    IF NOT EXISTS(SELECT TOP 1 1 FROM [dbo].[WaitStatistics] WHERE CaptureDate = @First_Time) 
    BEGIN
		DECLARE @overTime	DATETIME
		DECLARE @underTime	DATETIME
		DECLARE @overSec	int 
		DECLARE @underSec	int
		
		SET @overTime = (SELECT MIN(CaptureDate) FROM dbo.WaitStatistics WHERE CaptureDate > @First_Time)
		SET @underTime = (SELECT MAX(CaptureDate) FROM dbo.WaitStatistics WHERE CaptureDate < @First_Time)
		SET @overSec = DATEDIFF(SECOND,@First_Time, @overTime)
		Set @underSec  = DATEDIFF (SECOND,@underTime, @First_Time )
		If @overTime IS NOT NULL 
		begin
			If @overSec <= @underSec 
				Set @First_Time = @overTime 
			Else
				Set @First_Time = @underTime 		
		end
		else
			Set @First_Time = @underTime 		
    END
END
SET @start_SystemStartdt = (select top 1 SystemStartDate FROM dbo.WaitStatistics where CaptureDate = @First_Time) 

--  If no Last time was specified then use the latest sample
IF @Last_Time IS NULL
    SET @Last_Time = (SELECT MAX(CaptureDate) 
						FROM [dbo].WaitStatistics
					   WHERE SystemStartDate = @start_SystemStartdt)
ELSE
BEGIN
    --  If the time was not specified exactly find the closest one
    IF NOT EXISTS(SELECT * FROM [dbo].WaitStatistics WHERE CaptureDate = @Last_Time) 
    BEGIN
		SET @overTime = (SELECT MIN(CaptureDate) FROM dbo.WaitStatistics Where CaptureDate > @Last_Time )
		SET @underTime = (SELECT MAX(CaptureDate) FROM dbo.WaitStatistics Where CaptureDate < @Last_Time)
		SET @overSec = DATEDIFF(SECOND,@Last_Time, @overTime)
		Set @underSec  = DATEDIFF (SECOND,@underTime, @Last_Time )
		If @overTime IS NOT NULL 
		begin
			If @overSec <= @underSec 
				Set @Last_Time = @overTime 
			Else
				Set @Last_Time = @underTime 		
		end
		else
			Set @Last_Time = @underTime 		
    END
END
SET @end_SystemStartdt = (select top 1 SystemStartDate FROM dbo.WaitStatistics where CaptureDate = @Last_Time) 


--  Get the start wait numbers
INSERT INTO @Waits ([wait_type], [waiting_tasks_count], [wait_time_ms], [max_wait_time_ms], [signal_wait_time_ms], [capture_time], RecordType )
    SELECT	  Name,
			 WaitingTaksCount, 
			 WaitTime_ms, 
			 MaxWaitTime_ms, 
			 SignalWaitTime_ms, 
			 CaptureDate,
			 'Start'
        FROM [dbo].[vWaitStatistics] WHERE CaptureDate = @First_Time;
IF @@ROWCOUNT = 0
BEGIN
    RAISERROR('Error, there are no waits for the specified Start DateTime', 16, 1) WITH NOWAIT ;
    RETURN ;
END
-- Get the end wait numbers
INSERT INTO @Waits ([wait_type], [waiting_tasks_count], [wait_time_ms], [max_wait_time_ms], [signal_wait_time_ms], [capture_time], RecordType )
    SELECT	  Name,
			 WaitingTaksCount, 
			 WaitTime_ms, 
			 MaxWaitTime_ms, 
			 SignalWaitTime_ms, 
			 CaptureDate,
			 'End'
        FROM [dbo].[vWaitStatistics] WHERE CaptureDate = @Last_Time ;
IF @@ROWCOUNT = 0
BEGIN
    RAISERROR('Error, there are no waits for the specified End DateTime', 16, 1) WITH NOWAIT ;
    RETURN ;
END
  
--  Delete some of the misc types of waits and OLEDB if called for
IF @UseOLEDB = 0
		DELETE FROM @Waits  WHERE [wait_type] =  'OLEDB' ;

--Second filter for waits we are not interested in
DELETE FROM @Waits WHERE [wait_type] IN  (SELECT Name from dbo.WaitStatType WHERE CanIgnore = 1)

-- Get the delta
INSERT INTO @Waits ([wait_type], [waiting_tasks_count], [wait_time_ms], [max_wait_time_ms], [signal_wait_time_ms], 
			[capture_time], RecordType )
SELECT	
	en.wait_type, 
	en.waiting_tasks_count -st.waiting_tasks_count,
	en.wait_time_ms - st.wait_time_ms , 
	en.max_wait_time_ms,
	en.signal_wait_time_ms - st.signal_wait_time_ms, 
	en.capture_time, 'Result'   	    
FROM 
	@Waits st 
	INNER JOIN @Waits en on st.wait_type = en.wait_type 
WHERE 
	st.RecordType = 'Start'
	AND en.RecordType = 'End'

--  Get the totals
SELECT 
	@Total_Wait = SUM([wait_time_ms]) + 1, 
	@Total_SignalWait = SUM([signal_wait_time_ms]) + 1 
 FROM 
	@Waits 
WHERE 
	RecordType = 'Result';

SET @Total_ResourceWait = (1 + @Total_Wait) - @Total_SignalWait ;

SET @Total_Requests = (SELECT SUM([waiting_tasks_count]) FROM @Waits where RecordType = 'Result') ;


INSERT INTO @Waits ([wait_type], [waiting_tasks_count], [wait_time_ms], [max_wait_time_ms], [signal_wait_time_ms], [capture_time], RecordType )
    SELECT '***Total***',@Total_Requests,@Total_Wait,0,@Total_SignalWait,@Last_Time, 'Total' ;


 --Display the results
If @SingleResultSet = 0
BEGIN
	SELECT CONVERT(varchar(50),@First_Time,120) AS [Start Time], CONVERT(varchar(50), @start_SystemStartdt,120) as Start_SystemStartTime
		,CONVERT(varchar(50),@Last_Time,120) AS [End Time], CONVERT(varchar(50), @end_SystemStartdt ,120) as End_SystemStartTime
		,CONVERT(varchar(50),@Last_Time - @First_Time,108) AS [Duration (hh:mm:ss)] ;

	SELECT 
		[wait_type] AS [Wait Type]
		,[waiting_tasks_count] AS [Requests]
		,[wait_time_ms] AS [Total Wait Time (ms)]
		,[max_wait_time_ms] AS [Max Wait Time (ms)]
		,CAST(100 * [wait_time_ms] / @Total_Wait as numeric(20,1)) AS [% Waits]
		,[wait_time_ms] - [signal_wait_time_ms] AS [Resource Waits (ms)]
		,CAST(100 * ([wait_time_ms] - [signal_wait_time_ms]) / @Total_ResourceWait as numeric(20,1)) AS [% Res Waits]
		,[signal_wait_time_ms] AS [Signal Waits (ms)]
		,CAST(100*[signal_wait_time_ms] / @Total_SignalWait as numeric(20,1)) AS [% Signal Waits]
	 FROM 
		@Waits 
	WHERE 
		RecordType in ('Total','Result')
	ORDER BY  
		RecordType desc,  
		[Total Wait Time (ms)] DESC, 
		[Wait Type] ;
END   
ELSE
BEGIN
	SELECT 
		[wait_type] AS [Wait Type]
		,[waiting_tasks_count] AS [Requests]
		,[wait_time_ms] AS [Total Wait Time (ms)]
		,[max_wait_time_ms] AS [Max Wait Time (ms)]
		,CAST(100 * [wait_time_ms] / @Total_Wait as numeric(20,1)) AS [% Waits]
		,[wait_time_ms] - [signal_wait_time_ms] AS [Resource Waits (ms)]
		,CAST(100 * ([wait_time_ms] - [signal_wait_time_ms]) / @Total_ResourceWait as numeric(20,1)) AS [% Res Waits]
		,[signal_wait_time_ms] AS [Signal Waits (ms)]
		,CAST(100*[signal_wait_time_ms] / @Total_SignalWait as numeric(20,1)) AS [% Signal Waits]
		,CONVERT(varchar(50),@First_Time,120) AS [StartTime]
		,CONVERT(varchar(50),@Last_Time,120) AS [EndTime]
	 FROM 
		@Waits 
	WHERE 
		RecordType in ('Total','Result')
	ORDER BY 
	RecordType desc,  
	[Total Wait Time (ms)] DESC, 
	[Wait Type] ;
End










RAISERROR ('	CREATING OR ALTERING PROCEDURE dbo.pWaitStats_ReportByHour',10,1) WITH NOWAIT;

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pWaitStats_ReportByHour]',10,1) WITH NOWAIT;
if object_id('dbo.pWaitStats_ReportByHour') is null exec('create procedure [dbo].[pWaitStats_ReportByHour] as select getdate() DT')
GO
  /******************************************************
DECLARE @StartDate		DATETIME
DECLARE @EndDate		DATETIME

SET @StartDate = '2011-09-29 8:00:00.000'
SET @EndDate  = '2011-09-29 12:00:00.000'

Execute dbo.pWaitStats_ReportByHour @StartDate, @EndDate
******************************************************/
alter procedure dbo.pWaitStats_ReportByHour(	
 @myStart			DATETIME,
 @myEnd				DATETIME,
 @hourIncrement		int = 1,
 @UseOLEDB			int = 0)
WITH ENCRYPTION 
 AS
BEGIN

DECLARE @start				DATETIME
DECLARE @end				DATETIME

DECLARE @First_Time			DATETIME
DECLARE	@Last_Time			DATETIME
DECLARE @SingleResultSet	BIT

SET @start = @myStart 
SET @end = @myEnd 

IF OBJECT_ID('tempdb..#Waits') IS NOT NULL
	DROP TABLE #Waits

CREATE TABLE #Waits (
	WaitType nvarchar(60) NULL, 
    Requests BIGINT NULL,
    TotalWaitTime_ms BIGINT NULL,
    MaxWaitTime_ms BIGINT NULL,
    [%Waits] money NULL,
    ResourceWaitTime_ms BIGINT NULL,
    [%ResWaits] money NULL,
    SingnalWaitTyime_ms BIGINT NULL,
    [%SingalWaits] money NULL,
    StartTime DATETIME not null,
    EndTime DATETIME not null)

CREATE CLUSTERED INDEX PK_atWaits on #Waits(StartTime,WaitType)    

IF OBJECT_ID('tempdb..#TmpWaits') IS NOT NULL
	DROP TABLE #TmpWaits

CREATE TABLE #TmpWaits(
	WaitType nvarchar(60) not null, 
    Requests BIGINT not null,
    TotalWaitTime_ms BIGINT not null,
    MaxWaitTime_ms BIGINT not null,
    [%Waits] money NOT NULL,
    ResourceWaitTime_ms BIGINT not null,
    [%ResWaits] money not null,
    SingnalWaitTyime_ms BIGINT not null,
    [%SingalWaits] money not null,
    StartTime DATETIME not null,
    EndTime DATETIME not null)    
   

     
    
WHILE @start < @end 
Begin
	--Set @First_Time = @start 	
	SET @Last_Time = DATEADD (HOUR,1,@start)

	SET @SingleResultSet	 = 1

	TRUNCATE TABLE #TmpWaits
	INSERT INTO #TmpWaits 
	EXECUTE dbo.[pWaitStats_Report] 
	   @start
	  ,@Last_Time
	  ,@UseOLEDB
	  ,@SingleResultSet    
	  
	INSERT INTO #Waits 
	SELECT TOP 5 * FROM #TmpWaits 
	WHERE WaitType not like  '%Total%'
	ORDER BY  [%Waits] DESC 
	
	INSERT INTO #Waits 
	SELECT top 1 'BREAK', 0,0,0,0,0,0,0,0, StartTime, EndTime  from #TmpWaits 
	
	
	SET @start = DATEADD(hour,@hourIncrement , @start)
End

SELECT 
	CONVERT(VARCHAR(25),StartTime,100) AS StartDate, 
	CONVERT(VARCHAR(25),EndTime,100) AS EndDate,
	WaitType,  
	Requests , 
	TotalWaitTime_ms , 
	MaxWaitTime_ms , 
	[%Waits] , 
	ResourceWaitTime_ms ,
	[%ResWaits] , 
	SingnalWaitTyime_ms , 
	[%SingalWaits]
 FROM  
	#Waits
ORDER BY 
	StartTime, 
	[%Waits] DESC
DROP TABLE #Waits 

END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pWaitStats_ReportByInterval]',10,1) WITH NOWAIT;
if object_id('dbo.pWaitStats_ReportByInterval') is null exec('create procedure [dbo].[pWaitStats_ReportByInterval] as select getdate() DT')
GO
  

alter procedure dbo.pWaitStats_ReportByInterval(	 
 @myStart			DATETIME,			--
 @myEnd				DATETIME,
 @rowsPerInterval	INT = 5,
 @UseOLEDB			INT = 0
 )
 WITH ENCRYPTION
 AS
BEGIN



IF (ISNULL(@rowsPerInterval,0) < 1 OR ISNULL(@rowsPerInterval,0) > 30)
BEGIN
	RAISERROR('@rowsPerInterval value must be between 1 and 30, suggested value is 5.',15,99) WITH NOWAIT;
	RETURN
END

DECLARE @start				datetime
DECLARE @end				datetime

DECLARE	@Last_Time			datetime
DECLARE @SingleResultSet	bit


SELECT  @start  = min([CaptureDate]) from dbo.WaitStatistics where [CaptureDate] >= @myStart


CREATE TABLE #Waits (
	WaitType nvarchar(60) NULL, 
    Requests bigint NULL,
    TotalWaitTime_ms bigint NULL,
    MaxWaitTime_ms bigint NULL,
    [%Waits] money NULL,
    ResourceWaitTime_ms bigint NULL,
    [%ResWaits] money NULL,
    SingnalWaitTyime_ms bigint NULL,
    [%SingalWaits] money NULL,
    StartTime datetime not null,
    EndTime datetime not null)

CREATE CLUSTERED INDEX PK_atWaits on #Waits(StartTime,WaitType)    

IF OBJECT_ID('tempdb..#mywaits') IS NOT NULL
	DROP TABLE #mywaits

CREATE TABLE #mywaits(
	WaitType					NVARCHAR(60) NOT NULL, 
    Requests					BIGINT NOT NULL,
    TotalWaitTime_ms			BIGINT NOT NULL,
    MaxWaitTime_ms				BIGINT NOT NULL,
    [%Waits]					MONEY NOT NULL,
    ResourceWaitTime_ms			BIGINT NOT NULL,
    [%ResWaits]					MONEY NOT NULL,
    SingnalWaitTyime_ms			BIGINT NOT NULL,
    [%SingalWaits]				MONEY NOT NULL,
    StartTime					DATETIME NOT NULL,
    EndTime						DATETIME NOT NULL)    
   

     
    
WHILE @start < @myEnd 
BEGIN
	SELECT  @Last_Time  = min([CaptureDate]) from dbo.WaitStatistics where [CaptureDate] > @start
	IF @Last_Time  IS NULL SET @Last_Time = @myEnd
	SET @SingleResultSet	 = 1

	TRUNCATE TABLE #mywaits
	INSERT INTO #mywaits 
	EXECUTE dbo.[pWaitStats_Report]  
	   @start
	  ,@Last_Time
	  ,@UseOLEDB
	  ,@SingleResultSet    
	  
	INSERT INTO #Waits 
	SELECT TOP (@rowsPerInterval) * FROM #mywaits 
	WHERE WaitType not like  '%Total%'
	ORDER BY  [%Waits] DESC 
	
	INSERT INTO #Waits 
	SELECT top 1 'BREAK', NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL, StartTime, EndTime  from #mywaits 
	
	
	SET @start = @Last_Time
END



SELECT 
	CONVERT(VARCHAR(25),StartTime,100) AS StartDate, 
	CONVERT(VARCHAR(25),EndTime,100) AS EndDate,
	WaitType,  
	[%Waits] ,  
	[%ResWaits] ,
	Requests , 
	TotalWaitTime_ms , 
	MaxWaitTime_ms , 
	ResourceWaitTime_ms ,
	SingnalWaitTyime_ms , 
	[%SingalWaits]
FROM 
	#Waits
ORDER BY 
	StartTime, 
	[%Waits] DESC

DROP TABLE #Waits 

END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pWhoIsActive_Purge]',10,1) WITH NOWAIT;
if object_id('dbo.pWhoIsActive_Purge') is null exec('create procedure [dbo].[pWhoIsActive_Purge] as select getdate() DT')
GO
  
alter procedure [dbo].[pWhoIsActive_Purge]
(
	@days					int = -14,
	@batchsize				int = 1000,
	@debug					bit = 1
)
WITH ENCRYPTION
AS
SET NOCOUNT ON
exec dbo.usp_UpdateVersionStatics
declare @recsaffected			int
declare @mindate				datetime
declare @start					datetime
declare @end					datetime
declare @msg					nvarchar(1000)
declare @errMsg					nvarchar(2048)
declare @errorCount				int 

SET @errorCount = 0
If @days > 0 
	set @days = @days * -1

set @mindate = DATEADD(day,@days,getdate())

set @recsaffected = 1
While @recsaffected > 0
Begin
	Begin try
		set @recsaffected = 0
		set @start = SYSDATETIME()
		Begin Tran
		delete 
			top (@batchsize) 
		  from	
			dbo.WhoisActive 
		 Where
			collection_time < @mindate

		set @recsaffected = @@ROWCOUNT
		Commit

		If @debug = 1
		begin
			set @end = SYSDATETIME()
			set @msg = N'Deleted ' + cast(@recsaffected as nvarchar(20)) + N' records from dbo.WhoisActive table in ' + 
					cast(DATEDIFF(ms,@start, @end) as nvarchar(20)) + N' milliseconds (' +
					cast(DATEDIFF(second,@start, @end) as nvarchar(20)) + N' seconds).'
			RAISERROR(@msg, 10,1) with nowait;
		end

	End Try
	Begin Catch
		--get the error information and print it out, we are not going to stop the process we will continue on
		Select @errMsg = N' Error number ' + cast(ERROR_NUMBER() as nvarchar(20)) + N' occurred on line ' + cast(ERROR_LINE() as nvarchar(10)) + N', with message: ' +
			substring(ERROR_MESSAGE(),1,1975) 
		
		RAISERROR(@errMsg, 15,1) with nowait;
		--Transaction is not committable and must be rolled back
		If (XACT_STATE()) = -1
		begin
			Set @msg = 	N'The transaction is in an uncommittable state. Rolling back transaction with ' +
				cast(@recsaffected as nvarchar(20)) + N' records.'
			RAISERROR(@msg, 10,1) with nowait;
			ROLLBACK TRANSACTION;
		end
		-- Transaction is committable, so just do it!
		Else If (XACT_STATE()) = 1
		begin
			Set @msg = 	N'The transaction is in a committable state. Committing transaction.'
			RAISERROR(@msg, 10,1) with nowait;
			COMMIT TRANSACTION;   
		end
		set @errorCount = @errorCount + 1
		If @errorCount >= 3
			break;
	End Catch
End



GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pXE_trace_deadlocks]',10,1) WITH NOWAIT;
if object_id('dbo.pXE_trace_deadlocks') is null exec('create procedure [dbo].[pXE_trace_deadlocks] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[pXE_trace_deadlocks]
*
*	Purpose: Creates extended events trace to capture deadlock information and disables trace flags 1204 and 1222 if trace created
*
*	Inputs:	None
*
*	Notes:	
*		1. Session name of extended event trace hard coded to be FD_deadlock_capture
*		2. Extended event trace created by call to dbo.pXE_trace_enable
*		3. trace flags disabled by updating config_fddba2 table and calling [master].[dbo].[usp_EnableTraceFlags3]
*		4. value column of config_fddba2 table expected to be comma separated list of trace flags. negative values are disabled
*		5. Assumes that trace flag numbers will never be 5 bytes long (> 9999) and end with either 1204 or 1222
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*	2018-01-05			Mike Zawadzki			Changed to use fSplit function instead of parsing
*
*********************************************************************************************************************/
alter procedure [dbo].[pXE_trace_deadlocks]
WITH ENCRYPTION 
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @rc int
	DECLARE @trace_flags_config varchar(3950)
	DECLARE @name varchar(50) = 'trace_flags'
	DECLARE @domain varchar(100) = 'fddba\usp_EnableTraceFlags3'

	EXEC @rc = [dbo].[pXE_trace_enable] @session_name = 'FD_deadlock_capture', @if_exists_recreate = 1

	IF @rc = 0
	BEGIN
		SELECT TOP 1 @trace_flags_config = [value] FROM dbo.config_fddba2 WHERE [name] = @name and [domain] = @domain

		IF @trace_flags_config IS NOT NULL
		BEGIN
			--disable trace flags 1204 in config
			IF EXISTS(SELECT 1 FROM dbo.fSplit2columns(@trace_flags_config, '=', ',') WHERE a = '1204' AND b = 1)
			BEGIN
				--@TODO=1 --potential bug if there is a trace flag such as 11204 in list 
				SET @trace_flags_config = REPLACE(@trace_flags_config, '1204=1,', '1204=0,')
			END
			ELSE
			BEGIN
				IF NOT EXISTS(SELECT 1 FROM dbo.fSplit2columns(@trace_flags_config, '=', ',') WHERE a = '1204')
				BEGIN
					SET @trace_flags_config = @trace_flags_config + '1204=0,'
				END
			END

			--disable trace flags 1222 in config
			IF EXISTS(SELECT 1 FROM dbo.fSplit2columns(@trace_flags_config, '=', ',') WHERE a = '1222' AND b = 1)
			BEGIN
				--@TODO=1 --potential bug if there is a trace flag such as 11222 in list 
				SET @trace_flags_config = REPLACE(@trace_flags_config, '1222=1,', '1222=0,')
			END
			ELSE
			BEGIN
				IF NOT EXISTS(SELECT 1 FROM dbo.fSplit2columns(@trace_flags_config, '=', ',') WHERE a = '1222')
				BEGIN
					SET @trace_flags_config = @trace_flags_config + '1222=0,'
				END
			END
			UPDATE dbo.config_fddba2 
				SET [value] = @trace_flags_config
				WHERE [name] = @name 
					AND [domain]= @domain
		END
		ELSE
		BEGIN
			SET @trace_flags_config = '1204-0,1222=0,'
			INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES (@name, @domain, @trace_flags_config)
		END


		IF EXISTS(SELECT 1 FROM master.sys.procedures WHERE [name] = 'usp_EnableTraceFlags3')
		BEGIN
			EXEC [master].[dbo].[usp_EnableTraceFlags3]
		END
	END
	ELSE
	BEGIN
		RAISERROR('pXE_trace_deadlocks: dbo.pXE_trace_enable stored procedure failed. Please see prior errors.', 11, 1)
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[pXE_trace_enable]',10,1) WITH NOWAIT;
if object_id('dbo.pXE_trace_enable') is null exec('create procedure [dbo].[pXE_trace_enable] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[pXE_trace_enable]
*
*	Purpose: Create or re-create extended events trace based on config_fddba table and/or override parameters.
*
*	Inputs:	
*		@session_name : REQUIRED - extended events session and resulting file name prefix
*		@events_override : OPTIONAL - list of events and actions and filter conditions to collect. Defaults to config_fddba2 row based on session name
*		@path_override : OPTIONAL - path of extended event file. Null for this value is default as it is then created in SQL instance errorlog directory
*		@with_override : OPTIONAL - list of WITH options for extended event session. Defaults to config_fddba2 row based on session name
*		@if_exists_recreate : OPTIONAL - allows re-create of extended events session already existing
*		@debug bit : OPTIONAL - allows "test" mode to see queries being generated without being run
*		@version_override : OPTIONAL - allows generation of SQL Server 2008 extended events queries. Implies @debug = 1
*
*	Return Code: 0 for success and non-zero for failure or execution skipped

*	Notes:	
*		1. This procedure gets default values from config_fddba2 table using name column matching @session_name parameter
*		2. The [value] column of config_fddba2 table should be XML format with the following layout :
*			<CONFIG>
*				<EVENT></EVENT>
*				<FILEPATH></FILEPATH>
*				<MAX_FILE_SIZE_MB></MAX_FILE_SIZE_MB>
*				<MAX_ROLLOVER_FILES></MAX_ROLLOVER_FILES>
*				<WITH></WITH>
*			</CONFIG>
*		3. This stored procedure checks @@MICROSOFTVERSION to confirm that either running 2012 or later or specific build ranges for 2008 and 2008 R2 
*			due to existing ALTER EVENT SESSION command fix.
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-03			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*	2018-01-04			Mike Zawadzki			Use SQL instance errorlog path for @file_path for SQL Server 2008 and 2008R2
*	2018-01-17			Mike Zawadzki			Added support to handle 25632 (memory) error on CREATE EVENT SESSION
*
*********************************************************************************************************************/
alter procedure [dbo].[pXE_trace_enable]
(
	@session_name sysname,
	@events_override varchar(8000) = NULL,
	@path_override sysname = NULL,
	@with_override  varchar(8000) = NULL,
	@if_exists_recreate bit = 0,
	@debug bit = 0,
	@version_override bit = 0 --if 1 then implies @debug = 1
)
WITH ENCRYPTION 
AS
BEGIN
	SET NOCOUNT ON
	SET ANSI_PADDING ON

	DECLARE @return_code int = 0 --success, != 0 -> failure
	DECLARE @config varchar(8000)
	DECLARE @configxml xml
	DECLARE @events varchar(8000)
	DECLARE @file_path sysname
	DECLARE @target varchar(8000)
	DECLARE @max_file_size_MB varchar(12)
	DECLARE @max_rollover_files varchar(5)
	DECLARE @with varchar(8000)
	DECLARE @with2 varchar(8000)
	DECLARE @crlf varchar(2)
	DECLARE @sql varchar(8000)
	DECLARE @sql_create varchar(8000)
	DECLARE @major_version tinyint 
	DECLARE @error_number int
	DECLARE @error_severity int
	DECLARE @error_message varchar(1000)
	DECLARE @msg varchar(400)
	DECLARE @errorlog_msg varchar(1000)
	DECLARE @pos1 int
	DECLARE @pos2 int
	DECLARE @does_path_exist bit = 1
	DECLARE @was_session_created bit = 1
	DECLARE @does_session_exist bit = 0
	DECLARE @memory int
	DECLARE @memory_str varchar(40)
	DECLARE @error25632 varchar(1000)


	CREATE TABLE #FileExists
	(
		DoesExist	SMALLINT,
		FileInDir	SMALLINT,
		DirExist	SMALLINT
	)

	CREATE TABLE #errorlog
	(
		logdate datetime,
		processinfo varchar(100),
		logtext varchar(8000),
	)

	IF @version_override = 1 OR @@MICROSOFTVERSION < 184551476
	BEGIN
		SET @major_version = 10
	END
	ELSE
	BEGIN
		SET @major_version = CONVERT(tinyint, SERVERPROPERTY('ProductMajorVersion'))
	END

	SET @crlf = CHAR(13) + CHAR(10)


	--check for supported version of SQL Server (2008 SP2 CU3+ or 2008 R2 SP2 CU8+ or 2012+)
	IF @@MICROSOFTVERSION BETWEEN 167776439 AND 167837695 --2008
		OR @@MICROSOFTVERSION BETWEEN 171053250 AND 171114495 --2008 R2
		OR @@MICROSOFTVERSION >= 184551476
		OR @version_override = 1
	BEGIN
		--check for session configuration data
		SELECT TOP 1 @config = [value] FROM dbo.config_fddba2 WHERE [name] = @session_name and [domain] = 'fddba\pXE_trace_enable'

		IF @config IS NOT NULL
		BEGIN
			--parse config values
			SET @configxml = CONVERT(xml, @config)

			SELECT	@events = T.c.value('EVENT[1]', 'varchar(8000)'),
					@file_path = T.c.value('FILEPATH[1]', 'varchar(8000)'),
					@max_file_size_MB = T.c.value('MAX_FILE_SIZE_MB[1]', 'varchar(12)'),
					@max_rollover_files = T.c.value('MAX_ROLLOVER_FILES[1]', 'varchar(5)'),
					@with = T.c.value('WITH[1]', 'varchar(8000)')
				FROM @configxml.nodes('/CONFIG') T(c)  
		END

		IF @max_file_size_MB IS NULL
			SET @max_file_size_MB = '256'
	
		IF @max_rollover_files IS NULL
			SET @max_rollover_files = '4'

		--validate parameters
		IF @events_override IS NOT NULL
		BEGIN
			SET @events = @events_override
		END

		IF @with_override IS NOT NULL
		BEGIN
			SET @with = @with_override
		END
				
		IF @path_override IS NOT NULL
		BEGIN
			SET @file_path = @path_override
		END

		IF @version_override = 1
		BEGIN
			SET @debug = 1
		END

		IF @major_version = 10 AND (@file_path IS NULL OR @file_path = '')
		BEGIN
			INSERT #errorlog
				EXECUTE master.sys.xp_readerrorlog 0, 1, N'Logging SQL Server messages in file'

			SELECT TOP 1 @errorlog_msg = logtext FROM #errorlog
			IF @errorlog_msg IS NOT NULL
			BEGIN
				--Logging SQL Server messages in file 'C:\Program Files\Microsoft SQL Server\MSSQL13.BINSORT\MSSQL\Log\ERRORLOG'.
				SET @pos1 = CHARINDEX('''', @errorlog_msg)
				SET @pos2 = CHARINDEX('ERRORLOG''', @errorlog_msg)

				IF @pos1 > 0 and @pos2 > @pos1
				BEGIN
					SET @file_path = SUBSTRING(@errorlog_msg, @pos1 + 1, @pos2 - @pos1 - 1)
				END
				ELSE
				BEGIN
					SET @file_path = ''
				END
			END
			ELSE
			BEGIN
				SET @file_path = ''
			END
		END

		IF @file_path IS NOT NULL AND @file_path != ''
		BEGIN
			-- Insert into the temp table
			INSERT INTO #FileExists
				EXECUTE master.dbo.xp_fileexist @file_path
			-- Query the temp table to see if the directory exists
			IF NOT EXISTS (SELECT DoesExist FROM #FileExists FE WHERE FE.FileInDir = 1)
			BEGIN
				SET @does_path_exist = 0
			END
		END

		IF @does_path_exist = 1
		BEGIN
			IF @major_version > 10 AND @version_override = 0
			BEGIN
				SET @target = 'package0.event_file(SET filename=N''' + ISNULL(@file_path,'') + @session_name +''', max_file_size=(' + @max_file_size_MB + '), max_rollover_files=(' + @max_rollover_files + '))'
			END
			ELSE
			BEGIN
				SET @target = 'package0.asynchronous_file_target(SET filename=N''' + ISNULL(@file_path,'') + @session_name +''', max_file_size=(' + @max_file_size_MB + '), max_rollover_files=(' + @max_rollover_files + '))'
			END
		
			--check if session already exists
			IF EXISTS (SELECT 1 FROM sys.server_event_sessions WHERE [name] = @session_name)
			BEGIN
				--use sys.dm_xe_sessions to check if running
				SET @does_session_exist = 1
			END
			
			IF @does_session_exist = 0 OR @if_exists_recreate = 1
			BEGIN 
				IF @does_session_exist = 1
				BEGIN
					--stop session
					IF EXISTS(SELECT 1 FROM sys.dm_xe_sessions WHERE [name] = @session_name)
					BEGIN
						SET @sql = 'ALTER EVENT SESSION [' + @session_name + '] ON SERVER STATE = STOP'
						IF @debug = 1
						BEGIN
							PRINT 'pXE_trace_enable SKIPPED QUERY:'
							PRINT @sql
						END
						ELSE
						BEGIN
							BEGIN TRY
								EXEC (@sql)
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @msg = 'pXE_trace_enable: ERROR STOPPING SESSION: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_severity)) + ', Message=' + @error_message
								SET @return_code = 8
								RAISERROR(@msg, 11, @return_code)
								PRINT 'pXE_trace_enable STOP QUERY:'
								PRINT @sql
							END CATCH
						END
					END

					--delete session

					IF @error_number IS NULL OR @debug = 1
					BEGIN
						SET @sql = 'DROP EVENT SESSION [' + @session_name + '] ON SERVER'
						IF @debug = 1
						BEGIN
							PRINT 'pXE_trace_enable SKIPPED QUERY:'
							PRINT @sql
						END
						ELSE
						BEGIN
							BEGIN TRY
								EXEC (@sql)
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @msg = 'pXE_trace_enable: ERROR DELETING SESSION: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_severity)) + ', Message=' + @error_message
								SET @return_code = 7
								RAISERROR(@msg, 11, @return_code)
								PRINT 'pXE_trace_enable DROP QUERY:'
								PRINT @sql
							END CATCH
						END
					END
				END

				--build adhoc sql stmt
				SET @sql = 'CREATE EVENT SESSION [' + @session_name + '] ON SERVER' + @crlf
				SET @sql = @sql + 'ADD EVENT ' + ISNULL(@events, '(null)') + @crlf
				SET @sql = @sql + 'ADD TARGET ' + ISNULL(@target, '(null)') + @crlf
				SET @sql = @sql + 'WITH (' + ISNULL(@with, '(null)') + ')'

				IF @events IS NOT NULL AND @target IS NOT NULL AND @with IS NOT NULL AND (@error_number IS NULL OR @debug = 1)
				BEGIN
					IF @debug = 1
					BEGIN
						PRINT 'pXE_trace_enable SKIPPED QUERY:'
						PRINT @sql
					END
					ELSE
					BEGIN
						--create session
						SET @error_number = 25632
						WHILE @error_number = 25632 AND (@memory IS NULL OR @memory < 65)
						BEGIN
							BEGIN TRY
								EXEC (@sql)
								SET @error_number = NULL
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								IF @error_number != 25632
								BEGIN
									SET @msg = 'pXE_trace_enable: ERROR creating session: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_severity)) + ', Message=' + @error_message
									SET @return_code = 6
									RAISERROR(@msg, 11, @return_code)
									PRINT 'pXE_trace_enable Create Query:'
									PRINT @sql
								END
							END CATCH

							IF @error_number = 25632
							BEGIN
								IF @memory IS NULL
								BEGIN
									PRINT @error_message
									SELECT @error25632 = [text] FROM sys.messages WHERE message_id = 25632 AND language_id = 1033

									SET @pos1 = CHARINDEX('%d', @error25632)
									IF @pos1 > 0
									BEGIN
										SET @pos2 = CHARINDEX(' ', @error_message, @pos1)
										IF @pos2 > 0
										BEGIN
											SET @memory_str = SUBSTRING(@error_message, @pos1, @pos2 - @pos1)
											IF ISNUMERIC(@memory_str) = 1
											BEGIN
												--set to rounded MB amount larger than size in error
												SET @memory = CEILING(CONVERT(int, @memory_str)/1024./1024.)
											END
										END
									END
									
									IF @memory IS NULL
									BEGIN
										 --default is 4MB so start with 5MB
										SET @memory = 5
									END
								END
								ELSE
								BEGIN
									--increment previous tried size by 1MB
									SET @memory = @memory + 1
								END

								SET @with2 = @with + ', MAX_MEMORY=' + LTRIM(STR(@memory)) + 'MB'

								SET @sql = 'CREATE EVENT SESSION [' + @session_name + '] ON SERVER' + @crlf
								SET @sql = @sql + 'ADD EVENT ' + ISNULL(@events, '(null)') + @crlf
								SET @sql = @sql + 'ADD TARGET ' + ISNULL(@target, '(null)') + @crlf
								SET @sql = @sql + 'WITH (' + ISNULL(@with2, '(null)') + ')'
							END
						END
					END

					IF @memory IS NOT NULL
					BEGIN
						IF @error_number IS NULL
							PRINT 'Event Session successfully created with MAX_MEMORY set to ' + LTRIM(STR(@memory)) + 'MB.'
						ELSE
						BEGIN
							SET @msg = 'pXE_trace_enable: Event Session FAILED to create with MAX_MEMORY set to ' + LTRIM(STR(@memory)) + 'MB.'
							RAISERROR(@msg, 11, @return_code)
						END
					END

					--start session
					IF @error_number IS NULL OR @debug = 1
					BEGIN
						SET @sql_create = @sql
						SET @sql = 'ALTER EVENT SESSION [' + @session_name + '] ON SERVER STATE = START'
						IF @debug = 1
						BEGIN
							PRINT 'pXE_trace_enable SKIPPED QUERY:'
							PRINT @sql
						END
						ELSE
						BEGIN
							BEGIN TRY
								EXEC (@sql)
							END TRY
							BEGIN CATCH
								SET @error_number = ERROR_NUMBER()
								SET @error_severity = ERROR_SEVERITY()
								SET @error_message = ERROR_MESSAGE()
								SET @msg = 'pXE_trace_enable: ERROR STARTING SESSION: Error=' + LTRIM(STR(@error_number)) + ', Severity=' + LTRIM(STR(@error_severity)) + ', Message=' + @error_message
								SET @return_code = 5
								RAISERROR(@msg, 11, @return_code)
								PRINT 'pXE_trace_enable CREATE QUERY:'
								PRINT @sql_create
								PRINT 'pXE_trace_enable START QUERY:'
								PRINT @sql
							END CATCH
						END
					END
				END
				ELSE
				BEGIN
					SET @return_code = 4
					RAISERROR('pXE_trace_enable: Invalid CREATE EVENT SESSION query:', 11, @return_code)
					PRINT 'pXE_trace_enable QUERY:'
					PRINT @sql
				END
			END
			ELSE
			BEGIN
				SET @return_code = 3
				SET @msg = 'pXE_trace_enable: Event Session [' + @session_name + '] already exists: Please stop and delete before running again.'
				RAISERROR(@msg, 11, @return_code)
			END
		END
		ELSE
		BEGIN
			SET @return_code = 2
			SET @msg = 'pXE_trace_enable: Directory does not exist: ' + ISNULL(@file_path, '(null)')
			RAISERROR(@msg, 11, @return_code)
		END
	END
	ELSE
	BEGIN
		SET @return_code = 1
		RAISERROR ('pXE_trace_enable: SQL Server needs MSKB2511963 installed before using this!', 11, @return_code)
	END

	IF @debug = 1 and @return_code = 0
	BEGIN
		SET @return_code = -1
	END

	RETURN @return_code
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[ring_buffer_capture]',10,1) WITH NOWAIT;
if object_id('dbo.ring_buffer_capture') is null exec('create procedure [dbo].[ring_buffer_capture] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[ring_buffer_capture]
*
*	Purpose: Captures ring buffer information and stores into tables
*
*	Inputs:	None
*
*	Notes:	
*		1. value column of config_fddba2 table expected to be comma separated list of ring buffer collections to execute since not all may be needed
*		2. designed to run on SQL Server 2008 and later builds
*
*	TODO: Create job to run sproc with likely interval of every 15 minutes on 14 minute offset. This could cause gaps due to timing of service restarts
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-01-25			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/
alter procedure dbo.ring_buffer_capture
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @cpu bit
	DECLARE @connectivity bit
	DECLARE @security_error bit

	DECLARE @lastmsticks bigint = 0
	DECLARE @msticks bigint
	DECLARE @mstickstime datetime
	DECLARE @lastdt datetimeoffset(3)
	DECLARE @lastreboot datetimeoffset(3)
	DECLARE @vcparameters varchar(3950)

	SELECT @lastreboot = last_startup_time FROM sys.dm_server_services WHERE servicename LIKE 'SQL Server (%'

	IF OBJECT_ID('dbo.config_fddba2','U') IS NOT NULL
	BEGIN
		SELECT @vcparameters = [value] FROM dbo.config_fddba2 WHERE [name] = 'ring_buffer_capture' AND [domain] = 'fddba\ringbuffer\collect'
		SELECT @cpu = b FROM dbo.fSplit2columns(@vcparameters, '=', ',') WHERE a = 'cpu'
		SELECT @connectivity = b FROM dbo.fSplit2columns(@vcparameters, '=', ',') WHERE a = 'connectivity'
		SELECT @security_error = b FROM dbo.fSplit2columns(@vcparameters, '=', ',') WHERE a = 'security_error'
	END

	IF @cpu = 1
	BEGIN
		SELECT @lastdt = MAX(eventtime) FROM dbo.sched_mon_cpu_util

		IF @lastreboot < @lastdt
		BEGIN
			SELECT @lastmsticks = ts FROM dbo.sched_mon_cpu_util WHERE eventtime = @lastdt
		END

		IF @lastdt IS NULL
			SET @lastdt = '1900-01-01'

		IF @lastmsticks IS NULL
			SET @lastmsticks = 0

		SELECT @mstickstime = GETUTCDATE(), @msticks = ms_ticks FROM sys.dm_os_sys_info
 
		INSERT dbo.sched_mon_cpu_util
			SELECT [timestamp], 
					TODATETIMEOFFSET(CONVERT (varchar, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime), 126), '+00:00'), 
					record.value('(Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') AS 'system_idle_cpu',
					record.value('(Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int') AS 'sql_cpu_utilization',
					record.value('(Record/SchedulerMonitorEvent/SystemHealth/UserModeTime)[1]', 'bigint') AS 'usermodetime',
					record.value('(Record/SchedulerMonitorEvent/SystemHealth/KernelModeTime)[1]', 'bigint') AS 'kernelmodetime'
				FROM 
				(
					SELECT timestamp, CONVERT (xml, record) AS 'record' 
						FROM sys.dm_os_ring_buffers 
						WHERE ring_buffer_type = 'RING_BUFFER_SCHEDULER_MONITOR'
							AND record LIKE '%<SystemHealth>%'
							and [timestamp] > @lastmsticks
				) AS t
				WHERE TODATETIMEOFFSET(CONVERT (varchar, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime), 126), '+00:00') > @lastdt
	END

	IF @connectivity = 1
	BEGIN
		SET @lastmsticks = NULL
		SELECT @lastdt = MAX(eventtime) FROM dbo.ring_buffer_connectivity

		IF @lastreboot < @lastdt
		BEGIN
			SELECT @lastmsticks = ts FROM dbo.ring_buffer_connectivity WHERE eventtime = @lastdt
		END

		IF @lastdt IS NULL
			SET @lastdt = '1900-01-01'

		IF @lastmsticks IS NULL
			SET @lastmsticks = 0

		SELECT @mstickstime = GETUTCDATE(), @msticks = ms_ticks FROM sys.dm_os_sys_info
 
		INSERT [dbo].[ring_buffer_connectivity]
			SELECT	[timestamp],
					TODATETIMEOFFSET(CONVERT (varchar, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime), 126), '+00:00'), 
					record.value('(Record/ConnectivityTraceRecord/RecordType)[1]', 'varchar(20)') AS 'RecordType'

					, record.value('(Record/ConnectivityTraceRecord/RecordSource)[1]', 'varchar(20)') AS 'RecordSource' --Error/ConnectionClose
					, record.value('(Record/ConnectivityTraceRecord/IsClient)[1]', 'int') AS 'IsClient'
					, record.value('(Record/ConnectivityTraceRecord/Spid)[1]', 'int') AS 'Spid'
					, record.value('(Record/ConnectivityTraceRecord/OSError)[1]', 'int') AS 'OSError' --Error
					, record.value('(Record/ConnectivityTraceRecord/SniConsumerError)[1]', 'int') AS 'SniConsumerError' --Error/LoginTimers
					, record.value('(Record/ConnectivityTraceRecord/SniProvider)[1]', 'int') AS 'SniProvider'
					, record.value('(Record/ConnectivityTraceRecord/State)[1]', 'int') AS 'State' --Error/LoginTimers
					, record.value('(Record/ConnectivityTraceRecord/RemoteHost)[1]', 'varchar(50)') AS 'RemoteHost'
					, record.value('(Record/ConnectivityTraceRecord/RemotePort)[1]', 'int') AS 'RemotePort'
					, record.value('(Record/ConnectivityTraceRecord/LocalPort)[1]', 'int') AS 'LocalPort'
					--, record.value('(Record/ConnectivityTraceRecord/RecordTime)[1]', 'datetime') AS 'RecordTime'
					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/TdsBuffersInformation/TdsInputBufferError)[1]', 'int') IS NOT NULL
						THEN record.value('(Record/ConnectivityTraceRecord/TdsBuffersInformation/TdsInputBufferError)[1]', 'int') --Error/ConnectionClose
						ELSE record.value('(Record/ConnectivityTraceRecord/TdsBufInfo/InputBufError)[1]', 'int')  --LoginTimers
						END AS 'InputBufferError'
					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/TdsBuffersInformation/TdsOutputBufferError)[1]', 'int')  IS NOT NULL
						THEN record.value('(Record/ConnectivityTraceRecord/TdsBuffersInformation/TdsOutputBufferError)[1]', 'int')  --Error/ConnectionClose
						ELSE record.value('(Record/ConnectivityTraceRecord/TdsBufInfo/OutputBufError)[1]', 'int') --LoginTimers	
						END AS 'OutputBufferError'
					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/TdsBuffersInformation/TdsInputBufferBytes)[1]', 'int') IS NOT NULL
						THEN record.value('(Record/ConnectivityTraceRecord/TdsBuffersInformation/TdsInputBufferBytes)[1]', 'int') --Error/ConnectionClose
						ELSE record.value('(Record/ConnectivityTraceRecord/TdsBufInfo/InputBufBytes)[1]', 'int')  --LoginTimers
						END AS 'InputBufferBytes'

					, record.value('(Record/ConnectivityTraceRecord/TdsDisconnectFlags/PhysicalConnectionIsKilled)[1]', 'int') AS 'PhysicalConnectionIsKilled' --Error/ConnectionClose
					, record.value('(Record/ConnectivityTraceRecord/TdsDisconnectFlags/DisconnectDueToReadError)[1]', 'int') AS 'DisconnectDueToReadError' --Error/ConnectionClose
					, record.value('(Record/ConnectivityTraceRecord/TdsDisconnectFlags/NetworkErrorFoundInInputStream)[1]', 'int') AS 'NetworkErrorFoundInInputStream' --Error/ConnectionClose
					, record.value('(Record/ConnectivityTraceRecord/TdsDisconnectFlags/ErrorFoundBeforeLogin)[1]', 'int') AS 'ErrorFoundBeforeLogin' --Error/ConnectionClose
					, record.value('(Record/ConnectivityTraceRecord/TdsDisconnectFlags/SessionIsKilled)[1]', 'int') AS 'SessionIsKilled' --Error/ConnectionClose
					, record.value('(Record/ConnectivityTraceRecord/TdsDisconnectFlags/RoutingCompleted)[1]', 'int') AS 'RoutingCompleted' --Error/ConnectionClose
					, record.value('(Record/ConnectivityTraceRecord/TdsDisconnectFlags/NormalDisconnect)[1]', 'int') AS 'NormalDisconnect' --Error/ConnectionClose
					, record.value('(Record/ConnectivityTraceRecord/TdsDisconnectFlags/NormalLogout)[1]', 'varchar(3)') AS 'NormalLogout' --ConnectionClose, vc3 as sometimes is n\a
					--LoginTimers from this point on:
					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/TotalTime)[1]', 'int') IS NOT NULL --naming changed in 2012
						THEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/TotalTime)[1]', 'int')
						ELSE record.value('(Record/ConnectivityTraceRecord/LoginTimers/TotalLoginTimeInMilliseconds)[1]', 'int')
						END AS 'TotalTime'
					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/EnqueueTime)[1]', 'int') IS NOT NULL --naming changed in 2012
						THEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/EnqueueTime)[1]', 'int')
						ELSE record.value('(Record/ConnectivityTraceRecord/LoginTimers/LoginTaskEnqueuedInMilliseconds)[1]', 'int')
						END AS 'EnqueueTime'
					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/NetWritesTime)[1]', 'int') IS NOT NULL --naming changed in 2012
						THEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/NetWritesTime)[1]', 'int')
						ELSE record.value('(Record/ConnectivityTraceRecord/LoginTimers/NetworkWritesInMilliseconds)[1]', 'int')
						END AS 'NetWritesTime'
					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/NetReadsTime)[1]', 'int') IS NOT NULL --naming changed in 2012
						THEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/NetReadsTime)[1]', 'int')
						ELSE record.value('(Record/ConnectivityTraceRecord/LoginTimers/NetworkReadsInMilliseconds)[1]', 'int')
						END AS 'NetReadsTime'
					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/TriggerAndResGovTime)[1]', 'int') IS NOT NULL --naming changed in 2012
						THEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/TriggerAndResGovTime)[1]', 'int') 
						ELSE record.value('(Record/ConnectivityTraceRecord/LoginTimers/LoginTriggerAndResourceGovernorProcessingInMilliseconds)[1]', 'int')
						END AS 'TriggerAndResGovTime'

					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Ssl/TotalTime)[1]', 'int') IS NOT NULL --naming changed in 2012
						THEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Ssl/TotalTime)[1]', 'int') 
						ELSE record.value('(Record/ConnectivityTraceRecord/LoginTimers/SslProcessingInMilliseconds)[1]', 'int')
						END AS 'SslTotalTime'
					, record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Ssl/EnqueueTime)[1]', 'int') AS 'SslEnqueueTime'
					, record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Ssl/NetReadsTime)[1]', 'int') AS 'SslNetReadsTime'
					, record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Ssl/NetWritesTime)[1]', 'int') AS 'SslNetWritesTime'
					, record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Ssl/SecAPITime)[1]', 'int') AS 'SslSecAPITime'
					, CASE WHEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Sspi/TotalTime)[1]', 'int') IS NOT NULL  --naming changed in 2012
						THEN record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Sspi/TotalTime)[1]', 'int') 
						ELSE record.value('(Record/ConnectivityTraceRecord/LoginTimers/SspiProcessingInMilliseconds)[1]', 'int')
						END AS 'SspiTotalTime'
					, record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Sspi/EnqueueTime)[1]', 'int') AS 'SspiEnqueueTime'
					, record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Sspi/NetReadsTime)[1]', 'int') AS 'SspiNetReadsTime'
					, record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Sspi/NetWritesTime)[1]', 'int') AS 'SspiNetWritesTime'
					, record.value('(Record/ConnectivityTraceRecord/LoginTimersInMilliseconds/Sspi/SecAPITime)[1]', 'int') AS 'SspiSecAPITime'

				FROM 
				(
					SELECT
							[timestamp],
							CONVERT (xml, record) AS [record] 
						FROM sys.dm_os_ring_buffers 
						WHERE ring_buffer_type = 'RING_BUFFER_CONNECTIVITY'
							AND [timestamp] > @lastmsticks
				) as c
				WHERE TODATETIMEOFFSET(CONVERT (varchar, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime), 126), '+00:00') > @lastdt
	END

	IF @security_error = 1
	BEGIN
		SET @lastmsticks = NULL
		SELECT @lastdt = MAX(eventtime) FROM dbo.ring_buffer_security_error

		IF @lastreboot < @lastdt
		BEGIN
			SELECT @lastmsticks = ts FROM dbo.ring_buffer_security_error WHERE eventtime = @lastdt
		END

		IF @lastdt IS NULL
			SET @lastdt = '1900-01-01'

		IF @lastmsticks IS NULL
			SET @lastmsticks = 0

		SELECT @mstickstime = GETUTCDATE(), @msticks = ms_ticks FROM sys.dm_os_sys_info
 
		INSERT [dbo].[ring_buffer_security_error]
			SELECT [timestamp], 
					TODATETIMEOFFSET(CONVERT (varchar, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime), 126), '+00:00') 
					, record.value('(Record/Error/SPID)[1]', 'int') AS 'SPID'
					, record.value('(Record/Error/ErrorCode)[1]', 'varchar(10)') AS 'ErrorCode'
					, record.value('(Record/Error/APIName)[1]', 'varchar(100)') AS 'APIName'
					, record.value('(Record/Error/CallingAPIName)[1]', 'varchar(100)') AS 'CallingAPIName'
				FROM 
				(
					SELECT
							[timestamp],
							CONVERT (xml, record) AS [record] 
						FROM sys.dm_os_ring_buffers 
						WHERE ring_buffer_type = 'RING_BUFFER_SECURITY_ERROR'
							AND [timestamp] > @lastmsticks
				) as c
				WHERE TODATETIMEOFFSET(CONVERT (varchar, DATEADD (ms, -1 * (@msticks - [timestamp]),@mstickstime), 126), '+00:00') > @lastdt

	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].sp_help_revlogin',10,1) WITH NOWAIT;
if object_id('dbo.sp_help_revlogin') is null exec('create procedure [dbo].sp_help_revlogin as select getdate() DT')
GO
  

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


ALTER PROCEDURE [dbo].[sp_help_revlogin] @login_name sysname = NULL AS
DECLARE @name sysname
DECLARE @TYPE VARCHAR (1)
DECLARE @hasaccess INT
DECLARE @denylogin INT
DECLARE @is_disabled INT
DECLARE @PWD_varbinary  varbinary (256)
DECLARE @PWD_string  VARCHAR (514)
DECLARE @SID_varbinary varbinary (85)
DECLARE @SID_string VARCHAR (514)
DECLARE @tmpstr  VARCHAR (1024)
DECLARE @is_policy_checked VARCHAR (3)
DECLARE @is_expiration_checked VARCHAR (3)

DECLARE @defaultdb sysname
 
IF (@login_name IS NULL)
  DECLARE login_curs CURSOR FOR

      SELECT p.sid, p.name, p.TYPE, p.is_disabled, p.default_database_name, l.hasaccess, l.denylogin FROM 
sys.server_principals p LEFT JOIN sys.syslogins l
      ON ( l.name = p.name ) WHERE p.TYPE IN ( 'S', 'G', 'U' ) AND p.name <> 'sa'
ELSE
  DECLARE login_curs CURSOR FOR


      SELECT p.sid, p.name, p.TYPE, p.is_disabled, p.default_database_name, l.hasaccess, l.denylogin FROM 
sys.server_principals p LEFT JOIN sys.syslogins l
      ON ( l.name = p.name ) WHERE p.TYPE IN ( 'S', 'G', 'U' ) AND p.name = @login_name
OPEN login_curs

FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @TYPE, @is_disabled, @defaultdb, @hasaccess, @denylogin
IF (@@fetch_status = -1)
BEGIN
  PRINT 'No login(s) found.'
  CLOSE login_curs
  DEALLOCATE login_curs
  RETURN -1
END
SET @tmpstr = '/* sp_help_revlogin script '
PRINT @tmpstr
SET @tmpstr = '** Generated ' + CONVERT (VARCHAR, GETDATE()) + ' on ' + @@SERVERNAME + ' */'
PRINT @tmpstr
PRINT ''
WHILE (@@fetch_status <> -1)
BEGIN
  IF (@@fetch_status <> -2)
  BEGIN
    PRINT ''
    SET @tmpstr = '-- Login: ' + @name
    PRINT @tmpstr
    IF (@TYPE IN ( 'G', 'U'))
    BEGIN -- NT authenticated account/group

      SET @tmpstr = 'CREATE LOGIN ' + QUOTENAME( @name ) + ' FROM WINDOWS WITH DEFAULT_DATABASE = [' + @defaultdb + ']'
    END
    ELSE BEGIN -- SQL Server authentication
        -- obtain password and sid
            SET @PWD_varbinary = CAST( LOGINPROPERTY( @name, 'PasswordHash' ) AS varbinary (256) )
        EXEC sp_hexadecimal @PWD_varbinary, @PWD_string OUT
        EXEC sp_hexadecimal @SID_varbinary,@SID_string OUT
 
        -- obtain password policy state
        SELECT @is_policy_checked = CASE is_policy_checked WHEN 1 THEN 'ON' WHEN 0 THEN 'OFF' ELSE NULL END FROM sys.sql_logins WHERE name = @name
        SELECT @is_expiration_checked = CASE is_expiration_checked WHEN 1 THEN 'ON' WHEN 0 THEN 'OFF' ELSE NULL END FROM sys.sql_logins WHERE name = @name
 
            SET @tmpstr = 'CREATE LOGIN ' + QUOTENAME( @name ) + ' WITH PASSWORD = ' + @PWD_string + ' HASHED, SID = ' + @SID_string + ', DEFAULT_DATABASE = [' + @defaultdb + ']'

        IF ( @is_policy_checked IS NOT NULL )
        BEGIN
          SET @tmpstr = @tmpstr + ', CHECK_POLICY = ' + @is_policy_checked
        END
        IF ( @is_expiration_checked IS NOT NULL )
        BEGIN
          SET @tmpstr = @tmpstr + ', CHECK_EXPIRATION = ' + @is_expiration_checked
        END
    END
    IF (@denylogin = 1)
    BEGIN -- login is denied access
      SET @tmpstr = @tmpstr + '; DENY CONNECT SQL TO ' + QUOTENAME( @name )
    END
    ELSE IF (@hasaccess = 0)
    BEGIN -- login exists but does not have access
      SET @tmpstr = @tmpstr + '; REVOKE CONNECT SQL TO ' + QUOTENAME( @name )
    END
    IF (@is_disabled = 1)
    BEGIN -- login is disabled
      SET @tmpstr = @tmpstr + '; ALTER LOGIN ' + QUOTENAME( @name ) + ' DISABLE'
    END
    PRINT @tmpstr
  END

  FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @TYPE, @is_disabled, @defaultdb, @hasaccess, @denylogin
   END
CLOSE login_curs
DEALLOCATE login_curs
RETURN 0
go
exec sys.sp_MS_marksystemobject 'dbo.sp_help_revlogin';
go


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[sp_helpindex2]',10,1) WITH NOWAIT;
if object_id('dbo.sp_helpindex2') is null exec('create procedure [dbo].[sp_helpindex2] as select getdate() DT')
GO
  
alter procedure [dbo].[sp_helpindex2]
	@objname NVARCHAR(776)		-- the table to check for indexes
AS

-- April 2008: Updated to add included columns to the output. 

-- August 2008: Fixed a bug (missing begin/end block) AND I found
-- a few other issues that people hadn't noticed (yikes!)!

-- See Kimberly's blog for updates and/or additional information
-- http://www.SQLskills.com/blogs/Kimberly

	-- PRELIM
	SET nocount on

	DECLARE @objid INT,			-- the object id of the table
			@indid smallint,	-- the index id of an index
			@groupid INT,  		-- the filegroup id of an index
			@indname sysname,
			@groupname sysname,
			@status INT,
			@keys NVARCHAR(2126),	--Length (16*max_identifierLength)+(15*2)+(16*3)
			@inc_columns	NVARCHAR(max),
			@inc_Count		smallint,
			@loop_inc_Count		smallint,
			@dbname	sysname,
			@ignore_dup_key	bit,
			@is_unique		bit,
			@is_hypothetical	bit,
			@is_primary_key	bit,
			@is_unique_key 	bit,
			@auto_created	bit,
			@no_recompute	bit,
			@filter_definition	NVARCHAR(max)

	-- Check to see that the object names are local to the current database.
	SELECT @dbname = parsename(@objname,3)
	IF @dbname is null
		SELECT @dbname = db_name()
	ELSE IF @dbname <> db_name()
		begin
			raiserror(15250,-1,-1)
			RETURN (1)
		end

	-- Check to see the the table exists and initialize @objid.
	SELECT @objid = object_id(@objname)
	IF @objid is NULL
	begin
		raiserror(15009,-1,-1,@objname,@dbname)
		RETURN (1)
	end

	-- OPEN CURSOR OVER INDEXES (skip stats: bug shiloh_51196)
	DECLARE ms_crs_ind cursor local static for
		SELECT i.index_id, i.data_space_id, i.name,
			i.ignore_dup_key, i.is_unique, i.is_hypothetical, i.is_primary_key, i.is_unique_constraint,
			s.auto_created, s.no_recompute, i.filter_definition
		FROM sys.indexes i join sys.stats s
			on i.object_id = s.object_id and i.index_id = s.stats_id
		WHERE i.object_id = @objid
	open ms_crs_ind
	fetch ms_crs_ind INTO @indid, @groupid, @indname, @ignore_dup_key, @is_unique, @is_hypothetical,
			@is_primary_key, @is_unique_key, @auto_created, @no_recompute, @filter_definition

	-- IF NO INDEX, QUIT
	IF @@fetch_status < 0
	begin
		deallocate ms_crs_ind
		raiserror(15472,-1,-1,@objname) -- Object does not have any indexes.
		RETURN (0)
	end

	-- create temp tables
	CREATE TABLE #spindtab
	(
		index_name			sysname	collate database_default NOT NULL,
		index_id			INT,
		ignore_dup_key		bit,
		is_unique			bit,
		is_hypothetical		bit,
		is_primary_key		bit,
		is_unique_key		bit,
		auto_created		bit,
		no_recompute		bit,
		groupname			sysname collate database_default NULL,
		index_keys			NVARCHAR(2126)	collate database_default NOT NULL, -- see @keys above for length descr
		filter_definition	NVARCHAR(max),
		inc_Count			smallint,
		inc_columns			NVARCHAR(max)
	)

	CREATE TABLE #IncludedColumns
	(	RowNumber	smallint,
		[Name]	NVARCHAR(128)
	)

	-- Now check out each index, figure out its TYPE and keys and
	--	save the info in a temporary table that we'll print out at the end.
	WHILE @@fetch_status >= 0
	begin
		-- First we'll figure out what the keys are.
		DECLARE @i INT, @thiskey NVARCHAR(131) -- 128+3

		SELECT @keys = index_col(@objname, @indid, 1), @i = 2
		IF (indexkey_property(@objid, @indid, 1, 'isdescending') = 1)
			SELECT @keys = @keys  + '(-)'

		SELECT @thiskey = index_col(@objname, @indid, @i)
		IF ((@thiskey is not null) and (indexkey_property(@objid, @indid, @i, 'isdescending') = 1))
			SELECT @thiskey = @thiskey + '(-)'

		WHILE (@thiskey is not null )
		begin
			SELECT @keys = @keys + ', ' + @thiskey, @i = @i + 1
			SELECT @thiskey = index_col(@objname, @indid, @i)
			IF ((@thiskey is not null) and (indexkey_property(@objid, @indid, @i, 'isdescending') = 1))
				SELECT @thiskey = @thiskey + '(-)'
		end

		-- Second, we'll figure out what the included columns are.
		SELECT @inc_Count = count(*)
		FROM
		sys.tables AS tbl
		INNER JOIN sys.indexes AS si 
			ON (si.index_id > 0 
				and si.is_hypothetical = 0) 
				AND (si.object_id=tbl.object_id)
		INNER JOIN sys.index_columns AS ic 
			ON (ic.column_id > 0 
				and (ic.key_ordinal > 0 or ic.partition_ordinal = 0 or ic.is_included_column != 0)) 
				AND (ic.index_id=CAST(si.index_id AS INT) AND ic.object_id=si.object_id)
		INNER JOIN sys.columns AS clmns 
			ON clmns.object_id = ic.object_id 
			and clmns.column_id = ic.column_id
		WHERE ic.is_included_column = 1 and
			(si.index_id = @indid) and 
			(tbl.object_id= @objid)

		IF @inc_Count > 0
		BEGIN
			DELETE FROM #IncludedColumns
			INSERT #IncludedColumns
				SELECT ROW_NUMBER() OVER (ORDER BY clmns.column_id) 
				, clmns.name 
			FROM
			sys.tables AS tbl
			INNER JOIN sys.indexes AS si 
				ON (si.index_id > 0 
					and si.is_hypothetical = 0) 
					AND (si.object_id=tbl.object_id)
			INNER JOIN sys.index_columns AS ic 
				ON (ic.column_id > 0 
					and (ic.key_ordinal > 0 or ic.partition_ordinal = 0 or ic.is_included_column != 0)) 
					AND (ic.index_id=CAST(si.index_id AS INT) AND ic.object_id=si.object_id)
			INNER JOIN sys.columns AS clmns 
				ON clmns.object_id = ic.object_id 
				and clmns.column_id = ic.column_id
			WHERE ic.is_included_column = 1 and
				(si.index_id = @indid) and 
				(tbl.object_id= @objid)
			
			SELECT @inc_columns = [Name] FROM #IncludedColumns WHERE RowNumber = 1

			SET @loop_inc_Count = 1

			WHILE @loop_inc_Count < @inc_Count
			BEGIN
				SELECT @inc_columns = @inc_columns + ', ' + [Name] 
					FROM #IncludedColumns WHERE RowNumber = @loop_inc_Count + 1
				SET @loop_inc_Count = @loop_inc_Count + 1
			END
		END
	
		SELECT @groupname = null
		SELECT @groupname = name FROM sys.data_spaces WHERE data_space_id = @groupid

		-- INSERT ROW FOR INDEX
		INSERT INTO #spindtab VALUES (@indname, @indid, @ignore_dup_key, @is_unique, @is_hypothetical,
			@is_primary_key, @is_unique_key, @auto_created, @no_recompute, @groupname, @keys, @filter_definition, @inc_Count, @inc_columns)

		-- Next index
		fetch ms_crs_ind INTO @indid, @groupid, @indname, @ignore_dup_key, @is_unique, @is_hypothetical,
			@is_primary_key, @is_unique_key, @auto_created, @no_recompute, @filter_definition
	end
	deallocate ms_crs_ind

	-- DISPLAY THE RESULTS
	SELECT
		'index_name' = index_name,
		'index_description' = convert(VARCHAR(210), --bits 16 off, 1, 2, 16777216 on, located on group
				CASE WHEN index_id = 1 THEN 'clustered' ELSE 'nonclustered' end
				+ CASE WHEN ignore_dup_key <>0 THEN ', ignore duplicate keys' ELSE '' end
				+ CASE WHEN is_unique <>0 THEN ', unique' ELSE '' end
				+ CASE WHEN is_hypothetical <>0 THEN ', hypothetical' ELSE '' end
				+ CASE WHEN is_primary_key <>0 THEN ', primary key' ELSE '' end
				+ CASE WHEN is_unique_key <>0 THEN ', unique key' ELSE '' end
				+ CASE WHEN auto_created <>0 THEN ', auto create' ELSE '' end
				+ CASE WHEN no_recompute <>0 THEN ', stats no recompute' ELSE '' end
				+ ' located on ' + groupname),
		'index_keys' = index_keys,
		--'num_included_columns' = inc_Count,
		'included_columns' = inc_columns,
		'filter_definition' = filter_definition
	FROM #spindtab
	ORDER BY index_name

	RETURN (0) -- sp_helpindexwinc2


exec sys.sp_MS_marksystemobject 'dbo.sp_helpindex2';






GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[sp_hexadecimaltruncleadingzeros]',10,1) WITH NOWAIT;
if object_id('dbo.sp_hexadecimaltruncleadingzeros') is null exec('create procedure [dbo].[sp_hexadecimaltruncleadingzeros] as select getdate() DT')
GO
  
alter procedure [dbo].[sp_hexadecimaltruncleadingzeros]
    @binvalue varbinary(256),
    @hexvalue VARCHAR (514) OUTPUT
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Convert binary value into hexidecimal string without leading zeroes
*	Inputs:		
*
*	@binvalue - required binary value to convert
*
*	ASSIGN VARIABLES
*
*	Notes:	
*
*	Returns:	@hexvalue - string representation of @binvalue
*	Prerequisite: None
*				
*	History:	
*
*	3/20/2017 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	3/20/2017			Mike Zawadzki			Created
*	
*
*********************************************************************************************************************/

	DECLARE @charvalue VARCHAR (514)
	DECLARE @i INT
	DECLARE @length INT
	DECLARE @hexstring CHAR(16)
	DECLARE @leading_zero TINYINT = 1
	DECLARE @msg VARCHAR(100)

	SELECT @charvalue = '0x'
	SELECT @i = 1
	SELECT @length = DATALENGTH (@binvalue)
	SELECT @hexstring = '0123456789ABCDEF'

	WHILE (@i <= @length)
	BEGIN
		DECLARE @tempint INT
		DECLARE @firstint INT
		DECLARE @secondint INT
		SELECT @tempint = CONVERT(INT, SUBSTRING(@binvalue,@i,1))
		SELECT @firstint = FLOOR(@tempint/16)
		SELECT @secondint = @tempint - (@firstint*16)

		IF @leading_zero = 0 or @firstint != 0
		BEGIN
			SELECT @charvalue = @charvalue +
				SUBSTRING(@hexstring, @firstint+1, 1) +
				SUBSTRING(@hexstring, @secondint+1, 1)
			SET @leading_zero = 0
		END
		ELSE
		BEGIN
			IF @firstint = 0 and @secondint = 0
			BEGIN
				SET @leading_zero = 1
			END
			ELSE
			BEGIN
				IF @firstint = 0 and @secondint != 0
				BEGIN
					SELECT @charvalue = @charvalue +
						SUBSTRING(@hexstring, @secondint+1, 1)
					SET @leading_zero = 0
				END
				ELSE
				BEGIN
					EXEC dbo.sp_hexadecimal @binvalue, @hexvalue OUTPUT
					SET @msg = 'sp_hexadecimaltruncleadingzeros: invalid if logic: ' + @hexvalue
					RAISERROR(@msg,11,1)
					SET @hexvalue = NULL
				END
			END
		END
		SELECT @i = @i + 1
	END

	SELECT @hexvalue = @charvalue
END

GO




RAISERROR ('	CREATING OR ALTERING PROCEDURE dbo.sp_WhoIsActive',10,1) WITH NOWAIT;
go


SET QUOTED_IDENTIFIER ON;
SET ANSI_PADDING ON;
SET CONCAT_NULL_YIELDS_NULL ON;
SET ANSI_WARNINGS ON;
SET NUMERIC_ROUNDABORT OFF;
SET ARITHABORT ON;
GO

IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = 'sp_WhoIsActive')
	EXEC ('CREATE PROC dbo.sp_WhoIsActive AS SELECT ''stub version, to be replaced''')
GO

/*********************************************************************************************
Who Is Active? v11.33 (2019-07-28)
(C) 2007-2019, Adam Machanic

Feedback: mailto:adam@dataeducation.com
Updates: http://whoisactive.com
Blog: http://dataeducation.com

License: 
	https://github.com/amachanic/sp_whoisactive/blob/master/LICENSE
*********************************************************************************************/
ALTER PROC dbo.sp_WhoIsActive
(
--~
	--Filters--Both inclusive and exclusive
	--Set either filter to '' to disable
	--Valid filter types are: session, program, database, login, and host
	--Session is a session ID, and either 0 or '' can be used to indicate "all" sessions
	--All other filter types support % or _ as wildcards
	@filter sysname = '',
	@filter_type VARCHAR(10) = 'session',
	@not_filter sysname = '',
	@not_filter_type VARCHAR(10) = 'session',

	--Retrieve data about the calling session?
	@show_own_spid BIT = 0,

	--Retrieve data about system sessions?
	@show_system_spids BIT = 0,

	--Controls how sleeping SPIDs are handled, based on the idea of levels of interest
	--0 does not pull any sleeping SPIDs
	--1 pulls only those sleeping SPIDs that also have an open transaction
	--2 pulls all sleeping SPIDs
	@show_sleeping_spids TINYINT = 1,

	--If 1, gets the full stored procedure or running batch, when available
	--If 0, gets only the actual statement that is currently running in the batch or procedure
	@get_full_inner_text BIT = 0,

	--Get associated query plans for running tasks, if available
	--If @get_plans = 1, gets the plan based on the request's statement offset
	--If @get_plans = 2, gets the entire plan based on the request's plan_handle
	@get_plans TINYINT = 0,

	--Get the associated outer ad hoc query or stored procedure call, if available
	@get_outer_command BIT = 0,

	--Enables pulling transaction log write info and transaction duration
	@get_transaction_info BIT = 0,

	--Get information on active tasks, based on three interest levels
	--Level 0 does not pull any task-related information
	--Level 1 is a lightweight mode that pulls the top non-CXPACKET wait, giving preference to blockers
	--Level 2 pulls all available task-based metrics, including: 
	--number of active tasks, current wait stats, physical I/O, context switches, and blocker information
	@get_task_info TINYINT = 1,

	--Gets associated locks for each request, aggregated in an XML format
	@get_locks BIT = 0,

	--Get average time for past runs of an active query
	--(based on the combination of plan handle, sql handle, and offset)
	@get_avg_time BIT = 0,

	--Get additional non-performance-related information about the session or request
	--text_size, language, date_format, date_first, quoted_identifier, arithabort, ansi_null_dflt_on, 
	--ansi_defaults, ansi_warnings, ansi_padding, ansi_nulls, concat_null_yields_null, 
	--transaction_isolation_level, lock_timeout, deadlock_priority, row_count, command_type
	--
	--If a SQL Agent job is running, an subnode called agent_info will be populated with some or all of
	--the following: job_id, job_name, step_id, step_name, msdb_query_error (in the event of an error)
	--
	--If @get_task_info is set to 2 and a lock wait is detected, a subnode called block_info will be
	--populated with some or all of the following: lock_type, database_name, object_id, file_id, hobt_id, 
	--applock_hash, metadata_resource, metadata_class_id, object_name, schema_name
	@get_additional_info BIT = 0,

	--Walk the blocking chain and count the number of 
	--total SPIDs blocked all the way down by a given session
	--Also enables task_info Level 1, if @get_task_info is set to 0
	@find_block_leaders BIT = 0,

	--Pull deltas on various metrics
	--Interval in seconds to wait before doing the second data pull
	@delta_interval TINYINT = 0,

	--List of desired output columns, in desired order
	--Note that the final output will be the intersection of all enabled features and all 
	--columns in the list. Therefore, only columns associated with enabled features will 
	--actually appear in the output. Likewise, removing columns from this list may effectively
	--disable features, even if they are turned on
	--
	--Each element in this list must be one of the valid output column names. Names must be
	--delimited by square brackets. White space, formatting, and additional characters are
	--allowed, as long as the list contains exact matches of delimited valid column names.
	@output_column_list VARCHAR(8000) = '[dd%][session_id][sql_text][sql_command][login_name][wait_info][tasks][tran_log%][cpu%][temp%][block%][reads%][writes%][context%][physical%][query_plan][locks][%]',

	--Column(s) by which to sort output, optionally with sort directions. 
		--Valid column choices:
		--session_id, physical_io, reads, physical_reads, writes, tempdb_allocations, 
		--tempdb_current, CPU, context_switches, used_memory, physical_io_delta, reads_delta, 
		--physical_reads_delta, writes_delta, tempdb_allocations_delta, tempdb_current_delta, 
		--CPU_delta, context_switches_delta, used_memory_delta, tasks, tran_start_time, 
		--open_tran_count, blocking_session_id, blocked_session_count, percent_complete, 
		--host_name, login_name, database_name, start_time, login_time, program_name
		--
		--Note that column names in the list must be bracket-delimited. Commas and/or white
		--space are not required. 
	@sort_order VARCHAR(500) = '[start_time] ASC',

	--Formats some of the output columns in a more "human readable" form
	--0 disables outfput format
	--1 formats the output for variable-width fonts
	--2 formats the output for fixed-width fonts
	@format_output TINYINT = 1,

	--If set to a non-blank value, the script will attempt to insert into the specified 
	--destination table. Please note that the script will not verify that the table exists, 
	--or that it has the correct schema, before doing the insert.
	--Table can be specified in one, two, or three-part format
	@destination_table VARCHAR(4000) = '',

	--If set to 1, no data collection will happen and no result set will be returned; instead,
	--a CREATE TABLE statement will be returned via the @schema parameter, which will match 
	--the schema of the result set that would be returned by using the same collection of the
	--rest of the parameters. The CREATE TABLE statement will have a placeholder token of 
	--<table_name> in place of an actual table name.
	@return_schema BIT = 0,
	@schema VARCHAR(MAX) = NULL OUTPUT,

	--Help! What do I do?
	@help BIT = 0
--~
)
/*
OUTPUT COLUMNS
--------------
Formatted/Non:	[session_id] [smallint] NOT NULL
	Session ID (a.k.a. SPID)

Formatted:		[dd hh:mm:ss.mss] [varchar](15) NULL
Non-Formatted:	<not returned>
	For an active request, time the query has been running
	For a sleeping session, time since the last batch completed

Formatted:		[dd hh:mm:ss.mss (avg)] [varchar](15) NULL
Non-Formatted:	[avg_elapsed_time] [int] NULL
	(Requires @get_avg_time option)
	How much time has the active portion of the query taken in the past, on average?

Formatted:		[physical_io] [varchar](30) NULL
Non-Formatted:	[physical_io] [bigint] NULL
	Shows the number of physical I/Os, for active requests

Formatted:		[reads] [varchar](30) NULL
Non-Formatted:	[reads] [bigint] NULL
	For an active request, number of reads done for the current query
	For a sleeping session, total number of reads done over the lifetime of the session

Formatted:		[physical_reads] [varchar](30) NULL
Non-Formatted:	[physical_reads] [bigint] NULL
	For an active request, number of physical reads done for the current query
	For a sleeping session, total number of physical reads done over the lifetime of the session

Formatted:		[writes] [varchar](30) NULL
Non-Formatted:	[writes] [bigint] NULL
	For an active request, number of writes done for the current query
	For a sleeping session, total number of writes done over the lifetime of the session

Formatted:		[tempdb_allocations] [varchar](30) NULL
Non-Formatted:	[tempdb_allocations] [bigint] NULL
	For an active request, number of TempDB writes done for the current query
	For a sleeping session, total number of TempDB writes done over the lifetime of the session

Formatted:		[tempdb_current] [varchar](30) NULL
Non-Formatted:	[tempdb_current] [bigint] NULL
	For an active request, number of TempDB pages currently allocated for the query
	For a sleeping session, number of TempDB pages currently allocated for the session

Formatted:		[CPU] [varchar](30) NULL
Non-Formatted:	[CPU] [int] NULL
	For an active request, total CPU time consumed by the current query
	For a sleeping session, total CPU time consumed over the lifetime of the session

Formatted:		[context_switches] [varchar](30) NULL
Non-Formatted:	[context_switches] [bigint] NULL
	Shows the number of context switches, for active requests

Formatted:		[used_memory] [varchar](30) NOT NULL
Non-Formatted:	[used_memory] [bigint] NOT NULL
	For an active request, total memory consumption for the current query
	For a sleeping session, total current memory consumption

Formatted:		[physical_io_delta] [varchar](30) NULL
Non-Formatted:	[physical_io_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of physical I/Os reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[reads_delta] [varchar](30) NULL
Non-Formatted:	[reads_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of reads reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[physical_reads_delta] [varchar](30) NULL
Non-Formatted:	[physical_reads_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of physical reads reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[writes_delta] [varchar](30) NULL
Non-Formatted:	[writes_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of writes reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[tempdb_allocations_delta] [varchar](30) NULL
Non-Formatted:	[tempdb_allocations_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of TempDB writes reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[tempdb_current_delta] [varchar](30) NULL
Non-Formatted:	[tempdb_current_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of allocated TempDB pages reported on the first and second 
	collections. If the request started after the first collection, the value will be NULL

Formatted:		[CPU_delta] [varchar](30) NULL
Non-Formatted:	[CPU_delta] [int] NULL
	(Requires @delta_interval option)
	Difference between the CPU time reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[context_switches_delta] [varchar](30) NULL
Non-Formatted:	[context_switches_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the context switches count reported on the first and second collections
	If the request started after the first collection, the value will be NULL

Formatted:		[used_memory_delta] [varchar](30) NULL
Non-Formatted:	[used_memory_delta] [bigint] NULL
	Difference between the memory usage reported on the first and second collections
	If the request started after the first collection, the value will be NULL

Formatted:		[tasks] [varchar](30) NULL
Non-Formatted:	[tasks] [smallint] NULL
	Number of worker tasks currently allocated, for active requests

Formatted/Non:	[status] [varchar](30) NOT NULL
	Activity status for the session (running, sleeping, etc)

Formatted/Non:	[wait_info] [nvarchar](4000) NULL
	Aggregates wait information, in the following format:
		(Ax: Bms/Cms/Dms)E
	A is the number of waiting tasks currently waiting on resource type E. B/C/D are wait
	times, in milliseconds. If only one thread is waiting, its wait time will be shown as B.
	If two tasks are waiting, each of their wait times will be shown (B/C). If three or more 
	tasks are waiting, the minimum, average, and maximum wait times will be shown (B/C/D).
	If wait type E is a page latch wait and the page is of a "special" type (e.g. PFS, GAM, SGAM), 
	the page type will be identified.
	If wait type E is CXPACKET, the nodeId from the query plan will be identified

Formatted/Non:	[locks] [xml] NULL
	(Requires @get_locks option)
	Aggregates lock information, in XML format.
	The lock XML includes the lock mode, locked object, and aggregates the number of requests. 
	Attempts are made to identify locked objects by name

Formatted/Non:	[tran_start_time] [datetime] NULL
	(Requires @get_transaction_info option)
	Date and time that the first transaction opened by a session caused a transaction log 
	write to occur.

Formatted/Non:	[tran_log_writes] [nvarchar](4000) NULL
	(Requires @get_transaction_info option)
	Aggregates transaction log write information, in the following format:
	A:wB (C kB)
	A is a database that has been touched by an active transaction
	B is the number of log writes that have been made in the database as a result of the transaction
	C is the number of log kilobytes consumed by the log records

Formatted:		[open_tran_count] [varchar](30) NULL
Non-Formatted:	[open_tran_count] [smallint] NULL
	Shows the number of open transactions the session has open

Formatted:		[sql_command] [xml] NULL
Non-Formatted:	[sql_command] [nvarchar](max) NULL
	(Requires @get_outer_command option)
	Shows the "outer" SQL command, i.e. the text of the batch or RPC sent to the server, 
	if available

Formatted:		[sql_text] [xml] NULL
Non-Formatted:	[sql_text] [nvarchar](max) NULL
	Shows the SQL text for active requests or the last statement executed
	for sleeping sessions, if available in either case.
	If @get_full_inner_text option is set, shows the full text of the batch.
	Otherwise, shows only the active statement within the batch.
	If the query text is locked, a special timeout message will be sent, in the following format:
		<timeout_exceeded />
	If an error occurs, an error message will be sent, in the following format:
		<error message="message" />

Formatted/Non:	[query_plan] [xml] NULL
	(Requires @get_plans option)
	Shows the query plan for the request, if available.
	If the plan is locked, a special timeout message will be sent, in the following format:
		<timeout_exceeded />
	If an error occurs, an error message will be sent, in the following format:
		<error message="message" />

Formatted/Non:	[blocking_session_id] [smallint] NULL
	When applicable, shows the blocking SPID

Formatted:		[blocked_session_count] [varchar](30) NULL
Non-Formatted:	[blocked_session_count] [smallint] NULL
	(Requires @find_block_leaders option)
	The total number of SPIDs blocked by this session,
	all the way down the blocking chain.

Formatted:		[percent_complete] [varchar](30) NULL
Non-Formatted:	[percent_complete] [real] NULL
	When applicable, shows the percent complete (e.g. for backups, restores, and some rollbacks)

Formatted/Non:	[host_name] [sysname] NOT NULL
	Shows the host name for the connection

Formatted/Non:	[login_name] [sysname] NOT NULL
	Shows the login name for the connection

Formatted/Non:	[database_name] [sysname] NULL
	Shows the connected database

Formatted/Non:	[program_name] [sysname] NULL
	Shows the reported program/application name

Formatted/Non:	[additional_info] [xml] NULL
	(Requires @get_additional_info option)
	Returns additional non-performance-related session/request information
	If the script finds a SQL Agent job running, the name of the job and job step will be reported
	If @get_task_info = 2 and the script finds a lock wait, the locked object will be reported

Formatted/Non:	[start_time] [datetime] NOT NULL
	For active requests, shows the time the request started
	For sleeping sessions, shows the time the last batch completed

Formatted/Non:	[login_time] [datetime] NOT NULL
	Shows the time that the session connected

Formatted/Non:	[request_id] [int] NULL
	For active requests, shows the request_id
	Should be 0 unless MARS is being used

Formatted/Non:	[collection_time] [datetime] NOT NULL
	Time that this script's final SELECT ran
*/
AS
BEGIN;
	SET NOCOUNT ON; 
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET QUOTED_IDENTIFIER ON;
	SET ANSI_PADDING ON;
	SET CONCAT_NULL_YIELDS_NULL ON;
	SET ANSI_WARNINGS ON;
	SET NUMERIC_ROUNDABORT OFF;
	SET ARITHABORT ON;

	IF
		@filter IS NULL
		OR @filter_type IS NULL
		OR @not_filter IS NULL
		OR @not_filter_type IS NULL
		OR @show_own_spid IS NULL
		OR @show_system_spids IS NULL
		OR @show_sleeping_spids IS NULL
		OR @get_full_inner_text IS NULL
		OR @get_plans IS NULL
		OR @get_outer_command IS NULL
		OR @get_transaction_info IS NULL
		OR @get_task_info IS NULL
		OR @get_locks IS NULL
		OR @get_avg_time IS NULL
		OR @get_additional_info IS NULL
		OR @find_block_leaders IS NULL
		OR @delta_interval IS NULL
		OR @format_output IS NULL
		OR @output_column_list IS NULL
		OR @sort_order IS NULL
		OR @return_schema IS NULL
		OR @destination_table IS NULL
		OR @help IS NULL
	BEGIN;
		RAISERROR('Input parameters cannot be NULL', 16, 1);
		RETURN;
	END;
	
	IF @filter_type NOT IN ('session', 'program', 'database', 'login', 'host')
	BEGIN;
		RAISERROR('Valid filter types are: session, program, database, login, host', 16, 1);
		RETURN;
	END;
	
	IF @filter_type = 'session' AND @filter LIKE '%[^0123456789]%'
	BEGIN;
		RAISERROR('Session filters must be valid integers', 16, 1);
		RETURN;
	END;
	
	IF @not_filter_type NOT IN ('session', 'program', 'database', 'login', 'host')
	BEGIN;
		RAISERROR('Valid filter types are: session, program, database, login, host', 16, 1);
		RETURN;
	END;
	
	IF @not_filter_type = 'session' AND @not_filter LIKE '%[^0123456789]%'
	BEGIN;
		RAISERROR('Session filters must be valid integers', 16, 1);
		RETURN;
	END;
	
	IF @show_sleeping_spids NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @show_sleeping_spids are: 0, 1, or 2', 16, 1);
		RETURN;
	END;
	
	IF @get_plans NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @get_plans are: 0, 1, or 2', 16, 1);
		RETURN;
	END;

	IF @get_task_info NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @get_task_info are: 0, 1, or 2', 16, 1);
		RETURN;
	END;

	IF @format_output NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @format_output are: 0, 1, or 2', 16, 1);
		RETURN;
	END;
	
	IF @help = 1
	BEGIN;
		DECLARE 
			@header VARCHAR(MAX),
			@params VARCHAR(MAX),
			@outputs VARCHAR(MAX);

		SELECT 
			@header =
				REPLACE
				(
					REPLACE
					(
						CONVERT
						(
							VARCHAR(MAX),
							SUBSTRING
							(
								t.text, 
								CHARINDEX('/' + REPLICATE('*', 93), t.text) + 94,
								CHARINDEX(REPLICATE('*', 93) + '/', t.text) - (CHARINDEX('/' + REPLICATE('*', 93), t.text) + 94)
							)
						),
						CHAR(13)+CHAR(10),
						CHAR(13)
					),
					'	',
					''
				),
			@params =
				CHAR(13) +
					REPLACE
					(
						REPLACE
						(
							CONVERT
							(
								VARCHAR(MAX),
								SUBSTRING
								(
									t.text, 
									CHARINDEX('--~', t.text) + 5, 
									CHARINDEX('--~', t.text, CHARINDEX('--~', t.text) + 5) - (CHARINDEX('--~', t.text) + 5)
								)
							),
							CHAR(13)+CHAR(10),
							CHAR(13)
						),
						'	',
						''
					),
				@outputs = 
					CHAR(13) +
						REPLACE
						(
							REPLACE
							(
								REPLACE
								(
									CONVERT
									(
										VARCHAR(MAX),
										SUBSTRING
										(
											t.text, 
											CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32,
											CHARINDEX('*/', t.text, CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32) - (CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32)
										)
									),
									CHAR(9),
									CHAR(255)
								),
								CHAR(13)+CHAR(10),
								CHAR(13)
							),
							'	',
							''
						) +
						CHAR(13)
		FROM sys.dm_exec_requests AS r
		CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
		WHERE
			r.session_id = @@SPID;

		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@header) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		)
		SELECT
			RTRIM(LTRIM(
				SUBSTRING
				(
					@header,
					number + 1,
					CHARINDEX(CHAR(13), @header, number + 1) - number - 1
				)
			)) AS [------header---------------------------------------------------------------------------------------------------------------]
		FROM numbers
		WHERE
			SUBSTRING(@header, number, 1) = CHAR(13);

		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@params) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		),
		tokens AS
		(
			SELECT 
				RTRIM(LTRIM(
					SUBSTRING
					(
						@params,
						number + 1,
						CHARINDEX(CHAR(13), @params, number + 1) - number - 1
					)
				)) AS token,
				number,
				CASE
					WHEN SUBSTRING(@params, number + 1, 1) = CHAR(13) THEN number
					ELSE COALESCE(NULLIF(CHARINDEX(',' + CHAR(13) + CHAR(13), @params, number), 0), LEN(@params)) 
				END AS param_group,
				ROW_NUMBER() OVER
				(
					PARTITION BY
						CHARINDEX(',' + CHAR(13) + CHAR(13), @params, number),
						SUBSTRING(@params, number+1, 1)
					ORDER BY 
						number
				) AS group_order
			FROM numbers
			WHERE
				SUBSTRING(@params, number, 1) = CHAR(13)
		),
		parsed_tokens AS
		(
			SELECT
				MIN
				(
					CASE
						WHEN token LIKE '@%' THEN token
						ELSE NULL
					END
				) AS parameter,
				MIN
				(
					CASE
						WHEN token LIKE '--%' THEN RIGHT(token, LEN(token) - 2)
						ELSE NULL
					END
				) AS description,
				param_group,
				group_order
			FROM tokens
			WHERE
				NOT 
				(
					token = '' 
					AND group_order > 1
				)
			GROUP BY
				param_group,
				group_order
		)
		SELECT
			CASE
				WHEN description IS NULL AND parameter IS NULL THEN '-------------------------------------------------------------------------'
				WHEN param_group = MAX(param_group) OVER() THEN parameter
				ELSE COALESCE(LEFT(parameter, LEN(parameter) - 1), '')
			END AS [------parameter----------------------------------------------------------],
			CASE
				WHEN description IS NULL AND parameter IS NULL THEN '----------------------------------------------------------------------------------------------------------------------'
				ELSE COALESCE(description, '')
			END AS [------description-----------------------------------------------------------------------------------------------------]
		FROM parsed_tokens
		ORDER BY
			param_group, 
			group_order;
		
		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@outputs) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		),
		tokens AS
		(
			SELECT 
				RTRIM(LTRIM(
					SUBSTRING
					(
						@outputs,
						number + 1,
						CASE
							WHEN 
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) < 
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs))
								THEN COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) - number - 1
							ELSE
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs)) - number - 1
						END
					)
				)) AS token,
				number,
				COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) AS output_group,
				ROW_NUMBER() OVER
				(
					PARTITION BY 
						COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs))
					ORDER BY
						number
				) AS output_group_order
			FROM numbers
			WHERE
				SUBSTRING(@outputs, number, 10) = CHAR(13) + 'Formatted'
				OR SUBSTRING(@outputs, number, 2) = CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2
		),
		output_tokens AS
		(
			SELECT 
				*,
				CASE output_group_order
					WHEN 2 THEN MAX(CASE output_group_order WHEN 1 THEN token ELSE NULL END) OVER (PARTITION BY output_group)
					ELSE ''
				END COLLATE Latin1_General_Bin2 AS column_info
			FROM tokens
		)
		SELECT
			CASE output_group_order
				WHEN 1 THEN '-----------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN
							SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+1, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info))
						ELSE
							SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)-1)
					END
				ELSE ''
			END AS formatted_column_name,
			CASE output_group_order
				WHEN 1 THEN '-----------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN
							SUBSTRING(column_info, CHARINDEX(']', column_info)+2, LEN(column_info))
						ELSE
							SUBSTRING(column_info, CHARINDEX(']', column_info)+2, CHARINDEX('Non-Formatted:', column_info, CHARINDEX(']', column_info)+2) - CHARINDEX(']', column_info)-3)
					END
				ELSE ''
			END AS formatted_column_type,
			CASE output_group_order
				WHEN 1 THEN '---------------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN ''
						ELSE
							CASE
								WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, 1) = '<' THEN
									SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, CHARINDEX('>', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info)))
								ELSE
									SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info)))
							END
					END
				ELSE ''
			END AS unformatted_column_name,
			CASE output_group_order
				WHEN 1 THEN '---------------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN ''
						ELSE
							CASE
								WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, 1) = '<' THEN ''
								ELSE
									SUBSTRING(column_info, CHARINDEX(']', column_info, CHARINDEX('Non-Formatted:', column_info))+2, CHARINDEX('Non-Formatted:', column_info, CHARINDEX(']', column_info)+2) - CHARINDEX(']', column_info)-3)
							END
					END
				ELSE ''
			END AS unformatted_column_type,
			CASE output_group_order
				WHEN 1 THEN '----------------------------------------------------------------------------------------------------------------------'
				ELSE REPLACE(token, CHAR(255) COLLATE Latin1_General_Bin2, '')
			END AS [------description-----------------------------------------------------------------------------------------------------]
		FROM output_tokens
		WHERE
			NOT 
			(
				output_group_order = 1 
				AND output_group = LEN(@outputs)
			)
		ORDER BY
			output_group,
			CASE output_group_order
				WHEN 1 THEN 99
				ELSE output_group_order
			END;

		RETURN;
	END;

	WITH
	a0 AS
	(SELECT 1 AS n UNION ALL SELECT 1),
	a1 AS
	(SELECT 1 AS n FROM a0 AS a, a0 AS b),
	a2 AS
	(SELECT 1 AS n FROM a1 AS a, a1 AS b),
	a3 AS
	(SELECT 1 AS n FROM a2 AS a, a2 AS b),
	a4 AS
	(SELECT 1 AS n FROM a3 AS a, a3 AS b),
	numbers AS
	(
		SELECT TOP(LEN(@output_column_list))
			ROW_NUMBER() OVER
			(
				ORDER BY (SELECT NULL)
			) AS number
		FROM a4
		ORDER BY
			number
	),
	tokens AS
	(
		SELECT 
			'|[' +
				SUBSTRING
				(
					@output_column_list,
					number + 1,
					CHARINDEX(']', @output_column_list, number) - number - 1
				) + '|]' AS token,
			number
		FROM numbers
		WHERE
			SUBSTRING(@output_column_list, number, 1) = '['
	),
	ordered_columns AS
	(
		SELECT
			x.column_name,
			ROW_NUMBER() OVER
			(
				PARTITION BY
					x.column_name
				ORDER BY
					tokens.number,
					x.default_order
			) AS r,
			ROW_NUMBER() OVER
			(
				ORDER BY
					tokens.number,
					x.default_order
			) AS s
		FROM tokens
		JOIN
		(
			SELECT '[session_id]' AS column_name, 1 AS default_order
			UNION ALL
			SELECT '[dd hh:mm:ss.mss]', 2
			WHERE
				@format_output IN (1, 2)
			UNION ALL
			SELECT '[dd hh:mm:ss.mss (avg)]', 3
			WHERE
				@format_output IN (1, 2)
				AND @get_avg_time = 1
			UNION ALL
			SELECT '[avg_elapsed_time]', 4
			WHERE
				@format_output = 0
				AND @get_avg_time = 1
			UNION ALL
			SELECT '[physical_io]', 5
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[reads]', 6
			UNION ALL
			SELECT '[physical_reads]', 7
			UNION ALL
			SELECT '[writes]', 8
			UNION ALL
			SELECT '[tempdb_allocations]', 9
			UNION ALL
			SELECT '[tempdb_current]', 10
			UNION ALL
			SELECT '[CPU]', 11
			UNION ALL
			SELECT '[context_switches]', 12
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[used_memory]', 13
			UNION ALL
			SELECT '[physical_io_delta]', 14
			WHERE
				@delta_interval > 0	
				AND @get_task_info = 2
			UNION ALL
			SELECT '[reads_delta]', 15
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[physical_reads_delta]', 16
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[writes_delta]', 17
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tempdb_allocations_delta]', 18
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tempdb_current_delta]', 19
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[CPU_delta]', 20
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[context_switches_delta]', 21
			WHERE
				@delta_interval > 0
				AND @get_task_info = 2
			UNION ALL
			SELECT '[used_memory_delta]', 22
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tasks]', 23
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[status]', 24
			UNION ALL
			SELECT '[wait_info]', 25
			WHERE
				@get_task_info > 0
				OR @find_block_leaders = 1
			UNION ALL
			SELECT '[locks]', 26
			WHERE
				@get_locks = 1
			UNION ALL
			SELECT '[tran_start_time]', 27
			WHERE
				@get_transaction_info = 1
			UNION ALL
			SELECT '[tran_log_writes]', 28
			WHERE
				@get_transaction_info = 1
			UNION ALL
			SELECT '[open_tran_count]', 29
			UNION ALL
			SELECT '[sql_command]', 30
			WHERE
				@get_outer_command = 1
			UNION ALL
			SELECT '[sql_text]', 31
			UNION ALL
			SELECT '[query_plan]', 32
			WHERE
				@get_plans >= 1
			UNION ALL
			SELECT '[blocking_session_id]', 33
			WHERE
				@get_task_info > 0
				OR @find_block_leaders = 1
			UNION ALL
			SELECT '[blocked_session_count]', 34
			WHERE
				@find_block_leaders = 1
			UNION ALL
			SELECT '[percent_complete]', 35
			UNION ALL
			SELECT '[host_name]', 36
			UNION ALL
			SELECT '[login_name]', 37
			UNION ALL
			SELECT '[database_name]', 38
			UNION ALL
			SELECT '[program_name]', 39
			UNION ALL
			SELECT '[additional_info]', 40
			WHERE
				@get_additional_info = 1
			UNION ALL
			SELECT '[start_time]', 41
			UNION ALL
			SELECT '[login_time]', 42
			UNION ALL
			SELECT '[request_id]', 43
			UNION ALL
			SELECT '[collection_time]', 44
		) AS x ON 
			x.column_name LIKE token ESCAPE '|'
	)
	SELECT
		@output_column_list =
			STUFF
			(
				(
					SELECT
						',' + column_name as [text()]
					FROM ordered_columns
					WHERE
						r = 1
					ORDER BY
						s
					FOR XML
						PATH('')
				),
				1,
				1,
				''
			);
	
	IF COALESCE(RTRIM(@output_column_list), '') = ''
	BEGIN;
		RAISERROR('No valid column matches found in @output_column_list or no columns remain due to selected options.', 16, 1);
		RETURN;
	END;
	
	IF @destination_table <> ''
	BEGIN;
		SET @destination_table = 
			--database
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 3)) + '.', '') +
			--schema
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 2)) + '.', '') +
			--table
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 1)), '');
			
		IF COALESCE(RTRIM(@destination_table), '') = ''
		BEGIN;
			RAISERROR('Destination table not properly formatted.', 16, 1);
			RETURN;
		END;
	END;

	WITH
	a0 AS
	(SELECT 1 AS n UNION ALL SELECT 1),
	a1 AS
	(SELECT 1 AS n FROM a0 AS a, a0 AS b),
	a2 AS
	(SELECT 1 AS n FROM a1 AS a, a1 AS b),
	a3 AS
	(SELECT 1 AS n FROM a2 AS a, a2 AS b),
	a4 AS
	(SELECT 1 AS n FROM a3 AS a, a3 AS b),
	numbers AS
	(
		SELECT TOP(LEN(@sort_order))
			ROW_NUMBER() OVER
			(
				ORDER BY (SELECT NULL)
			) AS number
		FROM a4
		ORDER BY
			number
	),
	tokens AS
	(
		SELECT 
			'|[' +
				SUBSTRING
				(
					@sort_order,
					number + 1,
					CHARINDEX(']', @sort_order, number) - number - 1
				) + '|]' AS token,
			SUBSTRING
			(
				@sort_order,
				CHARINDEX(']', @sort_order, number) + 1,
				COALESCE(NULLIF(CHARINDEX('[', @sort_order, CHARINDEX(']', @sort_order, number)), 0), LEN(@sort_order)) - CHARINDEX(']', @sort_order, number)
			) AS next_chunk,
			number
		FROM numbers
		WHERE
			SUBSTRING(@sort_order, number, 1) = '['
	),
	ordered_columns AS
	(
		SELECT
			x.column_name +
				CASE
					WHEN tokens.next_chunk LIKE '%asc%' THEN ' ASC'
					WHEN tokens.next_chunk LIKE '%desc%' THEN ' DESC'
					ELSE ''
				END AS column_name,
			ROW_NUMBER() OVER
			(
				PARTITION BY
					x.column_name
				ORDER BY
					tokens.number
			) AS r,
			tokens.number
		FROM tokens
		JOIN
		(
			SELECT '[session_id]' AS column_name
			UNION ALL
			SELECT '[physical_io]'
			UNION ALL
			SELECT '[reads]'
			UNION ALL
			SELECT '[physical_reads]'
			UNION ALL
			SELECT '[writes]'
			UNION ALL
			SELECT '[tempdb_allocations]'
			UNION ALL
			SELECT '[tempdb_current]'
			UNION ALL
			SELECT '[CPU]'
			UNION ALL
			SELECT '[context_switches]'
			UNION ALL
			SELECT '[used_memory]'
			UNION ALL
			SELECT '[physical_io_delta]'
			UNION ALL
			SELECT '[reads_delta]'
			UNION ALL
			SELECT '[physical_reads_delta]'
			UNION ALL
			SELECT '[writes_delta]'
			UNION ALL
			SELECT '[tempdb_allocations_delta]'
			UNION ALL
			SELECT '[tempdb_current_delta]'
			UNION ALL
			SELECT '[CPU_delta]'
			UNION ALL
			SELECT '[context_switches_delta]'
			UNION ALL
			SELECT '[used_memory_delta]'
			UNION ALL
			SELECT '[tasks]'
			UNION ALL
			SELECT '[tran_start_time]'
			UNION ALL
			SELECT '[open_tran_count]'
			UNION ALL
			SELECT '[blocking_session_id]'
			UNION ALL
			SELECT '[blocked_session_count]'
			UNION ALL
			SELECT '[percent_complete]'
			UNION ALL
			SELECT '[host_name]'
			UNION ALL
			SELECT '[login_name]'
			UNION ALL
			SELECT '[database_name]'
			UNION ALL
			SELECT '[start_time]'
			UNION ALL
			SELECT '[login_time]'
			UNION ALL
			SELECT '[program_name]'
		) AS x ON 
			x.column_name LIKE token ESCAPE '|'
	)
	SELECT
		@sort_order = COALESCE(z.sort_order, '')
	FROM
	(
		SELECT
			STUFF
			(
				(
					SELECT
						',' + column_name as [text()]
					FROM ordered_columns
					WHERE
						r = 1
					ORDER BY
						number
					FOR XML
						PATH('')
				),
				1,
				1,
				''
			) AS sort_order
	) AS z;

	CREATE TABLE #sessions
	(
		recursion SMALLINT NOT NULL,
		session_id SMALLINT NOT NULL,
		request_id INT NOT NULL,
		session_number INT NOT NULL,
		elapsed_time INT NOT NULL,
		avg_elapsed_time INT NULL,
		physical_io BIGINT NULL,
		reads BIGINT NULL,
		physical_reads BIGINT NULL,
		writes BIGINT NULL,
		tempdb_allocations BIGINT NULL,
		tempdb_current BIGINT NULL,
		CPU INT NULL,
		thread_CPU_snapshot BIGINT NULL,
		context_switches BIGINT NULL,
		used_memory BIGINT NOT NULL, 
		tasks SMALLINT NULL,
		status VARCHAR(30) NOT NULL,
		wait_info NVARCHAR(4000) NULL,
		locks XML NULL,
		transaction_id BIGINT NULL,
		tran_start_time DATETIME NULL,
		tran_log_writes NVARCHAR(4000) NULL,
		open_tran_count SMALLINT NULL,
		sql_command XML NULL,
		sql_handle VARBINARY(64) NULL,
		statement_start_offset INT NULL,
		statement_end_offset INT NULL,
		sql_text XML NULL,
		plan_handle VARBINARY(64) NULL,
		query_plan XML NULL,
		blocking_session_id SMALLINT NULL,
		blocked_session_count SMALLINT NULL,
		percent_complete REAL NULL,
		host_name sysname NULL,
		login_name sysname NOT NULL,
		database_name sysname NULL,
		program_name sysname NULL,
		additional_info XML NULL,
		start_time DATETIME NOT NULL,
		login_time DATETIME NULL,
		last_request_start_time DATETIME NULL,
		PRIMARY KEY CLUSTERED (session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON),
		UNIQUE NONCLUSTERED (transaction_id, session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON)
	);

	IF @return_schema = 0
	BEGIN;
		--Disable unnecessary autostats on the table
		CREATE STATISTICS s_session_id ON #sessions (session_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_request_id ON #sessions (request_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_transaction_id ON #sessions (transaction_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_session_number ON #sessions (session_number)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_status ON #sessions (status)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_start_time ON #sessions (start_time)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_last_request_start_time ON #sessions (last_request_start_time)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_recursion ON #sessions (recursion)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;

		DECLARE @recursion SMALLINT;
		SET @recursion = 
			CASE @delta_interval
				WHEN 0 THEN 1
				ELSE -1
			END;

		DECLARE @first_collection_ms_ticks BIGINT;
		DECLARE @last_collection_start DATETIME;
		DECLARE @sys_info BIT;
		SET @sys_info = ISNULL(CONVERT(BIT, SIGN(OBJECT_ID('sys.dm_os_sys_info'))), 0);

		--Used for the delta pull
		REDO:;
		
		IF 
			@get_locks = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[locks|]%' ESCAPE '|'
		BEGIN;
			SELECT
				y.resource_type,
				y.database_name,
				y.object_id,
				y.file_id,
				y.page_type,
				y.hobt_id,
				y.allocation_unit_id,
				y.index_id,
				y.schema_id,
				y.principal_id,
				y.request_mode,
				y.request_status,
				y.session_id,
				y.resource_description,
				y.request_count,
				s.request_id,
				s.start_time,
				CONVERT(sysname, NULL) AS object_name,
				CONVERT(sysname, NULL) AS index_name,
				CONVERT(sysname, NULL) AS schema_name,
				CONVERT(sysname, NULL) AS principal_name,
				CONVERT(NVARCHAR(2048), NULL) AS query_error
			INTO #locks
			FROM
			(
				SELECT
					sp.spid AS session_id,
					CASE sp.status
						WHEN 'sleeping' THEN CONVERT(INT, 0)
						ELSE sp.request_id
					END AS request_id,
					CASE sp.status
						WHEN 'sleeping' THEN sp.last_batch
						ELSE COALESCE(req.start_time, sp.last_batch)
					END AS start_time,
					sp.dbid
				FROM sys.sysprocesses AS sp
				OUTER APPLY
				(
					SELECT TOP(1)
						CASE
							WHEN 
							(
								sp.hostprocess > ''
								OR r.total_elapsed_time < 0
							) THEN
								r.start_time
							ELSE
								DATEADD
								(
									ms, 
									1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())), 
									DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
								)
						END AS start_time
					FROM sys.dm_exec_requests AS r
					WHERE
						r.session_id = sp.spid
						AND r.request_id = sp.request_id
				) AS req
				WHERE
					--Process inclusive filter
					1 =
						CASE
							WHEN @filter <> '' THEN
								CASE @filter_type
									WHEN 'session' THEN
										CASE
											WHEN
												CONVERT(SMALLINT, @filter) = 0
												OR sp.spid = CONVERT(SMALLINT, @filter)
													THEN 1
											ELSE 0
										END
									WHEN 'program' THEN
										CASE
											WHEN sp.program_name LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'login' THEN
										CASE
											WHEN sp.loginame LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'host' THEN
										CASE
											WHEN sp.hostname LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'database' THEN
										CASE
											WHEN DB_NAME(sp.dbid) LIKE @filter THEN 1
											ELSE 0
										END
									ELSE 0
								END
							ELSE 1
						END
					--Process exclusive filter
					AND 0 =
						CASE
							WHEN @not_filter <> '' THEN
								CASE @not_filter_type
									WHEN 'session' THEN
										CASE
											WHEN sp.spid = CONVERT(SMALLINT, @not_filter) THEN 1
											ELSE 0
										END
									WHEN 'program' THEN
										CASE
											WHEN sp.program_name LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'login' THEN
										CASE
											WHEN sp.loginame LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'host' THEN
										CASE
											WHEN sp.hostname LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'database' THEN
										CASE
											WHEN DB_NAME(sp.dbid) LIKE @not_filter THEN 1
											ELSE 0
										END
									ELSE 0
								END
							ELSE 0
						END
					AND 
					(
						@show_own_spid = 1
						OR sp.spid <> @@SPID
					)
					AND 
					(
						@show_system_spids = 1
						OR sp.hostprocess > ''
					)
					AND sp.ecid = 0
			) AS s
			INNER HASH JOIN
			(
				SELECT
					x.resource_type,
					x.database_name,
					x.object_id,
					x.file_id,
					CASE
						WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN 'PFS'
						WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN 'GAM'
						WHEN x.page_no = 3 OR (x.page_no - 1) % 511232 = 0 THEN 'SGAM'
						WHEN x.page_no = 6 OR (x.page_no - 6) % 511232 = 0 THEN 'DCM'
						WHEN x.page_no = 7 OR (x.page_no - 7) % 511232 = 0 THEN 'BCM'
						WHEN x.page_no IS NOT NULL THEN '*'
						ELSE NULL
					END AS page_type,
					x.hobt_id,
					x.allocation_unit_id,
					x.index_id,
					x.schema_id,
					x.principal_id,
					x.request_mode,
					x.request_status,
					x.session_id,
					x.request_id,
					CASE
						WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '')
						ELSE NULL
					END AS resource_description,
					COUNT(*) AS request_count
				FROM
				(
					SELECT
						tl.resource_type +
							CASE
								WHEN tl.resource_subtype = '' THEN ''
								ELSE '.' + tl.resource_subtype
							END AS resource_type,
						COALESCE(DB_NAME(tl.resource_database_id), N'(null)') AS database_name,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_type = 'OBJECT' THEN tl.resource_associated_entity_id
								WHEN tl.resource_description LIKE '%object_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('object_id = ', tl.resource_description) + 12), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('object_id = ', tl.resource_description) + 12),
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('object_id = ', tl.resource_description) + 12)
										)
									)
								ELSE NULL
							END
						) AS object_id,
						CONVERT
						(
							INT,
							CASE 
								WHEN tl.resource_type = 'FILE' THEN CONVERT(INT, tl.resource_description)
								WHEN tl.resource_type IN ('PAGE', 'EXTENT', 'RID') THEN LEFT(tl.resource_description, CHARINDEX(':', tl.resource_description)-1)
								ELSE NULL
							END
						) AS file_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_type IN ('PAGE', 'EXTENT', 'RID') THEN 
									SUBSTRING
									(
										tl.resource_description, 
										CHARINDEX(':', tl.resource_description) + 1, 
										COALESCE
										(
											NULLIF
											(
												CHARINDEX(':', tl.resource_description, CHARINDEX(':', tl.resource_description) + 1), 
												0
											), 
											DATALENGTH(tl.resource_description)+1
										) - (CHARINDEX(':', tl.resource_description) + 1)
									)
								ELSE NULL
							END
						) AS page_no,
						CASE
							WHEN tl.resource_type IN ('PAGE', 'KEY', 'RID', 'HOBT') THEN tl.resource_associated_entity_id
							ELSE NULL
						END AS hobt_id,
						CASE
							WHEN tl.resource_type = 'ALLOCATION_UNIT' THEN tl.resource_associated_entity_id
							ELSE NULL
						END AS allocation_unit_id,
						CONVERT
						(
							INT,
							CASE
								WHEN
									/*TODO: Deal with server principals*/ 
									tl.resource_subtype <> 'SERVER_PRINCIPAL' 
									AND tl.resource_description LIKE '%index_id or stats_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23)
										)
									)
								ELSE NULL
							END 
						) AS index_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_description LIKE '%schema_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('schema_id = ', tl.resource_description) + 12), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('schema_id = ', tl.resource_description) + 12), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('schema_id = ', tl.resource_description) + 12)
										)
									)
								ELSE NULL
							END 
						) AS schema_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_description LIKE '%principal_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('principal_id = ', tl.resource_description) + 15), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('principal_id = ', tl.resource_description) + 15), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('principal_id = ', tl.resource_description) + 15)
										)
									)
								ELSE NULL
							END
						) AS principal_id,
						tl.request_mode,
						tl.request_status,
						tl.request_session_id AS session_id,
						tl.request_request_id AS request_id,

						/*TODO: Applocks, other resource_descriptions*/
						RTRIM(tl.resource_description) AS resource_description,
						tl.resource_associated_entity_id
						/*********************************************/
					FROM 
					(
						SELECT 
							request_session_id,
							CONVERT(VARCHAR(120), resource_type) COLLATE Latin1_General_Bin2 AS resource_type,
							CONVERT(VARCHAR(120), resource_subtype) COLLATE Latin1_General_Bin2 AS resource_subtype,
							resource_database_id,
							CONVERT(VARCHAR(512), resource_description) COLLATE Latin1_General_Bin2 AS resource_description,
							resource_associated_entity_id,
							CONVERT(VARCHAR(120), request_mode) COLLATE Latin1_General_Bin2 AS request_mode,
							CONVERT(VARCHAR(120), request_status) COLLATE Latin1_General_Bin2 AS request_status,
							request_request_id
						FROM sys.dm_tran_locks
					) AS tl
				) AS x
				GROUP BY
					x.resource_type,
					x.database_name,
					x.object_id,
					x.file_id,
					CASE
						WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN 'PFS'
						WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN 'GAM'
						WHEN x.page_no = 3 OR (x.page_no - 1) % 511232 = 0 THEN 'SGAM'
						WHEN x.page_no = 6 OR (x.page_no - 6) % 511232 = 0 THEN 'DCM'
						WHEN x.page_no = 7 OR (x.page_no - 7) % 511232 = 0 THEN 'BCM'
						WHEN x.page_no IS NOT NULL THEN '*'
						ELSE NULL
					END,
					x.hobt_id,
					x.allocation_unit_id,
					x.index_id,
					x.schema_id,
					x.principal_id,
					x.request_mode,
					x.request_status,
					x.session_id,
					x.request_id,
					CASE
						WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '')
						ELSE NULL
					END
			) AS y ON
				y.session_id = s.session_id
				AND y.request_id = s.request_id
			OPTION (HASH GROUP);

			--Disable unnecessary autostats on the table
			CREATE STATISTICS s_database_name ON #locks (database_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_id ON #locks (object_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_hobt_id ON #locks (hobt_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_allocation_unit_id ON #locks (allocation_unit_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_index_id ON #locks (index_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_id ON #locks (schema_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_principal_id ON #locks (principal_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_id ON #locks (request_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_start_time ON #locks (start_time)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_resource_type ON #locks (resource_type)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_name ON #locks (object_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_name ON #locks (schema_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_page_type ON #locks (page_type)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_mode ON #locks (request_mode)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_status ON #locks (request_status)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_resource_description ON #locks (resource_description)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_index_name ON #locks (index_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_principal_name ON #locks (principal_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
		END;
		
		DECLARE 
			@sql VARCHAR(MAX), 
			@sql_n NVARCHAR(MAX);

		SET @sql = 
			CONVERT(VARCHAR(MAX), '') +
			'DECLARE @blocker BIT;
			SET @blocker = 0;
			DECLARE @i INT;
			SET @i = 2147483647;

			DECLARE @sessions TABLE
			(
				session_id SMALLINT NOT NULL,
				request_id INT NOT NULL,
				login_time DATETIME,
				last_request_end_time DATETIME,
				status VARCHAR(30),
				statement_start_offset INT,
				statement_end_offset INT,
				sql_handle BINARY(20),
				host_name NVARCHAR(128),
				login_name NVARCHAR(128),
				program_name NVARCHAR(128),
				database_id SMALLINT,
				memory_usage INT,
				open_tran_count SMALLINT, 
				' +
				CASE
					WHEN 
					(
						@get_task_info <> 0 
						OR @find_block_leaders = 1 
					) THEN
						'wait_type NVARCHAR(32),
						wait_resource NVARCHAR(256),
						wait_time BIGINT, 
						'
					ELSE 
						''
				END +
				'blocked SMALLINT,
				is_user_process BIT,
				cmd VARCHAR(32),
				PRIMARY KEY CLUSTERED (session_id, request_id) WITH (IGNORE_DUP_KEY = ON)
			);

			DECLARE @blockers TABLE
			(
				session_id INT NOT NULL PRIMARY KEY WITH (IGNORE_DUP_KEY = ON)
			);

			BLOCKERS:;

			INSERT @sessions
			(
				session_id,
				request_id,
				login_time,
				last_request_end_time,
				status,
				statement_start_offset,
				statement_end_offset,
				sql_handle,
				host_name,
				login_name,
				program_name,
				database_id,
				memory_usage,
				open_tran_count, 
				' +
				CASE
					WHEN 
					(
						@get_task_info <> 0
						OR @find_block_leaders = 1 
					) THEN
						'wait_type,
						wait_resource,
						wait_time, 
						'
					ELSE
						''
				END +
				'blocked,
				is_user_process,
				cmd 
			)
			SELECT TOP(@i)
				spy.session_id,
				spy.request_id,
				spy.login_time,
				spy.last_request_end_time,
				spy.status,
				spy.statement_start_offset,
				spy.statement_end_offset,
				spy.sql_handle,
				spy.host_name,
				spy.login_name,
				spy.program_name,
				spy.database_id,
				spy.memory_usage,
				spy.open_tran_count,
				' +
				CASE
					WHEN 
					(
						@get_task_info <> 0  
						OR @find_block_leaders = 1 
					) THEN
						'spy.wait_type,
						CASE
							WHEN
								spy.wait_type LIKE N''PAGE%LATCH_%''
								OR spy.wait_type = N''CXPACKET''
								OR spy.wait_type LIKE N''LATCH[_]%''
								OR spy.wait_type = N''OLEDB'' THEN
									spy.wait_resource
							ELSE
								NULL
						END AS wait_resource,
						spy.wait_time, 
						'
					ELSE
						''
				END +
				'spy.blocked,
				spy.is_user_process,
				spy.cmd
			FROM
			(
				SELECT TOP(@i)
					spx.*, 
					' +
					CASE
						WHEN 
						(
							@get_task_info <> 0 
							OR @find_block_leaders = 1 
						) THEN
							'ROW_NUMBER() OVER
							(
								PARTITION BY
									spx.session_id,
									spx.request_id
								ORDER BY
									CASE
										WHEN spx.wait_type LIKE N''LCK[_]%'' THEN 
											1
										ELSE
											99
									END,
									spx.wait_time DESC,
									spx.blocked DESC
							) AS r 
							'
						ELSE 
							'1 AS r 
							'
					END +
				'FROM
				(
					SELECT TOP(@i)
						sp0.session_id,
						sp0.request_id,
						sp0.login_time,
						sp0.last_request_end_time,
						LOWER(sp0.status) AS status,
						CASE
							WHEN sp0.cmd = ''CREATE INDEX'' THEN
								0
							ELSE
								sp0.stmt_start
						END AS statement_start_offset,
						CASE
							WHEN sp0.cmd = N''CREATE INDEX'' THEN
								-1
							ELSE
								COALESCE(NULLIF(sp0.stmt_end, 0), -1)
						END AS statement_end_offset,
						sp0.sql_handle,
						sp0.host_name,
						sp0.login_name,
						sp0.program_name,
						sp0.database_id,
						sp0.memory_usage,
						sp0.open_tran_count, 
						' +
						CASE
							WHEN 
							(
								@get_task_info <> 0 
								OR @find_block_leaders = 1 
							) THEN
								'CASE
									WHEN sp0.wait_time > 0 AND sp0.wait_type <> N''CXPACKET'' THEN
										sp0.wait_type
									ELSE
										NULL
								END AS wait_type,
								CASE
									WHEN sp0.wait_time > 0 AND sp0.wait_type <> N''CXPACKET'' THEN 
										sp0.wait_resource
									ELSE
										NULL
								END AS wait_resource,
								CASE
									WHEN sp0.wait_type <> N''CXPACKET'' THEN
										sp0.wait_time
									ELSE
										0
								END AS wait_time, 
								'
							ELSE
								''
						END +
						'sp0.blocked,
						sp0.is_user_process,
						sp0.cmd
					FROM
					(
						SELECT TOP(@i)
							sp1.session_id,
							sp1.request_id,
							sp1.login_time,
							sp1.last_request_end_time,
							sp1.status,
							sp1.cmd,
							sp1.stmt_start,
							sp1.stmt_end,
							MAX(NULLIF(sp1.sql_handle, 0x00)) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS sql_handle,
							sp1.host_name,
							MAX(sp1.login_name) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS login_name,
							sp1.program_name,
							sp1.database_id,
							MAX(sp1.memory_usage)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS memory_usage,
							MAX(sp1.open_tran_count)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS open_tran_count,
							sp1.wait_type,
							sp1.wait_resource,
							sp1.wait_time,
							sp1.blocked,
							sp1.hostprocess,
							sp1.is_user_process
						FROM
						(
							SELECT TOP(@i)
								sp2.spid AS session_id,
								CASE sp2.status
									WHEN ''sleeping'' THEN
										CONVERT(INT, 0)
									ELSE
										sp2.request_id
								END AS request_id,
								MAX(sp2.login_time) AS login_time,
								MAX(sp2.last_batch) AS last_request_end_time,
								MAX(CONVERT(VARCHAR(30), RTRIM(sp2.status)) COLLATE Latin1_General_Bin2) AS status,
								MAX(CONVERT(VARCHAR(32), RTRIM(sp2.cmd)) COLLATE Latin1_General_Bin2) AS cmd,
								MAX(sp2.stmt_start) AS stmt_start,
								MAX(sp2.stmt_end) AS stmt_end,
								MAX(sp2.sql_handle) AS sql_handle,
								MAX(CONVERT(sysname, RTRIM(sp2.hostname)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS host_name,
								MAX(CONVERT(sysname, RTRIM(sp2.loginame)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS login_name,
								MAX
								(
									CASE
										WHEN blk.queue_id IS NOT NULL THEN
											N''Service Broker
												database_id: '' + CONVERT(NVARCHAR, blk.database_id) +
												N'' queue_id: '' + CONVERT(NVARCHAR, blk.queue_id)
										ELSE
											CONVERT
											(
												sysname,
												RTRIM(sp2.program_name)
											)
									END COLLATE SQL_Latin1_General_CP1_CI_AS
								) AS program_name,
								MAX(sp2.dbid) AS database_id,
								MAX(sp2.memusage) AS memory_usage,
								MAX(sp2.open_tran) AS open_tran_count,
								RTRIM(sp2.lastwaittype) AS wait_type,
								RTRIM(sp2.waitresource) AS wait_resource,
								MAX(sp2.waittime) AS wait_time,
								COALESCE(NULLIF(sp2.blocked, sp2.spid), 0) AS blocked,
								MAX
								(
									CASE
										WHEN blk.session_id = sp2.spid THEN
											''blocker''
										ELSE
											RTRIM(sp2.hostprocess)
									END
								) AS hostprocess,
								CONVERT
								(
									BIT,
									MAX
									(
										CASE
											WHEN sp2.hostprocess > '''' THEN
												1
											ELSE
												0
										END
									)
								) AS is_user_process
							FROM
							(
								SELECT TOP(@i)
									session_id,
									CONVERT(INT, NULL) AS queue_id,
									CONVERT(INT, NULL) AS database_id
								FROM @blockers

								UNION ALL

								SELECT TOP(@i)
									CONVERT(SMALLINT, 0),
									CONVERT(INT, NULL) AS queue_id,
									CONVERT(INT, NULL) AS database_id
								WHERE
									@blocker = 0

								UNION ALL

								SELECT TOP(@i)
									CONVERT(SMALLINT, spid),
									queue_id,
									database_id
								FROM sys.dm_broker_activated_tasks
								WHERE
									@blocker = 0
							) AS blk
							INNER JOIN sys.sysprocesses AS sp2 ON
								sp2.spid = blk.session_id
								OR
								(
									blk.session_id = 0
									AND @blocker = 0
								)
							' +
							CASE 
								WHEN 
								(
									@get_task_info = 0 
									AND @find_block_leaders = 0
								) THEN
									'WHERE
										sp2.ecid = 0 
									' 
								ELSE
									''
							END +
							'GROUP BY
								sp2.spid,
								CASE sp2.status
									WHEN ''sleeping'' THEN
										CONVERT(INT, 0)
									ELSE
										sp2.request_id
								END,
								RTRIM(sp2.lastwaittype),
								RTRIM(sp2.waitresource),
								COALESCE(NULLIF(sp2.blocked, sp2.spid), 0)
						) AS sp1
					) AS sp0
					WHERE
						@blocker = 1
						OR
						(1=1 
						' +
							--inclusive filter
							CASE
								WHEN @filter <> '' THEN
									CASE @filter_type
										WHEN 'session' THEN
											CASE
												WHEN CONVERT(SMALLINT, @filter) <> 0 THEN
													'AND sp0.session_id = CONVERT(SMALLINT, @filter) 
													'
												ELSE
													''
											END
										WHEN 'program' THEN
											'AND sp0.program_name LIKE @filter 
											'
										WHEN 'login' THEN
											'AND sp0.login_name LIKE @filter 
											'
										WHEN 'host' THEN
											'AND sp0.host_name LIKE @filter 
											'
										WHEN 'database' THEN
											'AND DB_NAME(sp0.database_id) LIKE @filter 
											'
										ELSE
											''
									END
								ELSE
									''
							END +
							--exclusive filter
							CASE
								WHEN @not_filter <> '' THEN
									CASE @not_filter_type
										WHEN 'session' THEN
											CASE
												WHEN CONVERT(SMALLINT, @not_filter) <> 0 THEN
													'AND sp0.session_id <> CONVERT(SMALLINT, @not_filter) 
													'
												ELSE
													''
											END
										WHEN 'program' THEN
											'AND sp0.program_name NOT LIKE @not_filter 
											'
										WHEN 'login' THEN
											'AND sp0.login_name NOT LIKE @not_filter 
											'
										WHEN 'host' THEN
											'AND sp0.host_name NOT LIKE @not_filter 
											'
										WHEN 'database' THEN
											'AND DB_NAME(sp0.database_id) NOT LIKE @not_filter 
											'
										ELSE
											''
									END
								ELSE
									''
							END +
							CASE @show_own_spid
								WHEN 1 THEN
									''
								ELSE
									'AND sp0.session_id <> @@spid 
									'
							END +
							CASE 
								WHEN @show_system_spids = 0 THEN
									'AND sp0.hostprocess > '''' 
									' 
								ELSE
									''
							END +
							CASE @show_sleeping_spids
								WHEN 0 THEN
									'AND sp0.status <> ''sleeping'' 
									'
								WHEN 1 THEN
									'AND
									(
										sp0.status <> ''sleeping''
										OR sp0.open_tran_count > 0
									)
									'
								ELSE
									''
							END +
						')
				) AS spx
			) AS spy
			WHERE
				spy.r = 1; 
			' + 
			CASE @recursion
				WHEN 1 THEN 
					'IF @@ROWCOUNT > 0
					BEGIN;
						INSERT @blockers
						(
							session_id
						)
						SELECT TOP(@i)
							blocked
						FROM @sessions
						WHERE
							NULLIF(blocked, 0) IS NOT NULL

						EXCEPT

						SELECT TOP(@i)
							session_id
						FROM @sessions; 
						' +

						CASE
							WHEN
							(
								@get_task_info > 0
								OR @find_block_leaders = 1
							) THEN
								'IF @@ROWCOUNT > 0
								BEGIN;
									SET @blocker = 1;
									GOTO BLOCKERS;
								END; 
								'
							ELSE 
								''
						END +
					'END; 
					'
				ELSE 
					''
			END +
			'SELECT TOP(@i)
				@recursion AS recursion,
				x.session_id,
				x.request_id,
				DENSE_RANK() OVER
				(
					ORDER BY
						x.session_id
				) AS session_number,
				' +
				CASE
					WHEN @output_column_list LIKE '%|[dd hh:mm:ss.mss|]%' ESCAPE '|' THEN 
						'x.elapsed_time '
					ELSE 
						'0 '
				END + 
					'AS elapsed_time, 
					' +
				CASE
					WHEN
						(
							@output_column_list LIKE '%|[dd hh:mm:ss.mss (avg)|]%' ESCAPE '|' OR 
							@output_column_list LIKE '%|[avg_elapsed_time|]%' ESCAPE '|'
						)
						AND @recursion = 1
							THEN 
								'x.avg_elapsed_time / 1000 '
					ELSE 
						'NULL '
				END + 
					'AS avg_elapsed_time, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[physical_io|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[physical_io_delta|]%' ESCAPE '|'
							THEN 
								'x.physical_io '
					ELSE 
						'NULL '
				END + 
					'AS physical_io, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[reads|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[reads_delta|]%' ESCAPE '|'
							THEN 
								'x.reads '
					ELSE 
						'0 '
				END + 
					'AS reads, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[physical_reads|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[physical_reads_delta|]%' ESCAPE '|'
							THEN 
								'x.physical_reads '
					ELSE 
						'0 '
				END + 
					'AS physical_reads, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[writes|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[writes_delta|]%' ESCAPE '|'
							THEN 
								'x.writes '
					ELSE 
						'0 '
				END + 
					'AS writes, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tempdb_allocations|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[tempdb_allocations_delta|]%' ESCAPE '|'
							THEN 
								'x.tempdb_allocations '
					ELSE 
						'0 '
				END + 
					'AS tempdb_allocations, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tempdb_current|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[tempdb_current_delta|]%' ESCAPE '|'
							THEN 
								'x.tempdb_current '
					ELSE 
						'0 '
				END + 
					'AS tempdb_current, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[CPU|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
							THEN
								'x.CPU '
					ELSE
						'0 '
				END + 
					'AS CPU, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
						AND @get_task_info = 2
						AND @sys_info = 1
							THEN 
								'x.thread_CPU_snapshot '
					ELSE 
						'0 '
				END + 
					'AS thread_CPU_snapshot, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[context_switches|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[context_switches_delta|]%' ESCAPE '|'
							THEN 
								'x.context_switches '
					ELSE 
						'NULL '
				END + 
					'AS context_switches, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[used_memory|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[used_memory_delta|]%' ESCAPE '|'
							THEN 
								'x.used_memory '
					ELSE 
						'0 '
				END + 
					'AS used_memory, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tasks|]%' ESCAPE '|'
						AND @recursion = 1
							THEN 
								'x.tasks '
					ELSE 
						'NULL '
				END + 
					'AS tasks, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[status|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[sql_command|]%' ESCAPE '|'
						)
						AND @recursion = 1
							THEN 
								'x.status '
					ELSE 
						''''' '
				END + 
					'AS status, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[wait_info|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								CASE @get_task_info
									WHEN 2 THEN
										'COALESCE(x.task_wait_info, x.sys_wait_info) '
									ELSE
										'x.sys_wait_info '
								END
					ELSE 
						'NULL '
				END + 
					'AS wait_info, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[tran_start_time|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[tran_log_writes|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
								'x.transaction_id '
					ELSE 
						'NULL '
				END + 
					'AS transaction_id, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[open_tran_count|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.open_tran_count '
					ELSE 
						'NULL '
				END + 
					'AS open_tran_count, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.sql_handle '
					ELSE 
						'NULL '
				END + 
					'AS sql_handle, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
								'x.statement_start_offset '
					ELSE 
						'NULL '
				END + 
					'AS statement_start_offset, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
								'x.statement_end_offset '
					ELSE 
						'NULL '
				END + 
					'AS statement_end_offset, 
					' +
				'NULL AS sql_text, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.plan_handle '
					ELSE 
						'NULL '
				END + 
					'AS plan_handle, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[blocking_session_id|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'NULLIF(x.blocking_session_id, 0) '
					ELSE 
						'NULL '
				END + 
					'AS blocking_session_id, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[percent_complete|]%' ESCAPE '|'
						AND @recursion = 1
							THEN 
								'x.percent_complete '
					ELSE 
						'NULL '
				END + 
					'AS percent_complete, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[host_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.host_name '
					ELSE 
						''''' '
				END + 
					'AS host_name, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[login_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.login_name '
					ELSE 
						''''' '
				END + 
					'AS login_name, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[database_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'DB_NAME(x.database_id) '
					ELSE 
						'NULL '
				END + 
					'AS database_name, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[program_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.program_name '
					ELSE 
						''''' '
				END + 
					'AS program_name, 
					' +
				CASE
					WHEN
						@output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
						AND @recursion = 1
							THEN
								'(
									SELECT TOP(@i)
										x.text_size,
										x.language,
										x.date_format,
										x.date_first,
										CASE x.quoted_identifier
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS quoted_identifier,
										CASE x.arithabort
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS arithabort,
										CASE x.ansi_null_dflt_on
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_null_dflt_on,
										CASE x.ansi_defaults
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_defaults,
										CASE x.ansi_warnings
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_warnings,
										CASE x.ansi_padding
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_padding,
										CASE ansi_nulls
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_nulls,
										CASE x.concat_null_yields_null
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS concat_null_yields_null,
										CASE x.transaction_isolation_level
											WHEN 0 THEN ''Unspecified''
											WHEN 1 THEN ''ReadUncomitted''
											WHEN 2 THEN ''ReadCommitted''
											WHEN 3 THEN ''Repeatable''
											WHEN 4 THEN ''Serializable''
											WHEN 5 THEN ''Snapshot''
										END AS transaction_isolation_level,
										x.lock_timeout,
										x.deadlock_priority,
										x.row_count,
										x.command_type, 
										' +
										CASE
											WHEN OBJECT_ID('master.dbo.fn_varbintohexstr') IS NOT NULL THEN
												'master.dbo.fn_varbintohexstr(x.sql_handle) AS sql_handle,
												master.dbo.fn_varbintohexstr(x.plan_handle) AS plan_handle,'
											ELSE
												'CONVERT(VARCHAR(256), x.sql_handle, 1) AS sql_handle,
												CONVERT(VARCHAR(256), x.plan_handle, 1) AS plan_handle,'
										END +
										'
										x.statement_start_offset,
										x.statement_end_offset,
										' +
										CASE
											WHEN @output_column_list LIKE '%|[program_name|]%' ESCAPE '|' THEN
												'(
													SELECT TOP(1)
														CONVERT(uniqueidentifier, CONVERT(XML, '''').value(''xs:hexBinary( substring(sql:column("agent_info.job_id_string"), 0) )'', ''binary(16)'')) AS job_id,
														agent_info.step_id,
														(
															SELECT TOP(1)
																NULL
															FOR XML
																PATH(''job_name''),
																TYPE
														),
														(
															SELECT TOP(1)
																NULL
															FOR XML
																PATH(''step_name''),
																TYPE
														)
													FROM
													(
														SELECT TOP(1)
															SUBSTRING(x.program_name, CHARINDEX(''0x'', x.program_name) + 2, 32) AS job_id_string,
															SUBSTRING(x.program_name, CHARINDEX('': Step '', x.program_name) + 7, CHARINDEX('')'', x.program_name, CHARINDEX('': Step '', x.program_name)) - (CHARINDEX('': Step '', x.program_name) + 7)) AS step_id
														WHERE
															x.program_name LIKE N''SQLAgent - TSQL JobStep (Job 0x%''
													) AS agent_info
													FOR XML
														PATH(''agent_job_info''),
														TYPE
												),
												'
											ELSE ''
										END +
										CASE
											WHEN @get_task_info = 2 THEN
												'CONVERT(XML, x.block_info) AS block_info, 
												'
											ELSE
												''
										END + '
										x.host_process_id,
										x.group_id
									FOR XML
										PATH(''additional_info''),
										TYPE
								) '
					ELSE
						'NULL '
				END + 
					'AS additional_info, 
				x.start_time, 
					' +
				CASE
					WHEN
						@output_column_list LIKE '%|[login_time|]%' ESCAPE '|'
						AND @recursion = 1
							THEN
								'x.login_time '
					ELSE 
						'NULL '
				END + 
					'AS login_time, 
				x.last_request_start_time
			FROM
			(
				SELECT TOP(@i)
					y.*,
					CASE
						WHEN DATEDIFF(hour, y.start_time, GETDATE()) > 576 THEN
							DATEDIFF(second, GETDATE(), y.start_time)
						ELSE DATEDIFF(ms, y.start_time, GETDATE())
					END AS elapsed_time,
					COALESCE(tempdb_info.tempdb_allocations, 0) AS tempdb_allocations,
					COALESCE
					(
						CASE
							WHEN tempdb_info.tempdb_current < 0 THEN 0
							ELSE tempdb_info.tempdb_current
						END,
						0
					) AS tempdb_current, 
					' +
					CASE
						WHEN 
							(
								@get_task_info <> 0
								OR @find_block_leaders = 1
							) THEN
								'N''('' + CONVERT(NVARCHAR, y.wait_duration_ms) + N''ms)'' +
									y.wait_type +
										CASE
											WHEN y.wait_type LIKE N''PAGE%LATCH_%'' THEN
												N'':'' +
												COALESCE(DB_NAME(CONVERT(INT, LEFT(y.resource_description, CHARINDEX(N'':'', y.resource_description) - 1))), N''(null)'') +
												N'':'' +
												SUBSTRING(y.resource_description, CHARINDEX(N'':'', y.resource_description) + 1, LEN(y.resource_description) - CHARINDEX(N'':'', REVERSE(y.resource_description)) - CHARINDEX(N'':'', y.resource_description)) +
												N''('' +
													CASE
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 1 OR
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 8088 = 0
																THEN 
																	N''PFS''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 2 OR
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 511232 = 0
																THEN 
																	N''GAM''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 3 OR
															(CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) - 1) % 511232 = 0
																THEN
																	N''SGAM''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 6 OR
															(CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) - 6) % 511232 = 0 
																THEN 
																	N''DCM''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 7 OR
															(CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) - 7) % 511232 = 0 
																THEN 
																	N''BCM''
														ELSE 
															N''*''
													END +
												N'')''
											WHEN y.wait_type = N''CXPACKET'' THEN
												N'':'' + SUBSTRING(y.resource_description, CHARINDEX(N''nodeId'', y.resource_description) + 7, 4)
											WHEN y.wait_type LIKE N''LATCH[_]%'' THEN
												N'' ['' + LEFT(y.resource_description, COALESCE(NULLIF(CHARINDEX(N'' '', y.resource_description), 0), LEN(y.resource_description) + 1) - 1) + N'']''
											WHEN
												y.wait_type = N''OLEDB''
												AND y.resource_description LIKE N''%(SPID=%)'' THEN
													N''['' + LEFT(y.resource_description, CHARINDEX(N''(SPID='', y.resource_description) - 2) +
														N'':'' + SUBSTRING(y.resource_description, CHARINDEX(N''(SPID='', y.resource_description) + 6, CHARINDEX(N'')'', y.resource_description, (CHARINDEX(N''(SPID='', y.resource_description) + 6)) - (CHARINDEX(N''(SPID='', y.resource_description) + 6)) + '']''
											ELSE
												N''''
										END COLLATE Latin1_General_Bin2 AS sys_wait_info, 
										'
							ELSE
								''
						END +
						CASE
							WHEN @get_task_info = 2 THEN
								'tasks.physical_io,
								tasks.context_switches,
								tasks.tasks,
								tasks.block_info,
								tasks.wait_info AS task_wait_info,
								tasks.thread_CPU_snapshot,
								'
							ELSE
								'' 
					END +
					CASE 
						WHEN NOT (@get_avg_time = 1 AND @recursion = 1) THEN
							'CONVERT(INT, NULL) '
						ELSE 
							'qs.total_elapsed_time / qs.execution_count '
					END + 
						'AS avg_elapsed_time 
				FROM
				(
					SELECT TOP(@i)
						sp.session_id,
						sp.request_id,
						COALESCE(r.logical_reads, s.logical_reads) AS reads,
						COALESCE(r.reads, s.reads) AS physical_reads,
						COALESCE(r.writes, s.writes) AS writes,
						COALESCE(r.CPU_time, s.CPU_time) AS CPU,
						sp.memory_usage + COALESCE(r.granted_query_memory, 0) AS used_memory,
						LOWER(sp.status) AS status,
						COALESCE(r.sql_handle, sp.sql_handle) AS sql_handle,
						COALESCE(r.statement_start_offset, sp.statement_start_offset) AS statement_start_offset,
						COALESCE(r.statement_end_offset, sp.statement_end_offset) AS statement_end_offset,
						' +
						CASE
							WHEN 
							(
								@get_task_info <> 0
								OR @find_block_leaders = 1 
							) THEN
								'sp.wait_type COLLATE Latin1_General_Bin2 AS wait_type,
								sp.wait_resource COLLATE Latin1_General_Bin2 AS resource_description,
								sp.wait_time AS wait_duration_ms, 
								'
							ELSE
								''
						END +
						'NULLIF(sp.blocked, 0) AS blocking_session_id,
						r.plan_handle,
						NULLIF(r.percent_complete, 0) AS percent_complete,
						sp.host_name,
						sp.login_name,
						sp.program_name,
						s.host_process_id,
						COALESCE(r.text_size, s.text_size) AS text_size,
						COALESCE(r.language, s.language) AS language,
						COALESCE(r.date_format, s.date_format) AS date_format,
						COALESCE(r.date_first, s.date_first) AS date_first,
						COALESCE(r.quoted_identifier, s.quoted_identifier) AS quoted_identifier,
						COALESCE(r.arithabort, s.arithabort) AS arithabort,
						COALESCE(r.ansi_null_dflt_on, s.ansi_null_dflt_on) AS ansi_null_dflt_on,
						COALESCE(r.ansi_defaults, s.ansi_defaults) AS ansi_defaults,
						COALESCE(r.ansi_warnings, s.ansi_warnings) AS ansi_warnings,
						COALESCE(r.ansi_padding, s.ansi_padding) AS ansi_padding,
						COALESCE(r.ansi_nulls, s.ansi_nulls) AS ansi_nulls,
						COALESCE(r.concat_null_yields_null, s.concat_null_yields_null) AS concat_null_yields_null,
						COALESCE(r.transaction_isolation_level, s.transaction_isolation_level) AS transaction_isolation_level,
						COALESCE(r.lock_timeout, s.lock_timeout) AS lock_timeout,
						COALESCE(r.deadlock_priority, s.deadlock_priority) AS deadlock_priority,
						COALESCE(r.row_count, s.row_count) AS row_count,
						COALESCE(r.command, sp.cmd) AS command_type,
						COALESCE
						(
							CASE
								WHEN
								(
									s.is_user_process = 0
									AND r.total_elapsed_time >= 0
								) THEN
									DATEADD
									(
										ms,
										1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
										DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
									)
							END,
							NULLIF(COALESCE(r.start_time, sp.last_request_end_time), CONVERT(DATETIME, ''19000101'', 112)),
							sp.login_time
						) AS start_time,
						sp.login_time,
						CASE
							WHEN s.is_user_process = 1 THEN
								s.last_request_start_time
							ELSE
								COALESCE
								(
									DATEADD
									(
										ms,
										1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
										DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
									),
									s.last_request_start_time
								)
						END AS last_request_start_time,
						r.transaction_id,
						sp.database_id,
						sp.open_tran_count,
						' +
							CASE
								WHEN EXISTS
								(
									SELECT
										*
									FROM sys.all_columns AS ac
									WHERE
										ac.object_id = OBJECT_ID('sys.dm_exec_sessions')
										AND ac.name = 'group_id'
								)
									THEN 's.group_id'
								ELSE 'CONVERT(INT, NULL) AS group_id'
							END + '
					FROM @sessions AS sp
					LEFT OUTER LOOP JOIN sys.dm_exec_sessions AS s ON
						s.session_id = sp.session_id
						AND s.login_time = sp.login_time
					LEFT OUTER LOOP JOIN sys.dm_exec_requests AS r ON
						sp.status <> ''sleeping''
						AND r.session_id = sp.session_id
						AND r.request_id = sp.request_id
						AND
						(
							(
								s.is_user_process = 0
								AND sp.is_user_process = 0
							)
							OR
							(
								r.start_time = s.last_request_start_time
								AND s.last_request_end_time <= sp.last_request_end_time
							)
						)
				) AS y
				' + 
				CASE 
					WHEN @get_task_info = 2 THEN
						CONVERT(VARCHAR(MAX), '') +
						'LEFT OUTER HASH JOIN
						(
							SELECT TOP(@i)
								task_nodes.task_node.value(''(session_id/text())[1]'', ''SMALLINT'') AS session_id,
								task_nodes.task_node.value(''(request_id/text())[1]'', ''INT'') AS request_id,
								task_nodes.task_node.value(''(physical_io/text())[1]'', ''BIGINT'') AS physical_io,
								task_nodes.task_node.value(''(context_switches/text())[1]'', ''BIGINT'') AS context_switches,
								task_nodes.task_node.value(''(tasks/text())[1]'', ''INT'') AS tasks,
								task_nodes.task_node.value(''(block_info/text())[1]'', ''NVARCHAR(4000)'') AS block_info,
								task_nodes.task_node.value(''(waits/text())[1]'', ''NVARCHAR(4000)'') AS wait_info,
								task_nodes.task_node.value(''(thread_CPU_snapshot/text())[1]'', ''BIGINT'') AS thread_CPU_snapshot
							FROM
							(
								SELECT TOP(@i)
									CONVERT
									(
										XML,
										REPLACE
										(
											CONVERT(NVARCHAR(MAX), tasks_raw.task_xml_raw) COLLATE Latin1_General_Bin2,
											N''</waits></tasks><tasks><waits>'',
											N'', ''
										)
									) AS task_xml
								FROM
								(
									SELECT TOP(@i)
										CASE waits.r
											WHEN 1 THEN
												waits.session_id
											ELSE
												NULL
										END AS [session_id],
										CASE waits.r
											WHEN 1 THEN
												waits.request_id
											ELSE
												NULL
										END AS [request_id],											
										CASE waits.r
											WHEN 1 THEN
												waits.physical_io
											ELSE
												NULL
										END AS [physical_io],
										CASE waits.r
											WHEN 1 THEN
												waits.context_switches
											ELSE
												NULL
										END AS [context_switches],
										CASE waits.r
											WHEN 1 THEN
												waits.thread_CPU_snapshot
											ELSE
												NULL
										END AS [thread_CPU_snapshot],
										CASE waits.r
											WHEN 1 THEN
												waits.tasks
											ELSE
												NULL
										END AS [tasks],
										CASE waits.r
											WHEN 1 THEN
												waits.block_info
											ELSE
												NULL
										END AS [block_info],
										REPLACE
										(
											REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
											REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
											REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												CONVERT
												(
													NVARCHAR(MAX),
													N''('' +
														CONVERT(NVARCHAR, num_waits) + N''x: '' +
														CASE num_waits
															WHEN 1 THEN
																CONVERT(NVARCHAR, min_wait_time) + N''ms''
															WHEN 2 THEN
																CASE
																	WHEN min_wait_time <> max_wait_time THEN
																		CONVERT(NVARCHAR, min_wait_time) + N''/'' + CONVERT(NVARCHAR, max_wait_time) + N''ms''
																	ELSE
																		CONVERT(NVARCHAR, max_wait_time) + N''ms''
																END
															ELSE
																CASE
																	WHEN min_wait_time <> max_wait_time THEN
																		CONVERT(NVARCHAR, min_wait_time) + N''/'' + CONVERT(NVARCHAR, avg_wait_time) + N''/'' + CONVERT(NVARCHAR, max_wait_time) + N''ms''
																	ELSE 
																		CONVERT(NVARCHAR, max_wait_time) + N''ms''
																END
														END +
													N'')'' + wait_type COLLATE Latin1_General_Bin2
												),
												NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
												NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
												NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
											NCHAR(0),
											N''''
										) AS [waits]
									FROM
									(
										SELECT TOP(@i)
											w1.*,
											ROW_NUMBER() OVER
											(
												PARTITION BY
													w1.session_id,
													w1.request_id
												ORDER BY
													w1.block_info DESC,
													w1.num_waits DESC,
													w1.wait_type
											) AS r
										FROM
										(
											SELECT TOP(@i)
												task_info.session_id,
												task_info.request_id,
												task_info.physical_io,
												task_info.context_switches,
												task_info.thread_CPU_snapshot,
												task_info.num_tasks AS tasks,
												CASE
													WHEN task_info.runnable_time IS NOT NULL THEN
														''RUNNABLE''
													ELSE
														wt2.wait_type
												END AS wait_type,
												NULLIF(COUNT(COALESCE(task_info.runnable_time, wt2.waiting_task_address)), 0) AS num_waits,
												MIN(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS min_wait_time,
												AVG(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS avg_wait_time,
												MAX(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS max_wait_time,
												MAX(wt2.block_info) AS block_info
											FROM
											(
												SELECT TOP(@i)
													t.session_id,
													t.request_id,
													SUM(CONVERT(BIGINT, t.pending_io_count)) OVER (PARTITION BY t.session_id, t.request_id) AS physical_io,
													SUM(CONVERT(BIGINT, t.context_switches_count)) OVER (PARTITION BY t.session_id, t.request_id) AS context_switches, 
													' +
													CASE
														WHEN 
															@output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
															AND @sys_info = 1
															THEN
																'SUM(tr.usermode_time + tr.kernel_time) OVER (PARTITION BY t.session_id, t.request_id) '
														ELSE
															'CONVERT(BIGINT, NULL) '
													END + 
														' AS thread_CPU_snapshot, 
													COUNT(*) OVER (PARTITION BY t.session_id, t.request_id) AS num_tasks,
													t.task_address,
													t.task_state,
													CASE
														WHEN
															t.task_state = ''RUNNABLE''
															AND w.runnable_time > 0 THEN
																w.runnable_time
														ELSE
															NULL
													END AS runnable_time
												FROM sys.dm_os_tasks AS t
												CROSS APPLY
												(
													SELECT TOP(1)
														sp2.session_id
													FROM @sessions AS sp2
													WHERE
														sp2.session_id = t.session_id
														AND sp2.request_id = t.request_id
														AND sp2.status <> ''sleeping''
												) AS sp20
												LEFT OUTER HASH JOIN
												( 
												' +
													CASE
														WHEN @sys_info = 1 THEN
															'SELECT TOP(@i)
																(
																	SELECT TOP(@i)
																		ms_ticks
																	FROM sys.dm_os_sys_info
																) -
																	w0.wait_resumed_ms_ticks AS runnable_time,
																w0.worker_address,
																w0.thread_address,
																w0.task_bound_ms_ticks
															FROM sys.dm_os_workers AS w0
															WHERE
																w0.state = ''RUNNABLE''
																OR @first_collection_ms_ticks >= w0.task_bound_ms_ticks'
														ELSE
															'SELECT
																CONVERT(BIGINT, NULL) AS runnable_time,
																CONVERT(VARBINARY(8), NULL) AS worker_address,
																CONVERT(VARBINARY(8), NULL) AS thread_address,
																CONVERT(BIGINT, NULL) AS task_bound_ms_ticks
															WHERE
																1 = 0'
														END +
												'
												) AS w ON
													w.worker_address = t.worker_address 
												' +
												CASE
													WHEN
														@output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
														AND @sys_info = 1
														THEN
															'LEFT OUTER HASH JOIN sys.dm_os_threads AS tr ON
																tr.thread_address = w.thread_address
																AND @first_collection_ms_ticks >= w.task_bound_ms_ticks
															'
													ELSE
														''
												END +
											') AS task_info
											LEFT OUTER HASH JOIN
											(
												SELECT TOP(@i)
													wt1.wait_type,
													wt1.waiting_task_address,
													MAX(wt1.wait_duration_ms) AS wait_duration_ms,
													MAX(wt1.block_info) AS block_info
												FROM
												(
													SELECT DISTINCT TOP(@i)
														wt.wait_type +
															CASE
																WHEN wt.wait_type LIKE N''PAGE%LATCH_%'' THEN
																	'':'' +
																	COALESCE(DB_NAME(CONVERT(INT, LEFT(wt.resource_description, CHARINDEX(N'':'', wt.resource_description) - 1))), N''(null)'') +
																	N'':'' +
																	SUBSTRING(wt.resource_description, CHARINDEX(N'':'', wt.resource_description) + 1, LEN(wt.resource_description) - CHARINDEX(N'':'', REVERSE(wt.resource_description)) - CHARINDEX(N'':'', wt.resource_description)) +
																	N''('' +
																		CASE
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 1 OR
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 8088 = 0
																					THEN 
																						N''PFS''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 2 OR
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 511232 = 0 
																					THEN 
																						N''GAM''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 3 OR
																				(CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) - 1) % 511232 = 0 
																					THEN 
																						N''SGAM''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 6 OR
																				(CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) - 6) % 511232 = 0 
																					THEN 
																						N''DCM''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 7 OR
																				(CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) - 7) % 511232 = 0
																					THEN 
																						N''BCM''
																			ELSE
																				N''*''
																		END +
																	N'')''
																WHEN wt.wait_type = N''CXPACKET'' THEN
																	N'':'' + SUBSTRING(wt.resource_description, CHARINDEX(N''nodeId'', wt.resource_description) + 7, 4)
																WHEN wt.wait_type LIKE N''LATCH[_]%'' THEN
																	N'' ['' + LEFT(wt.resource_description, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description), 0), LEN(wt.resource_description) + 1) - 1) + N'']''
																ELSE 
																	N''''
															END COLLATE Latin1_General_Bin2 AS wait_type,
														CASE
															WHEN
															(
																wt.blocking_session_id IS NOT NULL
																AND wt.wait_type LIKE N''LCK[_]%''
															) THEN
																(
																	SELECT TOP(@i)
																		x.lock_type,
																		REPLACE
																		(
																			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
																			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
																			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
																				DB_NAME
																				(
																					CONVERT
																					(
																						INT,
																						SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''dbid='', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''dbid='', wt.resource_description) + 5), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''dbid='', wt.resource_description) - 5)
																					)
																				),
																				NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
																				NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
																				NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
																			NCHAR(0),
																			N''''
																		) AS database_name,
																		CASE x.lock_type
																			WHEN N''objectlock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''objid='', wt.resource_description), 0) + 6, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''objid='', wt.resource_description) + 6), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''objid='', wt.resource_description) - 6)
																			ELSE
																				NULL
																		END AS object_id,
																		CASE x.lock_type
																			WHEN N''filelock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''fileid='', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''fileid='', wt.resource_description) + 7), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''fileid='', wt.resource_description) - 7)
																			ELSE
																				NULL
																		END AS file_id,
																		CASE
																			WHEN x.lock_type in (N''pagelock'', N''extentlock'', N''ridlock'') THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''associatedObjectId='', wt.resource_description), 0) + 19, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''associatedObjectId='', wt.resource_description) + 19), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''associatedObjectId='', wt.resource_description) - 19)
																			WHEN x.lock_type in (N''keylock'', N''hobtlock'', N''allocunitlock'') THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''hobtid='', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''hobtid='', wt.resource_description) + 7), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''hobtid='', wt.resource_description) - 7)
																			ELSE
																				NULL
																		END AS hobt_id,
																		CASE x.lock_type
																			WHEN N''applicationlock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''hash='', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''hash='', wt.resource_description) + 5), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''hash='', wt.resource_description) - 5)
																			ELSE
																				NULL
																		END AS applock_hash,
																		CASE x.lock_type
																			WHEN N''metadatalock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''subresource='', wt.resource_description), 0) + 12, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''subresource='', wt.resource_description) + 12), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''subresource='', wt.resource_description) - 12)
																			ELSE
																				NULL
																		END AS metadata_resource,
																		CASE x.lock_type
																			WHEN N''metadatalock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''classid='', wt.resource_description), 0) + 8, COALESCE(NULLIF(CHARINDEX(N'' dbid='', wt.resource_description) - CHARINDEX(N''classid='', wt.resource_description), 0), LEN(wt.resource_description) + 1) - 8)
																			ELSE
																				NULL
																		END AS metadata_class_id
																	FROM
																	(
																		SELECT TOP(1)
																			LEFT(wt.resource_description, CHARINDEX(N'' '', wt.resource_description) - 1) COLLATE Latin1_General_Bin2 AS lock_type
																	) AS x
																	FOR XML
																		PATH('''')
																)
															ELSE NULL
														END AS block_info,
														wt.wait_duration_ms,
														wt.waiting_task_address
													FROM
													(
														SELECT TOP(@i)
															wt0.wait_type COLLATE Latin1_General_Bin2 AS wait_type,
															wt0.resource_description COLLATE Latin1_General_Bin2 AS resource_description,
															wt0.wait_duration_ms,
															wt0.waiting_task_address,
															CASE
																WHEN wt0.blocking_session_id = p.blocked THEN
																	wt0.blocking_session_id
																ELSE
																	NULL
															END AS blocking_session_id
														FROM sys.dm_os_waiting_tasks AS wt0
														CROSS APPLY
														(
															SELECT TOP(1)
																s0.blocked
															FROM @sessions AS s0
															WHERE
																s0.session_id = wt0.session_id
																AND COALESCE(s0.wait_type, N'''') <> N''OLEDB''
																AND wt0.wait_type <> N''OLEDB''
														) AS p
													) AS wt
												) AS wt1
												GROUP BY
													wt1.wait_type,
													wt1.waiting_task_address
											) AS wt2 ON
												wt2.waiting_task_address = task_info.task_address
												AND wt2.wait_duration_ms > 0
												AND task_info.runnable_time IS NULL
											GROUP BY
												task_info.session_id,
												task_info.request_id,
												task_info.physical_io,
												task_info.context_switches,
												task_info.thread_CPU_snapshot,
												task_info.num_tasks,
												CASE
													WHEN task_info.runnable_time IS NOT NULL THEN
														''RUNNABLE''
													ELSE
														wt2.wait_type
												END
										) AS w1
									) AS waits
									ORDER BY
										waits.session_id,
										waits.request_id,
										waits.r
									FOR XML
										PATH(N''tasks''),
										TYPE
								) AS tasks_raw (task_xml_raw)
							) AS tasks_final
							CROSS APPLY tasks_final.task_xml.nodes(N''/tasks'') AS task_nodes (task_node)
							WHERE
								task_nodes.task_node.exist(N''session_id'') = 1
						) AS tasks ON
							tasks.session_id = y.session_id
							AND tasks.request_id = y.request_id 
						'
					ELSE
						''
				END +
				'LEFT OUTER HASH JOIN
				(
					SELECT TOP(@i)
						t_info.session_id,
						COALESCE(t_info.request_id, -1) AS request_id,
						SUM(t_info.tempdb_allocations) AS tempdb_allocations,
						SUM(t_info.tempdb_current) AS tempdb_current
					FROM
					(
						SELECT TOP(@i)
							tsu.session_id,
							tsu.request_id,
							tsu.user_objects_alloc_page_count +
								tsu.internal_objects_alloc_page_count AS tempdb_allocations,
							tsu.user_objects_alloc_page_count +
								tsu.internal_objects_alloc_page_count -
								tsu.user_objects_dealloc_page_count -
								tsu.internal_objects_dealloc_page_count AS tempdb_current
						FROM sys.dm_db_task_space_usage AS tsu
						CROSS APPLY
						(
							SELECT TOP(1)
								s0.session_id
							FROM @sessions AS s0
							WHERE
								s0.session_id = tsu.session_id
						) AS p

						UNION ALL

						SELECT TOP(@i)
							ssu.session_id,
							NULL AS request_id,
							ssu.user_objects_alloc_page_count +
								ssu.internal_objects_alloc_page_count AS tempdb_allocations,
							ssu.user_objects_alloc_page_count +
								ssu.internal_objects_alloc_page_count -
								ssu.user_objects_dealloc_page_count -
								ssu.internal_objects_dealloc_page_count AS tempdb_current
						FROM sys.dm_db_session_space_usage AS ssu
						CROSS APPLY
						(
							SELECT TOP(1)
								s0.session_id
							FROM @sessions AS s0
							WHERE
								s0.session_id = ssu.session_id
						) AS p
					) AS t_info
					GROUP BY
						t_info.session_id,
						COALESCE(t_info.request_id, -1)
				) AS tempdb_info ON
					tempdb_info.session_id = y.session_id
					AND tempdb_info.request_id =
						CASE
							WHEN y.status = N''sleeping'' THEN
								-1
							ELSE
								y.request_id
						END
				' +
				CASE 
					WHEN 
						NOT 
						(
							@get_avg_time = 1 
							AND @recursion = 1
						) THEN 
							''
					ELSE
						'LEFT OUTER HASH JOIN
						(
							SELECT TOP(@i)
								*
							FROM sys.dm_exec_query_stats
						) AS qs ON
							qs.sql_handle = y.sql_handle
							AND qs.plan_handle = y.plan_handle
							AND qs.statement_start_offset = y.statement_start_offset
							AND qs.statement_end_offset = y.statement_end_offset
						'
				END + 
			') AS x
			OPTION (KEEPFIXED PLAN, OPTIMIZE FOR (@i = 1)); ';

		SET @sql_n = CONVERT(NVARCHAR(MAX), @sql);

		SET @last_collection_start = GETDATE();

		IF 
			@recursion = -1
			AND @sys_info = 1
		BEGIN;
			SELECT
				@first_collection_ms_ticks = ms_ticks
			FROM sys.dm_os_sys_info;
		END;

		INSERT #sessions
		(
			recursion,
			session_id,
			request_id,
			session_number,
			elapsed_time,
			avg_elapsed_time,
			physical_io,
			reads,
			physical_reads,
			writes,
			tempdb_allocations,
			tempdb_current,
			CPU,
			thread_CPU_snapshot,
			context_switches,
			used_memory,
			tasks,
			status,
			wait_info,
			transaction_id,
			open_tran_count,
			sql_handle,
			statement_start_offset,
			statement_end_offset,		
			sql_text,
			plan_handle,
			blocking_session_id,
			percent_complete,
			host_name,
			login_name,
			database_name,
			program_name,
			additional_info,
			start_time,
			login_time,
			last_request_start_time
		)
		EXEC sp_executesql 
			@sql_n,
			N'@recursion SMALLINT, @filter sysname, @not_filter sysname, @first_collection_ms_ticks BIGINT',
			@recursion, @filter, @not_filter, @first_collection_ms_ticks;

		--Collect transaction information?
		IF
			@recursion = 1
			AND
			(
				@output_column_list LIKE '%|[tran_start_time|]%' ESCAPE '|'
				OR @output_column_list LIKE '%|[tran_log_writes|]%' ESCAPE '|' 
			)
		BEGIN;	
			DECLARE @i INT;
			SET @i = 2147483647;

			UPDATE s
			SET
				tran_start_time =
					CONVERT
					(
						DATETIME,
						LEFT
						(
							x.trans_info,
							NULLIF(CHARINDEX(NCHAR(254) COLLATE Latin1_General_Bin2, x.trans_info) - 1, -1)
						),
						121
					),
				tran_log_writes =
					RIGHT
					(
						x.trans_info,
						LEN(x.trans_info) - CHARINDEX(NCHAR(254) COLLATE Latin1_General_Bin2, x.trans_info)
					)
			FROM
			(
				SELECT TOP(@i)
					trans_nodes.trans_node.value('(session_id/text())[1]', 'SMALLINT') AS session_id,
					COALESCE(trans_nodes.trans_node.value('(request_id/text())[1]', 'INT'), 0) AS request_id,
					trans_nodes.trans_node.value('(trans_info/text())[1]', 'NVARCHAR(4000)') AS trans_info				
				FROM
				(
					SELECT TOP(@i)
						CONVERT
						(
							XML,
							REPLACE
							(
								CONVERT(NVARCHAR(MAX), trans_raw.trans_xml_raw) COLLATE Latin1_General_Bin2, 
								N'</trans_info></trans><trans><trans_info>', N''
							)
						)
					FROM
					(
						SELECT TOP(@i)
							CASE u_trans.r
								WHEN 1 THEN u_trans.session_id
								ELSE NULL
							END AS [session_id],
							CASE u_trans.r
								WHEN 1 THEN u_trans.request_id
								ELSE NULL
							END AS [request_id],
							CONVERT
							(
								NVARCHAR(MAX),
								CASE
									WHEN u_trans.database_id IS NOT NULL THEN
										CASE u_trans.r
											WHEN 1 THEN COALESCE(CONVERT(NVARCHAR, u_trans.transaction_start_time, 121) + NCHAR(254), N'')
											ELSE N''
										END + 
											REPLACE
											(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
													CONVERT(VARCHAR(128), COALESCE(DB_NAME(u_trans.database_id), N'(null)')),
													NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
													NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
													NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
												NCHAR(0),
												N'?'
											) +
											N': ' +
										CONVERT(NVARCHAR, u_trans.log_record_count) + N' (' + CONVERT(NVARCHAR, u_trans.log_kb_used) + N' kB)' +
										N','
									ELSE
										N'N/A,'
								END COLLATE Latin1_General_Bin2
							) AS [trans_info]
						FROM
						(
							SELECT TOP(@i)
								trans.*,
								ROW_NUMBER() OVER
								(
									PARTITION BY
										trans.session_id,
										trans.request_id
									ORDER BY
										trans.transaction_start_time DESC
								) AS r
							FROM
							(
								SELECT TOP(@i)
									session_tran_map.session_id,
									session_tran_map.request_id,
									s_tran.database_id,
									COALESCE(SUM(s_tran.database_transaction_log_record_count), 0) AS log_record_count,
									COALESCE(SUM(s_tran.database_transaction_log_bytes_used), 0) / 1024 AS log_kb_used,
									MIN(s_tran.database_transaction_begin_time) AS transaction_start_time
								FROM
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_active_transactions
									WHERE
										transaction_begin_time <= @last_collection_start
								) AS a_tran
								INNER HASH JOIN
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_database_transactions
									WHERE
										database_id < 32767
								) AS s_tran ON
									s_tran.transaction_id = a_tran.transaction_id
								LEFT OUTER HASH JOIN
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_session_transactions
								) AS tst ON
									s_tran.transaction_id = tst.transaction_id
								CROSS APPLY
								(
									SELECT TOP(1)
										s3.session_id,
										s3.request_id
									FROM
									(
										SELECT TOP(1)
											s1.session_id,
											s1.request_id
										FROM #sessions AS s1
										WHERE
											s1.transaction_id = s_tran.transaction_id
											AND s1.recursion = 1
											
										UNION ALL
									
										SELECT TOP(1)
											s2.session_id,
											s2.request_id
										FROM #sessions AS s2
										WHERE
											s2.session_id = tst.session_id
											AND s2.recursion = 1
									) AS s3
									ORDER BY
										s3.request_id
								) AS session_tran_map
								GROUP BY
									session_tran_map.session_id,
									session_tran_map.request_id,
									s_tran.database_id
							) AS trans
						) AS u_trans
						FOR XML
							PATH('trans'),
							TYPE
					) AS trans_raw (trans_xml_raw)
				) AS trans_final (trans_xml)
				CROSS APPLY trans_final.trans_xml.nodes('/trans') AS trans_nodes (trans_node)
			) AS x
			INNER HASH JOIN #sessions AS s ON
				s.session_id = x.session_id
				AND s.request_id = x.request_id
			OPTION (OPTIMIZE FOR (@i = 1));
		END;

		--Variables for text and plan collection
		DECLARE	
			@session_id SMALLINT,
			@request_id INT,
			@sql_handle VARBINARY(64),
			@plan_handle VARBINARY(64),
			@statement_start_offset INT,
			@statement_end_offset INT,
			@start_time DATETIME,
			@database_name sysname;

		IF 
			@recursion = 1
			AND @output_column_list LIKE '%|[sql_text|]%' ESCAPE '|'
		BEGIN;
			DECLARE sql_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT 
					session_id,
					request_id,
					sql_handle,
					statement_start_offset,
					statement_end_offset
				FROM #sessions
				WHERE
					recursion = 1
					AND sql_handle IS NOT NULL
			OPTION (KEEPFIXED PLAN);

			OPEN sql_cursor;

			FETCH NEXT FROM sql_cursor
			INTO 
				@session_id,
				@request_id,
				@sql_handle,
				@statement_start_offset,
				@statement_end_offset;

			--Wait up to 5 ms for the SQL text, then give up
			SET LOCK_TIMEOUT 5;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					UPDATE s
					SET
						s.sql_text =
						(
							SELECT
								REPLACE
								(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
										N'--' + NCHAR(13) + NCHAR(10) +
										CASE 
											WHEN @get_full_inner_text = 1 THEN est.text
											WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN est.text
											WHEN SUBSTRING(est.text, (@statement_start_offset/2), 2) LIKE N'[a-zA-Z0-9][a-zA-Z0-9]' THEN est.text
											ELSE
												CASE
													WHEN @statement_start_offset > 0 THEN
														SUBSTRING
														(
															est.text,
															((@statement_start_offset/2) + 1),
															(
																CASE
																	WHEN @statement_end_offset = -1 THEN 2147483647
																	ELSE ((@statement_end_offset - @statement_start_offset)/2) + 1
																END
															)
														)
													ELSE RTRIM(LTRIM(est.text))
												END
										END +
										NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2,
										NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
										NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
										NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
									NCHAR(0),
									N''
								) AS [processing-instruction(query)]
							FOR XML
								PATH(''),
								TYPE
						),
						s.statement_start_offset = 
							CASE 
								WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN 0
								WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE '[a-zA-Z0-9][a-zA-Z0-9]' THEN 0
								ELSE @statement_start_offset
							END,
						s.statement_end_offset = 
							CASE 
								WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN -1
								WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE '[a-zA-Z0-9][a-zA-Z0-9]' THEN -1
								ELSE @statement_end_offset
							END
					FROM 
						#sessions AS s,
						(
							SELECT TOP(1)
								text
							FROM
							(
								SELECT 
									text, 
									0 AS row_num
								FROM sys.dm_exec_sql_text(@sql_handle)
								
								UNION ALL
								
								SELECT 
									NULL,
									1 AS row_num
							) AS est0
							ORDER BY
								row_num
						) AS est
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END TRY
				BEGIN CATCH;
					UPDATE s
					SET
						s.sql_text = 
							CASE ERROR_NUMBER() 
								WHEN 1222 THEN '<timeout_exceeded />'
								ELSE '<error message="' + ERROR_MESSAGE() + '" />'
							END
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM sql_cursor
				INTO
					@session_id,
					@request_id,
					@sql_handle,
					@statement_start_offset,
					@statement_end_offset;
			END;

			--Return this to the default
			SET LOCK_TIMEOUT -1;

			CLOSE sql_cursor;
			DEALLOCATE sql_cursor;
		END;

		IF 
			@get_outer_command = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[sql_command|]%' ESCAPE '|'
		BEGIN;
			DECLARE @buffer_results TABLE
			(
				EventType VARCHAR(30),
				Parameters INT,
				EventInfo NVARCHAR(4000),
				start_time DATETIME,
				session_number INT IDENTITY(1,1) NOT NULL PRIMARY KEY
			);

			DECLARE buffer_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT 
					session_id,
					MAX(start_time) AS start_time
				FROM #sessions
				WHERE
					recursion = 1
				GROUP BY
					session_id
				ORDER BY
					session_id
				OPTION (KEEPFIXED PLAN);

			OPEN buffer_cursor;

			FETCH NEXT FROM buffer_cursor
			INTO 
				@session_id,
				@start_time;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					--In SQL Server 2008, DBCC INPUTBUFFER will throw 
					--an exception if the session no longer exists
					INSERT @buffer_results
					(
						EventType,
						Parameters,
						EventInfo
					)
					EXEC sp_executesql
						N'DBCC INPUTBUFFER(@session_id) WITH NO_INFOMSGS;',
						N'@session_id SMALLINT',
						@session_id;

					UPDATE br
					SET
						br.start_time = @start_time
					FROM @buffer_results AS br
					WHERE
						br.session_number = 
						(
							SELECT MAX(br2.session_number)
							FROM @buffer_results br2
						);
				END TRY
				BEGIN CATCH
				END CATCH;

				FETCH NEXT FROM buffer_cursor
				INTO 
					@session_id,
					@start_time;
			END;

			UPDATE s
			SET
				sql_command = 
				(
					SELECT 
						REPLACE
						(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								CONVERT
								(
									NVARCHAR(MAX),
									N'--' + NCHAR(13) + NCHAR(10) + br.EventInfo + NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2
								),
								NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
								NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
								NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
							NCHAR(0),
							N''
						) AS [processing-instruction(query)]
					FROM @buffer_results AS br
					WHERE 
						br.session_number = s.session_number
						AND br.start_time = s.start_time
						AND 
						(
							(
								s.start_time = s.last_request_start_time
								AND EXISTS
								(
									SELECT *
									FROM sys.dm_exec_requests r2
									WHERE
										r2.session_id = s.session_id
										AND r2.request_id = s.request_id
										AND r2.start_time = s.start_time
								)
							)
							OR 
							(
								s.request_id = 0
								AND EXISTS
								(
									SELECT *
									FROM sys.dm_exec_sessions s2
									WHERE
										s2.session_id = s.session_id
										AND s2.last_request_start_time = s.last_request_start_time
								)
							)
						)
					FOR XML
						PATH(''),
						TYPE
				)
			FROM #sessions AS s
			WHERE
				recursion = 1
			OPTION (KEEPFIXED PLAN);

			CLOSE buffer_cursor;
			DEALLOCATE buffer_cursor;
		END;

		IF 
			@get_plans >= 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|'
		BEGIN;
			DECLARE @live_plan BIT;
			SET @live_plan = ISNULL(CONVERT(BIT, SIGN(OBJECT_ID('sys.dm_exec_query_statistics_xml'))), 0)

			DECLARE plan_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT
					session_id,
					request_id,
					plan_handle,
					statement_start_offset,
					statement_end_offset
				FROM #sessions
				WHERE
					recursion = 1
					AND plan_handle IS NOT NULL
			OPTION (KEEPFIXED PLAN);

			OPEN plan_cursor;

			FETCH NEXT FROM plan_cursor
			INTO 
				@session_id,
				@request_id,
				@plan_handle,
				@statement_start_offset,
				@statement_end_offset;

			--Wait up to 5 ms for a query plan, then give up
			SET LOCK_TIMEOUT 5;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				DECLARE @query_plan XML;
				SET @query_plan = NULL;

				IF @live_plan = 1
				BEGIN;
					BEGIN TRY;
						SELECT
							@query_plan = x.query_plan
						FROM sys.dm_exec_query_statistics_xml(@session_id) AS x;

						IF 
							@query_plan IS NOT NULL
							AND EXISTS
							(
								SELECT
									*
								FROM sys.dm_exec_requests AS r
								WHERE
									r.session_id = @session_id
									AND r.request_id = @request_id
									AND r.plan_handle = @plan_handle
									AND r.statement_start_offset = @statement_start_offset
									AND r.statement_end_offset = @statement_end_offset
							)
						BEGIN;
							UPDATE s
							SET
								s.query_plan = @query_plan
							FROM #sessions AS s
							WHERE 
								s.session_id = @session_id
								AND s.request_id = @request_id
								AND s.recursion = 1
							OPTION (KEEPFIXED PLAN);
						END;
					END TRY
					BEGIN CATCH;
						SET @query_plan = NULL;
					END CATCH;
				END;

				IF @query_plan IS NULL
				BEGIN;
					BEGIN TRY;
						UPDATE s
						SET
							s.query_plan =
							(
								SELECT
									CONVERT(xml, query_plan)
								FROM sys.dm_exec_text_query_plan
								(
									@plan_handle, 
									CASE @get_plans
										WHEN 1 THEN
											@statement_start_offset
										ELSE
											0
									END, 
									CASE @get_plans
										WHEN 1 THEN
											@statement_end_offset
										ELSE
											-1
									END
								)
							)
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.request_id = @request_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
					END TRY
					BEGIN CATCH;
						IF ERROR_NUMBER() = 6335
						BEGIN;
							UPDATE s
							SET
								s.query_plan =
								(
									SELECT
										N'--' + NCHAR(13) + NCHAR(10) + 
										N'-- Could not render showplan due to XML data type limitations. ' + NCHAR(13) + NCHAR(10) + 
										N'-- To see the graphical plan save the XML below as a .SQLPLAN file and re-open in SSMS.' + NCHAR(13) + NCHAR(10) +
										N'--' + NCHAR(13) + NCHAR(10) +
											REPLACE(qp.query_plan, N'<RelOp', NCHAR(13)+NCHAR(10)+N'<RelOp') + 
											NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2 AS [processing-instruction(query_plan)]
									FROM sys.dm_exec_text_query_plan
									(
										@plan_handle, 
										CASE @get_plans
											WHEN 1 THEN
												@statement_start_offset
											ELSE
												0
										END, 
										CASE @get_plans
											WHEN 1 THEN
												@statement_end_offset
											ELSE
												-1
										END
									) AS qp
									FOR XML
										PATH(''),
										TYPE
								)
							FROM #sessions AS s
							WHERE 
								s.session_id = @session_id
								AND s.request_id = @request_id
								AND s.recursion = 1
							OPTION (KEEPFIXED PLAN);
						END;
						ELSE
						BEGIN;
							UPDATE s
							SET
								s.query_plan = 
									CASE ERROR_NUMBER() 
										WHEN 1222 THEN '<timeout_exceeded />'
										ELSE '<error message="' + ERROR_MESSAGE() + '" />'
									END
							FROM #sessions AS s
							WHERE 
								s.session_id = @session_id
								AND s.request_id = @request_id
								AND s.recursion = 1
							OPTION (KEEPFIXED PLAN);
						END;
					END CATCH;
				END;

				FETCH NEXT FROM plan_cursor
				INTO
					@session_id,
					@request_id,
					@plan_handle,
					@statement_start_offset,
					@statement_end_offset;
			END;

			--Return this to the default
			SET LOCK_TIMEOUT -1;

			CLOSE plan_cursor;
			DEALLOCATE plan_cursor;
		END;

		IF 
			@get_locks = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[locks|]%' ESCAPE '|'
		BEGIN;
			DECLARE locks_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT DISTINCT
					database_name
				FROM #locks
				WHERE
					EXISTS
					(
						SELECT *
						FROM #sessions AS s
						WHERE
							s.session_id = #locks.session_id
							AND recursion = 1
					)
					AND database_name <> '(null)'
				OPTION (KEEPFIXED PLAN);

			OPEN locks_cursor;

			FETCH NEXT FROM locks_cursor
			INTO 
				@database_name;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					SET @sql_n = CONVERT(NVARCHAR(MAX), '') +
						'UPDATE l ' +
						'SET ' +
							'object_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'o.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'index_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'i.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'schema_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										's.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'principal_name = ' + 
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'dp.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								') ' +
						'FROM #locks AS l ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.allocation_units AS au ON ' +
							'au.allocation_unit_id = l.allocation_unit_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p ON ' +
							'p.hobt_id = ' +
								'COALESCE ' +
								'( ' +
									'l.hobt_id, ' +
									'CASE ' +
										'WHEN au.type IN (1, 3) THEN au.container_id ' +
										'ELSE NULL ' +
									'END ' +
								') ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p1 ON ' +
							'l.hobt_id IS NULL ' +
							'AND au.type = 2 ' +
							'AND p1.partition_id = au.container_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.objects AS o ON ' +
							'o.object_id = COALESCE(l.object_id, p.object_id, p1.object_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.indexes AS i ON ' +
							'i.object_id = COALESCE(l.object_id, p.object_id, p1.object_id) ' +
							'AND i.index_id = COALESCE(l.index_id, p.index_id, p1.index_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.schemas AS s ON ' +
							's.schema_id = COALESCE(l.schema_id, o.schema_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.database_principals AS dp ON ' +
							'dp.principal_id = l.principal_id ' +
						'WHERE ' +
							'l.database_name = @database_name ' +
						'OPTION (KEEPFIXED PLAN); ';
					
					EXEC sp_executesql
						@sql_n,
						N'@database_name sysname',
						@database_name;
				END TRY
				BEGIN CATCH;
					UPDATE #locks
					SET
						query_error = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									CONVERT
									(
										NVARCHAR(MAX), 
										ERROR_MESSAGE() COLLATE Latin1_General_Bin2
									),
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N''
							)
					WHERE 
						database_name = @database_name
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM locks_cursor
				INTO
					@database_name;
			END;

			CLOSE locks_cursor;
			DEALLOCATE locks_cursor;

			CREATE CLUSTERED INDEX IX_SRD ON #locks (session_id, request_id, database_name);

			UPDATE s
			SET 
				s.locks =
				(
					SELECT 
						REPLACE
						(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								CONVERT
								(
									NVARCHAR(MAX), 
									l1.database_name COLLATE Latin1_General_Bin2
								),
								NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
								NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
								NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
							NCHAR(0),
							N''
						) AS [Database/@name],
						MIN(l1.query_error) AS [Database/@query_error],
						(
							SELECT 
								l2.request_mode AS [Lock/@request_mode],
								l2.request_status AS [Lock/@request_status],
								COUNT(*) AS [Lock/@request_count]
							FROM #locks AS l2
							WHERE 
								l1.session_id = l2.session_id
								AND l1.request_id = l2.request_id
								AND l2.database_name = l1.database_name
								AND l2.resource_type = 'DATABASE'
							GROUP BY
								l2.request_mode,
								l2.request_status
							FOR XML
								PATH(''),
								TYPE
						) AS [Database/Locks],
						(
							SELECT
								COALESCE(l3.object_name, '(null)') AS [Object/@name],
								l3.schema_name AS [Object/@schema_name],
								(
									SELECT
										l4.resource_type AS [Lock/@resource_type],
										l4.page_type AS [Lock/@page_type],
										l4.index_name AS [Lock/@index_name],
										CASE 
											WHEN l4.object_name IS NULL THEN l4.schema_name
											ELSE NULL
										END AS [Lock/@schema_name],
										l4.principal_name AS [Lock/@principal_name],
										l4.resource_description AS [Lock/@resource_description],
										l4.request_mode AS [Lock/@request_mode],
										l4.request_status AS [Lock/@request_status],
										SUM(l4.request_count) AS [Lock/@request_count]
									FROM #locks AS l4
									WHERE 
										l4.session_id = l3.session_id
										AND l4.request_id = l3.request_id
										AND l3.database_name = l4.database_name
										AND COALESCE(l3.object_name, '(null)') = COALESCE(l4.object_name, '(null)')
										AND COALESCE(l3.schema_name, '') = COALESCE(l4.schema_name, '')
										AND l4.resource_type <> 'DATABASE'
									GROUP BY
										l4.resource_type,
										l4.page_type,
										l4.index_name,
										CASE 
											WHEN l4.object_name IS NULL THEN l4.schema_name
											ELSE NULL
										END,
										l4.principal_name,
										l4.resource_description,
										l4.request_mode,
										l4.request_status
									FOR XML
										PATH(''),
										TYPE
								) AS [Object/Locks]
							FROM #locks AS l3
							WHERE 
								l3.session_id = l1.session_id
								AND l3.request_id = l1.request_id
								AND l3.database_name = l1.database_name
								AND l3.resource_type <> 'DATABASE'
							GROUP BY 
								l3.session_id,
								l3.request_id,
								l3.database_name,
								COALESCE(l3.object_name, '(null)'),
								l3.schema_name
							FOR XML
								PATH(''),
								TYPE
						) AS [Database/Objects]
					FROM #locks AS l1
					WHERE
						l1.session_id = s.session_id
						AND l1.request_id = s.request_id
						AND l1.start_time IN (s.start_time, s.last_request_start_time)
						AND s.recursion = 1
					GROUP BY 
						l1.session_id,
						l1.request_id,
						l1.database_name
					FOR XML
						PATH(''),
						TYPE
				)
			FROM #sessions s
			OPTION (KEEPFIXED PLAN);
		END;

		IF 
			@find_block_leaders = 1
			AND @recursion = 1
			AND @output_column_list LIKE '%|[blocked_session_count|]%' ESCAPE '|'
		BEGIN;
			WITH
			blockers AS
			(
				SELECT
					session_id,
					session_id AS top_level_session_id,
					CONVERT(VARCHAR(8000), '.' + CONVERT(VARCHAR(8000), session_id) + '.') AS the_path
				FROM #sessions
				WHERE
					recursion = 1

				UNION ALL

				SELECT
					s.session_id,
					b.top_level_session_id,
					CONVERT(VARCHAR(8000), b.the_path + CONVERT(VARCHAR(8000), s.session_id) + '.') AS the_path
				FROM blockers AS b
				JOIN #sessions AS s ON
					s.blocking_session_id = b.session_id
					AND s.recursion = 1
					AND b.the_path NOT LIKE '%.' + CONVERT(VARCHAR(8000), s.session_id) + '.%' COLLATE Latin1_General_Bin2
			)
			UPDATE s
			SET
				s.blocked_session_count = x.blocked_session_count
			FROM #sessions AS s
			JOIN
			(
				SELECT
					b.top_level_session_id AS session_id,
					COUNT(*) - 1 AS blocked_session_count
				FROM blockers AS b
				GROUP BY
					b.top_level_session_id
			) x ON
				s.session_id = x.session_id
			WHERE
				s.recursion = 1;
		END;

		IF
			@get_task_info = 2
			AND @output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
			AND @recursion = 1
		BEGIN;
			CREATE TABLE #blocked_requests
			(
				session_id SMALLINT NOT NULL,
				request_id INT NOT NULL,
				database_name sysname NOT NULL,
				object_id INT,
				hobt_id BIGINT,
				schema_id INT,
				schema_name sysname NULL,
				object_name sysname NULL,
				query_error NVARCHAR(2048),
				PRIMARY KEY (database_name, session_id, request_id)
			);

			CREATE STATISTICS s_database_name ON #blocked_requests (database_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_name ON #blocked_requests (schema_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_name ON #blocked_requests (object_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_query_error ON #blocked_requests (query_error)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
		
			INSERT #blocked_requests
			(
				session_id,
				request_id,
				database_name,
				object_id,
				hobt_id,
				schema_id
			)
			SELECT
				session_id,
				request_id,
				database_name,
				object_id,
				hobt_id,
				CONVERT(INT, SUBSTRING(schema_node, CHARINDEX(' = ', schema_node) + 3, LEN(schema_node))) AS schema_id
			FROM
			(
				SELECT
					session_id,
					request_id,
					agent_nodes.agent_node.value('(database_name/text())[1]', 'sysname') AS database_name,
					agent_nodes.agent_node.value('(object_id/text())[1]', 'int') AS object_id,
					agent_nodes.agent_node.value('(hobt_id/text())[1]', 'bigint') AS hobt_id,
					agent_nodes.agent_node.value('(metadata_resource/text()[.="SCHEMA"]/../../metadata_class_id/text())[1]', 'varchar(100)') AS schema_node
				FROM #sessions AS s
				CROSS APPLY s.additional_info.nodes('//block_info') AS agent_nodes (agent_node)
				WHERE
					s.recursion = 1
			) AS t
			WHERE
				t.database_name IS NOT NULL
				AND
				(
					t.object_id IS NOT NULL
					OR t.hobt_id IS NOT NULL
					OR t.schema_node IS NOT NULL
				);
			
			DECLARE blocks_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR
				SELECT DISTINCT
					database_name
				FROM #blocked_requests;
				
			OPEN blocks_cursor;
			
			FETCH NEXT FROM blocks_cursor
			INTO 
				@database_name;
			
			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					SET @sql_n = 
						CONVERT(NVARCHAR(MAX), '') +
						'UPDATE b ' +
						'SET ' +
							'b.schema_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										's.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'b.object_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'o.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								') ' +
						'FROM #blocked_requests AS b ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p ON ' +
							'p.hobt_id = b.hobt_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.objects AS o ON ' +
							'o.object_id = COALESCE(p.object_id, b.object_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.schemas AS s ON ' +
							's.schema_id = COALESCE(o.schema_id, b.schema_id) ' +
						'WHERE ' +
							'b.database_name = @database_name; ';
					
					EXEC sp_executesql
						@sql_n,
						N'@database_name sysname',
						@database_name;
				END TRY
				BEGIN CATCH;
					UPDATE #blocked_requests
					SET
						query_error = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									CONVERT
									(
										NVARCHAR(MAX), 
										ERROR_MESSAGE() COLLATE Latin1_General_Bin2
									),
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N''
							)
					WHERE
						database_name = @database_name;
				END CATCH;

				FETCH NEXT FROM blocks_cursor
				INTO
					@database_name;
			END;
			
			CLOSE blocks_cursor;
			DEALLOCATE blocks_cursor;
			
			UPDATE s
			SET
				additional_info.modify
				('
					insert <schema_name>{sql:column("b.schema_name")}</schema_name>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.schema_name IS NOT NULL;

			UPDATE s
			SET
				additional_info.modify
				('
					insert <object_name>{sql:column("b.object_name")}</object_name>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.object_name IS NOT NULL;

			UPDATE s
			SET
				additional_info.modify
				('
					insert <query_error>{sql:column("b.query_error")}</query_error>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.query_error IS NOT NULL;
		END;

		IF
			@output_column_list LIKE '%|[program_name|]%' ESCAPE '|'
			AND @output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
			AND @recursion = 1
			AND DB_ID('msdb') IS NOT NULL
		BEGIN;
			SET @sql_n =
				N'BEGIN TRY;
					DECLARE @job_name sysname;
					SET @job_name = NULL;
					DECLARE @step_name sysname;
					SET @step_name = NULL;

					SELECT
						@job_name = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									j.name,
									NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
									NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
									NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
								NCHAR(0),
								N''?''
							),
						@step_name = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									s.step_name,
									NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
									NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
									NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
								NCHAR(0),
								N''?''
							)
					FROM msdb.dbo.sysjobs AS j
					INNER JOIN msdb.dbo.sysjobsteps AS s ON
						j.job_id = s.job_id
					WHERE
						j.job_id = @job_id
						AND s.step_id = @step_id;

					IF @job_name IS NOT NULL
					BEGIN;
						UPDATE s
						SET
							additional_info.modify
							(''
								insert text{sql:variable("@job_name")}
								into (/additional_info/agent_job_info/job_name)[1]
							'')
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
						
						UPDATE s
						SET
							additional_info.modify
							(''
								insert text{sql:variable("@step_name")}
								into (/additional_info/agent_job_info/step_name)[1]
							'')
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
					END;
				END TRY
				BEGIN CATCH;
					DECLARE @msdb_error_message NVARCHAR(256);
					SET @msdb_error_message = ERROR_MESSAGE();
				
					UPDATE s
					SET
						additional_info.modify
						(''
							insert <msdb_query_error>{sql:variable("@msdb_error_message")}</msdb_query_error>
							as last
							into (/additional_info/agent_job_info)[1]
						'')
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END CATCH;'

			DECLARE @job_id UNIQUEIDENTIFIER;
			DECLARE @step_id INT;

			DECLARE agent_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT
					s.session_id,
					agent_nodes.agent_node.value('(job_id/text())[1]', 'uniqueidentifier') AS job_id,
					agent_nodes.agent_node.value('(step_id/text())[1]', 'int') AS step_id
				FROM #sessions AS s
				CROSS APPLY s.additional_info.nodes('//agent_job_info') AS agent_nodes (agent_node)
				WHERE
					s.recursion = 1
			OPTION (KEEPFIXED PLAN);
			
			OPEN agent_cursor;

			FETCH NEXT FROM agent_cursor
			INTO 
				@session_id,
				@job_id,
				@step_id;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				EXEC sp_executesql
					@sql_n,
					N'@job_id UNIQUEIDENTIFIER, @step_id INT, @session_id SMALLINT',
					@job_id, @step_id, @session_id

				FETCH NEXT FROM agent_cursor
				INTO 
					@session_id,
					@job_id,
					@step_id;
			END;

			CLOSE agent_cursor;
			DEALLOCATE agent_cursor;
		END; 
		
		IF 
			@delta_interval > 0 
			AND @recursion <> 1
		BEGIN;
			SET @recursion = 1;

			DECLARE @delay_time CHAR(12);
			SET @delay_time = CONVERT(VARCHAR, DATEADD(second, @delta_interval, 0), 114);
			WAITFOR DELAY @delay_time;

			GOTO REDO;
		END;
	END;

	SET @sql = 
		--Outer column list
		CONVERT
		(
			VARCHAR(MAX),
			CASE
				WHEN 
					@destination_table <> '' 
					AND @return_schema = 0 
						THEN 'INSERT ' + @destination_table + ' '
				ELSE ''
			END +
			'SELECT ' +
				@output_column_list + ' ' +
			CASE @return_schema
				WHEN 1 THEN 'INTO #session_schema '
				ELSE ''
			END
		--End outer column list
		) + 
		--Inner column list
		CONVERT
		(
			VARCHAR(MAX),
			'FROM ' +
			'( ' +
				'SELECT ' +
					'session_id, ' +
					--[dd hh:mm:ss.mss]
					CASE
						WHEN @format_output IN (1, 2) THEN
							'CASE ' +
								'WHEN elapsed_time < 0 THEN ' +
									'RIGHT ' +
									'( ' +
										'REPLICATE(''0'', max_elapsed_length) + CONVERT(VARCHAR, (-1 * elapsed_time) / 86400), ' +
										'max_elapsed_length ' +
									') + ' +
										'RIGHT ' +
										'( ' +
											'CONVERT(VARCHAR, DATEADD(second, (-1 * elapsed_time), 0), 120), ' +
											'9 ' +
										') + ' +
										'''.000'' ' +
								'ELSE ' +
									'RIGHT ' +
									'( ' +
										'REPLICATE(''0'', max_elapsed_length) + CONVERT(VARCHAR, elapsed_time / 86400000), ' +
										'max_elapsed_length ' +
									') + ' +
										'RIGHT ' +
										'( ' +
											'CONVERT(VARCHAR, DATEADD(second, elapsed_time / 1000, 0), 120), ' +
											'9 ' +
										') + ' +
										'''.'' + ' + 
										'RIGHT(''000'' + CONVERT(VARCHAR, elapsed_time % 1000), 3) ' +
							'END AS [dd hh:mm:ss.mss], '
						ELSE
							''
					END +
					--[dd hh:mm:ss.mss (avg)] / avg_elapsed_time
					CASE 
						WHEN  @format_output IN (1, 2) THEN 
							'RIGHT ' +
							'( ' +
								'''00'' + CONVERT(VARCHAR, avg_elapsed_time / 86400000), ' +
								'2 ' +
							') + ' +
								'RIGHT ' +
								'( ' +
									'CONVERT(VARCHAR, DATEADD(second, avg_elapsed_time / 1000, 0), 120), ' +
									'9 ' +
								') + ' +
								'''.'' + ' +
								'RIGHT(''000'' + CONVERT(VARCHAR, avg_elapsed_time % 1000), 3) AS [dd hh:mm:ss.mss (avg)], '
						ELSE
							'avg_elapsed_time, '
					END +
					--physical_io
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_io))) OVER() - LEN(CONVERT(VARCHAR, physical_io))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io), 1), 19)) AS '
						ELSE ''
					END + 'physical_io, ' +
					--reads
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, reads))) OVER() - LEN(CONVERT(VARCHAR, reads))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads), 1), 19)) AS '
						ELSE ''
					END + 'reads, ' +
					--physical_reads
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_reads))) OVER() - LEN(CONVERT(VARCHAR, physical_reads))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads), 1), 19)) AS '
						ELSE ''
					END + 'physical_reads, ' +
					--writes
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, writes))) OVER() - LEN(CONVERT(VARCHAR, writes))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes), 1), 19)) AS '
						ELSE ''
					END + 'writes, ' +
					--tempdb_allocations
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_allocations))) OVER() - LEN(CONVERT(VARCHAR, tempdb_allocations))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations), 1), 19)) AS '
						ELSE ''
					END + 'tempdb_allocations, ' +
					--tempdb_current
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_current))) OVER() - LEN(CONVERT(VARCHAR, tempdb_current))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current), 1), 19)) AS '
						ELSE ''
					END + 'tempdb_current, ' +
					--CPU
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, CPU))) OVER() - LEN(CONVERT(VARCHAR, CPU))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU), 1), 19)) AS '
						ELSE ''
					END + 'CPU, ' +
					--context_switches
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, context_switches))) OVER() - LEN(CONVERT(VARCHAR, context_switches))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches), 1), 19)) AS '
						ELSE ''
					END + 'context_switches, ' +
					--used_memory
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, used_memory))) OVER() - LEN(CONVERT(VARCHAR, used_memory))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory), 1), 19)) AS '
						ELSE ''
					END + 'used_memory, ' +
					CASE
						WHEN @output_column_list LIKE '%|_delta|]%' ESCAPE '|' THEN
							--physical_io_delta			
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND physical_io_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_io_delta))) OVER() - LEN(CONVERT(VARCHAR, physical_io_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io_delta), 1), 19)) ' 
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io_delta), 1), 19)) '
											ELSE 'physical_io_delta '
										END +
								'ELSE NULL ' +
							'END AS physical_io_delta, ' +
							--reads_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND reads_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, reads_delta))) OVER() - LEN(CONVERT(VARCHAR, reads_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads_delta), 1), 19)) '
											ELSE 'reads_delta '
										END +
								'ELSE NULL ' +
							'END AS reads_delta, ' +
							--physical_reads_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND physical_reads_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_reads_delta))) OVER() - LEN(CONVERT(VARCHAR, physical_reads_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads_delta), 1), 19)) '
											ELSE 'physical_reads_delta '
										END + 
								'ELSE NULL ' +
							'END AS physical_reads_delta, ' +
							--writes_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND writes_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, writes_delta))) OVER() - LEN(CONVERT(VARCHAR, writes_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes_delta), 1), 19)) '
											ELSE 'writes_delta '
										END + 
								'ELSE NULL ' +
							'END AS writes_delta, ' +
							--tempdb_allocations_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND tempdb_allocations_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_allocations_delta))) OVER() - LEN(CONVERT(VARCHAR, tempdb_allocations_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations_delta), 1), 19)) '
											ELSE 'tempdb_allocations_delta '
										END + 
								'ELSE NULL ' +
							'END AS tempdb_allocations_delta, ' +
							--tempdb_current_delta
							--this is the only one that can (legitimately) go negative 
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_current_delta))) OVER() - LEN(CONVERT(VARCHAR, tempdb_current_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current_delta), 1), 19)) '
											ELSE 'tempdb_current_delta '
										END + 
								'ELSE NULL ' +
							'END AS tempdb_current_delta, ' +
							--CPU_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
										'THEN ' +
											'CASE ' +
												'WHEN ' +
													'thread_CPU_delta > CPU_delta ' +
													'AND thread_CPU_delta > 0 ' +
														'THEN ' +
															CASE @format_output
																WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, thread_CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, thread_CPU_delta), 1), 19)) '
																WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, thread_CPU_delta), 1), 19)) '
																ELSE 'thread_CPU_delta '
															END + 
												'WHEN CPU_delta >= 0 THEN ' +
													CASE @format_output
														WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU_delta), 1), 19)) '
														WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU_delta), 1), 19)) '
														ELSE 'CPU_delta '
													END + 
												'ELSE NULL ' +
											'END ' +
								'ELSE ' +
									'NULL ' +
							'END AS CPU_delta, ' +
							--context_switches_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND context_switches_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, context_switches_delta))) OVER() - LEN(CONVERT(VARCHAR, context_switches_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches_delta), 1), 19)) '
											ELSE 'context_switches_delta '
										END + 
								'ELSE NULL ' +
							'END AS context_switches_delta, ' +
							--used_memory_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND used_memory_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, used_memory_delta))) OVER() - LEN(CONVERT(VARCHAR, used_memory_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory_delta), 1), 19)) '
											ELSE 'used_memory_delta '
										END + 
								'ELSE NULL ' +
							'END AS used_memory_delta, '
						ELSE ''
					END +
					--tasks
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tasks))) OVER() - LEN(CONVERT(VARCHAR, tasks))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tasks), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tasks), 1), 19)) '
						ELSE ''
					END + 'tasks, ' +
					'status, ' +
					'wait_info, ' +
					'locks, ' +
					'tran_start_time, ' +
					'LEFT(tran_log_writes, LEN(tran_log_writes) - 1) AS tran_log_writes, ' +
					--open_tran_count
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, open_tran_count))) OVER() - LEN(CONVERT(VARCHAR, open_tran_count))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, open_tran_count), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, open_tran_count), 1), 19)) AS '
						ELSE ''
					END + 'open_tran_count, ' +
					--sql_command
					CASE @format_output 
						WHEN 0 THEN 'REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_command), ''<?query --''+CHAR(13)+CHAR(10), ''''), CHAR(13)+CHAR(10)+''--?>'', '''') AS '
						ELSE ''
					END + 'sql_command, ' +
					--sql_text
					CASE @format_output 
						WHEN 0 THEN 'REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_text), ''<?query --''+CHAR(13)+CHAR(10), ''''), CHAR(13)+CHAR(10)+''--?>'', '''') AS '
						ELSE ''
					END + 'sql_text, ' +
					'query_plan, ' +
					'blocking_session_id, ' +
					--blocked_session_count
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, blocked_session_count))) OVER() - LEN(CONVERT(VARCHAR, blocked_session_count))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1), 19)) AS '
						ELSE ''
					END + 'blocked_session_count, ' +
					--percent_complete
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, CONVERT(MONEY, percent_complete), 2))) OVER() - LEN(CONVERT(VARCHAR, CONVERT(MONEY, percent_complete), 2))) + CONVERT(CHAR(22), CONVERT(MONEY, percent_complete), 2)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1)) AS '
						ELSE ''
					END + 'percent_complete, ' +
					'host_name, ' +
					'login_name, ' +
					'database_name, ' +
					'program_name, ' +
					'additional_info, ' +
					'start_time, ' +
					'login_time, ' +
					'CASE ' +
						'WHEN status = N''sleeping'' THEN NULL ' +
						'ELSE request_id ' +
					'END AS request_id, ' +
					'GETDATE() AS collection_time '
		--End inner column list
		) +
		--Derived table and INSERT specification
		CONVERT
		(
			VARCHAR(MAX),
				'FROM ' +
				'( ' +
					'SELECT TOP(2147483647) ' +
						'*, ' +
						'CASE ' +
							'MAX ' +
							'( ' +
								'LEN ' +
								'( ' +
									'CONVERT ' +
									'( ' +
										'VARCHAR, ' +
										'CASE ' +
											'WHEN elapsed_time < 0 THEN ' +
												'(-1 * elapsed_time) / 86400 ' +
											'ELSE ' +
												'elapsed_time / 86400000 ' +
										'END ' +
									') ' +
								') ' +
							') OVER () ' +
								'WHEN 1 THEN 2 ' +
								'ELSE ' +
									'MAX ' +
									'( ' +
										'LEN ' +
										'( ' +
											'CONVERT ' +
											'( ' +
												'VARCHAR, ' +
												'CASE ' +
													'WHEN elapsed_time < 0 THEN ' +
														'(-1 * elapsed_time) / 86400 ' +
													'ELSE ' +
														'elapsed_time / 86400000 ' +
												'END ' +
											') ' +
										') ' +
									') OVER () ' +
						'END AS max_elapsed_length, ' +
						CASE
							WHEN @output_column_list LIKE '%|_delta|]%' ESCAPE '|' THEN
								'MAX(physical_io * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(physical_io * recursion) OVER (PARTITION BY session_id, request_id) AS physical_io_delta, ' +
								'MAX(reads * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(reads * recursion) OVER (PARTITION BY session_id, request_id) AS reads_delta, ' +
								'MAX(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) AS physical_reads_delta, ' +
								'MAX(writes * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(writes * recursion) OVER (PARTITION BY session_id, request_id) AS writes_delta, ' +
								'MAX(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_allocations_delta, ' +
								'MAX(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_current_delta, ' +
								'MAX(CPU * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(CPU * recursion) OVER (PARTITION BY session_id, request_id) AS CPU_delta, ' +
								'MAX(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) AS thread_CPU_delta, ' +
								'MAX(context_switches * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(context_switches * recursion) OVER (PARTITION BY session_id, request_id) AS context_switches_delta, ' +
								'MAX(used_memory * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(used_memory * recursion) OVER (PARTITION BY session_id, request_id) AS used_memory_delta, ' +
								'MIN(last_request_start_time) OVER (PARTITION BY session_id, request_id) AS first_request_start_time, '
							ELSE ''
						END +
						'COUNT(*) OVER (PARTITION BY session_id, request_id) AS num_events ' +
					'FROM #sessions AS s1 ' +
					CASE 
						WHEN @sort_order = '' THEN ''
						ELSE
							'ORDER BY ' +
								@sort_order
					END +
				') AS s ' +
				'WHERE ' +
					's.recursion = 1 ' +
			') x ' +
			'OPTION (KEEPFIXED PLAN); ' +
			'' +
			CASE @return_schema
				WHEN 1 THEN
					'SET @schema = ' +
						'''CREATE TABLE <table_name> ( '' + ' +
							'STUFF ' +
							'( ' +
								'( ' +
									'SELECT ' +
										''','' + ' +
										'QUOTENAME(COLUMN_NAME) + '' '' + ' +
										'DATA_TYPE + ' + 
										'CASE ' +
											'WHEN DATA_TYPE LIKE ''%char'' THEN ''('' + COALESCE(NULLIF(CONVERT(VARCHAR, CHARACTER_MAXIMUM_LENGTH), ''-1''), ''max'') + '') '' ' +
											'ELSE '' '' ' +
										'END + ' +
										'CASE IS_NULLABLE ' +
											'WHEN ''NO'' THEN ''NOT '' ' +
											'ELSE '''' ' +
										'END + ''NULL'' AS [text()] ' +
									'FROM tempdb.INFORMATION_SCHEMA.COLUMNS ' +
									'WHERE ' +
										'TABLE_NAME = (SELECT name FROM tempdb.sys.objects WHERE object_id = OBJECT_ID(''tempdb..#session_schema'')) ' +
										'ORDER BY ' +
											'ORDINAL_POSITION ' +
									'FOR XML ' +
										'PATH('''') ' +
								'), + ' +
								'1, ' +
								'1, ' +
								''''' ' +
							') + ' +
						''')''; ' 
				ELSE ''
			END
		--End derived table and INSERT specification
		);

	SET @sql_n = CONVERT(NVARCHAR(MAX), @sql);

	EXEC sp_executesql
		@sql_n,
		N'@schema VARCHAR(MAX) OUTPUT',
		@schema OUTPUT;
END;
GO


exec sys.sp_MS_marksystemobject 'dbo.sp_WhoIsActive';
go


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[startupcheck_fddba_convert_0_to_4]',10,1) WITH NOWAIT;
if object_id('dbo.startupcheck_fddba_convert_0_to_4') is null exec('create procedure [dbo].[startupcheck_fddba_convert_0_to_4] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[startupcheck_fddba_convert_0_to_4]
*
*	Purpose: Read StartupCheck configuration 0 format and update to 4 format
*
*	Inputs:	
*		@name : REQUIRED - name column of config_fddba2 to update
*		@domain_old : REQUIRED - domain column of config_fddba2 to update
*		@domain_new : OPTIONAL - new domain column value
*
*	Notes:	
*		1. This change is begin made to be consistent with other multi-value configuration settings in config_fddba2 table
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-03-20			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/

alter procedure [dbo].[startupcheck_fddba_convert_0_to_4]
(

	@domain_old varchar(100),
	@email_domain_new varchar(100) = NULL,
	@domain_new varchar(100) = NULL
)
AS
BEGIN
	DECLARE @name varchar(50)
	DECLARE @value nvarchar(3950)
	DECLARE @value2 nvarchar(3950)

	SET @name = 'parameters'

	SELECT TOP 1 @value = 'profile_name=' + [value] + ',' FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'profile_name' and [domain] = 'fddba\pStartUpCheck'
	SELECT TOP 1 @value = @value + 'recipients_normal=' + [value] + ',' FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'recipients' and [domain] = 'fddba\pStartUpCheck'
	SELECT TOP 1 @value = @value + 'fd_file_attachment=' + [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'file_attachments' and [domain] = 'fddba\pStartUpCheck'

	IF @value IS NULL
	BEGIN
		SET @value = 'profile_name=Agent Mail,recipients_normal=support@fortifieddata.com,fd_file_attachment=\\REPLACESERVER\REPLACESHARE\fdlogo.png,'
	END

	SELECT TOP 1 @value2 = 'FreeSpaceWarningPercent=' + [value] + ',' 
		FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'FreeSpaceWarningPercent' and [domain] = 'fddba\pStartUpCheck'
	SELECT TOP 1 @value2 = @value2 + 'IncludeSpaceReport=' + [value] + ',' 
		FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'IncludeSpaceReport' and [domain] = 'fddba\pStartUpCheck'

	IF @value2 IS NULL
	BEGIN
		SET @value2 = 'FreeSpaceWarningPercent=10,IncludeSpaceReport=1,'
	END

	BEGIN TRAN
		IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @name AND domain = @email_domain_new)
		BEGIN
			INSERT dbo.config_fddba2 ([name], domain, [value])
				VALUES (@name, @email_domain_new, @value)
		END

		IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2 WHERE [name] = @name AND domain = @domain_new)
		BEGIN
			INSERT dbo.config_fddba2 ([name], domain, [value])
				VALUES (@name, @domain_new, @value2)
		END

		DELETE dbo.config_fddba2 WHERE domain = @domain_old
	COMMIT TRAN
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[trace_flag_fddba_convert_2_to_3]',10,1) WITH NOWAIT;
if object_id('dbo.trace_flag_fddba_convert_2_to_3') is null exec('create procedure [dbo].[trace_flag_fddba_convert_2_to_3] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*
*	[dbo].[trace_flag_fddba_convert_2_to_3]
*
*	Purpose: Read trace flag configuration 2 format and update to 3 format
*
*	Inputs:	
*		@name : REQUIRED - name column of config_fddba2 to update
*		@domain_old : REQUIRED - domain column of config_fddba2 to update
*		@domain_new : OPTIONAL - new domain column value
*
*	Notes:	
*		1. Format 2 for trace flags was comma separated list with disabled trace flags as negative and enabled as positive. 
			Example for enabling 1118 and disabling 4199 is "1118,-4199,"
*		2. Format 3 for trace flag is multi-value list of <traceflag>=<0 or 1 for off or on respectively>. So 1 would become "1118=1,4199=0"
*		3. This change is begin made to be consistent with other multi-value configuration settings in config_fddba2 table
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2018-02-09			Mike Zawadzki			Created by FORTIFIED DATA SERVICES
*
*********************************************************************************************************************/

alter procedure [dbo].[trace_flag_fddba_convert_2_to_3]
(
	@name varchar(50),
	@domain_old varchar(100),
	@domain_new varchar(100) = NULL
)
AS
BEGIN
	DECLARE @trace_flags nvarchar(3950)

	SELECT @trace_flags = [value] FROM dbo.config_fddba2 WHERE [name] = @name AND [domain] = @domain_old
	IF @trace_flags IS NOT NULL
	BEGIN
		--convert to new format
		DECLARE @trace_flags_new nvarchar(3950)
		DECLARE @trace_flag varchar(10)

		SET @trace_flags_new = ''
		DECLARE trace_flag_convert_cursor CURSOR FOR
			SELECT items FROM dbo.fSplit(@trace_flags, ',')
		OPEN trace_flag_convert_cursor
		FETCH NEXT FROM trace_flag_convert_cursor INTO @trace_flag

		WHILE @@FETCH_STATUS != -1
		BEGIN
			IF CHARINDEX('-', @trace_flag) = 1
				SET @trace_flags_new = @trace_flags_new + SUBSTRING(@trace_flag, 2, LEN(@trace_flag)) + '=0,'
			ELSE
				SET @trace_flags_new = @trace_flags_new + @trace_flag + '=1,'

			FETCH NEXT FROM trace_flag_convert_cursor INTO @trace_flag
		END

		DEALLOCATE trace_flag_convert_cursor

		UPDATE dbo.config_fddba2 
			SET [value] = @trace_flags_new,
				[domain] = @domain_new,
				UpdatedOn = GETDATE()
			WHERE [name] = @name 
				AND [domain] = @domain_old 
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[track_waitstats_2005]',10,1) WITH NOWAIT;
if object_id('dbo.track_waitstats_2005') is null exec('create procedure [dbo].[track_waitstats_2005] as select getdate() DT')
GO
  
alter procedure [dbo].[track_waitstats_2005] (@num_samples INT=10
								,@delay_interval INT=1
								,@delay_type NVARCHAR(10)='minutes'
								,@truncate_history NVARCHAR(1)='N'
								,@clear_waitstats NVARCHAR(1)='Y')
WITH ENCRYPTION
AS
--
-- @num_samples is the number of times to capture waitstats, default is 10 times
-- default delay interval is 1 minute
-- delaynum is the delay interval - can be minutes or seconds
-- delaytype specifies whether the delay interval is minutes or seconds
-- create waitstats table IF it doesn't exist, otherwise truncate
-- Revision: 4/19/05 
--- (1) added object owner qualifier
--- (2) optional parameters to truncate history and clear waitstats
SET nocount on
IF not exists (SELECT 1 FROM sys.objects WHERE object_id = object_id ( N'[dbo].[waitstats]') and OBJECTPROPERTY(object_id, N'IsUserTable') = 1)
	create table [dbo].[waitstats] 
		(InstanceName	SYSNAME NOT NULL,
		[wait_type] NVARCHAR(60) not null, 
		[waiting_tasks_count] BIGINT not null,
		[wait_time_ms] BIGINT not null,
		[max_wait_time_ms] BIGINT not null,
		[signal_wait_time_ms] BIGINT not null,
		now DATETIME not null default getdate())
IF lower(@truncate_history) not in (N'y',N'n')
	begin
	raiserror ('valid @truncate_history VALUES are ''y'' or ''n''',16,1) with nowait	
	end
IF lower(@clear_waitstats) not in (N'y',N'n')
	begin
	raiserror ('valid @clear_waitstats VALUES are ''y'' or ''n''',16,1) with nowait	
	end
IF lower(@truncate_history) = N'y' 
	truncate table dbo.waitstats
IF lower (@clear_waitstats) = N'y' 
	dbcc sqlperf ([sys.dm_os_wait_stats],clear) with no_infomsgs -- clear out waitstats

DECLARE @i INT,@delay VARCHAR(8),@dt VARCHAR(3), @now DATETIME, @totalwait numeric(20,1)
	,@endtime DATETIME,@begintime DATETIME
	,@hr INT, @min INT, @sec INT
SELECT @i = 1
SELECT @dt = CASE lower(@delay_type)
	WHEN N'minutes' THEN 'm'
	WHEN N'minute' THEN 'm'
	WHEN N'min' THEN 'm'
	WHEN N'mi' THEN 'm'
	WHEN N'n' THEN 'm'
	WHEN N'm' THEN 'm'
	WHEN N'seconds' THEN 's'
	WHEN N'second' THEN 's'
	WHEN N'sec' THEN 's'
	WHEN N'ss' THEN 's'
	WHEN N's' THEN 's'
	ELSE @delay_type
end
IF @dt not in ('s','m')
begin
	raiserror ('delay TYPE must be either ''seconds'' or ''minutes''',16,1) with nowait
	RETURN
end
IF @dt = 's'
begin
	SELECT @sec = @delay_interval % 60, @min = cast((@delay_interval / 60) AS INT), @hr = cast((@min / 60) AS INT)
end
IF @dt = 'm'
begin
	SELECT @sec = 0, @min = @delay_interval % 60, @hr = cast((@delay_interval / 60) AS INT)
end
SELECT @delay= right('0'+ convert(VARCHAR(2),@hr),2) + ':' + 
	+ right('0'+convert(VARCHAR(2),@min),2) + ':' + 
	+ right('0'+convert(VARCHAR(2),@sec),2)
IF @hr > 23 or @min > 59 or @sec > 59
begin
	SELECT 'delay interval and TYPE: ' + convert (VARCHAR(10),@delay_interval) + ',' + @delay_type + ' converts to ' + @delay
	raiserror ('hh:mm:ss delay time cannot > 23:59:59',16,1) with nowait
	RETURN
end
WHILE (@i <= @num_samples)
begin
			SELECT @now = getdate()
            INSERT INTO [dbo].[waitstats] ([InstanceName],[wait_type], [waiting_tasks_count], [wait_time_ms], [max_wait_time_ms], [signal_wait_time_ms], CreatedOn)	
			SELECT @@SERVERNAME, [wait_type], [waiting_tasks_count], [wait_time_ms], [max_wait_time_ms], [signal_wait_time_ms], @now
				FROM sys.dm_os_wait_stats
			INSERT INTO [dbo].[waitstats] ([InstanceName], [wait_type], [waiting_tasks_count], [wait_time_ms], [max_wait_time_ms], [signal_wait_time_ms], CreatedOn)	
				SELECT @@SERVERNAME,'Total',sum([waiting_tasks_count]), sum([wait_time_ms]), 0, sum([signal_wait_time_ms]),@now
				FROM [dbo].[waitstats]
				WHERE CreatedOn = @now
			SELECT @i = @i + 1
			waitfor delay @delay
end


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_clustered_swap_results]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_clustered_swap_results') is null exec('create procedure [dbo].[usp_index_analysis_clustered_swap_results] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_clustered_swap_results
(
	@collection_session_id int, 
	@override_blacklist tinyint = 0,
	@database_name_filter sysname = NULL
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Return potential clustered index swap analysis result set
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. To easily differentiate result set and query from first column (collection_session_id) is renamed to type and query number.
*
*	Future Enhancements:
*	1. alter column list for usability
*
*	Current Known Bugs:
*	
*	Returns: single result set
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	--cleanup and generate data
	EXEC dbo.usp_index_analysis_expensive_results_generate @collection_session_id


	SELECT --e.*, 
			[DBName] = d.name,
			[Schema] = sc.name, 
			TableName = o.name, 
			IndexName = i.name, 
	--probably have to persist data for following column
	--		ColumnNames = e. 
			TotalSize_GB = CAST(e.TotalPages/128./1024. AS NUMERIC(13,4)),
			InRowSize_GB = CAST(e.InRowPages/128./1024. AS NUMERIC(13,4)),
			e.UserSeeks, 
			e.UserScans, 
			e.UserLookups, 
			e.UserUpdates, 
			e.TotalUsage,
			e.data_compression_max,
			[Filegroup Name] = f.name,
			[IsUnique] = i.is_unique,
			[FillFactor] = i.fill_factor,
			e.IndexCount, 
			[Disabled] = i.is_disabled,
			e.PartitionCount, 
			[RowLocks] = i.allow_row_locks,
			[PageLocks] = i.allow_page_locks,
			[Hypothetical] = i.is_hypothetical, 
			[IsDefault] = f.is_default,
			[IsReadOnly] = f.is_read_only,
			e.Last_User_Scan, 
			e.Last_User_Seek,
			[rownum] = 1,
			[tablenum] = ROW_NUMBER() OVER (ORDER BY e.UserLookups Desc),
			e.database_id,
			e.[object_id],
			e.index_id,
			e.collection_session_id
		INTO #HighLookups
		FROM [dbo].[index_analysis_expensive_indexes] e
			INNER JOIN db_indexes AS i
				ON i.[object_id] = e.[object_id]
				AND i.index_id = e.index_id 
				and i.database_id = e.database_id
				AND i.collection_session_id = e.collection_session_id
			INNER JOIN dbo.srv_databases AS d
				ON d.database_id = e.database_id
				AND d.collection_session_id = e.collection_session_id
			INNER JOIN db_objects AS o 
				ON o.[object_id] = i.[object_id]
				and o.database_id = i.database_id
				and o.collection_session_id = i.collection_session_id
			INNER JOIN db_schemas AS sc
				ON sc.[schema_id] = o.[schema_id]
				and sc.database_id = o.database_id
				and sc.collection_session_id = o.collection_session_id
			JOIN db_filegroups f 
				ON i.data_space_id = f.data_space_id
				and i.database_id = f.database_id
				and i.collection_session_id = f.collection_session_id
		WHERE e.index_id = 1 --clustered index
			AND e.IndexCount > 1
			AND e.UserLookups >= (e.UserSeeks * 2)
			AND e.collection_session_id = @collection_session_id

	SELECT --e.*, 
			[DBName] = d.name,
			[Schema] = sc.name, 
			TableName = o.name, 
			IndexName = i.name, 
	--probably have to persist data for following column
	--		ColumnNames = e. 
			TotalSize_GB = CAST(e.TotalPages/128./1024. AS NUMERIC(13,4)),
			InRowSize_GB = CAST(e.InRowPages/128./1024. AS NUMERIC(13,4)),
			e.UserSeeks, 
			e.UserScans, 
			e.UserLookups, 
			e.UserUpdates, 
			e.TotalUsage,
			e.data_compression_max,
			[Filegroup Name] = f.name,
			[IsUnique] = i.is_unique,
			[FillFactor] = i.fill_Factor,
			e.IndexCount, 
			[Disabled] = i.is_disabled,
			e.PartitionCount, 
			[RowLocks] = i.allow_row_locks,
			[PageLocks] = i.allow_page_locks,
			[Hypothetical] = i.is_hypothetical, 
			[IsDefault] = f.is_default,
			[IsReadOnly] = f.is_read_only,
			e.Last_User_Scan, 
			e.Last_User_Seek,
			[rownum] = ROW_NUMBER() OVER (PARTITION BY e.database_id, e.[object_id] ORDER BY e.UserSeeks Desc) + 1,
			[tablenum] = hl.tablenum,
			e.database_id,
			e.[object_id],
			e.index_id,
			e.collection_session_id
		INTO #Candidates
		FROM [dbo].[index_analysis_expensive_indexes] e
			INNER JOIN #HighLookups hl
				ON hl.database_id = e.database_id
				and hl.[object_id] = e.[object_id] 
				and hl.collection_session_id = e.collection_session_id
			INNER JOIN db_indexes AS i
				ON i.[object_id] = e.[object_id]
				AND i.index_id = e.index_id 
				and i.database_id = e.database_id
				AND i.collection_session_id = e.collection_session_id
			INNER JOIN dbo.srv_databases AS d
				ON d.database_id = e.database_id
				AND d.collection_session_id = e.collection_session_id
			INNER JOIN db_objects AS o 
				ON o.[object_id] = i.[object_id]
				and o.database_id = i.database_id
				and o.collection_session_id = i.collection_session_id
			INNER JOIN db_schemas AS sc
				ON sc.[schema_id] = o.[schema_id]
				and sc.database_id = o.database_id
				and sc.collection_session_id = o.collection_session_id
			JOIN db_filegroups f 
				ON i.data_space_id = f.data_space_id
				and i.database_id = f.database_id
				and i.collection_session_id = f.collection_session_id
		WHERE e.index_id > 1 --nonclustered index
			AND e.IndexCount > 1
			AND e.UserSeeks > hl.UserSeeks
			AND e.collection_session_id = @collection_session_id

	IF @database_name_filter IS NULL
	BEGIN
		IF @override_blacklist = 0
		BEGIN
			SELECT collection_session_id AS [ClusteredIDXSwapsAnalysis1 CSID], *
				FROM #HighLookups
				WHERE EXISTS (select 1 from #Candidates c where c.tablenum = tablenum)
					AND database_id NOT IN (SELECT ISNULL(database_id,0) FROM dbo.index_analysis_db_backlist WHERE is_enabled = 1)
			UNION
			SELECT collection_session_id AS [ClusteredIDXSwapsAnalysis1 CSID], *
				FROM #Candidates
				WHERE rownum <=3
					AND database_id NOT IN (SELECT ISNULL(database_id,0) FROM dbo.index_analysis_db_backlist WHERE is_enabled = 1)
			ORDER BY tablenum, rownum
		END
		ELSE --@override_blacklist != 0
		BEGIN
			SELECT collection_session_id AS [ClusteredIDXSwapsAnalysis2 CSID], *
				FROM #HighLookups
				WHERE EXISTS (select 1 from #Candidates c where c.tablenum = tablenum)
			UNION
			SELECT collection_session_id AS [ClusteredIDXSwapsAnalysis2 CSID], *
				FROM #Candidates
				WHERE rownum <=3
			ORDER BY tablenum, rownum
		END
	END
	ELSE --@database_name_filter IS NOT NULL
	BEGIN
		SELECT collection_session_id AS [ClusteredIDXSwapsAnalysis3 CSID], *
			FROM #HighLookups
			WHERE EXISTS (select 1 from #Candidates c where c.tablenum = tablenum)
				AND DBName = @database_name_filter
		UNION
		SELECT collection_session_id AS [ClusteredIDXSwapsAnalysis3 CSID], *
			FROM #Candidates
			WHERE rownum <=3
				AND DBName = @database_name_filter
		ORDER BY tablenum, rownum
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_collect]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_collect') is null exec('create procedure [dbo].[usp_index_analysis_collect] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_collect
(
	@collect_index_metadata tinyint = 1,
	@collect_index_perfdata tinyint = 1,
	@collect_query_stats_data tinyint = 1,
	@object_filter nvarchar(392) = NULL, --size is 128*3 (for db, sch, obj) +  6 (square brackes for each prior name) + 2 (periods to separte names)
	@query_stats_filter sysname = NULL,
	@min_index_size int = 1024,
	@max_compression_count int = 200,
	@compression_index_filter nvarchar(523) = NULL --size is 128*4 (for db, sch, obj, idx names) +  8 (square brackes for each prior name) + 3 (periods to separte names)
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	collect index data and query statistics to be able to perform offline index analysis with backup of 
*				FDDBA database. 
*	Inputs:		
*
*	@collect_index_metadata - optional with default of 1 to collect index metadata and index compression data
*	@collect_index_perfdata - optional with default of 1 to collect sys.dm_db_index_operational_stats and 
*		sys.dm_db_index_usage_stats
*	@collect_query_stats_data - optional with default of 1 to collect top worst query stats by CPU, Duration, 
*		stored proc, trigger, function, and aggregated ad-hoc
*	@object_filter - optional with default of null causing no filtering. Non-null values passed expected to be
*		in format of <database_name>.<schema_name>.<table_name>. Wildcard characters are not allowed. Using this parameter will 
*		override @collect_query_stats_data to 0 and will disable index compression testing.
*	@query_stats_filter - optional with default of null allowing capture of query stats for stored proc, trigger, and function
*		to be from a specific database. NULL means no filtering. If invalid database name is passed it will abort all 
*		execution of this procedure.
*	@min_index_size - optional with default of 8MB (in pages) to set minimum index size to consider for compression analysis
*	@max_compression_count - optional with default of 200 to set maximum number of indexes to perform compression
*		analysis and logic causes doubling of @min_index_size until number of indexes of that size is less than this
*	@compression_index_filter - optional with default of null causing no filtering. Non-null values passed expected to be
*		in format of <database_name>.<schema_name>.<table_name>.<index_name>. Also, wildcard character "%" is allowed in any 
*		name and passing partial set of values implies "%" is value for missing names. Using this format will override behavior
*		of not repeating compression analysis.
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. The various tables are all joined together by time using collection_session_id column which exists in every table
*		so that multiple runs can be separated from one another.
*	2. This procedure will collect data to but does not do the actual analysis. There are additional queries that can be
*		executed against a collection_session_id run to complete the analysis. I will update location here once checked in
*	3. Expected use would be complete run to start analysis with, then possibly runs of just @collect_query_stats_data = 1
*		as code and query changes are possibly made then full run again after a round of index changes are made.
*	4. Please review comments of usp_snapshot_dm_db_index_usage_stats for how to manage IndexUsageStats table before making
*		a round of index changes. The dbo.IndexUsageStats table of FDDBA database has NOT been modified for this collection
*		to include the collection_session_id column as it is a running total over time. 
*	5. Performance statistics are kept of each run along with parameters used. This data is the same as the text mode
*		output seen during a run with exception of only saving data when an individual collection runs for more than one
*		second. Parameters, skipped sections and final completion are always logged. Data is stored in 
*		collection_session_perf table.
*	6. This has been designed to easily add in another query and if done a new collection_type should be added to the
*		collection_session_perf table.
*	7. Index compression analysis will only be run one time for a perticular index so that repeated work is not done. If
*		you wish to repeat work please use @compression_index_filter parameter.
*
*	Future Enhancements:
*	1. Always pull stats for objects that are in dm_exec_code_to_track (collection type 15,16,17)
*	2. Find way to record changes for future review/analysis
*	3. Consider page level compression evaluation for indexes with row level compression that have not been checked in the past
*
*	Current Known Bugs:
*	1. Allow unfiltered database collection for dm_exec_code (collection type 18)
*	
*	Returns:	Stores data in various tables in FDDBA and gives progress messages when using text results mode
*	Prerequisite: usp_persist_dm_db_index_usage_stats if @collect_index_perfdata = 1
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/8/2017			Mike Zawadzki			Created
*	6/19/2017			Mike Zawadzki			Added collector 22 and removed repeated compression work
*	6/22/2017			Mike Zawadzki			Changed parameters and added ability to filter to specific object to target after index changes
*	6/23/2017			Mike Zawadzki			Fixed bug with due to column order of dbo.db_indexes
*	6/26/2017			Mike Zawadzki			Fixed bug when @query_stats_filter is null causing null value insert of in perf table for database_id
********************************************************************************************************************/
	SET NOCOUNT ON

	DECLARE @dbname sysname 
	DECLARE @object_name sysname 
	DECLARE @schema_name sysname 
	DECLARE @index_id varchar(20)
	DECLARE @partition_id varchar(20)
	DECLARE @sqltext VARCHAR(MAX)
	DECLARE @count int
	DECLARE @id int
	DECLARE @database_id int
	DECLARE @object_id int
	DECLARE @msg varchar(100)
	DECLARE @dt datetime = GETDATE()
	DECLARE @dtstart datetime
	DECLARE @dtend datetime
	DECLARE @delta int
	DECLARE @cid int
	DECLARE @cmd nvarchar(4000)
	DECLARE @dbid smallint = DB_ID(@query_stats_filter) 
	--DECLARE @plan_dbid_filter binary(4)
	DECLARE @index_name sysname
	DECLARE @comp_dbname sysname
	DECLARE @comp_schname sysname
	DECLARE @comp_objname sysname
	DECLARE @comp_idxname sysname
	DECLARE @comp_dbid int
	DECLARE @comp_schid int
	DECLARE @comp_objid int
	DECLARE @comp_idxid int
	DECLARE @period1 int
	DECLARE @period2 int
	DECLARE @period3 int
	DECLARE @wildcard int
	DECLARE @obj_dbname sysname
	DECLARE @obj_schname sysname
	DECLARE @obj_objname sysname
	DECLARE @obj_idxname sysname
	DECLARE @obj_dbid int
	DECLARE @obj_schid int
	DECLARE @obj_objid int


	DECLARE @fValidParams tinyint = 1

	--temporary tables necessary for index compression analysis
	CREATE TABLE #Page
	(
		[object_name] sysname NOT NULL,
		[schema_name] sysname NOT NULL,
		[index_id] int NOT NULL,
		[partition_number] int NOT NULL,
		[size_with_current_compression_setting(KB)] bigint NOT NULL,
		[size_with_requested_compression_setting(KB)] bigint NOT NULL,
		[sample_size_with_current_compression_setting(KB)] bigint NOT NULL,
		[sample_size_with_requested_compression_setting(KB)] bigint NOT NULL,
		database_id int NULL,
		[object_id] int NULL,
		Page_ID int identity(1,1) NOT NULL,
	)

	CREATE TABLE #Row
	(
		[object_name] sysname NOT NULL,
		[schema_name] sysname NOT NULL,
		[index_id] int NOT NULL,
		[partition_number] int NOT NULL,
		[size_with_current_compression_setting(KB)] bigint NOT NULL,
		[size_with_requested_compression_setting(KB)] bigint NOT NULL,
		[sample_size_with_current_compression_setting(KB)] bigint NOT NULL,
		[sample_size_with_requested_compression_setting(KB)] bigint NOT NULL,
		database_id int NULL,
		[object_id] int NULL,
		Row_ID int identity(1,1) NOT NULL,
	)

	SET @dtstart = GETDATE()

	INSERT dbo.collection_session VALUES (getdate(),@@SERVERNAME, NULL)
	SET @cid = @@IDENTITY

	--check for valid parameters
	IF @query_stats_filter IS NOT NULL and @dbid IS NULL
	BEGIN
		SET @msg = convert(varchar(23), @dtstart, 126) + ' ERROR! Invalid @query_stats_filter = [' + @query_stats_filter + '] - EXITING!'
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)
		SET @fValidParams = 0
	END
	
	IF @object_filter IS NOT NULL
	BEGIN
		EXEC dbo.usp_parse_name @object_filter, 3, @obj_dbname OUTPUT, @obj_schname OUTPUT, @obj_objname OUTPUT, @obj_idxname OUTPUT

		SET @obj_dbid = DB_ID(@obj_dbname)
		IF @obj_dbid IS NOT NULL
		BEGIN
			SET @cmd = N'SELECT @id = schema_id FROM [' + @obj_dbname + N'].sys.schemas WHERE name = ''' + @obj_schname + N''''
			EXEC sys.sp_executesql @cmd, N'@id int OUTPUT', @id = @obj_schid OUTPUT
			IF @obj_schid IS NOT NULL
			BEGIN
				SET @cmd = N'SELECT @id = object_id FROM [' + @obj_dbname + N'].sys.tables WHERE name = ''' + @obj_objname + N''' and schema_id = ' + LTRIM(STR(@obj_schid)) + N' and type in (''U'',''V'')' 
				EXEC sys.sp_executesql @cmd, N'@id int OUTPUT', @id = @obj_objid OUTPUT
				IF @obj_objid IS NULL
				BEGIN
					SET @msg = convert(varchar(23), @dtstart, 126) + ' Invalid @object_filter parameter: object=[' + @obj_objname + '] - EXITING!'
					RAISERROR (@msg,10,1) WITH NOWAIT
					INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)
					SET @fValidParams = 0
				END
			END
			ELSE
			BEGIN
				SET @msg = convert(varchar(23), @dtstart, 126) + ' Invalid @object_filter parameter: schema=[' + @obj_schname + '] - EXITING!'
				RAISERROR (@msg,10,1) WITH NOWAIT
				INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)
				SET @fValidParams = 0
			END
		END
		ELSE
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Invalid @object_filter parameter: database=[' + @obj_dbname + '] - EXITING!'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)
			SET @fValidParams = 0
		END
	END

	IF @fValidParams = 1
	BEGIN
		--record parameters
		SET @msg = convert(varchar(23), @dtstart, 126) + ' @collect_index_metadata = ' + LTRIM(STR(@collect_index_metadata))
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)

		SET @msg = convert(varchar(23), @dtstart, 126) + ' @collect_index_perfdata = ' + LTRIM(STR(@collect_index_perfdata))
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)

		SET @msg = convert(varchar(23), @dtstart, 126) + ' @collect_query_stats_data = ' + LTRIM(STR(@collect_query_stats_data))
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)

		SET @msg = convert(varchar(23), @dtstart, 126) + ' @object_filter = ' + ISNULL(@object_filter, '(null)')
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)

		SET @msg = convert(varchar(23), @dtstart, 126) + ' @query_stats_filter = ' + ISNULL(@query_stats_filter, '(null)')
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)

		SET @msg = convert(varchar(23), @dtstart, 126) + ' @min_index_size = ' + LTRIM(STR(@min_index_size))
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)

		SET @msg = convert(varchar(23), @dtstart, 126) + ' @max_compression_count = ' + LTRIM(STR(@max_compression_count))
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)

		SET @msg = convert(varchar(23), @dtstart, 126) + ' @compression_index_filter = ' + ISNULL(@compression_index_filter, '(null)')
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)

		--override behavior if @object_filter is passed
		IF @object_filter IS NOT NULL
		BEGIN
			IF @collect_query_stats_data = 1
			BEGIN
				SET @collect_query_stats_data = 0
			END
		END

		SET @dtstart = GETDATE()

		IF @collect_index_metadata = 1
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [sys.databases]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			INSERT dbo.srv_databases
				SELECT @cid, database_id, [name], is_read_only, [state] from sys.databases
			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0
			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, @delta, @msg)
			END
		END
		ELSE
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Skipping index metadata due to parameter'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)
		END

		SET @dtstart = GETDATE()

		IF @collect_index_perfdata = 1
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [sys.dm_db_index_operational_stats]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			IF @obj_objid IS NULL
			BEGIN
				INSERT dbo.db_index_operational_stats
					SELECT @cid, database_id, [object_id], index_id, partition_number, leaf_insert_count, leaf_delete_count, leaf_update_count, leaf_ghost_count, nonleaf_insert_count, nonleaf_delete_count, 
							nonleaf_update_count, leaf_page_merge_count, range_scan_count, singleton_lookup_count, lob_fetch_in_pages, row_overflow_fetch_in_pages, index_lock_promotion_count
						FROM sys.dm_db_index_operational_stats (NULL, NULL, NULL, NULL)
						WHERE [object_id] > 100 
							AND 
							(
								leaf_insert_count > 0 OR
								leaf_delete_count > 0 OR
								leaf_update_count > 0 OR
								leaf_page_merge_count > 0
						)
			END
			ELSE
			BEGIN
				INSERT dbo.db_index_operational_stats
					SELECT @cid, database_id, [object_id], index_id, partition_number, leaf_insert_count, leaf_delete_count, leaf_update_count, leaf_ghost_count, nonleaf_insert_count, nonleaf_delete_count, 
							nonleaf_update_count, leaf_page_merge_count, range_scan_count, singleton_lookup_count, lob_fetch_in_pages, row_overflow_fetch_in_pages, index_lock_promotion_count
						FROM sys.dm_db_index_operational_stats (@obj_dbid, @obj_objid, NULL, NULL)
			END
			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0
			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, 0, 1, @delta, @msg)
			END
		END
		ELSE
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Skipping index perfdata due to parameter'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 1, 0, @msg)
		END

		IF @collect_index_metadata = 1
		BEGIN
			DECLARE db_cur CURSOR FOR SELECT database_id, [name] FROM sys.databases WHERE state = 0
			OPEN db_cur
			FETCH NEXT FROM db_cur INTO @database_id, @dbname
			WHILE @@FETCH_STATUS != -1
			BEGIN
				SET @dtstart = GETDATE()

				IF @obj_objid IS NULL OR @dbname = @obj_dbname
				BEGIN
					SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [' + @dbname + ']'
					RAISERROR (@msg,10,1) WITH NOWAIT

					--all ad-hoc inserts below in @cmd variable must be 3 part named since in a different database than FDDBA
					SET @dtstart = GETDATE()
					SET @cmd = N'use [' + @dbname + N'];
insert FDDBA.dbo.db_schemas select ' + ltrim(str(@cid)) + N', db_id(), schema_id, name from sys.schemas where schema_id < 16384'

					EXEC (@cmd)

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT FDDBA.dbo.collection_session_perf VALUES (@cid, @database_id, 2, @delta, NULL)
					END
					
					SET @dtstart = GETDATE()
					SET @cmd = 'use [' + @dbname + N'];
insert FDDBA.dbo.db_objects select ' + ltrim(str(@cid)) + N', db_id(), object_id, schema_id, type, name from sys.objects where type in (''V'',''U'',''S'') '
					IF @obj_objid IS NOT NULL
					BEGIN
						SET @cmd = @cmd + N'and object_id = ' + LTRIM(STR(@obj_objid))
					END

					EXEC (@cmd)

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT FDDBA.dbo.collection_session_perf VALUES (@cid, @database_id, 3, @delta, NULL)
					END

					SET @dtstart = GETDATE()
					SET @cmd = 'use [' + @dbname + N'];
insert FDDBA.dbo.db_indexes (collection_session_id, database_id, object_id, index_id, type, data_space_id, is_unique, ignore_dup_key, is_primary_key, is_unique_constraint, fill_factor, is_padded, is_disabled, is_hypothetical, allow_row_locks, allow_page_locks, has_filter, name)
	select ' + ltrim(str(@cid)) + N', db_id(), object_id, index_id, type, data_space_id, is_unique, ignore_dup_key, is_primary_key, is_unique_constraint, fill_factor, is_padded, is_disabled, is_hypothetical, allow_row_locks, allow_page_locks, has_filter, name from sys.indexes '
					IF @obj_objid IS NOT NULL
					BEGIN
						SET @cmd = @cmd + N'where object_id = ' + LTRIM(STR(@obj_objid))
					END

					EXEC (@cmd)

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT FDDBA.dbo.collection_session_perf VALUES (@cid, @database_id, 4, @delta, NULL)
					END

					SET @dtstart = GETDATE()
					SET @cmd = 'use [' + @dbname + N'];
insert FDDBA.dbo.db_sysindexes select ' + ltrim(str(@cid)) + N', db_id(), id, indid, dpages, rowcnt, rowmodctr from sys.sysindexes where dpages > 0 '
					IF @obj_objid IS NOT NULL
					BEGIN
						SET @cmd = @cmd + N'and id = ' + LTRIM(STR(@obj_objid))
					END

					EXEC (@cmd)

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT FDDBA.dbo.collection_session_perf VALUES (@cid, @database_id, 5, @delta, NULL)
					END
					SET @dtstart = GETDATE()
					SET @cmd = 'use [' + @dbname + N'];
insert FDDBA.dbo.db_filegroups select ' + ltrim(str(@cid)) + N', db_id(), data_space_id, [type], is_default, is_read_only, [name] from sys.filegroups'

					EXEC (@cmd)

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT FDDBA.dbo.collection_session_perf VALUES (@cid, @database_id, 6, @delta, NULL)
					END

					SET @dtstart = GETDATE()
					SET @cmd = 'use [' + @dbname + N'];
insert FDDBA.dbo.db_partitions select ' + ltrim(str(@cid)) + N', db_id(), [partition_id], object_id, index_id, partition_number, hobt_id, [data_compression] from sys.partitions where '
					IF @obj_objid IS NOT NULL
					BEGIN
						SET @cmd = @cmd + N'object_id = ' + LTRIM(STR(@obj_objid))
					END
					ELSE
					BEGIN
						SET @cmd = @cmd + N'object_id > 100'
					END 
					
					EXEC (@cmd)

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT FDDBA.dbo.collection_session_perf VALUES (@cid, @database_id, 7, @delta, NULL)
					END
					SET @dtstart = GETDATE()
					SET @cmd = 'use [' + @dbname + N'];
insert FDDBA.dbo.db_allocation_units select ' + ltrim(str(@cid)) + N', db_id(), au.[type], au.container_id, au.data_space_id, au.total_pages 
	from sys.allocation_units au '
					IF @obj_objid IS NOT NULL
					BEGIN
						SET @cmd = @cmd + N'inner join sys.partitions p on au.container_id = p.hobt_id where p.object_id = ' + LTRIM(STR(@obj_objid))
					END
					ELSE
					BEGIN
						SET @cmd = @cmd + N'where au.total_pages > 0'
					END 

					EXEC (@cmd)

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT FDDBA.dbo.collection_session_perf VALUES (@cid, @database_id, 8, @delta, NULL)
					END

					SET @dtstart = GETDATE()
					SET @cmd = 'use [' + @dbname + N'];
insert FDDBA.dbo.db_index_columns select ' + ltrim(str(@cid)) + N', db_id(), object_id, index_id, column_id, key_ordinal, is_descending_key, is_included_column from sys.index_columns where '
					IF @obj_objid IS NOT NULL
					BEGIN
						SET @cmd = @cmd + N'object_id = ' + LTRIM(STR(@obj_objid))
					END
					ELSE
					BEGIN
						SET @cmd = @cmd + N'object_id > 100'
					END 

					EXEC (@cmd)

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT FDDBA.dbo.collection_session_perf VALUES (@cid, @database_id, 9, @delta, NULL)
					END

					SET @dtstart = GETDATE()
					SET @cmd = 'use [' + @dbname + N'];
insert FDDBA.dbo.db_columns select distinct ' + ltrim(str(@cid)) + N', db_id(), c.object_id, c.column_id, c.[name] from sys.columns c 
    inner join sys.index_columns i on c.object_id = i.object_id and c.column_id = i.column_id 
	inner join sys.sysindexes si on i.object_id = si.id and i.index_id = si.indid '
					IF @obj_objid IS NOT NULL
					BEGIN
						SET @cmd = @cmd + N'where c.object_id = ' + LTRIM(STR(@obj_objid))
					END
					ELSE
					BEGIN
						SET @cmd = @cmd + N'where c.object_id > 100	and si.dpages > 0'
					END
					
					EXEC (@cmd)

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT FDDBA.dbo.collection_session_perf VALUES (@cid, @database_id, 10, @delta, NULL)
					END
				END
				FETCH NEXT FROM db_cur INTO @database_id, @dbname
			END
			DEALLOCATE db_cur
		END

		IF @collect_index_perfdata = 1
		BEGIN
			SET @dtstart = GETDATE()

			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [sys.dm_db_index_usage_stats]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			EXEC dbo.usp_persist_dm_db_index_usage_stats

			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0

			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, 0, 11, @delta, @msg)
			END
		END

		IF @collect_index_perfdata = 1
		BEGIN
			SET @dtstart = GETDATE()

			SET @msg = convert(varchar(23),@dtstart, 126) + ' Starting [missing_indexes join]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			INSERT dbo.db_missing_indexes
				SELECT @cid, database_id
					, d.object_id
					, avg_total_user_cost
					, avg_user_impact
					, user_seeks
					, user_scans
					, s.unique_compiles
					, s.last_user_seek
					, equality_columns
					, inequality_columns
					, included_columns
				FROM sys.dm_db_missing_index_group_stats s
				JOIN sys.dm_db_missing_index_groups g
					ON s.group_handle = g.index_group_handle
				JOIN sys.dm_db_missing_index_details d
					ON d.index_handle = g.index_handle

			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0
			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, 0, 12, @delta, @msg)
			END
		END

		SET @dtstart = GETDATE()

		IF @collect_query_stats_data = 1
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [sys.dm_exec_query_stats (unfiltered)]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			/*
			IF @dbid IS NOT NULL
			BEGIN
				SET @plan_dbid_filter = 0x0500 + SUBSTRING(CONVERT(binary(2), @dbid),2,1) + SUBSTRING(CONVERT(binary(2), @dbid),1,1)

						dm_exec_query_stats_id int identity(1,1) NOT NULL,
			*/
			INSERT dbo.dm_exec_query_stats (collection_session_id, database_id, [object_id], usecounts, plansizeKB, total_worker_timeMS, total_elapsed_timeMS, 
					total_physical_reads, total_logical_writes, total_logical_reads,CpuRank, PhysicalReadsRank, DurationRank, query_hash, query_plan_hash, creation_time,
					statement_start_offset, statement_end_offset, plan_generation_num, min_worker_time, last_worker_time, max_worker_time, 
					min_elapsed_time, last_elapsed_time, max_elapsed_time, min_physical_reads, last_physical_reads, max_physical_reads,
					min_logical_writes, last_logical_writes, max_logical_writes, min_logical_reads, last_logical_reads, max_logical_reads,
					total_rows, min_rows, last_rows, max_rows, plan_handle, cacheobjtype, procname, stmt_text)
				SELECT @cid,
						CONVERT(int, pa.value),
						sql.objectid,
						p.usecounts, 
						p.size_in_bytes / 1024, -- 'size_in_kb'
						PlanStats.total_worker_time/1000, -- AS 'tot_cpu_ms'
						PlanStats.total_elapsed_time/1000, -- AS 'tot_duration_ms'
						PlanStats.total_physical_reads, PlanStats.total_logical_writes, PlanStats.total_logical_reads,
						PlanStats.CpuRank, PlanStats.PhysicalReadsRank, PlanStats.DurationRank, 
						PlanStats.query_hash, PlanStats.query_plan_hash, PlanStats.creation_time, 
						PlanStats.statement_start_offset, PlanStats.statement_end_offset, PlanStats.plan_generation_num,
						PlanStats.min_worker_time, PlanStats.last_worker_time, PlanStats.max_worker_time,
						PlanStats.min_elapsed_time, PlanStats.last_elapsed_time, PlanStats.max_elapsed_time,
						PlanStats.min_physical_reads, PlanStats.last_physical_reads, PlanStats.max_physical_reads, 
						PlanStats.min_logical_writes, PlanStats.last_logical_writes, PlanStats.max_logical_writes, 
						PlanStats.min_logical_reads, PlanStats.last_logical_reads, PlanStats.max_logical_reads,
						PlanStats.total_rows, PlanStats.min_rows, PlanStats.last_rows, PlanStats.max_rows,
						PlanStats.plan_handle,
						LEFT (p.cacheobjtype + ' (' + p.objtype + ')', 35), -- AS 'cacheobjtype'
						case 
							when substring(PlanStats.plan_handle,1,1) = 0x05 and pa.value!=32767
								then object_name(sql.objectid,convert(int,pa.value))
							when substring(PlanStats.plan_handle,1,1) = 0x05 and pa.value=32767
								then --CONVERT (sysname, REPLACE (REPLACE (sql.[text],CHAR(13), ' '), CHAR(10), ' '))
									LEFT(SUBSTRING(sql.[text], CHARINDEX(N' sys.', sql.[text]) + 1, CHARINDEX(N' ', sql.[text], CHARINDEX(N' sys.', sql.[text]) + 1) - CHARINDEX(N' sys.', sql.[text])),128)
							else null 
						end, -- as 'procname'
						LEFT(SUBSTRING (sql.[text], PlanStats.statement_start_offset/2 + 1, 
								CASE 
									WHEN PlanStats.statement_end_offset = -1 THEN LEN (CONVERT(nvarchar(max), sql.[text])) 
									ELSE PlanStats.statement_end_offset/2 - PlanStats.statement_start_offset/2 + 1
								END)
							,512) -- AS 'stmt_text' 
					FROM 
					(
						SELECT 
							stat.plan_handle, statement_start_offset, statement_end_offset, 
							stat.total_worker_time, stat.total_elapsed_time, stat.total_physical_reads, 
							stat.total_logical_writes, stat.total_logical_reads,
							stat.query_hash, stat.query_plan_hash, stat.plan_generation_num, stat.creation_time, 
							stat.last_worker_time, stat.min_worker_time, stat.max_worker_time, stat.last_elapsed_time, stat.min_elapsed_time, stat.max_elapsed_time,
							stat.last_physical_reads, stat.min_physical_reads, stat.max_physical_reads, stat.last_logical_writes, stat.min_logical_writes, stat.max_logical_writes, 
							stat.last_logical_reads, stat.min_logical_reads, stat.max_logical_reads,
							stat.total_rows, stat.min_rows, stat.last_rows, stat.max_rows,
							ROW_NUMBER() OVER (ORDER BY stat.total_worker_time DESC) AS CpuRank, 
							ROW_NUMBER() OVER (ORDER BY stat.total_physical_reads DESC) AS PhysicalReadsRank, 
							ROW_NUMBER() OVER (ORDER BY stat.total_elapsed_time DESC) AS DurationRank 
						FROM sys.dm_exec_query_stats stat 
			--	WHERE SUBSTRING(stat.plan_handle,1,4) = @plan_dbid_filter
					) AS PlanStats 
						INNER JOIN sys.dm_exec_cached_plans p 
							ON p.plan_handle = PlanStats.plan_handle 
						OUTER APPLY sys.dm_exec_plan_attributes (p.plan_handle) pa 
						OUTER APPLY sys.dm_exec_sql_text (p.plan_handle) AS sql
					WHERE 
					(
						PlanStats.CpuRank < 100 
						OR PlanStats.PhysicalReadsRank < 100 
						OR PlanStats.DurationRank < 100
					)
						AND pa.attribute = 'dbid' 
					ORDER BY 6 DESC

			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0
			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, 0, 13, @delta, @msg)
			END

			SET @dtstart = GETDATE()

			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [sys.dm_exec_procedure_stats]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			IF @dbid IS NOT NULL
			BEGIN
				INSERT dbo.dm_exec_code_stats
					SELECT top 50 @cid, database_id, [object_id], [type], cached_time, last_execution_time, execution_count, total_worker_time/1000, total_elapsed_time/1000
						from sys.dm_exec_procedure_stats
						WHERE database_id = @dbid
						ORDER BY total_worker_time
			END
			ELSE
			BEGIN
				INSERT dbo.dm_exec_code_stats
					SELECT top 200 @cid, database_id, [object_id], [type], cached_time, last_execution_time, execution_count, total_worker_time/1000, total_elapsed_time/1000
						from sys.dm_exec_procedure_stats
						ORDER BY total_worker_time
			END

			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0
			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, ISNULL(@dbid,0), 15, @delta, @msg)
			END

			SET @dtstart = GETDATE()

			IF @@MICROSOFTVERSION > 218103808 --13.0.0
			BEGIN
				SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [sys.dm_exec_function_stats]'
				RAISERROR (@msg,10,1) WITH NOWAIT

				IF @dbid IS NOT NULL
				BEGIN
					SET @cmd = 'INSERT dbo.dm_exec_code_stats
	SELECT TOP 50 ' + LTRIM(STR(@cid)) + ', database_id, [object_id], [type], cached_time, last_execution_time, execution_count, total_worker_time/1000, total_elapsed_time/1000
		FROM sys.dm_exec_function_stats
		WHERE database_id = ' + LTRIM(STR(@dbid)) + '
		ORDER BY total_worker_time'
				END
				ELSE
				BEGIN
					SET @cmd = 'INSERT dbo.dm_exec_code_stats
	SELECT top 200 ' + LTRIM(STR(@cid)) + ', database_id, [object_id], [type], cached_time, last_execution_time, execution_count, total_worker_time/1000, total_elapsed_time/1000
		from sys.dm_exec_function_stats
		ORDER BY total_worker_time'
				END

				EXEC (@cmd)

				SET @dtend = GETDATE()
				SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
				IF @delta > 0
				BEGIN
					INSERT dbo.collection_session_perf VALUES (@cid, ISNULL(@dbid,0), 16, @delta, @msg)
				END
			END

			SET @dtstart = GETDATE()

			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [sys.dm_exec_trigger_stats]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			IF @dbid IS NOT NULL
			BEGIN
				INSERT dbo.dm_exec_code_stats
					SELECT top 50 @cid, database_id, [object_id], [type], cached_time, last_execution_time, execution_count, total_worker_time/1000, total_elapsed_time/1000
						from sys.dm_exec_trigger_stats
						WHERE database_id = @dbid
						ORDER BY total_worker_time
			END
			ELSE
			BEGIN
				INSERT dbo.dm_exec_code_stats
					SELECT top 200 @cid, database_id, [object_id], [type], cached_time, last_execution_time, execution_count, total_worker_time/1000, total_elapsed_time/1000
						from sys.dm_exec_trigger_stats
						ORDER BY total_worker_time
			END

			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0
			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, ISNULL(@dbid,0), 17, @delta, @msg)
			END

			SET @dtstart = GETDATE()

			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [dbo.dm_exec_code]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			--TODO: change to cursor over db in exec() to handle more than single db
			IF @dbid IS NOT NULL
			BEGIN
				SET @cmd = 'USE ['+@query_stats_filter+']; 
INSERT FDDBA.dbo.dm_exec_code (collection_session_id, database_id, schema_id, object_id, name, type, create_date, modified_date)
	SELECT ' + LTRIM(STR(@cid)) + ', db_id(), 
			[schema_id], o.[object_id], [name], o.[type], o.create_date, o.modify_date
		FROM sys.objects o
			INNER JOIN FDDBA.dbo.dm_exec_code_stats cs
				on o.object_id = cs.object_id
					and cs.collection_session_id = ' + LTRIM(STR(@cid)) + '
					and cs.database_id = db_id()
--following code pulls object type and schema_id for objects captured by FDDBA.dbo.dm_exec_query_stats
INSERT FDDBA.dbo.dm_exec_code (collection_session_id, database_id, schema_id, object_id, name, type, create_date, modified_date)
	SELECT ' + LTRIM(STR(@cid)) + ', db_id(), 
			[schema_id], o.[object_id], o.[name], o.[type], o.create_date, o.modify_date
		FROM sys.objects o
			INNER JOIN FDDBA.dbo.dm_exec_query_stats qs
				on o.object_id = qs.object_id
					and qs.collection_session_id = ' + LTRIM(STR(@cid)) + '
					and qs.database_id = db_id()					
		WHERE qs.object_id not in 
		(
			SELECT DISTINCT object_id FROM FDDBA.dbo.dm_exec_code c
				WHERE qs.collection_session_id = c.collection_session_id
				and qs.database_id = c.database_id
		)'

				EXEC (@cmd)

				SET @dtend = GETDATE()
				SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
				IF @delta > 0
				BEGIN
					INSERT dbo.collection_session_perf VALUES (@cid, ISNULL(@dbid,0), 18, @delta, @msg)
				END
			END

			SET @dtstart = GETDATE()

			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [sys.dm_exec_query_stats (adhoc aggregate)]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			INSERT dbo.dm_exec_adhoc_stats
				SELECT TOP 50 @cid, SUM(execution_count), SUM(total_worker_time)/1000, SUM(total_elapsed_time)/1000, COUNT(DISTINCT query_plan_hash) AS 'plan_cnt', query_hash 
					FROM sys.dm_exec_query_stats 
					WHERE SUBSTRING(plan_handle,1,1) = 0x06 
					GROUP BY query_hash
					ORDER BY 3 DESC

			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0
			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, ISNULL(@dbid,0), 19, @delta, @msg)
			END

			SET @dtstart = GETDATE()

			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [dbo.dm_exec_adhoc_sql]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			BEGIN TRAN
			DECLARE @qh binary(8)
			DECLARE qh_cursor CURSOR FOR 
				SELECT query_hash FROM dbo.dm_exec_adhoc_stats WHERE collection_session_id = @cid ORDER BY dm_exec_adhoc_stats_id
			OPEN qh_cursor
			FETCH NEXT FROM qh_cursor INTO @qh
			WHILE @@FETCH_STATUS != -1
			BEGIN
				INSERT dbo.dm_exec_adhoc_sql
					SELECT TOP 1 @cid, @qh, LEFT(stmt_text,4000) FROM
					(
						SELECT REPLACE (REPLACE (SUBSTRING (st.[text], PlanStats.statement_start_offset/2 + 1, 
							CASE WHEN PlanStats.statement_end_offset = -1 THEN LEN (CONVERT(nvarchar(max), st.[text])) 
							ELSE PlanStats.statement_end_offset/2 - PlanStats.statement_start_offset/2 + 1
							END), CHAR(13), ' '), CHAR(10), ' ') AS 'stmt_text' 
						FROM
						(
							SELECT plan_handle, statement_start_offset, statement_end_offset
								FROM sys.dm_exec_query_stats qs
								WHERE qs.query_hash = @qh and SUBSTRING(qs.plan_handle,1,1) = 0x06 
						) PlanStats
						OUTER APPLY sys.dm_exec_sql_text (PlanStats.plan_handle) AS st
					) a
				FETCH NEXT FROM qh_cursor INTO @qh
			END
			DEALLOCATE qh_cursor
			COMMIT TRAN

			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0
			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, ISNULL(@dbid,0), 20, @delta, @msg)
			END
		END
		ELSE
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Skipping query stats data due to parameter'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 20, @delta, @msg)
		END

		SET @dtstart = GETDATE()

		IF CONVERT(varchar(256),SERVERPROPERTY('EDITION')) LIKE 'Enterprise Edition%' OR @@MICROSOFTVERSION > 218108230 --13.0.4422.0.
		BEGIN
			IF @collect_index_metadata = 1
			BEGIN
				IF @object_filter IS NULL
				BEGIN
					IF @compression_index_filter IS NULL
					BEGIN
						--get initial estimate of indexes to attempt to process excluding indexes previously checked
						SELECT @count = COUNT(*) 
							FROM dbo.db_sysindexes i 
							WHERE i.index_id > 1 
								AND i.dpages > @min_index_size
								AND NOT EXISTS
								(
									SELECT 1 FROM index_analysis_compression c WHERE i.database_id = c.database_id and i.[object_id] = c.[object_id] and i.index_id = c.index_id
								)
						--loop until less than @max_compression_count while doubling @min_index_size each run
						WHILE @count > @max_compression_count
						BEGIN
							--SELECT @count, @min_index_size / 128
							SET @min_index_size = @min_index_size * 2
							SELECT @count = COUNT(*) 
								FROM dbo.db_sysindexes i 
								WHERE i.index_id > 1 
									AND i.dpages > @min_index_size
									AND NOT EXISTS
									(
										SELECT 1 FROM index_analysis_compression c WHERE i.database_id = c.database_id and i.[object_id] = c.[object_id] and i.index_id = c.index_id
									)
						END
					END
					ELSE
					BEGIN
						--parse @compression_index_filter parameter
						EXEC dbo.usp_parse_name @compression_index_filter, 4, @comp_dbname OUTPUT, @comp_schname OUTPUT, @comp_objname OUTPUT, @comp_idxname OUTPUT

						IF @comp_schname IS NULL
						BEGIN
							SET @comp_schname = '%'
						END

						IF @comp_objname IS NULL
						BEGIN
							SET @comp_objname = '%'
						END

						IF @comp_idxname IS NULL
						BEGIN
							SET @comp_idxname = '%'
						END
					
						/*
						print @comp_dbname
						print @comp_schname
						print @comp_objname
						print @comp_idxname
						*/
					END

					SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [dbo.index_analysis_compression],  Est. count =' + LTRIM(STR(@count)) + ', min size MB =' + LTRIM(STR(@min_index_size/128))
					RAISERROR (@msg,10,1) WITH NOWAIT

					IF @compression_index_filter IS NULL
					BEGIN
						DECLARE compression_test_cursor CURSOR FOR
						-- no need for top on following as above code for @min_index_size scaling will limit to less than @max_compression_count indexes
							SELECT d.[name], s.[name], o.[name], i.index_id, p.[partition_id], i.database_id, i.[object_id] --, SUM(sa.total_pages) as 'TotalPages'
								FROM dbo.db_objects o
									INNER JOIN dbo.db_indexes i
										on o.[object_id] = i.[object_id]
										AND o.database_id = i.database_id
										AND o.collection_session_id = i.collection_session_id
									INNER JOIN dbo.db_schemas s 
										on o.[schema_id] = s.[schema_id]
										AND o.database_id = s.database_id
										AND o.collection_session_id = s.collection_session_id
									INNER JOIN dbo.db_partitions p
										on p.[object_id] = i.[object_id] 
										and p.index_id = i.index_id
										AND p.database_id = i.database_id
										AND p.collection_session_id = i.collection_session_id
									INNER JOIN dbo.srv_databases d
										ON o.database_id = d.database_id
										AND o.collection_session_id = d.collection_session_id
									LEFT JOIN db_allocation_units AS sa
										ON sa.container_id = p.hobt_id
										and sa.database_id = p.database_id
										and sa.collection_session_id = p.collection_session_id
								WHERE i.type = 2 --Nonclustered
									and i.is_disabled = 0
									and i.is_hypothetical = 0
									and p.[data_compression] = 0
									and i.database_id > 4
									and i.collection_session_id = (SELECT MAX(collection_session_id) FROM dbo.db_indexes)
									AND d.is_read_only = 0
									AND d.[state] = 0
								group by d.[name], s.[name], o.[name], i.index_id, p.[partition_id], i.database_id, i.[object_id]
								having SUM(sa.total_pages) > @min_index_size
								ORDER BY SUM(sa.total_pages) desc
					END
					ELSE
					BEGIN
						DECLARE compression_test_cursor CURSOR FOR
						-- no need for top on following as above code for @min_index_size scaling will limit to less than @max_compression_count indexes
							SELECT d.[name], s.[name], o.[name], i.index_id, p.[partition_id], i.database_id, i.[object_id] --, SUM(sa.total_pages) as 'TotalPages'
								FROM dbo.db_objects o
									INNER JOIN dbo.db_indexes i
										on o.[object_id] = i.[object_id]
										AND o.database_id = i.database_id
										AND o.collection_session_id = i.collection_session_id
									INNER JOIN dbo.db_schemas s 
										on o.[schema_id] = s.[schema_id]
										AND o.database_id = s.database_id
										AND o.collection_session_id = s.collection_session_id
									INNER JOIN dbo.db_partitions p
										on p.[object_id] = i.[object_id] 
										and p.index_id = i.index_id
										AND p.database_id = i.database_id
										AND p.collection_session_id = i.collection_session_id
									INNER JOIN dbo.srv_databases d
										ON o.database_id = d.database_id
										AND o.collection_session_id = d.collection_session_id
									LEFT JOIN db_allocation_units AS sa
										ON sa.container_id = p.hobt_id
										and sa.database_id = p.database_id
										and sa.collection_session_id = p.collection_session_id
								WHERE i.type = 2 --Nonclustered
									and i.is_disabled = 0
									and i.is_hypothetical = 0
									and p.[data_compression] = 0
									and i.database_id > 4
									and i.collection_session_id = (SELECT MAX(collection_session_id) FROM dbo.db_indexes)
									AND d.is_read_only = 0
									AND d.[state] = 0
									AND d.name LIKE @comp_dbname
									AND s.name LIKE @comp_schname
									AND o.name LIKE @comp_objname
									AND i.name LIKE @comp_idxname
								group by d.[name], s.[name], o.[name], i.index_id, p.[partition_id], i.database_id, i.[object_id]
								having SUM(sa.total_pages) > @min_index_size
								ORDER BY SUM(sa.total_pages) desc
					END

					OPEN compression_test_cursor
					FETCH compression_test_cursor INTO @dbname, @schema_name, @object_name, @index_id, @partition_id, @database_id, @object_id

					WHILE @@FETCH_STATUS != -1
					BEGIN

						IF EXISTS (SELECT 1 FROM dbo.index_analysis_compression WHERE database_id = @database_id AND [object_id] = @object_id and index_id = @index_id ) AND @compression_index_filter IS NULL
						BEGIN
							SET @msg = convert(varchar(23), GETDATE(), 126) + ' Skipping compression [' + @schema_name + '].[' +  @object_name + '] index_id = ' + LTRIM(STR(@index_id))
							RAISERROR (@msg,10,1) WITH NOWAIT
							INSERT dbo.collection_session_perf VALUES (@cid, @database_id, 21, 0, @msg)
						END
						ELSE
						BEGIN
							SET @msg = convert(varchar(23), GETDATE(), 126) + ' Starting compression [' + @dbname + '].[' + @schema_name + '].[' +  @object_name + '] index_id = ' + LTRIM(STR(@index_id))
							RAISERROR (@msg,10,1) WITH NOWAIT

							SET @sqltext = '['+ @dbname +'].sys.sp_estimate_data_compression_savings ''' + @schema_name + ''', ''' + @object_name + ''', '+@index_id+', NULL, ''PAGE'''
							RAISERROR(@sqltext ,10,1) with nowait

							INSERT INTO #Page ([object_name], [schema_name], [index_id], [partition_number], [size_with_current_compression_setting(KB)], 
									[size_with_requested_compression_setting(KB)], [sample_size_with_current_compression_setting(KB)], [sample_size_with_requested_compression_setting(KB)])
								EXEC (@sqltext)

							SET @id = @@IDENTITY

							UPDATE #Page
								SET database_id = @database_id, [object_id] = @object_id
								WHERE Page_ID = @id

							SET @sqltext = '['+ @dbname +'].sys.sp_estimate_data_compression_savings ''' + @schema_name + ''', ''' + @object_name + ''', '+@index_id+', NULL, ''ROW'''
							RAISERROR(@sqltext ,10,1) with nowait

							INSERT INTO #Row ([object_name], [schema_name], [index_id], [partition_number], [size_with_current_compression_setting(KB)], 
									[size_with_requested_compression_setting(KB)], [sample_size_with_current_compression_setting(KB)], [sample_size_with_requested_compression_setting(KB)])
								EXEC (@sqltext)

							SET @id = @@IDENTITY

							UPDATE #Row
								SET database_id = @database_id, [object_id] = @object_id
								WHERE Row_ID = @id
						END

						FETCH compression_test_cursor INTO @dbname, @schema_name, @object_name, @index_id, @partition_id, @database_id, @object_id 
					END
					DEALLOCATE compression_test_cursor

					INSERT dbo.index_analysis_compression
						SELECT  @cid, p.database_id, p.[object_id], p.index_id, p.partition_number, p.[size_with_current_compression_setting(KB)], p.[size_with_requested_compression_setting(KB)], 
							r.[size_with_requested_compression_setting(KB)], p.[sample_size_with_current_compression_setting(KB)], p.[sample_size_with_requested_compression_setting(KB)],
							r.[sample_size_with_requested_compression_setting(KB)]
							FROM #Page p
								INNER JOIN #Row r
									ON p.database_id = r.database_id
									AND p.[object_id] = r.[object_id]
									AND p.index_id = r.index_id
									AND p.partition_number = r.partition_number

					SET @dtend = GETDATE()
					SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
					IF @delta > 0
					BEGIN
						INSERT dbo.collection_session_perf VALUES (@cid, ISNULL(@dbid,0), 21, @delta, @msg)
					END
				END
				ELSE
				BEGIN
					SET @msg = convert(varchar(23), @dtstart, 126) + ' Skipping index compression analysis due to @object_filter'
					RAISERROR (@msg,10,1) WITH NOWAIT
					INSERT dbo.collection_session_perf VALUES (@cid, 0, 21, @delta, @msg)
				END
			END
			ELSE
			BEGIN
				SET @msg = convert(varchar(23), @dtstart, 126) + ' Skipping index compression analysis due to parameter'
				RAISERROR (@msg,10,1) WITH NOWAIT
				INSERT dbo.collection_session_perf VALUES (@cid, 0, 21, @delta, @msg)
			END
		END
		ELSE
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Skipping index compression analysis due to SQL EDITION'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 21, @delta, @msg)
		END


		IF @collect_query_stats_data = 1
		BEGIN
			SET @dtstart = GETDATE()

			SET @msg = convert(varchar(23), @dtstart, 126) + ' Starting [dbo.dm_exec_query_plan_summary]'
			RAISERROR (@msg,10,1) WITH NOWAIT

			INSERT dbo.dm_exec_query_plan_summary (collection_session_id, database_id, objtype, entry_count, cache_size_MB)
				SELECT @cid, ISNULL(CAST(t.value AS int),32767), p.objtype, count_big (*), sum(cast(size_in_bytes as bigint))/1024.00/1024.00
					FROM  sys.dm_exec_cached_plans AS p 
						CROSS APPLY sys.dm_exec_plan_attributes (p.plan_handle) as t 
					WHERE t.attribute='dbid'
					GROUP BY  ISNULL(CAST(t.value AS int),32767), p.objtype

			SET @dtend = GETDATE()
			SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
			IF @delta > 0
			BEGIN
				INSERT dbo.collection_session_perf VALUES (@cid, 0, 22, @delta, @msg)
			END

		END

		SET @delta = DATEDIFF(SECOND, @dt, GETDATE())

		UPDATE dbo.collection_session SET durationS = @delta WHERE collection_session_id = @cid

		SET @msg = convert(varchar(23),@dtend,126) + ' Collection Complete'
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, @delta, @msg)
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_compression_results]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_compression_results') is null exec('create procedure [dbo].[usp_index_analysis_compression_results] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_compression_results
(
	@collection_session_id int, 
	@override_blacklist tinyint = 0,
	@database_name_filter sysname = NULL
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Return analysis result set
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. To easily differentiate result set and query from first column (collection_session_id) is renamed to type and query number.
*
*	Future Enhancements:
*	1. Consider commented filters for future inclusion
*
*	Current Known Bugs:
*	
*	Returns: single result set
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	IF @database_name_filter IS NULL
	BEGIN
		IF @override_blacklist = 0
		BEGIN
			SELECT 	a.collection_session_id AS [IndexCompressionAnalysis1 CSID],
					CASE WHEN a.PagePctSaved - a.RowPctSaved <= 10 THEN 'ROW'
						WHEN a.Percent_Update >= 10 THEN 'ROW'
						ELSE 'PAGE'
					END AS [Recommendation],
					a.Index_ID,
					a.PagePctSaved,
					a.RowPctSaved,
					a.GBSaved,
					CASE WHEN Index_ID=0 THEN 'ALTER TABLE ' + a.[Object_Name] + 'REBUILD WITH (DATA_COMPRESSION='
						+ CASE WHEN a.PagePctSaved - a.RowPctSaved <= 10 THEN 'ROW'
								WHEN a.Percent_Update >= 10 THEN 'ROW'
								ELSE 'PAGE'	END + ', ONLINE=ON)'
						ELSE 'ALTER INDEX ['+a.Index_Name+'] ON ' + a.[Object_Name] + ' REBUILD WITH (DATA_COMPRESSION='
							+ CASE WHEN a.PagePctSaved - a.RowPctSaved <= 10 THEN 'ROW'
									WHEN a.Percent_Update >= 10 THEN 'ROW'
									ELSE 'PAGE'	END + ', ONLINE=ON, SORT_IN_TEMPDB=ON)'
					END AS [AlterCommand]
				FROM 
				(
					SELECT 
							x.index_id AS [Index_ID]
						--	, i.partition_number AS [Partition]
						,CAST(((ic.current_size_KB-ic.est_page_compressed_KB)/(ic.current_size_KB*1.))*100.00 AS decimal(5,2)) AS [PagePctSaved]
						,CAST(((ic.current_size_KB-ic.est_row_compressed_KB)/(ic.current_size_KB*1.))*100.00 AS decimal(5,2)) AS [RowPctSaved] 
						, CASE WHEN ic.est_row_compressed_KB < ic.est_page_compressed_KB THEN (ic.current_size_KB-ic.est_row_compressed_KB)/1024./1024.
							ELSE (ic.current_size_KB-ic.est_page_compressed_KB)/1024./1024.
							END AS [GBSaved]
						 , '['+d.[name]+'].['+s.[name]+'].['+o.[name]+']' AS [Object_Name]
						   , x.name AS [Index_Name]
			--not sure if need following column
			--			   x.type_desc AS [Index_Type],
						   , CAST(i.leaf_update_count * 100.0 /
							   (i.range_scan_count + i.leaf_insert_count
								+ i.leaf_delete_count + i.leaf_update_count
								+ i.leaf_page_merge_count + i.singleton_lookup_count + 1
							   ) AS decimal(5,2)) AS [Percent_Update]
							,CAST(i.range_scan_count * 100.0 /
							   (i.range_scan_count + i.leaf_insert_count
								+ i.leaf_delete_count + i.leaf_update_count
								+ i.leaf_page_merge_count + i.singleton_lookup_count + 1
							   ) AS decimal(5,2)) AS [Percent_Scan]
							,CAST(i.leaf_insert_count * 100.0 /
							   (i.range_scan_count + i.leaf_insert_count
								+ i.leaf_delete_count + i.leaf_update_count
								+ i.leaf_page_merge_count + i.singleton_lookup_count + 1
							   ) AS decimal(5,2)) AS [Percent_Insert]
							, ic.current_size_KB AS CurrentSizeKB
						, ic.est_page_compressed_KB AS PageCompressedKB
						, ic.est_row_compressed_KB AS RowCompressedKB 
						, o.database_id
						, o.collection_session_id
					FROM dbo.db_objects o 
					INNER JOIN dbo.db_indexes x 
						ON x.[object_id] = o.[object_id] 
						AND x.database_id = o.database_id
						AND x.collection_session_id = o.collection_session_id
					INNER JOIN dbo.db_schemas s
						ON s.[schema_id] = o.[schema_id] 
						AND s.database_id = o.database_id
						AND s.collection_session_id = o.collection_session_id
					INNER JOIN dbo.srv_databases d
						ON d.database_id = o.database_id
						AND d.collection_session_id = o.collection_session_id
					LEFT JOIN dbo.db_index_operational_stats i 
						ON x.database_id = i.database_id
						AND x.[object_id] = i.[object_id] 
						AND x.index_id = i.index_id
						AND x.collection_session_id = i.collection_session_id
						--and (i.range_scan_count + i.leaf_insert_count
						--   + i.leaf_delete_count + leaf_update_count
						--   + i.leaf_page_merge_count + i.singleton_lookup_count) != 0
					INNER JOIN dbo.index_analysis_compression ic
						ON x.object_id = ic.object_id 
						AND x.database_id = ic.database_id
						AND x.index_id = ic.index_id
						--and p.partition_number = i.partition_number
						AND x.collection_session_id = ic.collection_session_id 

					WHERE ic.current_size_KB > 0
						AND ic.est_page_compressed_KB > 0
					--AND objectproperty(i.object_id,''IsUserTable'') = 1
				) a
				WHERE a.collection_session_id = @collection_session_id
					AND a.database_id NOT IN (SELECT ISNULL(database_id,0) FROM dbo.index_analysis_db_backlist WHERE is_enabled = 1)
				ORDER BY CurrentSizeKB-PageCompressedKB DESC

		END
		ELSE --@override_blacklist != 0
		BEGIN
			SELECT a.collection_session_id AS [IndexCompressionAnalysis2 CSID],
					CASE WHEN a.PagePctSaved - a.RowPctSaved <= 10 THEN 'ROW'
						WHEN a.Percent_Update >= 10 THEN 'ROW'
						ELSE 'PAGE'
					END AS [Recommendation],
					a.Index_ID,
					a.PagePctSaved,
					a.RowPctSaved,
					a.GBSaved,
					CASE WHEN Index_ID=0 THEN 'ALTER TABLE ' + a.[Object_Name] + 'REBUILD WITH (DATA_COMPRESSION='
						+ CASE WHEN a.PagePctSaved - a.RowPctSaved <= 10 THEN 'ROW'
								WHEN a.Percent_Update >= 10 THEN 'ROW'
								ELSE 'PAGE'	END + ', ONLINE=ON)'
						ELSE 'ALTER INDEX ['+a.Index_Name+'] ON ' + a.[Object_Name] + ' REBUILD WITH (DATA_COMPRESSION='
							+ CASE WHEN a.PagePctSaved - a.RowPctSaved <= 10 THEN 'ROW'
									WHEN a.Percent_Update >= 10 THEN 'ROW'
									ELSE 'PAGE'	END + ', ONLINE=ON, SORT_IN_TEMPDB=ON)'
					END AS [AlterCommand]
				FROM 
				(
					SELECT 
							x.index_id AS [Index_ID]
						--	, i.partition_number AS [Partition]
						,CAST(((ic.current_size_KB-ic.est_page_compressed_KB)/(ic.current_size_KB*1.))*100.00 AS decimal(5,2)) AS [PagePctSaved]
						,CAST(((ic.current_size_KB-ic.est_row_compressed_KB)/(ic.current_size_KB*1.))*100.00 AS decimal(5,2)) AS [RowPctSaved] 
						, CASE WHEN ic.est_row_compressed_KB < ic.est_page_compressed_KB THEN (ic.current_size_KB-ic.est_row_compressed_KB)/1024./1024.
							ELSE (ic.current_size_KB-ic.est_page_compressed_KB)/1024./1024.
							END AS [GBSaved]
						 , '['+d.[name]+'].['+s.[name]+'].['+o.[name]+']' AS [Object_Name]
						   , x.name AS [Index_Name]
			--not sure if need following column
			--			   x.type_desc AS [Index_Type],
						   , CAST(i.leaf_update_count * 100.0 /
							   (i.range_scan_count + i.leaf_insert_count
								+ i.leaf_delete_count + i.leaf_update_count
								+ i.leaf_page_merge_count + i.singleton_lookup_count + 1
							   ) AS decimal(5,2)) AS [Percent_Update]
							,CAST(i.range_scan_count * 100.0 /
							   (i.range_scan_count + i.leaf_insert_count
								+ i.leaf_delete_count + i.leaf_update_count
								+ i.leaf_page_merge_count + i.singleton_lookup_count + 1
							   ) AS decimal(5,2)) AS [Percent_Scan]
							,CAST(i.leaf_insert_count * 100.0 /
							   (i.range_scan_count + i.leaf_insert_count
								+ i.leaf_delete_count + i.leaf_update_count
								+ i.leaf_page_merge_count + i.singleton_lookup_count + 1
							   ) AS decimal(5,2)) AS [Percent_Insert]
							, ic.current_size_KB AS CurrentSizeKB
						, ic.est_page_compressed_KB AS PageCompressedKB
						, ic.est_row_compressed_KB AS RowCompressedKB 
						, o.database_id
						, o.collection_session_id
					FROM dbo.db_objects o 
					INNER JOIN dbo.db_indexes x 
						ON x.[object_id] = o.[object_id] 
						AND x.database_id = o.database_id
						AND x.collection_session_id = o.collection_session_id
					INNER JOIN dbo.db_schemas s
						ON s.[schema_id] = o.[schema_id] 
						AND s.database_id = o.database_id
						AND s.collection_session_id = o.collection_session_id
					INNER JOIN dbo.srv_databases d
						ON d.database_id = o.database_id
						AND d.collection_session_id = o.collection_session_id
					LEFT JOIN dbo.db_index_operational_stats i 
						ON x.database_id = i.database_id
						AND x.[object_id] = i.[object_id] 
						AND x.index_id = i.index_id
						AND x.collection_session_id = i.collection_session_id
						--and (i.range_scan_count + i.leaf_insert_count
						--   + i.leaf_delete_count + leaf_update_count
						--   + i.leaf_page_merge_count + i.singleton_lookup_count) != 0
					INNER JOIN dbo.index_analysis_compression ic
						ON x.object_id = ic.object_id 
						AND x.database_id = ic.database_id
						AND x.index_id = ic.index_id
						--and p.partition_number = i.partition_number
						AND x.collection_session_id = ic.collection_session_id 

					WHERE ic.current_size_KB > 0
						AND ic.est_page_compressed_KB > 0
					--AND objectproperty(i.object_id,''IsUserTable'') = 1
				) a
				WHERE a.collection_session_id = @collection_session_id
				ORDER BY CurrentSizeKB-PageCompressedKB DESC
		END
	END
	ELSE
	BEGIN
		SELECT a.collection_session_id AS [IndexCompressionAnalysis3 CSID],
			CASE WHEN a.PagePctSaved - a.RowPctSaved <= 10 THEN 'ROW'
					WHEN a.Percent_Update >= 10 THEN 'ROW'
					ELSE 'PAGE'
				END AS [Recommendation],
				a.Index_ID,
				a.PagePctSaved,
				a.RowPctSaved,
				a.GBSaved,
				CASE WHEN Index_ID=0 THEN 'ALTER TABLE ' + a.[Object_Name] + 'REBUILD WITH (DATA_COMPRESSION='
					+ CASE WHEN a.PagePctSaved - a.RowPctSaved <= 10 THEN 'ROW'
							WHEN a.Percent_Update >= 10 THEN 'ROW'
							ELSE 'PAGE'	END + ', ONLINE=ON)'
					ELSE 'ALTER INDEX ['+a.Index_Name+'] ON ' + a.[Object_Name] + ' REBUILD WITH (DATA_COMPRESSION='
						+ CASE WHEN a.PagePctSaved - a.RowPctSaved <= 10 THEN 'ROW'
								WHEN a.Percent_Update >= 10 THEN 'ROW'
								ELSE 'PAGE'	END + ', ONLINE=ON, SORT_IN_TEMPDB=ON)'
				END AS [AlterCommand]
			FROM 
			(
				SELECT 
						x.index_id AS [Index_ID]
					--	, i.partition_number AS [Partition]
					,CAST(((ic.current_size_KB-ic.est_page_compressed_KB)/(ic.current_size_KB*1.))*100.00 AS decimal(5,2)) AS [PagePctSaved]
					,CAST(((ic.current_size_KB-ic.est_row_compressed_KB)/(ic.current_size_KB*1.))*100.00 AS decimal(5,2)) AS [RowPctSaved] 
					, CASE WHEN ic.est_row_compressed_KB < ic.est_page_compressed_KB THEN (ic.current_size_KB-ic.est_row_compressed_KB)/1024./1024.
						ELSE (ic.current_size_KB-ic.est_page_compressed_KB)/1024./1024.
						END AS [GBSaved]
						, '['+d.[name]+'].['+s.[name]+'].['+o.[name]+']' AS [Object_Name]
						, x.name AS [Index_Name]
		--not sure if need following column
		--			   x.type_desc AS [Index_Type],
						, CAST(i.leaf_update_count * 100.0 /
							(i.range_scan_count + i.leaf_insert_count
							+ i.leaf_delete_count + i.leaf_update_count
							+ i.leaf_page_merge_count + i.singleton_lookup_count + 1
							) AS decimal(5,2)) AS [Percent_Update]
						,CAST(i.range_scan_count * 100.0 /
							(i.range_scan_count + i.leaf_insert_count
							+ i.leaf_delete_count + i.leaf_update_count
							+ i.leaf_page_merge_count + i.singleton_lookup_count + 1
							) AS decimal(5,2)) AS [Percent_Scan]
						,CAST(i.leaf_insert_count * 100.0 /
							(i.range_scan_count + i.leaf_insert_count
							+ i.leaf_delete_count + i.leaf_update_count
							+ i.leaf_page_merge_count + i.singleton_lookup_count + 1
							) AS decimal(5,2)) AS [Percent_Insert]
						, ic.current_size_KB AS CurrentSizeKB
					, ic.est_page_compressed_KB AS PageCompressedKB
					, ic.est_row_compressed_KB AS RowCompressedKB 
					, o.database_id
					, o.collection_session_id
				FROM dbo.db_objects o 
				INNER JOIN dbo.db_indexes x 
					ON x.[object_id] = o.[object_id] 
					AND x.database_id = o.database_id
					AND x.collection_session_id = o.collection_session_id
				INNER JOIN dbo.db_schemas s
					ON s.[schema_id] = o.[schema_id] 
					AND s.database_id = o.database_id
					AND s.collection_session_id = o.collection_session_id
				INNER JOIN dbo.srv_databases d
					ON d.database_id = o.database_id
					AND d.collection_session_id = o.collection_session_id
				LEFT JOIN dbo.db_index_operational_stats i 
					ON x.database_id = i.database_id
					AND x.[object_id] = i.[object_id] 
					AND x.index_id = i.index_id
					AND x.collection_session_id = i.collection_session_id
					--and (i.range_scan_count + i.leaf_insert_count
					--   + i.leaf_delete_count + leaf_update_count
					--   + i.leaf_page_merge_count + i.singleton_lookup_count) != 0
				INNER JOIN dbo.index_analysis_compression ic
					ON x.object_id = ic.object_id 
					AND x.database_id = ic.database_id
					AND x.index_id = ic.index_id
					--and p.partition_number = i.partition_number
					AND x.collection_session_id = ic.collection_session_id 

				WHERE ic.current_size_KB > 0
					AND ic.est_page_compressed_KB > 0
				--AND objectproperty(i.object_id,''IsUserTable'') = 1
			) a
			WHERE a.collection_session_id = @collection_session_id
				AND a.database_id = (SELECT database_id FROM dbo.srv_databases WHERE name = @database_name_filter and collection_session_id = @collection_session_id)
			ORDER BY CurrentSizeKB-PageCompressedKB DESC
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_duplicate_results]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_duplicate_results') is null exec('create procedure [dbo].[usp_index_analysis_duplicate_results] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_duplicate_results
(
	@collection_session_id int, 
	@override_blacklist tinyint = 0,
	@database_name_filter sysname = NULL
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose:	Return duplicate index analysis result set
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. This builds results into a table which is used for later processing
*	2. Evaluate commented filter conditions for possible use
*	3. To easily differentiate result set and query from first column (collection_session_id) is renamed to type and query number.
*
*	Future Enhancements:
*	1. Consider commented filters
*
*	Current Known Bugs:
*	
*	Returns: single result set
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	--DELETE existing data for reprocessing
	DELETE dbo.index_analysis_duplicate_indexes WHERE collection_session_id = @collection_session_id;

	WITH CTE_INDEX_DATA AS 
	(
		SELECT DISTINCT
				INDEX_DATA.collection_session_id
				,INDEX_DATA.database_id
				, INDEX_DATA.object_id
				, INDEX_DATA.index_id
				--SCHEMA_DATA.schema_id
				, key_column_list = STUFF(
				(
					SELECT  ', ' + COLUMN_DATA_KEY_COLS.name + ' ' + CASE WHEN INDEX_COLUMN_DATA_KEY_COLS.is_descending_key = 1 THEN 'DESC' ELSE 'ASC' END -- Include column order (ASC / DESC)
						FROM db_objects AS T
							INNER JOIN db_indexes INDEX_DATA_KEY_COLS
								ON T.object_id = INDEX_DATA_KEY_COLS.object_id
								and T.database_id = INDEX_DATA_KEY_COLS.database_id
								and T.collection_session_id = INDEX_DATA_KEY_COLS.collection_session_id
							INNER JOIN db_index_columns INDEX_COLUMN_DATA_KEY_COLS
								ON INDEX_DATA_KEY_COLS.object_id = INDEX_COLUMN_DATA_KEY_COLS.object_id
								AND INDEX_DATA_KEY_COLS.index_id = INDEX_COLUMN_DATA_KEY_COLS.index_id
								and INDEX_DATA_KEY_COLS.database_id = INDEX_COLUMN_DATA_KEY_COLS.database_id
								and INDEX_DATA_KEY_COLS.collection_session_id = INDEX_COLUMN_DATA_KEY_COLS.collection_session_id
							INNER JOIN db_columns COLUMN_DATA_KEY_COLS
								ON INDEX_COLUMN_DATA_KEY_COLS.object_id = COLUMN_DATA_KEY_COLS.object_id
								AND INDEX_COLUMN_DATA_KEY_COLS.column_id = COLUMN_DATA_KEY_COLS.column_id
								and INDEX_COLUMN_DATA_KEY_COLS.database_id = COLUMN_DATA_KEY_COLS.database_id
								and INDEX_COLUMN_DATA_KEY_COLS.collection_session_id = COLUMN_DATA_KEY_COLS.collection_session_id
						WHERE INDEX_COLUMN_DATA_KEY_COLS.is_included_column = 0
							AND INDEX_DATA.object_id = INDEX_DATA_KEY_COLS.object_id
							AND INDEX_DATA.index_id = INDEX_DATA_KEY_COLS.index_id
							AND INDEX_DATA.database_id = INDEX_DATA_KEY_COLS.database_id
							and INDEX_DATA.collection_session_id = INDEX_DATA_KEY_COLS.collection_session_id

						ORDER BY INDEX_COLUMN_DATA_KEY_COLS.key_ordinal
						FOR XML PATH('')
				), 1, 2, '')  
				, include_column_list = STUFF(
				( 
					SELECT  ', ' + COLUMN_DATA_INC_COLS.name
						FROM db_objects AS T
							INNER JOIN db_indexes INDEX_DATA_INC_COLS
								ON T.object_id = INDEX_DATA_INC_COLS.object_id
								and T.database_id = INDEX_DATA_INC_COLS.database_id
								and T.collection_session_id = INDEX_DATA_INC_COLS.collection_session_id
							INNER JOIN db_index_columns INDEX_COLUMN_DATA_INC_COLS
								ON INDEX_DATA_INC_COLS.object_id = INDEX_COLUMN_DATA_INC_COLS.object_id
								AND INDEX_DATA_INC_COLS.index_id = INDEX_COLUMN_DATA_INC_COLS.index_id
								and INDEX_DATA_INC_COLS.database_id = INDEX_COLUMN_DATA_INC_COLS.database_id
								and INDEX_DATA_INC_COLS.collection_session_id = INDEX_COLUMN_DATA_INC_COLS.collection_session_id
							INNER JOIN db_columns COLUMN_DATA_INC_COLS
								ON T.object_id = COLUMN_DATA_INC_COLS.object_id
								AND INDEX_COLUMN_DATA_INC_COLS.column_id = COLUMN_DATA_INC_COLS.column_id
								and INDEX_COLUMN_DATA_INC_COLS.database_id = COLUMN_DATA_INC_COLS.database_id
								and INDEX_COLUMN_DATA_INC_COLS.collection_session_id = COLUMN_DATA_INC_COLS.collection_session_id
						WHERE   INDEX_DATA.object_id = INDEX_DATA_INC_COLS.object_id
							AND INDEX_DATA.index_id = INDEX_DATA_INC_COLS.index_id
							AND INDEX_DATA.database_id = INDEX_DATA_INC_COLS.database_id
							and INDEX_DATA.collection_session_id = INDEX_DATA_INC_COLS.collection_session_id
							AND INDEX_COLUMN_DATA_INC_COLS.is_included_column = 1
						ORDER BY INDEX_COLUMN_DATA_INC_COLS.key_ordinal
						FOR XML PATH('')
					), 1, 2, '') 
/*
--following shouldn't be needed
				, is_disabled = INDEX_DATA.is_disabled -- Check if index is disabled before determining which dupe to drop (if applicable)
				, is_unique = INDEX_DATA.is_unique
*/
			FROM db_indexes INDEX_DATA
				INNER JOIN db_objects TABLE_DATA
					ON TABLE_DATA.object_id = INDEX_DATA.object_id
					AND TABLE_DATA.database_id = INDEX_DATA.database_id
					AND TABLE_DATA.collection_session_id = INDEX_DATA.collection_session_id
			WHERE INDEX_DATA.is_hypothetical = 0
				AND INDEX_DATA.is_disabled = 0
				AND INDEX_DATA.type IN (2,1)
		   --AND TABLE_DATA.is_ms_shipped = 0
	)

	INSERT INTO dbo.index_analysis_duplicate_indexes
		SELECT DUPE1.collection_session_id,
				DUPE1.database_id, DUPE1.[object_id], DUPE1.index_id, DUPE2.index_id, DUPE1.key_column_list, DUPE1.include_column_list 
				--, DUPE1.is_unique, DUPE1.is_disabled, USG.total_reads, USG.total_writes
				, CASE WHEN DUPE1.key_column_list = DUPE2.key_column_list THEN 1 ELSE 0 END as exact
			FROM CTE_INDEX_DATA DUPE1
				JOIN CTE_INDEX_DATA DUPE2
					ON DUPE1.[object_id] = DUPE2.[object_id]
					and DUPE1.database_id = DUPE2.database_id
					and DUPE1.collection_session_id = DUPE2.collection_session_id

					AND 
					(
						DUPE1.key_column_list = DUPE2.key_column_list
						OR 1 = CASE
								WHEN LEN(DUPE2.key_column_list) > LEN(DUPE1.key_column_list) and DUPE1.key_column_list = LEFT(DUPE2.key_column_list, LEN(DUPE1.key_column_list))
									THEN 1
								WHEN LEN(DUPE1.key_column_list) > LEN(DUPE2.key_column_list) and DUPE2.key_column_list = LEFT(DUPE1.key_column_list, LEN(DUPE1.key_column_list))
									THEN 1
								ELSE 0
							END
					)
					AND DUPE1.index_id <> DUPE2.index_id
			WHERE DUPE1.collection_session_id = @collection_session_id


	IF @database_name_filter IS NULL
	BEGIN
		IF @override_blacklist = 0
		BEGIN
			SELECT DISTINCT di.collection_session_id AS [DuplicateAnalysis1 CSID],
					s.name, o.name,d.name, di.index_id, di.dup_index_id, di.exact, di.KeyColumns, di.IncludeColumns,ius.user_scans,
					CASE WHEN di.index_id > 1 and i.is_unique = 0 --and (subset = 1 or exact = 1)
						 THEN 'ALTER INDEX ['+i.name+'] ON ['+d.name+'].['+s.name+'].['+o.name+'] DISABLE ' END as 'DisableSQL'
					,ROW_NUMBER() OVER (PARTITION BY d.name, s.name, o.name, di.KeyColumns, i.is_unique ORDER BY ius.user_scans desc) as DupeNum
				FROM dbo.index_analysis_duplicate_indexes di
					inner join dbo.db_indexes i
						on di.collection_session_id = i.collection_session_id
						and di.database_id = i.database_id
						and di.object_id = i.object_id
						and di.index_id = i.index_id
					inner join dbo.srv_databases d
						on di.collection_session_id = d.collection_session_id
						and di.database_id = d.database_id
					inner join dbo.db_objects o
						on di.collection_session_id = o.collection_session_id
						and di.database_id = o.database_id
						and di.object_id = o.object_id
					inner join dbo.db_schemas s
						on s.collection_session_id = o.collection_session_id
						and s.database_id = o.database_id
						and s.schema_id = o.schema_id
					inner join IndexUsageStats ius
						on di.database_id = ius.database_id
						and di.object_id = ius.object_id
						and di.index_id = ius.index_id
				WHERE di.collection_session_id = @collection_session_id
					AND di.database_id NOT IN (SELECT ISNULL(database_id,0) FROM dbo.index_analysis_db_backlist WHERE is_enabled = 1)
				ORDER BY d.name, s.name, o.name, di.KeyColumns, di.exact, DupeNum
		END
		ELSE
		BEGIN
			SELECT DISTINCT di.collection_session_id AS [DuplicateAnalysis2 CSID],
					s.name, o.name,d.name, di.index_id, di.dup_index_id, di.exact, di.KeyColumns, di.IncludeColumns,ius.user_scans,
					CASE WHEN di.index_id > 1 and i.is_unique = 0 --and (subset = 1 or exact = 1)
						 THEN 'ALTER INDEX ['+i.name+'] ON ['+d.name+'].['+s.name+'].['+o.name+'] DISABLE ' END as 'DisableSQL'
					,ROW_NUMBER() OVER (PARTITION BY d.name, s.name, o.name, di.KeyColumns, i.is_unique ORDER BY ius.user_scans desc) as DupeNum
				FROM dbo.index_analysis_duplicate_indexes di
					inner join dbo.db_indexes i
						on di.collection_session_id = i.collection_session_id
						and di.database_id = i.database_id
						and di.object_id = i.object_id
						and di.index_id = i.index_id
					inner join dbo.srv_databases d
						on di.collection_session_id = d.collection_session_id
						and di.database_id = d.database_id
					inner join dbo.db_objects o
						on di.collection_session_id = o.collection_session_id
						and di.database_id = o.database_id
						and di.object_id = o.object_id
					inner join dbo.db_schemas s
						on s.collection_session_id = o.collection_session_id
						and s.database_id = o.database_id
						and s.schema_id = o.schema_id
					inner join IndexUsageStats ius
						on di.database_id = ius.database_id
						and di.object_id = ius.object_id
						and di.index_id = ius.index_id
				WHERE di.collection_session_id = @collection_session_id
				ORDER BY d.name, s.name, o.name, di.KeyColumns, di.exact, DupeNum
		END
	END
	ELSE
	BEGIN
		SELECT DISTINCT di.collection_session_id AS [DuplicateAnalysis3 CSID],
				s.name, o.name,d.name, di.index_id, di.dup_index_id, di.exact, di.KeyColumns, di.IncludeColumns,ius.user_scans,
				CASE WHEN di.index_id > 1 and i.is_unique = 0 --and (subset = 1 or exact = 1)
					 THEN 'ALTER INDEX ['+i.name+'] ON ['+d.name+'].['+s.name+'].['+o.name+'] DISABLE ' END as 'DisableSQL'
				,ROW_NUMBER() OVER (PARTITION BY d.name, s.name, o.name, di.KeyColumns, i.is_unique ORDER BY ius.user_scans desc) as DupeNum
			FROM dbo.index_analysis_duplicate_indexes di
				inner join dbo.db_indexes i
					on di.collection_session_id = i.collection_session_id
					and di.database_id = i.database_id
					and di.object_id = i.object_id
					and di.index_id = i.index_id
				inner join dbo.srv_databases d
					on di.collection_session_id = d.collection_session_id
					and di.database_id = d.database_id
				inner join dbo.db_objects o
					on di.collection_session_id = o.collection_session_id
					and di.database_id = o.database_id
					and di.object_id = o.object_id
				inner join dbo.db_schemas s
					on s.collection_session_id = o.collection_session_id
					and s.database_id = o.database_id
					and s.schema_id = o.schema_id
				inner join IndexUsageStats ius
					on di.database_id = ius.database_id
					and di.object_id = ius.object_id
					and di.index_id = ius.index_id
			WHERE di.collection_session_id = @collection_session_id
				AND di.database_id = (SELECT database_id FROM dbo.srv_databases WHERE name = @database_name_filter and collection_session_id = @collection_session_id)
			ORDER BY d.name, s.name, o.name, di.KeyColumns, di.exact, DupeNum
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_expensive_results]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_expensive_results') is null exec('create procedure [dbo].[usp_index_analysis_expensive_results] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_expensive_results
(
	@collection_session_id int, 
	@override_blacklist tinyint = 0,
	@database_name_filter sysname = NULL
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Return expensive index analysis result set
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. To easily differentiate result set and query from first column (collection_session_id) is renamed to type and query number.
*
*	Future Enhancements:
*	1. Consider commented filters
*	2. alter column list for usability
*
*	Current Known Bugs:
*
*	Returns: single result set
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	--cleanup and generate data
	EXEC dbo.usp_index_analysis_expensive_results_generate @collection_session_id
	
	IF @database_name_filter IS NULL
	BEGIN
		IF @override_blacklist = 0
		BEGIN
			SELECT e.collection_session_id AS [ExpensiveIDXAnalysis1 CSID], e.date_stamp,
					[DBName] = d.name,
					[Schema]  = sc.name,
					TableName = o.name,
					IndexName =  (CASE i.index_id WHEN 0 THEN '(HEAP)' ELSE i.name END),
					ColumnNames = (CASE i.index_id WHEN 0 THEN '(HEAP)' ELSE SUBSTRING(c.indexColumns, 1, LEN(c.indexColumns) - 1) END),
					TotalSize_GB = CAST(e.TotalPages/128./1024. AS NUMERIC(13,4)),
					InRowSize_GB = CAST(e.InRowPages/128./1024. AS NUMERIC(13,4)),
					e.[UserSeeks],
					e.[UserScans],
					e.[UserLookups],
					e.[UserUpdates],
					e.[TotalUsage],
					[PercentRead] = CASE WHEN e.[TotalUsage] > 0 THEN CAST(CAST(e.[UserSeeks] + e.[UserScans] + e.[UserLookups] AS DEC(16,2))/CAST(e.[TotalUsage] AS DEC(16,2)) * 100 AS DEC(6,2)) ELSE 0.0 END,
					[PercentWrite] = CASE WHEN e.[TotalUsage] > 0 THEN CAST(CAST(e.[UserUpdates] AS DEC(16,2))/CAST(e.[TotalUsage] AS DEC(16,2)) * 100 AS DEC(6,2)) ELSE 0.0 END,
					data_compression_max,
					[MixedDataCompression] = case when e.data_compression_max != e.data_compression_min then 1 else 0 end,
					[Filegroup Name] = f.name,
					[IsUnique] = i.is_unique,
					[FillFactor] = i.fill_factor,
					e.IndexCount,
					[Disabled] = i.is_disabled,
					PartitionCount,
					[RowLocks] = i.allow_row_locks,
					[PageLocks] = i.allow_page_locks,
					[Hypothetical] = i.is_hypothetical,
					[IsDefault] = f.is_default,
					[IsReadOnly] = f.is_read_only,
					e.[Last_User_Scan],
					e.[Last_User_Seek],
					[DisableSQL] = 'ALTER INDEX ['+i.name+'] ON ['+d.name+'].['+sc.name+'].['+o.name+'] DISABLE'
				FROM index_analysis_expensive_indexes AS e 
					JOIN db_indexes AS i
						on e.[object_id] = i.[object_id]
						and e.index_id = i.index_id
						and e.database_id = i.database_id
						and e.collection_session_id = i.collection_session_id
					JOIN srv_databases AS d 
						ON e.database_id = d.database_id
						and e.collection_session_id = d.collection_session_id
					JOIN db_objects AS o 
						ON e.[object_id] = o.[object_id]
						and e.database_id = o.database_id
						and e.collection_session_id = o.collection_session_id
						--and o.type in ('U','V')
					JOIN db_schemas AS sc
						ON o.[schema_id] = sc.[schema_id]
						and o.database_id = sc.database_id
						and o.collection_session_id = sc.collection_session_id
					JOIN db_filegroups f 
						ON i.data_space_id = f.data_space_id
						and i.database_id = f.database_id
						and i.collection_session_id = f.collection_session_id
					LEFT JOIN 
					(
						select distinct
							collection_session_id,
							database_id,
							[object_id],
							index_id,
							indexColumns = 
							(
								SELECT t3.name + CASE is_included_column WHEN 1 THEN ' (INCL), ' ELSE ',' END AS 'data()'
									FROM db_index_columns t2 
										inner join db_columns t3
											on t2.column_id = t3.column_id
											and t2.[object_id] =t3.[object_id]
											AND t2.database_id = t3.database_id
											and t2.collection_session_id = t3.collection_session_id
									WHERE t1.[object_id] =t2.[object_id]
										AND t1.index_id = t2.index_id
										AND t1.database_id = t2.database_id
										and t1.collection_session_id = t2.collection_session_id
									FOR XML PATH ('')
							)
						FROM db_index_columns t1  
					) c 
						ON c.index_id = e.index_id
						and c.[object_id] = e.[object_id]
						AND c.database_id = e.database_id
						and c.collection_session_id = e.collection_session_id
			--			WHERE OBJECTPROPERTY(i.object_id, 'IsUserTable') = 1
				WHERE e.collection_session_id = @collection_session_id
					AND e.database_id NOT IN (SELECT ISNULL(database_id,0) FROM dbo.index_analysis_db_backlist WHERE is_enabled = 1)
					--AND 'events' = object_name(i.object_id)
					--AND i.name like 'idx_%' 
				ORDER BY [TotalUsage] DESC, TotalSize_GB DESC
		END
		ELSE --@override_blacklist != 0
		BEGIN
			SELECT e.collection_session_id AS [ExpensiveIDXAnalysis2 CSID], e.date_stamp,
					[DBName] = d.name,
					[Schema]  = sc.name,
					TableName = o.name,
					IndexName =  (CASE i.index_id WHEN 0 THEN '(HEAP)' ELSE i.name END),
					ColumnNames = (CASE i.index_id WHEN 0 THEN '(HEAP)' ELSE SUBSTRING(c.indexColumns, 1, LEN(c.indexColumns) - 1) END),
					TotalSize_GB = CAST(e.TotalPages/128./1024. AS NUMERIC(13,4)),
					InRowSize_GB = CAST(e.InRowPages/128./1024. AS NUMERIC(13,4)),
					e.[UserSeeks],
					e.[UserScans],
					e.[UserLookups],
					e.[UserUpdates],
					e.[TotalUsage],
					[PercentRead] = CASE WHEN e.[TotalUsage] > 0 THEN CAST(CAST(e.[UserSeeks] + e.[UserScans] + e.[UserLookups] AS DEC(16,2))/CAST(e.[TotalUsage] AS DEC(16,2)) * 100 AS DEC(6,2)) ELSE 0.0 END,
					[PercentWrite] = CASE WHEN e.[TotalUsage] > 0 THEN CAST(CAST(e.[UserUpdates] AS DEC(16,2))/CAST(e.[TotalUsage] AS DEC(16,2)) * 100 AS DEC(6,2)) ELSE 0.0 END,
					data_compression_max,
					[MixedDataCompression] = case when e.data_compression_max != e.data_compression_min then 1 else 0 end,
					[Filegroup Name] = f.name,
					[IsUnique] = i.is_unique,
					[FillFactor] = i.fill_factor,
					e.IndexCount,
					[Disabled] = i.is_disabled,
					PartitionCount,
					[RowLocks] = i.allow_row_locks,
					[PageLocks] = i.allow_page_locks,
					[Hypothetical] = i.is_hypothetical,
					[IsDefault] = f.is_default,
					[IsReadOnly] = f.is_read_only,
					e.[Last_User_Scan],
					e.[Last_User_Seek],
					[DisableSQL] = 'ALTER INDEX ['+i.name+'] ON ['+d.name+'].['+sc.name+'].['+o.name+'] DISABLE'
				FROM index_analysis_expensive_indexes AS e 
					JOIN db_indexes AS i
						on e.[object_id] = i.[object_id]
						and e.index_id = i.index_id
						and e.database_id = i.database_id
						and e.collection_session_id = i.collection_session_id
					JOIN srv_databases AS d 
						ON e.database_id = d.database_id
						and e.collection_session_id = d.collection_session_id
					JOIN db_objects AS o 
						ON e.[object_id] = o.[object_id]
						and e.database_id = o.database_id
						and e.collection_session_id = o.collection_session_id
						--and o.type in ('U','V')
					JOIN db_schemas AS sc
						ON o.[schema_id] = sc.[schema_id]
						and o.database_id = sc.database_id
						and o.collection_session_id = sc.collection_session_id
					JOIN db_filegroups f 
						ON i.data_space_id = f.data_space_id
						and i.database_id = f.database_id
						and i.collection_session_id = f.collection_session_id
					LEFT JOIN 
					(
						select distinct
							collection_session_id,
							database_id,
							[object_id],
							index_id,
							indexColumns = 
							(
								SELECT t3.name + CASE is_included_column WHEN 1 THEN ' (INCL), ' ELSE ',' END AS 'data()'
									FROM db_index_columns t2 
										inner join db_columns t3
											on t2.column_id = t3.column_id
											and t2.[object_id] =t3.[object_id]
											AND t2.database_id = t3.database_id
											and t2.collection_session_id = t3.collection_session_id
									WHERE t1.[object_id] =t2.[object_id]
										AND t1.index_id = t2.index_id
										AND t1.database_id = t2.database_id
										and t1.collection_session_id = t2.collection_session_id
									FOR XML PATH ('')
							)
						FROM db_index_columns t1  
					) c 
						ON c.index_id = e.index_id
						and c.[object_id] = e.[object_id]
						AND c.database_id = e.database_id
						and c.collection_session_id = e.collection_session_id
			--			WHERE OBJECTPROPERTY(i.object_id, 'IsUserTable') = 1
				WHERE e.collection_session_id = @collection_session_id
					--AND 'events' = object_name(i.object_id)
					--AND i.name like 'idx_%' 
				ORDER BY [TotalUsage] DESC, TotalSize_GB DESC
		END
	END
	ELSE --@database_name_filter IS NOT NULL
	BEGIN
		SELECT e.collection_session_id AS [ExpensiveIDXAnalysis3 CSID], e.date_stamp,
				[DBName] = d.name,
				[Schema]  = sc.name,
				TableName = o.name,
				IndexName =  (CASE i.index_id WHEN 0 THEN '(HEAP)' ELSE i.name END),
				ColumnNames = (CASE i.index_id WHEN 0 THEN '(HEAP)' ELSE SUBSTRING(c.indexColumns, 1, LEN(c.indexColumns) - 1) END),
				TotalSize_GB = CAST(e.TotalPages/128./1024. AS NUMERIC(13,4)),
				InRowSize_GB = CAST(e.InRowPages/128./1024. AS NUMERIC(13,4)),
				e.[UserSeeks],
				e.[UserScans],
				e.[UserLookups],
				e.[UserUpdates],
				e.[TotalUsage],
				[PercentRead] = CASE WHEN e.[TotalUsage] > 0 THEN CAST(CAST(e.[UserSeeks] + e.[UserScans] + e.[UserLookups] AS DEC(16,2))/CAST(e.[TotalUsage] AS DEC(16,2)) * 100 AS DEC(6,2)) ELSE 0.0 END,
				[PercentWrite] = CASE WHEN e.[TotalUsage] > 0 THEN CAST(CAST(e.[UserUpdates] AS DEC(16,2))/CAST(e.[TotalUsage] AS DEC(16,2)) * 100 AS DEC(6,2)) ELSE 0.0 END,
				data_compression_max,
				[MixedDataCompression] = case when e.data_compression_max != e.data_compression_min then 1 else 0 end,
				[Filegroup Name] = f.name,
				[IsUnique] = i.is_unique,
				[FillFactor] = i.fill_factor,
				e.IndexCount,
				[Disabled] = i.is_disabled,
				PartitionCount,
				[RowLocks] = i.allow_row_locks,
				[PageLocks] = i.allow_page_locks,
				[Hypothetical] = i.is_hypothetical,
				[IsDefault] = f.is_default,
				[IsReadOnly] = f.is_read_only,
				e.[Last_User_Scan],
				e.[Last_User_Seek],
				[DisableSQL] = 'ALTER INDEX ['+i.name+'] ON ['+d.name+'].['+sc.name+'].['+o.name+'] DISABLE'
			FROM index_analysis_expensive_indexes AS e 
				JOIN db_indexes AS i
					on e.[object_id] = i.[object_id]
					and e.index_id = i.index_id
					and e.database_id = i.database_id
					and e.collection_session_id = i.collection_session_id
				JOIN srv_databases AS d 
					ON e.database_id = d.database_id
					and e.collection_session_id = d.collection_session_id
				JOIN db_objects AS o 
					ON e.[object_id] = o.[object_id]
					and e.database_id = o.database_id
					and e.collection_session_id = o.collection_session_id
					--and o.type in ('U','V')
				JOIN db_schemas AS sc
					ON o.[schema_id] = sc.[schema_id]
					and o.database_id = sc.database_id
					and o.collection_session_id = sc.collection_session_id
				JOIN db_filegroups f 
					ON i.data_space_id = f.data_space_id
					and i.database_id = f.database_id
					and i.collection_session_id = f.collection_session_id
				LEFT JOIN 
				(
					select distinct
						collection_session_id,
						database_id,
						[object_id],
						index_id,
						indexColumns = 
						(
							SELECT t3.name + CASE is_included_column WHEN 1 THEN ' (INCL), ' ELSE ',' END AS 'data()'
								FROM db_index_columns t2 
									inner join db_columns t3
										on t2.column_id = t3.column_id
										and t2.[object_id] =t3.[object_id]
										AND t2.database_id = t3.database_id
										and t2.collection_session_id = t3.collection_session_id
								WHERE t1.[object_id] =t2.[object_id]
									AND t1.index_id = t2.index_id
									AND t1.database_id = t2.database_id
									and t1.collection_session_id = t2.collection_session_id
								FOR XML PATH ('')
						)
					FROM db_index_columns t1  
				) c 
					ON c.index_id = e.index_id
					and c.[object_id] = e.[object_id]
					AND c.database_id = e.database_id
					and c.collection_session_id = e.collection_session_id
		--			WHERE OBJECTPROPERTY(i.object_id, 'IsUserTable') = 1
			WHERE e.collection_session_id = @collection_session_id
				AND e.database_id = (SELECT database_id FROM dbo.srv_databases WHERE name = @database_name_filter and collection_session_id = @collection_session_id)
				--AND 'events' = object_name(i.object_id)
				--AND i.name like 'idx_%' 
			ORDER BY [TotalUsage] DESC, TotalSize_GB DESC

	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_expensive_results_generate]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_expensive_results_generate') is null exec('create procedure [dbo].[usp_index_analysis_expensive_results_generate] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_expensive_results_generate
(
	@collection_session_id int
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Generate intermediate results set for expensive and clustered index swap analysis
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*
*	Future Enhancements:
*	1. Consider commented filters for inclusion
*
*	Current Known Bugs:
*	
*	Returns: single result set
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	--cleanup prior run data for reprocessing
	DELETE dbo.index_analysis_expensive_indexes WHERE collection_session_id = @collection_session_id

	--add data for run
	INSERT INTO dbo.index_analysis_expensive_indexes
		SELECT ISNULL(MAX(s.date_stamp),'1/1/1900'),
				i.collection_session_id,
				i.database_id,
				i.[object_id],
				i.index_id,
				i.data_space_id,
				[TotalPages] = ISNULL(SUM(sa.total_pages), 0),
				[InRowPages] = ISNULL(SUM(CASE sa.[type] WHEN 1 THEN sa.total_pages ELSE 0 END), 0),
				[UserSeeks] = ISNULL(SUM(user_seeks), 0) ,
				[UserScans] = ISNULL(SUM(user_scans), 0) ,
				[UserLookups] = ISNULL(SUM(user_lookups), 0) ,
				[UserUpdates] = ISNULL(SUM(user_updates), 0) ,
				min(data_compression),
				max(data_compression),
				[IndexCount] = (SELECT count(*)
					FROM db_indexes r 
					WHERE r.object_id = i.object_id
					and r.database_id = i.database_id
					and r.collection_session_id = i.collection_session_id),
				MAX(ISNULL(partition_number, -1)),
				[Last_User_Scan] = ISNULL(MAX(last_user_scan),'1/1/1900'),
				[Last_User_Seek] = ISNULL(MAX(last_user_seek),'1/1/1900')
			FROM db_indexes AS i 
				LEFT JOIN IndexUsageStats AS s 
					ON i.[object_id] = s.[object_id]
					AND i.index_id = s.index_id 
					and i.database_id = s.database_id
				INNER JOIN db_objects AS o 
					ON i.[object_id] = o.[object_id]
					and i.database_id = o.database_id
					and i.collection_session_id = o.collection_session_id
					--and o.type in ('U','V')
				LEFT JOIN db_partitions AS sp 
					ON i.[object_id] = sp.[object_id]
					AND i.index_id = sp.index_id
					and i.database_id = sp.database_id
					and i.collection_session_id = sp.collection_session_id
				LEFT JOIN db_allocation_units AS sa
					ON sa.container_id = sp.hobt_id
					and sa.database_id = sp.database_id
					and sa.collection_session_id = sp.collection_session_id
			WHERE i.[object_id] > 100
				and i.collection_session_id = (select max(collection_session_id) from db_indexes)
				--AND 'events' = object_name(i.object_id)
				--AND i.name like 'idx_%' 
			GROUP BY
				s.date_stamp, 
				i.collection_session_id,
				i.database_id,
				i.[object_id],
				i.index_id,
				i.data_space_id

			HAVING SUM(sa.total_pages) > 128 --1MB

END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_heap_results]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_heap_results') is null exec('create procedure [dbo].[usp_index_analysis_heap_results] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_heap_results
(
	@collection_session_id int, 
	@override_blacklist tinyint = 0,
	@database_name_filter sysname = NULL
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose:	Perform heap analysis of single collection to determine heaps that should be considered for clustered indexes
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. To easily differentiate result set and query from first column (collection_session_id) is renamed to type and query number.
*
*	Future Enhancements:
*	1. consider parameter for min size to report
*	2. Consider second result set to summarize by size
*
*	Current Known Bugs:
*	
*	Returns: single result set
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	IF @database_name_filter IS NULL
	BEGIN
		IF @override_blacklist = 0
		BEGIN
			SELECT i.collection_session_id AS [HeapAnalysis1 CSID],
					si.dpages/128 AS [sizeMB],
					d.name+'.'+s.name+'.'+o.name AS [name], 
					(
				
						SELECT count(*)-1 
							FROM db_indexes i2 
							WHERE i.database_id = i2.database_id 
								AND i.[object_id] = i2.[object_id] 
								AND i2.collection_session_id = si.collection_session_id
					) as [nc_index_count],
					si.rowcnt, 
					i.[type],
					i.[name],
					i.is_disabled,
					i.is_hypothetical,
					i.is_primary_key,
					i.is_unique,
					i.is_unique_constraint,
					i.[ignore_dup_key], 
					i.fill_factor,
					i.is_padded,
					i.has_filter,
					i.[allow_row_locks],
					i.[allow_page_locks],
					i.data_space_id,
					i.database_id,
					i.[object_id],
					i.index_id
				FROM db_indexes i
				LEFT OUTER JOIN db_sysindexes si
					ON i.database_id = si.database_id
					AND i.[object_id] = si.[object_id]
					AND i.index_id = si.index_id
					AND i.collection_session_id = si.collection_session_id
				INNER JOIN srv_databases d
					ON i.database_id = d.database_id
					AND i.collection_session_id = d.collection_session_id
				INNER JOIN db_objects o
					ON i.database_id = o.database_id
					AND i.[object_id] = o.[object_id]
					AND i.collection_session_id = o.collection_session_id
				INNER JOIN db_schemas s
					ON o.database_id = s.database_id
					AND o.[schema_id] = s.[schema_id]
					AND o.collection_session_id = s.collection_session_id
				WHERE i.index_id = 0
					AND si.dpages > 128
					AND i.collection_session_id = @collection_session_id
					AND i.database_id NOT IN (SELECT ISNULL(database_id,0) FROM dbo.index_analysis_db_backlist WHERE is_enabled = 1)
				ORDER BY si.dpages DESC
		END
		ELSE --@override_blacklist != 0
		BEGIN
			SELECT i.collection_session_id AS [HeapAnalysis2 CSID],
					si.dpages/128 AS [sizeMB],
					d.name+'.'+s.name+'.'+o.name AS [name], 
					(
				
						SELECT count(*)-1 
							FROM db_indexes i2 
							WHERE i.database_id = i2.database_id 
								AND i.[object_id] = i2.[object_id] 
								AND i2.collection_session_id = si.collection_session_id
					) as [nc_index_count],
					si.rowcnt, 
					i.[type],
					i.[name],
					i.is_disabled,
					i.is_hypothetical,
					i.is_primary_key,
					i.is_unique,
					i.is_unique_constraint,
					i.[ignore_dup_key], 
					i.fill_factor,
					i.is_padded,
					i.has_filter,
					i.[allow_row_locks],
					i.[allow_page_locks],
					i.data_space_id,
					i.database_id,
					i.[object_id],
					i.index_id
				FROM db_indexes i
				LEFT OUTER JOIN db_sysindexes si
					ON i.database_id = si.database_id
					AND i.[object_id] = si.[object_id]
					AND i.index_id = si.index_id
					AND i.collection_session_id = si.collection_session_id
				INNER JOIN srv_databases d
					ON i.database_id = d.database_id
					AND i.collection_session_id = d.collection_session_id
				INNER JOIN db_objects o
					ON i.database_id = o.database_id
					AND i.[object_id] = o.[object_id]
					AND i.collection_session_id = o.collection_session_id
				INNER JOIN db_schemas s
					ON o.database_id = s.database_id
					AND o.[schema_id] = s.[schema_id]
					AND o.collection_session_id = s.collection_session_id
				WHERE i.index_id = 0
					AND si.dpages > 128
					AND i.collection_session_id = @collection_session_id
				ORDER BY si.dpages DESC
		END
	END
	ELSE --@database_name_filter IS NULL
	BEGIN
		SELECT i.collection_session_id AS [HeapAnalysis3 CSID],
				si.dpages/128 AS [sizeMB],
				d.name+'.'+s.name+'.'+o.name AS [name], 
				(
				
					SELECT count(*)-1 
						FROM db_indexes i2 
						WHERE i.database_id = i2.database_id 
							AND i.[object_id] = i2.[object_id] 
							AND i2.collection_session_id = si.collection_session_id
				) as [nc_index_count],
				si.rowcnt, 
				i.[type],
				i.[name],
				i.is_disabled,
				i.is_hypothetical,
				i.is_primary_key,
				i.is_unique,
				i.is_unique_constraint,
				i.[ignore_dup_key], 
				i.fill_factor,
				i.is_padded,
				i.has_filter,
				i.[allow_row_locks],
				i.[allow_page_locks],
				i.data_space_id,
				i.database_id,
				i.[object_id],
				i.index_id
			FROM db_indexes i
			LEFT OUTER JOIN db_sysindexes si
				ON i.database_id = si.database_id
				AND i.[object_id] = si.[object_id]
				AND i.index_id = si.index_id
				AND i.collection_session_id = si.collection_session_id
			INNER JOIN srv_databases d
				ON i.database_id = d.database_id
				AND i.collection_session_id = d.collection_session_id
			INNER JOIN db_objects o
				ON i.database_id = o.database_id
				AND i.[object_id] = o.[object_id]
				AND i.collection_session_id = o.collection_session_id
			INNER JOIN db_schemas s
				ON o.database_id = s.database_id
				AND o.[schema_id] = s.[schema_id]
				AND o.collection_session_id = s.collection_session_id
			WHERE i.index_id = 0
				AND si.dpages > 128
				AND i.collection_session_id = @collection_session_id
				AND i.database_id = (SELECT database_id FROM dbo.srv_databases WHERE name = @database_name_filter and collection_session_id = @collection_session_id)
			ORDER BY si.dpages DESC
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_high_scan_results]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_high_scan_results') is null exec('create procedure [dbo].[usp_index_analysis_high_scan_results] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_high_scan_results
(
	@collection_session_id int, 
	@override_blacklist tinyint = 0,
	@database_name_filter sysname = NULL
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Return high index scan analysis result set
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. To easily differentiate result set and query from first column (collection_session_id) is renamed to type and query number.
*
*	Future Enhancements:
*	1. Allow filtering with optional parameters
*	2. alter column list for usability
*
*	Current Known Bugs:
*
*	Returns: single result set
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	IF @database_name_filter IS NULL
	BEGIN
		IF @override_blacklist = 0
		BEGIN
			SELECT si.collection_session_id as [HighScanAnalysis1 CSID], d.name, o.name,
				si.dpages, 
				i.* 
				FROM IndexUsageStats i
					INNER JOIN srv_databases d 
						ON i.database_id = d.database_id
					INNER JOIN db_objects o
						ON i.database_id = o.database_id
						AND i.[object_id] = o.[object_id]
						AND d.collection_session_id = o.collection_session_id
					INNER JOIN db_sysindexes si
						ON i.database_id = si.database_id
						AND i.[object_id] = si.[object_id]
						AND i.index_id = si.index_id
						AND o.collection_session_id = si.collection_session_id

				WHERE si.dpages > 128
					AND si.database_id > 4
					AND si.collection_session_id = @collection_session_id
					AND si.database_id NOT IN (SELECT ISNULL(database_id,0) FROM dbo.index_analysis_db_backlist WHERE is_enabled = 1)
				ORDER BY i.user_scans DESC
		END
		ELSE --@override_blacklist != 0
		BEGIN
			SELECT si.collection_session_id as [HighScanAnalysis2 CSID], d.name, o.name,
				si.dpages, 
				i.* 
				FROM IndexUsageStats i
					INNER JOIN srv_databases d 
						ON i.database_id = d.database_id
					INNER JOIN db_objects o
						ON i.database_id = o.database_id
						AND i.[object_id] = o.[object_id]
						AND d.collection_session_id = o.collection_session_id
					INNER JOIN db_sysindexes si
						ON i.database_id = si.database_id
						AND i.[object_id] = si.[object_id]
						AND i.index_id = si.index_id
						AND o.collection_session_id = si.collection_session_id

				WHERE si.dpages > 128
					AND si.database_id > 4
					AND si.collection_session_id = @collection_session_id
				ORDER BY i.user_scans DESC
		END
	END
	ELSE --@database_name_filter IS NOT NULL
	BEGIN
		SELECT si.collection_session_id as [HighScanAnalysis3 CSID], d.name, o.name,
			si.dpages, 
			i.* 
			FROM IndexUsageStats i
				INNER JOIN srv_databases d 
					ON i.database_id = d.database_id
				INNER JOIN db_objects o
					ON i.database_id = o.database_id
					AND i.[object_id] = o.[object_id]
					AND d.collection_session_id = o.collection_session_id
				INNER JOIN db_sysindexes si
					ON i.database_id = si.database_id
					AND i.[object_id] = si.[object_id]
					AND i.index_id = si.index_id
					AND o.collection_session_id = si.collection_session_id

			WHERE si.dpages > 128
				AND si.database_id = (SELECT database_id FROM dbo.srv_databases WHERE name = @database_name_filter and collection_session_id = @collection_session_id)
				AND si.collection_session_id = @collection_session_id
			ORDER BY i.user_scans DESC
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_missing_results]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_missing_results') is null exec('create procedure [dbo].[usp_index_analysis_missing_results] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_missing_results
(
	@collection_session_id int, 
	@override_blacklist tinyint = 0,
	@database_name_filter sysname = NULL
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Return missing indexes analysis result set
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. To easily differentiate result set and query from first column (collection_session_id) is renamed to type and query number.
*
*	Future Enhancements:
*	1. Allow filtering with new optional parameters
*	2. Consider commented filters
*
*	Current Known Bugs:
*	
*	Returns: single result set
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	IF @database_name_filter IS NULL
	BEGIN
		IF @override_blacklist = 0
		BEGIN
			SELECT mi.collection_session_id as [MissingIndex1 CSID],
					CEILING(CAST(mi.avg_total_user_cost * mi.avg_user_impact * (mi.user_seeks + mi.user_scans) AS dec(18,2))) AS [Impact],
					d.[name] AS [database_name],
					'CREATE INDEX idx_'
						+ ISNULL(o.name,'null_object_name')
						+ '_' + REPLACE(REPLACE(REPLACE(ISNULL(equality_columns,'null_eq_columns'), '[', ''), ']', ''), ', ', '_')
						+ ' ON [' 
						+ ISNULL(d.name,'null_database_name') + '].[' 
						+ ISNULL(s.name,'null_schema_name') + '].['
						+ ISNULL(o.name,'null_object_name') + '] ('
						+ ISNULL(o.name,'null_object_name') + '] ('
						+ equality_columns + ')' --causes null data rows
			--			+ ISNULL(equality_columns,'null_eq_columns') + ')'
						+ (
								CASE 
									WHEN included_columns IS NOT NULL THEN 'INCLUDE(' + ISNULL(included_columns, '') + ') WITH (DATA_COMPRESSION = row)'
									ELSE ' WITH (DATA_COMPRESSION = row)' 
								END
							) AS [Stmt],
						mi.db_missing_indexes_id
				FROM dbo.db_missing_indexes mi
					INNER JOIN dbo.srv_databases d
						ON mi.database_id = d.database_id
						AND mi.collection_session_id = d.collection_session_id
					INNER JOIN dbo.db_objects o
						ON mi.[object_id] = o.[object_id]
						AND mi.database_id = o.database_id
						AND mi.collection_session_id = o.collection_session_id
					INNER JOIN dbo.db_schemas s
						ON o.[schema_id] = s.[schema_id]
						AND mi.database_id = s.database_id
						AND mi.collection_session_id = s.collection_session_id
				WHERE mi.database_id > 4
					AND mi.collection_session_id = @collection_session_id
					AND mi.database_id NOT IN (SELECT ISNULL(database_id,0) FROM dbo.index_analysis_db_backlist WHERE is_enabled = 1)
					--and equality_columns is not null
				ORDER BY 1 desc
		END
		ELSE --@override_blacklist != 0
		BEGIN
			SELECT mi.collection_session_id as [MissingIndex2 CSID],
					CEILING(CAST(mi.avg_total_user_cost * mi.avg_user_impact * (mi.user_seeks + mi.user_scans) AS dec(18,2))) AS [Impact],
					d.[name] AS [database_name],
					'CREATE INDEX idx_'
						+ ISNULL(o.name,'null_object_name')
						+ '_' + REPLACE(REPLACE(REPLACE(ISNULL(equality_columns,'null_eq_columns'), '[', ''), ']', ''), ', ', '_')
						+ ' ON [' 
						+ ISNULL(d.name,'null_database_name') + '].[' 
						+ ISNULL(s.name,'null_schema_name') + '].['
						+ ISNULL(o.name,'null_object_name') + '] ('
						+ ISNULL(o.name,'null_object_name') + '] ('
						+ equality_columns + ')' --causes null data rows
			--			+ ISNULL(equality_columns,'null_eq_columns') + ')'
						+ (
								CASE 
									WHEN included_columns IS NOT NULL THEN 'INCLUDE(' + ISNULL(included_columns, '') + ') WITH (DATA_COMPRESSION = row)'
									ELSE ' WITH (DATA_COMPRESSION = row)' 
								END
							) AS [Stmt],
						mi.db_missing_indexes_id
				FROM dbo.db_missing_indexes mi
					INNER JOIN dbo.srv_databases d
						ON mi.database_id = d.database_id
						AND mi.collection_session_id = d.collection_session_id
					INNER JOIN dbo.db_objects o
						ON mi.[object_id] = o.[object_id]
						AND mi.database_id = o.database_id
						AND mi.collection_session_id = o.collection_session_id
					INNER JOIN dbo.db_schemas s
						ON o.[schema_id] = s.[schema_id]
						AND mi.database_id = s.database_id
						AND mi.collection_session_id = s.collection_session_id
				WHERE mi.collection_session_id = @collection_session_id
					--and equality_columns is not null
				ORDER BY 1 desc
		END
	END
	ELSE --@database_name_filter IS NOT NULL
	BEGIN
		SELECT mi.collection_session_id as [MissingIndex3 CSID],
				CEILING(CAST(mi.avg_total_user_cost * mi.avg_user_impact * (mi.user_seeks + mi.user_scans) AS dec(18,2))) AS [Impact],
				d.[name] AS [database_name],
				'CREATE INDEX idx_'
					+ ISNULL(o.name,'null_object_name')
					+ '_' + REPLACE(REPLACE(REPLACE(ISNULL(equality_columns,'null_eq_columns'), '[', ''), ']', ''), ', ', '_')
					+ ' ON [' 
					+ ISNULL(d.name,'null_database_name') + '].[' 
					+ ISNULL(s.name,'null_schema_name') + '].['
					+ ISNULL(o.name,'null_object_name') + '] ('
					+ ISNULL(o.name,'null_object_name') + '] ('
					+ equality_columns + ')' --causes null data rows
		--			+ ISNULL(equality_columns,'null_eq_columns') + ')'
					+ (
							CASE 
								WHEN included_columns IS NOT NULL THEN 'INCLUDE(' + ISNULL(included_columns, '') + ') WITH (DATA_COMPRESSION = row)'
								ELSE ' WITH (DATA_COMPRESSION = row)' 
							END
						) AS [Stmt],
					mi.db_missing_indexes_id
			FROM dbo.db_missing_indexes mi
				INNER JOIN dbo.srv_databases d
					ON mi.database_id = d.database_id
					AND mi.collection_session_id = d.collection_session_id
				INNER JOIN dbo.db_objects o
					ON mi.[object_id] = o.[object_id]
					AND mi.database_id = o.database_id
					AND mi.collection_session_id = o.collection_session_id
				INNER JOIN dbo.db_schemas s
					ON o.[schema_id] = s.[schema_id]
					AND mi.database_id = s.database_id
					AND mi.collection_session_id = s.collection_session_id
			WHERE mi.collection_session_id = @collection_session_id
				AND mi.database_id = (SELECT database_id FROM dbo.srv_databases WHERE name = @database_name_filter and collection_session_id = @collection_session_id)
				--and equality_columns is not null
			ORDER BY 1 desc
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_purge_collection]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_purge_collection') is null exec('create procedure [dbo].[usp_index_analysis_purge_collection] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_purge_collection
(
	@collection_session_id int
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	purge old data from Index Analysis data in the FDDBA database
*				
*	Inputs:		
*
*	@collection_session_id - required. See table dbo.collection_sessions for possible values.
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. This will delete data from all index analysis tables besides dbo.collection_sessions and dbo.collection_sessions_perf
*
*	Future Enhancements:
*
*	Current Known Bugs:
*	
*	Returns:	Nothing
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/19/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/
	SET NOCOUNT ON
	DECLARE @msg varchar(200)
	DECLARE @cid int
	DECLARE @dt datetime
	DECLARE @dtstart datetime
	DECLARE @dtend datetime
	DECLARE @delta int
	DECLARE @row_count int

	IF NOT EXISTS (SELECT 1 FROM dbo.collection_session WHERE collection_session_id = @collection_session_id)
	BEGIN
		SET @msg = 'Invalid @collection_session_id parameter! Exiting!'
		RAISERROR(@msg, 10, 1)
	END
	ELSE
	BEGIN
		SET @dt = GETDATE()
		SET @dtstart = @dt

		INSERT dbo.collection_session VALUES (@dtstart, @@SERVERNAME, NULL)
		SET @cid = @@IDENTITY

		--record parameters
		SET @msg = convert(varchar(23), @dtstart, 126) + ' @collection_session_id = ' + ISNULL(LTRIM(STR(@collection_session_id)), '(null)')
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, 0, @msg)

		--loop from here
		SET @dtstart = GETDATE()
		
		DELETE dbo.srv_databases WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.srv_databases]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_index_operational_stats WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_index_operational_stats]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 1, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_schemas WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_schemas]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 2, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_objects WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_objects]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 3, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_indexes WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_indexes]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 4, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_sysindexes WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_sysindexes]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 5, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_filegroups WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_filegroups]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 6, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_partitions WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_partitions]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 7, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_allocation_units WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_allocation_units]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 8, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_index_columns WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_index_columns]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 9, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_columns WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_columns]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 10, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.db_missing_indexes WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.db_missing_indexes]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 12, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.dm_exec_query_stats WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.dm_exec_query_stats]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 13, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.dm_exec_code_stats WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.dm_exec_code_stats]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 16, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.dm_exec_code WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.dm_exec_code]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 18, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.dm_exec_adhoc_stats WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.dm_exec_adhoc_stats]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 19, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.dm_exec_adhoc_sql WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.dm_exec_adhoc_sql]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 20, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.index_analysis_compression WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.index_analysis_compression]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 21, @delta, @msg)
		END

		SET @dtstart = GETDATE()
		
		DELETE dbo.dm_exec_query_plan_summary WHERE collection_session_id = @collection_session_id
		SET @row_count = @@ROWCOUNT

		SET @dtend = GETDATE()
		SET @delta = DATEDIFF(SECOND, @dtstart, @dtend)
		IF @delta > 0
		BEGIN
			SET @msg = convert(varchar(23), @dtstart, 126) + ' Purged ' + LTRIM(STR(@row_count)) + ' rows from [dbo.dm_exec_query_plan_summary]'
			RAISERROR (@msg,10,1) WITH NOWAIT
			INSERT dbo.collection_session_perf VALUES (@cid, 0, 22, @delta, @msg)
		END

		SET @delta = DATEDIFF(SECOND, @dt, @dtend)

		UPDATE dbo.collection_session SET durationS = @delta WHERE collection_session_id = @cid

		SET @msg = convert(varchar(23),@dtend,126) + ' Purge Complete'
		RAISERROR (@msg,10,1) WITH NOWAIT
		INSERT dbo.collection_session_perf VALUES (@cid, 0, 0, @delta, @msg)
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_query_stats_results]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_query_stats_results') is null exec('create procedure [dbo].[usp_index_analysis_query_stats_results] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_query_stats_results
(
	@collection_session_id int, 
	@override_blacklist tinyint = 0,
	@database_name_filter sysname = NULL
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Return results of high impact execution query stats
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. To easily differentiate result set and query from first column (collection_session_id) is renamed to type and query number.
*
*	Future Enhancements:
*
*	Current Known Bugs:
*	1. Implement query
*	2. Filter for optional parameters
*	3. alter column list for usability
*
*
*	Returns: single result set
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	IF @database_name_filter IS NULL
	BEGIN
		IF @override_blacklist = 0
		BEGIN
			SELECT 'NOT YET IMPLEMENTED - CONTACT MIKE' AS [QueryStatsAnalysis1 CSID]
		END
		ELSE --@override_blacklist != 0
		BEGIN
			SELECT 'NOT YET IMPLEMENTED - CONTACT MIKE' AS [QueryStatsAnalysis2 CSID]
		END
	END
	ELSE --@database_name_filter IS NOT NULL
	BEGIN
		SELECT 'NOT YET IMPLEMENTED - CONTACT MIKE' AS [QueryStatsAnalysis3 CSID]
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_index_analysis_results]',10,1) WITH NOWAIT;
if object_id('dbo.usp_index_analysis_results') is null exec('create procedure [dbo].[usp_index_analysis_results] as select getdate() DT')
GO
  
alter procedure dbo.usp_index_analysis_results
(
	@collection_session_id int = NULL, 
	@run_heaps tinyint = 1,
	@run_duplicates tinyint = 1,
	@run_missing tinyint = 1,
	@run_high_scans tinyint = 1,
	@run_expensive tinyint = 1,
	@run_clustered_swaps tinyint = 1,
	@run_compression tinyint = 1,
	@run_query_stats tinyint = 1,
	@override_blacklist tinyint = 0,
	@database_name_filter sysname = NULL
)
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: Validate parameters and run all index analysis procedures
*				
*	Inputs:		
*
*	@collection_session_id - required collection to return results on with default of latest collection
*	@run_heaps - optional to run heap analysis
*	@run_duplicates - optional to run duplicate index analysis
*	@run_missing - optional to run missing index analysis
*	@run_high_scans - optional to run high index scan analysis
*	@run_expensive - optional to run expensive index analysis
*	@run_clustered_swaps - optional to run clustered index swap analysis
*	@run_compression - optional to run index compression analysis
*	@run_query_stats - optional to run query stats analysis
*	@override_blacklist - optional to see all data from all databases
*	@database_name_filter - optional filter to see all data from one perticular database
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. This is just a wrapper proc which validates parameters for downlevel analysis procedures
*	2. Design of collection and analysis is so that multiple collection and analysis can be done and can be compared over time
*
*	Future Enhancements:
*
*	Current Known Bugs:
*	
*	Returns: Nothing however called stored procedures return results
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/27/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	DECLARE @msg varchar(200)
	DECLARE @fCIDPassed tinyint = 0

	IF @collection_session_id IS NOT NULL
	BEGIN
		SET @fCIDPassed = 1
		IF NOT EXISTS (SELECT 1 FROM dbo.collection_session WHERE collection_session_id = @collection_session_id)
		BEGIN
			SET @msg = 'Invalid @collection_session_id parameter. Value = ' + LTRIM(STR(@collection_session_id))
			RAISERROR(@msg, 10, 1)
			RETURN
		END
	END
	ELSE
	BEGIN
		SELECT @collection_session_id = MAX(collection_session_id) FROM dbo.db_indexes
	END

	IF @database_name_filter IS NOT NULL
	BEGIN
		IF NOT EXISTS (SELECT 1 FROM dbo.srv_databases WHERE name = @database_name_filter)
		BEGIN
			SET @msg = 'Invalid @@database_name_filter parameter. Value = [' + @database_name_filter + ']'
			RAISERROR(@msg, 10, 1)
			RETURN
		END
	END

	--update database backlist database_ids for enabled databases
/*
	works with local data but not remote
	UPDATE dbo.index_analysis_db_backlist
		SET database_id = 
			CASE WHEN DB_ID(database_name) IS NOT NULL THEN DB_ID(database_name)
				ELSE ABS(database_id)*-1 END
		WHERE is_enabled = 1
*/
	UPDATE b
		SET database_id = 
			CASE WHEN d.database_id IS NOT NULL THEN d.database_id
				ELSE ABS(b.database_id)*-1 END
		FROM dbo.index_analysis_db_backlist b
			LEFT OUTER JOIN dbo.srv_databases d
			ON b.database_name = d.name
		WHERE b.is_enabled = 1


	IF @run_heaps = 1
	BEGIN
		EXEC dbo.usp_index_analysis_heap_results @collection_session_id, @override_blacklist, @database_name_filter
	END

	IF @run_duplicates = 1
	BEGIN
		EXEC dbo.usp_index_analysis_duplicate_results @collection_session_id, @override_blacklist, @database_name_filter
	END

	IF @run_missing = 1
	BEGIN
		EXEC dbo.usp_index_analysis_missing_results @collection_session_id, @override_blacklist, @database_name_filter
	END

	IF @run_high_scans = 1
	BEGIN
		EXEC dbo.usp_index_analysis_high_scan_results @collection_session_id, @override_blacklist, @database_name_filter
	END

	IF @run_expensive = 1
	BEGIN
		EXEC dbo.usp_index_analysis_expensive_results @collection_session_id, @override_blacklist, @database_name_filter
	END

	IF @run_clustered_swaps = 1
	BEGIN
		EXEC dbo.usp_index_analysis_clustered_swap_results @collection_session_id, @override_blacklist, @database_name_filter
	END

	IF @run_compression = 1
	BEGIN
		EXEC dbo.usp_index_analysis_compression_results @collection_session_id, @override_blacklist, @database_name_filter
	END

	IF @run_query_stats = 1
	BEGIN
		IF @fCIDPassed = 0
		BEGIN
			SELECT @collection_session_id = MAX(collection_session_id) FROM dbo.dm_exec_query_stats
		END
		EXEC dbo.usp_index_analysis_query_stats_results @collection_session_id, @override_blacklist, @database_name_filter
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_Load_Process_Monitor_Adhoc]',10,1) WITH NOWAIT;
if object_id('dbo.usp_Load_Process_Monitor_Adhoc') is null exec('create procedure [dbo].[usp_Load_Process_Monitor_Adhoc] as select getdate() DT')
GO
  
alter procedure dbo.usp_Load_Process_Monitor_Adhoc
(
	@includePlan	BIT = 0
)
WITH ENCRYPTION
AS

/*********************************************************************************************************************
*	Written By:	Ben DeBow
*	Purpose: 	Track active process data
*	Inputs:		
*
*	ASSIGN VARIABLES
*
*	Notes:	This procedure stores off the active sessions that are running.
*
*	Returns:	Errors
*	Prerequisite: 
*				
*	History:	
*
*	6/15/2010 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/15/2010			Ben DeBow				Created
*	5/24/2017			Keith Buck				Insert sometimes fails on XML conversion. Added second error handler that outputs the error info as a message
*												and then attempts the insert again but passes in NULLS for the XML columns
*	6/14/2018			Mike Zawadzki			Added memory grant dmvs based on zd ticket 43201 and performance logging
*	2/5/2019			Keith Buck				Added optional parameter for capturing plan, defaulted to off, to save space
*	3/11/2019			Keith Buck				Updated insert into mon.dm_exec_query_memory_grants to use expicit column names as new columns added in 2017  
*********************************************************************************************************************/
SET NOCOUNT ON
SET ANSI_WARNINGS OFF

DECLARE @ErrorMessage NVARCHAR(4000)
DECLARE @ErrorSeverity INT
DECLARE @ErrorState INT
DECLARE @rowcount INT
DECLARE @utc_proc DATETIME
DECLARE @utc_stmt DATETIME
DECLARE @utc_current DATETIME
DECLARE @diff SMALLINT
DECLARE @id INT
DECLARE @msg VARCHAR(2048)

BEGIN TRY
EXEC dbo.usp_UpdateVersionStatics
SET @utc_proc = GETUTCDATE()
SET @utc_stmt = @utc_proc
INSERT [dbo].[collection_session] (runtime, servername) VALUES (@utc_proc,@@SERVERNAME)
SET @id = @@IDENTITY

INSERT [mon].[dm_exec_query_resource_semaphores] 
	SELECT @id, * FROM sys.dm_exec_query_resource_semaphores

SET @rowcount = @@ROWCOUNT
SET @utc_current = GETUTCDATE()

SET @diff = DATEDIFF(SECOND, @utc_stmt, @utc_current)
IF @diff > 0
BEGIN
	SET @msg = 'dbid=objid,rc=' + LTRIM(STR(@rowcount))
	INSERT [dbo].[collection_session_perf] (collection_session_id, database_id, collection_type, durationSEC, result_message) 
		VALUES (@id, @@PROCID, 0, @diff, @msg)
END

SET @utc_stmt = @utc_current

INSERT [mon].[dm_exec_query_memory_grants] 	(collection_session_id, session_id, request_id ,scheduler_id ,dop ,request_time ,grant_time ,requested_memory_kb ,granted_memory_kb ,required_memory_kb ,used_memory_kb ,max_used_memory_kb,query_cost
,timeout_sec ,resource_semaphore_id ,queue_id ,wait_order ,is_next_candidate ,wait_time_ms ,plan_handle ,sql_handle ,group_id ,pool_id ,is_small ,ideal_memory_kb )
SELECT @id, session_id, request_id ,scheduler_id ,dop ,request_time ,grant_time ,requested_memory_kb ,granted_memory_kb ,required_memory_kb ,used_memory_kb ,max_used_memory_kb,query_cost
,timeout_sec ,resource_semaphore_id ,queue_id ,wait_order ,is_next_candidate ,wait_time_ms ,plan_handle ,sql_handle ,group_id ,pool_id ,is_small ,ideal_memory_kb  
FROM sys.dm_exec_query_memory_grants


SET @rowcount = @@ROWCOUNT
SET @utc_current = GETUTCDATE()

SET @diff = DATEDIFF(SECOND, @utc_stmt, @utc_current)
IF @diff > 0
BEGIN
	SET @msg = 'dbid=objid,rc=' + LTRIM(STR(@rowcount))
	INSERT [dbo].[collection_session_perf] (collection_session_id, database_id, collection_type, durationSEC, result_message) 
		VALUES (@id, @@PROCID, 1, @diff, @msg)
END


INSERT dbo.Process_Monitor_Adhoc
(	session_id
	, [status]
	, [host_name]
	, login_name
	, wait_type
	, wait_resource
	, wait_time
	, start_time
	, totallogical_reads
	, totalWrites
	, totalCPU
	, writes_in_tempdb
	, parallelquery
	, blocking_session_id
	, statement_text
	, blocking_text
	, sql_text
	, transaction_id
	, percent_complete
	, estimated_completion_time
	, scheduler_id
	, statement_text_xml
	, sql_text_xml
	, blocking_text_xml
	, inserted_dt
	, execution_plan
	, plan_handle
	, granted_query_memory)
SELECT
    x.session_id,
	status,
    x.host_name,
    x.login_name,
	x.wait_type,
	x.wait_resource,
	x.wait_time,
    x.start_time,
    x.totallogical_reads ,
    x.totalWrites,
    x.totalCPU,
    x.writes_in_tempdb,
	parallelquery,
	COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
    (
        SELECT          
			substring(text, (statement_start_offset/2)+1
                , ((case statement_end_offset
                      when -1 then datalength(text)
                      else statement_end_offset
                   end - statement_start_offset)/2) + 1)
        FROM sys.dm_exec_sql_text(x.sql_handle)
    ) AS statement_text,
    (
        SELECT
            p.text
        FROM
        (
            SELECT
                MIN(sql_handle) AS sql_handle
            FROM sys.dm_exec_requests r2
            WHERE
                r2.session_id = x.blocking_session_id
        ) AS r_blocking
        CROSS APPLY
        (
            SELECT
                text AS [text()]
            FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
        ) p (text)
    ) AS blocking_text,
    (
        SELECT
            text AS [text()]
        FROM sys.dm_exec_sql_text(x.sql_handle)
    ) AS sql_text,
	transaction_id,
	percent_complete,
	estimated_completion_time,
	scheduler_id,
	    (
        SELECT          
			substring(text, (statement_start_offset/2)+1
                , ((case statement_end_offset
                      when -1 then datalength(text)
                      else statement_end_offset
                   end - statement_start_offset)/2) + 1)
        FROM sys.dm_exec_sql_text(x.sql_handle)
        FOR XML PATH(''), TYPE
    ) AS statement_text,
        (
        SELECT
            text AS [text()]
        FROM sys.dm_exec_sql_text(x.sql_handle)
        FOR XML PATH(''), TYPE
    ) AS sql_text,
        (
        SELECT
            p.text
        FROM
        (
            SELECT
                MIN(sql_handle) AS sql_handle
            FROM sys.dm_exec_requests r2
            WHERE
                r2.session_id = x.blocking_session_id
        ) AS r_blocking
        CROSS APPLY
        (
            SELECT
                text AS [text()]
            FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
            FOR XML PATH(''), TYPE
        ) p (text)
    ) AS blocking_text,
    GETDATE(),
	CASE WHEN @includePlan = 0 THEN NULL
	ELSE 
		( SELECT query_plan 
			FROM sys.dm_exec_query_plan (plan_handle)) 
	END AS execution_plan,
    plan_handle,
	x.granted_query_memory
FROM
(
    SELECT
        r.session_id,
		r.status,
        s.host_name,
        s.login_name,
        r.start_time,
        r.sql_handle,
		wait_type,
		wait_resource,
		wait_time,
		statement_start_offset,
		statement_end_offset,
        r.blocking_session_id,
		transaction_id,
		percent_complete,
		estimated_completion_time,
		scheduler_id,
		--r.row_count,
		last_request_start_time,
		count(*) AS parallelquery,
        SUM(r.logical_reads ) AS totallogical_reads ,
        SUM(r.writes) AS totalWrites,
        SUM(r.cpu_time) AS totalCPU,
        SUM(tsu.user_objects_alloc_page_count + tsu.internal_objects_alloc_page_count) AS writes_in_tempdb,
        plan_handle,
        granted_query_memory
    FROM sys.dm_exec_requests r
    JOIN sys.dm_exec_sessions s ON s.session_id = r.session_id
    JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id and r.request_id = tsu.request_id
    WHERE r.status IN ('running', 'runnable', 'suspended','rollback')
	AND r.session_id > 50
    GROUP BY
        r.session_id,
		r.status,
        s.host_name,
        s.login_name,
        r.start_time,
        r.sql_handle,
		wait_type,
		wait_resource,
		wait_time,
		statement_start_offset,
		statement_end_offset,
        r.blocking_session_id,
		transaction_id,
		percent_complete,
		estimated_completion_time,
		scheduler_id,
		--, r.row_count
		last_request_start_time,
        plan_handle,
        granted_query_memory
) x
SET @rowcount = @@ROWCOUNT
SET @utc_current = GETUTCDATE()

SET @diff = DATEDIFF(SECOND, @utc_stmt, @utc_current)
IF @diff > 0
BEGIN
	SET @msg = 'dbid=objid,rc=' + LTRIM(STR(@rowcount))
	INSERT [dbo].[collection_session_perf] (collection_session_id, database_id, collection_type, durationSEC, result_message) 
		VALUES (@id, @@PROCID, 2, @diff, @msg)
END

UPDATE [dbo].[collection_session] SET durationS = DATEDIFF(SECOND, @utc_proc, @utc_current) WHERE collection_session_id = @id

END TRY

BEGIN CATCH
	BEGIN TRY
		SELECT @msg = 'Error occurred in FDDBA.dbo.Process_Monitor_Adhoc, will run second try to see if we can get the data. Error message is:' + SUBSTRING(ERROR_MESSAGE(),1,1900);
		RAISERROR(@msg,10,1) WITH NOWAIT;

		INSERT dbo.Process_Monitor_Adhoc
		(	session_id
			, [status]
			, [host_name]
			, login_name
			, wait_type
			, wait_resource
			, wait_time
			, start_time
			, totallogical_reads
			, totalWrites
			, totalCPU
			, writes_in_tempdb
			, parallelquery
			, blocking_session_id
			, statement_text
			, blocking_text
			, sql_text
			, transaction_id
			, percent_complete
			, estimated_completion_time
			, scheduler_id
			, statement_text_xml
			, sql_text_xml
			, blocking_text_xml
			, inserted_dt
			, execution_plan
			, plan_handle
			, granted_query_memory)
		SELECT
			x.session_id,
			status,
			x.host_name,
			x.login_name,
			x.wait_type,
			x.wait_resource,
			x.wait_time,
			x.start_time,
			x.totallogical_reads ,
			x.totalWrites,
			x.totalCPU,
			x.writes_in_tempdb,
			parallelquery,
			COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
			(
				SELECT          
					substring(text, (statement_start_offset/2)+1
						, ((case statement_end_offset
							  when -1 then datalength(text)
							  else statement_end_offset
						   end - statement_start_offset)/2) + 1)
				FROM sys.dm_exec_sql_text(x.sql_handle)
			) AS statement_text,
			(
				SELECT
					p.text
				FROM
				(
					SELECT
						MIN(sql_handle) AS sql_handle
					FROM sys.dm_exec_requests r2
					WHERE
						r2.session_id = x.blocking_session_id
				) AS r_blocking
				CROSS APPLY
				(
					SELECT
						text AS [text()]
					FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
				) p (text)
			) AS blocking_text,
			(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(x.sql_handle)
			) AS sql_text,
			transaction_id,
			percent_complete,
			estimated_completion_time,
			scheduler_id,
			NULL AS statement_text,
			NULL AS sql_text,
			NULL AS blocking_text,
			GETDATE(),
			CASE WHEN @includePlan = 0 THEN NULL
			ELSE 
				( SELECT query_plan 
					FROM sys.dm_exec_query_plan (plan_handle)) 
			END AS execution_plan,
			plan_handle,
			x.granted_query_memory
		FROM
		(
			SELECT
				r.session_id,
				r.status,
				s.host_name,
				s.login_name,
				r.start_time,
				r.sql_handle,
				wait_type,
				wait_resource,
				wait_time,
				statement_start_offset,
				statement_end_offset,
				r.blocking_session_id,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				--r.row_count,
				last_request_start_time,
				count(*) AS parallelquery,
				SUM(r.logical_reads ) AS totallogical_reads ,
				SUM(r.writes) AS totalWrites,
				SUM(r.cpu_time) AS totalCPU,
				SUM(tsu.user_objects_alloc_page_count + tsu.internal_objects_alloc_page_count) AS writes_in_tempdb,
				plan_handle,
				granted_query_memory
			FROM sys.dm_exec_requests r
			JOIN sys.dm_exec_sessions s ON s.session_id = r.session_id
			JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id and r.request_id = tsu.request_id
			WHERE r.status IN ('running', 'runnable', 'suspended','rollback')
			AND r.session_id > 50
			GROUP BY
				r.session_id,
				r.status,
				s.host_name,
				s.login_name,
				r.start_time,
				r.sql_handle,
				wait_type,
				wait_resource,
				wait_time,
				statement_start_offset,
				statement_end_offset,
				r.blocking_session_id,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				--, r.row_count
				last_request_start_time,
				plan_handle,
				granted_query_memory
		) x

		SET @diff = DATEDIFF(SECOND, @utc_stmt, @utc_current)
		IF @diff > 0
		BEGIN
			SET @msg = 'dbid=objid,rc=' + LTRIM(STR(@rowcount))
			INSERT [dbo].[collection_session_perf] (collection_session_id, database_id, collection_type, durationSEC, result_message) 
				VALUES (@id, @@PROCID, 3, @diff, @msg)
		END


		UPDATE [dbo].[collection_session] SET durationS = DATEDIFF(SECOND, @utc_proc, @utc_current) WHERE collection_session_id = @id
	END TRY
	BEGIN CATCH
		    SELECT @ErrorMessage = ERROR_MESSAGE()
		, @ErrorSeverity = ERROR_SEVERITY()
		, @ErrorState = ERROR_STATE()

		SELECT ERROR_NUMBER() AS ErrorNumber
		, ERROR_SEVERITY() AS ErrorSeverity
		, ERROR_STATE() AS ErrorState
		, ERROR_PROCEDURE() AS ErrorProcedure
		, ERROR_LINE() AS ErrorLine
		, ERROR_MESSAGE() AS ErrorMessage
    
		RAISERROR (@ErrorMessage,
			   @ErrorSeverity,
			   @ErrorState)

	END CATCH


END CATCH

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_parse_name]',10,1) WITH NOWAIT;
if object_id('dbo.usp_parse_name') is null exec('create procedure [dbo].[usp_parse_name] as select getdate() DT')
GO
  
alter procedure dbo.usp_parse_name
(
	@string nvarchar(max),
	@namelimit tinyint = 4,
	@name1 sysname = NULL OUTPUT,
	@name2 sysname = NULL OUTPUT,
	@name3 sysname = NULL OUTPUT,
	@name4 sysname = NULL OUTPUT
)
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	parse a string of names deliminted by periods, stripping brackets ([ and ])
*				
*	Inputs:		
*
*	@string - required string to parse
*	@namelimit - optional number of names to parse with a maximum
*
*	ASSIGN VARIABLES
*
*	Notes:	
*
*	Future Enhancements:
*
*	Current Known Bugs:
*	
*	Returns: @name parameters
*
*	@name1 - required output of first name parsed
*	@name2 - required output of second name parsed
*	@name3 - required output of third name parsed
*	@name4 - required output of fourth name parsed
*
*	Prerequisite: None
*				
*	History:	
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/22/2017			Mike Zawadzki			Created
*
*********************************************************************************************************************/

	DECLARE @len int 
	DECLARE @lastperiod int = 0
	DECLARE @nextperiod int = 1
	DECLARE @nameid tinyint = 1
	DECLARE @tempname sysname

	SET @len = LEN(@string)
	WHILE @nextperiod > 0 and @len > 0 and @nameid <= @namelimit
	BEGIN
		SET @nextperiod =  CHARINDEX(N'.', @string, @lastperiod + 1)

		IF @nextperiod > 0 
		BEGIN
			SET @tempname = SUBSTRING(@string, @lastperiod + 1, @nextperiod - @lastperiod - 1)
			--print 'XXX'+@tempname+'XXX'
		END
		ELSE
		BEGIN
			SET @tempname = SUBSTRING(@string, @lastperiod + 1, @len)
			--print 'XXX'+@tempname+'XXX'
		END
			
		IF @nameid = 1
		BEGIN
			SET @name1 = @tempname
		END
		
		IF @nameid = 2
		BEGIN
			SET @name2 = @tempname
		END
		
		IF @nameid = 3
		BEGIN
			SET @name3 = @tempname
		END
		
		IF @nameid = 4
		BEGIN
			SET @name4 = @tempname
		END
				
		SET @lastperiod = @nextperiod
		SET @nameid = @nameid + 1
		SET @len = @len -  1 --prevent infinite loop
	END

	SET @name1 = REPLACE(REPLACE(@name1,'[',''), ']', '')
	SET @name2 = REPLACE(REPLACE(@name2,'[',''), ']', '')
	SET @name3 = REPLACE(REPLACE(@name3,'[',''), ']', '')
	SET @name4 = REPLACE(REPLACE(@name4,'[',''), ']', '')
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_persist_dm_db_index_usage_stats]',10,1) WITH NOWAIT;
if object_id('dbo.usp_persist_dm_db_index_usage_stats') is null exec('create procedure [dbo].[usp_persist_dm_db_index_usage_stats] as select getdate() DT')
GO
/******************************************************************************************************  
Changes
	2019-08-23: added filter to queries to only get user database records

******************************************************************************************************/
alter procedure [dbo].[usp_persist_dm_db_index_usage_stats] 
WITH ENCRYPTION
AS  
exec dbo.usp_UpdateVersionStatics
DECLARE @last_service_start_date datetime 
DECLARE @last_data_persist_date datetime 

--Determine last service restart date based upon tempdb creation date 
SELECT @last_service_start_date =   
  SD.[create_date]  
  FROM sys.databases SD  
  WHERE SD.[name] = 'tempdb' 
   
--Return the value for the last refresh date of the persisting table 
SELECT @last_data_persist_date =  
  MAX(MDDIUS.[date_stamp])  
  FROM [FDDBA].[dbo].[IndexUsageStats] MDDIUS 

--Take care of updated records first 
IF @last_service_start_date < @last_data_persist_date 
  BEGIN 
     --Service restart date > last poll date 
     PRINT 'The latest persist date was ' +  
        CAST(@last_data_persist_date AS VARCHAR(50)) +  
        '; no restarts occurred since ' +  
        CAST(@last_service_start_date AS VARCHAR(50)) + 
        '  (' + CAST(DATEDIFF(d, @last_service_start_date, @last_data_persist_date) AS VARCHAR(10)) +  
        ' days ago.)' 

     UPDATE MDDIUS 
     SET  
        MDDIUS.[user_seeks] = MDDIUS.[user_seeks]+(SDDIUS.[user_seeks] - MDDIUS.[last_poll_user_seeks]), 
        MDDIUS.[user_scans] = MDDIUS.[user_scans]+(SDDIUS.[user_scans] - MDDIUS.[last_poll_user_scans]), 
        MDDIUS.[user_lookups] = MDDIUS.[user_lookups]+(SDDIUS.[user_lookups] - MDDIUS.[last_poll_user_lookups]), 
        MDDIUS.[user_updates] = MDDIUS.[user_updates]+(SDDIUS.[user_updates] - MDDIUS.[last_poll_user_updates]), 
        MDDIUS.[last_user_seek] = SDDIUS.[last_user_seek], 
        MDDIUS.[last_user_scan] = SDDIUS.[last_user_scan], 
        MDDIUS.[last_user_lookup] = SDDIUS.[last_user_lookup], 
        MDDIUS.[last_user_update] = SDDIUS.[last_user_update], 
        MDDIUS.[system_seeks] = MDDIUS.[system_seeks]+(SDDIUS.[system_seeks] - MDDIUS.[last_poll_system_seeks]), 
        MDDIUS.[system_scans] = MDDIUS.[system_scans]+(SDDIUS.[system_scans] - MDDIUS.[last_poll_system_scans]), 
        MDDIUS.[system_lookups] = MDDIUS.[system_lookups]+(SDDIUS.[system_lookups] - MDDIUS.[last_poll_system_lookups]), 
        MDDIUS.[system_updates] = MDDIUS.[system_updates]+(SDDIUS.[system_updates] - MDDIUS.[last_poll_system_updates]), 
        MDDIUS.[last_system_seek] = SDDIUS.[last_system_seek], 
        MDDIUS.[last_system_scan] = SDDIUS.[last_system_scan], 
        MDDIUS.[last_system_lookup] = SDDIUS.[last_system_lookup], 
        MDDIUS.[last_system_update] = SDDIUS.[last_system_update], 
        MDDIUS.[last_poll_user_seeks] = SDDIUS.[user_seeks], 
        MDDIUS.[last_poll_user_scans] = SDDIUS.[user_scans], 
        MDDIUS.[last_poll_user_lookups] = SDDIUS.[user_lookups], 
        MDDIUS.[last_poll_user_updates] = SDDIUS.[user_updates], 
        MDDIUS.[last_poll_system_seeks] = SDDIUS.[system_seeks], 
        MDDIUS.[last_poll_system_scans] = SDDIUS.[system_scans], 
        MDDIUS.[last_poll_system_lookups] = SDDIUS.[system_lookups], 
        MDDIUS.[last_poll_system_updates] = SDDIUS.[system_updates], 
        MDDIUS.date_stamp = GETDATE() 
     FROM [sys].[dm_db_index_usage_stats] SDDIUS INNER JOIN  
        [FDDBA].[dbo].[IndexUsageStats] MDDIUS 
           ON SDDIUS.[database_id] = MDDIUS.[database_id] 
              AND SDDIUS.[object_id] = MDDIUS.[object_id] 
              AND SDDIUS.[index_id] = MDDIUS.[index_id] 
	WHERE
		SDDIUS.database_id > 4
  END 
ELSE 
  BEGIN 
     --Service restart date < last poll date 
     PRINT 'Lastest service restart occurred on ' +  
        CAST(@last_service_start_date AS VARCHAR(50)) +  
        ' which is after the latest persist date of ' +  
        CAST(@last_data_persist_date AS VARCHAR(50)) 
      
     UPDATE MDDIUS 
     SET  
        MDDIUS.[user_seeks] = MDDIUS.[user_seeks]+ SDDIUS.[user_seeks], 
        MDDIUS.[user_scans] = MDDIUS.[user_scans]+ SDDIUS.[user_scans], 
        MDDIUS.[user_lookups] = MDDIUS.[user_lookups]+ SDDIUS.[user_lookups], 
        MDDIUS.[user_updates] = MDDIUS.[user_updates]+ SDDIUS.[user_updates], 
        MDDIUS.[last_user_seek] = SDDIUS.[last_user_seek], 
        MDDIUS.[last_user_scan] = SDDIUS.[last_user_scan], 
        MDDIUS.[last_user_lookup] = SDDIUS.[last_user_lookup], 
        MDDIUS.[last_user_update] = SDDIUS.[last_user_update], 
        MDDIUS.[system_seeks] = MDDIUS.[system_seeks]+ SDDIUS.[system_seeks], 
        MDDIUS.[system_scans] = MDDIUS.[system_scans]+ SDDIUS.[system_scans], 
        MDDIUS.[system_lookups] = MDDIUS.[system_lookups]+ SDDIUS.[system_lookups], 
        MDDIUS.[system_updates] = MDDIUS.[system_updates]+ SDDIUS.[system_updates], 
        MDDIUS.[last_system_seek] = SDDIUS.[last_system_seek], 
        MDDIUS.[last_system_scan] = SDDIUS.[last_system_scan], 
        MDDIUS.[last_system_lookup] = SDDIUS.[last_system_lookup], 
        MDDIUS.[last_system_update] = SDDIUS.[last_system_update], 
        MDDIUS.[last_poll_user_seeks] = SDDIUS.[user_seeks], 
        MDDIUS.[last_poll_user_scans] = SDDIUS.[user_scans], 
        MDDIUS.[last_poll_user_lookups] = SDDIUS.[user_lookups], 
        MDDIUS.[last_poll_user_updates] = SDDIUS.[user_updates], 
        MDDIUS.[last_poll_system_seeks] = SDDIUS.[system_seeks], 
        MDDIUS.[last_poll_system_scans] = SDDIUS.[system_scans], 
        MDDIUS.[last_poll_system_lookups] = SDDIUS.[system_lookups], 
        MDDIUS.[last_poll_system_updates] = SDDIUS.[system_updates], 
        MDDIUS.date_stamp = GETDATE() 
     FROM [sys].[dm_db_index_usage_stats] SDDIUS INNER JOIN  
        [FDDBA].[dbo].[IndexUsageStats] MDDIUS 
           ON SDDIUS.[database_id] = MDDIUS.[database_id] 
              AND SDDIUS.[object_id] = MDDIUS.[object_id] 
              AND SDDIUS.[index_id] = MDDIUS.[index_id] 
	WHERE SDDIUS.database_id > 4
  END    

--Take care of new records next 
     INSERT INTO [FDDBA].[dbo].[IndexUsageStats] 
        ( 
        [database_id], [object_id], [index_id],  
        [user_seeks], [user_scans], [user_lookups], 
        [user_updates], [last_user_seek], [last_user_scan], 
        [last_user_lookup], [last_user_update], [system_seeks], 
        [system_scans], [system_lookups], [system_updates], 
        [last_system_seek], [last_system_scan],  
        [last_system_lookup], [last_system_update], 
        [last_poll_user_seeks],    [last_poll_user_scans],  
        [last_poll_user_lookups], [last_poll_user_updates], 
        [last_poll_system_seeks], [last_poll_system_scans],  
        [last_poll_system_lookups], [last_poll_system_updates], 
        [date_stamp] 
        ) 
     SELECT SDDIUS.[database_id], SDDIUS.[object_id], SDDIUS.[index_id],  
        SDDIUS.[user_seeks], SDDIUS.[user_scans], SDDIUS.[user_lookups], 
        SDDIUS.[user_updates], SDDIUS.[last_user_seek], SDDIUS.[last_user_scan], 
        SDDIUS.[last_user_lookup], SDDIUS.[last_user_update], SDDIUS.[system_seeks], 
        SDDIUS.[system_scans], SDDIUS.[system_lookups], SDDIUS.[system_updates], 
        SDDIUS.[last_system_seek], SDDIUS.[last_system_scan],  
        SDDIUS.[last_system_lookup], SDDIUS.[last_system_update], 
        SDDIUS.[user_seeks], SDDIUS.[user_scans], SDDIUS.[user_lookups], 
        SDDIUS.[user_updates],SDDIUS.[system_seeks], 
        SDDIUS.[system_scans], SDDIUS.[system_lookups],  
        SDDIUS.[system_updates], GETDATE()   
     FROM [sys].[dm_db_index_usage_stats] SDDIUS LEFT JOIN  
        [FDDBA].[dbo].[IndexUsageStats] MDDIUS 
           ON SDDIUS.[database_id] = MDDIUS.[database_id] 
           AND SDDIUS.[object_id] = MDDIUS.[object_id] 
           AND SDDIUS.[index_id] = MDDIUS.[index_id] 
     WHERE MDDIUS.[database_id] IS NULL  
        AND MDDIUS.[object_id] IS NULL 
        AND MDDIUS.[index_id] IS NULL
		AND SDDIUS.database_id > 4



GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_PlanStatistic_Add_Track]',10,1) WITH NOWAIT;
if object_id('dbo.usp_PlanStatistic_Add_Track') is null exec('create procedure [dbo].[usp_PlanStatistic_Add_Track] as select getdate() DT')
GO
  
alter procedure [dbo].[usp_PlanStatistic_Add_Track]
(
	@dbname sysname,
	@schname sysname = NULL,
	@objname sysname = NULL,
	@query_hash binary(8) = NULL,
	@adhoc_string nvarchar(100) = NULL
)
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	propagate data into dbo.exec_plan_stats_to_track table and enable scheduled job to check for changes
*	Inputs:		
*
*	@dbname - required database name
*	@schname - required schema name for procedure, trigger or function and NULL for adhoc
*	@objname - required object name for procedure, trigger or function and NULL for adhoc
*	@query_hash - required query_hash value for adhoc and NULL for procedure, trigger or function
*	@adhoc_string - optional query text fragment for adhoc which should wildcard characters and NULL for procedure, trigger or function
*
*	ASSIGN VARIABLES
*
*	Notes:	
*
*	Returns:	None
*	Prerequisite: None
*				
*	History:	
*
*	3/20/2017 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	3/20/2017			Mike Zawadzki			Created
*	6/15/2018			Mike Zawadzki			Also enable job FD - Monitor Plan Results
*
*********************************************************************************************************************/

	DECLARE @dbid smallint
	DECLARE @schid int
	DECLARE @objid int
	DECLARE @cmd nvarchar(4000)
	DECLARE @plan_handle_filter varbinary(8)

	--check if DB exists
	SET @dbid = DB_ID(@dbname)
	IF @dbid IS NULL
	BEGIN
		RAISERROR('usp_PlanStatistic_Add_Track: invalid @dbname parameter',16,1)
		RETURN
	END

	--check if SCH exists
	IF @schname IS NOT NULL
	BEGIN
		--procedure, trigger or function
		SET @cmd = N'SELECT @p = schema_id from [' + @dbname + '].sys.schemas WHERE name = ''' + @schname + ''''
		EXEC sp_executesql @cmd, N'@p int output', @schid output
		IF @schid IS NULL
		BEGIN
			RAISERROR('usp_PlanStatistic_Add_Track: invalid @schname parameter',16,2)
			RETURN
		END

		--check if OBJ exists
		IF @objname IS NOT NULL
		BEGIN
			SET @cmd = N'SELECT @p = object_id from [' + @dbname + '].sys.objects WHERE name = ''' + @objname + ''' and schema_id = ' + LTRIM(STR(@schid))
			--print @cmd
			EXEC sp_executesql @cmd, N'@p int output', @objid output
			IF @objid IS NULL
			BEGIN
				RAISERROR('usp_PlanStatistic_Add_Track: invalid @objname parameter',16,3)
				RETURN
			END
		END
	END
			
	--following line for debugging
	--select @dbid, @schid, @objid

	--insert into table
	IF @objid IS NOT NULL
	BEGIN
		SET @plan_handle_filter = 0x0500 
			+ substring(convert(binary(2), @dbid),2,1) 
			+ substring(convert(binary(2), @dbid),1,1) 
			+ substring(convert(binary(4), @objid),4,1) 
			+ substring(convert(binary(4), @objid),3,1) 
			+ substring(convert(binary(4), @objid),2,1) 
			+ substring(convert(binary(4), @objid),1,1)

		IF NOT EXISTS (SELECT 1 FROM dbo.exec_plan_stats_to_track WHERE database_id = @dbid AND [schema_id] = @schid AND [object_id] = @objid AND query_hash IS NULL)
		BEGIN
			INSERT dbo.exec_plan_stats_to_track (database_id, [schema_id], [object_id], [database_name], [schema_name], [object_name], query_hash, adhoc_string, plan_handle_filter, [enabled], ins_date)
				VALUES (@dbid, @schid, @objid, @dbname, @schname, @objname, NULL, NULL, @plan_handle_filter, 1, GETDATE())
		END
	END
	ELSE
	BEGIN
		SET @plan_handle_filter = 0x0600 
			+ substring(convert(binary(2), @dbid),2,1) 
			+ substring(convert(binary(2), @dbid),1,1) 

		IF NOT EXISTS (SELECT 1 FROM dbo.exec_plan_stats_to_track WHERE database_id = @dbid AND [schema_id] IS NULL AND [object_id] IS NULL AND query_hash = @query_hash)
		BEGIN
			IF @adhoc_string IS NULL
			BEGIN
				SET @adhoc_string = '%'
			END

			INSERT dbo.exec_plan_stats_to_track (database_id, [schema_id], [object_id], [database_name], [schema_name], [object_name], query_hash, adhoc_string, plan_handle_filter, [enabled], ins_date)
				VALUES (@dbid, NULL, NULL, @dbname, NULL, NULL, @query_hash, @adhoc_string, @plan_handle_filter, 1, GETDATE())
		END
	END

	--update job to be enabled
	EXEC msdb.dbo.sp_update_job @job_name=N'FD - Monitor Plan Statistics', @enabled=1
	EXEC msdb.dbo.sp_update_job @job_name=N'FD - Monitor Plan Results', @enabled=1
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_PlanStatistic_Update_Track]',10,1) WITH NOWAIT;
if object_id('dbo.usp_PlanStatistic_Update_Track') is null exec('create procedure [dbo].[usp_PlanStatistic_Update_Track] as select getdate() DT')
GO
  
alter procedure [dbo].[usp_PlanStatistic_Update_Track]
(
	@dbname sysname,
	@schname sysname,
	@objname sysname
)
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	update dbo.exec_plan_stats_to_track table when stored procedures are dropped and re-created 
*	Inputs:		
*
*	@dbname - required database name
*	@schname - required schema name for procedure, trigger or function
*	@objname - required object name for procedure, trigger or function
*
*	ASSIGN VARIABLES
*
*	Notes:	
*
*	Returns:	None
*	Prerequisite: None
*				
*	History:	
*
*	3/20/2017 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	3/20/2017			Mike Zawadzki			Created
*	12/6/2017			Mike Zawadzki			Fixed bug noted in version notes for 1.1.0044
*
*********************************************************************************************************************/

	DECLARE @dbid smallint
	DECLARE @schid int
	DECLARE @objid int
	DECLARE @cmd nvarchar(4000)
	DECLARE @plan_handle_filter varbinary(8)

	--check if object tracked]
	IF EXISTS (SELECT 1 FROM dbo.exec_plan_stats_to_track WHERE [database_name] = @dbname and [schema_name] = @schname and [object_name] = @objname)
	BEGIN
		UPDATE dbo.exec_plan_stats_to_track
			SET [enabled] = 0
			WHERE [database_name] = @dbname and [schema_name] = @schname and [object_name] = @objname
	END
	ELSE
	BEGIN
		RAISERROR('usp_PlanStatistic_Update_Track: object not currently tracked',16,0)
		RETURN
	END

	--check if DB exists
	SET @dbid = DB_ID(@dbname)
	IF @dbid IS NULL
	BEGIN
		RAISERROR('usp_PlanStatistic_Update_Track: invalid @dbname parameter',16,1)
		RETURN
	END

	--check if SCH exists
	IF @schname IS NOT NULL
	BEGIN
		--procedure, trigger or function
		SET @cmd = N'SELECT @p = schema_id from [' + @dbname + '].sys.schemas WHERE name = ''' + @schname + ''''
		EXEC sp_executesql @cmd, N'@p int output', @schid output
		IF @schid IS NULL
		BEGIN
			RAISERROR('usp_PlanStatistic_Update_Track: invalid @schname parameter',16,2)
			RETURN
		END

		--check if OBJ exists
		IF @objname IS NOT NULL
		BEGIN
			SET @cmd = N'SELECT @p = object_id from [' + @dbname + '].sys.objects WHERE name = ''' + @objname + ''' and schema_id = ' + LTRIM(STR(@schid))
			--print @cmd
			EXEC sp_executesql @cmd, N'@p int output', @objid output
			IF @objid IS NULL
			BEGIN
				RAISERROR('usp_PlanStatistic_Update_Track: invalid @objname parameter',16,3)
				RETURN
			END
		END
	END
			
	--following line for debugging
	--select @dbid, @schid, @objid

	--insert into table
	SET @plan_handle_filter = 0x0500 
		+ substring(convert(binary(2), @dbid),2,1) 
		+ substring(convert(binary(2), @dbid),1,1) 
		+ substring(convert(binary(4), @objid),4,1) 
		+ substring(convert(binary(4), @objid),3,1) 
		+ substring(convert(binary(4), @objid),2,1) 
		+ substring(convert(binary(4), @objid),1,1)

	IF NOT EXISTS (SELECT 1 FROM dbo.exec_plan_stats_to_track WHERE database_id = @dbid AND [schema_id] = @schid AND [object_id] = @objid AND query_hash IS NULL)
	BEGIN
		INSERT dbo.exec_plan_stats_to_track (database_id, [schema_id], [object_id], [database_name], [schema_name], [object_name], query_hash, adhoc_string, plan_handle_filter, [enabled], ins_date)
			VALUES (@dbid, @schid, @objid,@dbname, @schname, @objname, NULL, NULL, @plan_handle_filter, 1, GETDATE())
	END
	ELSE
	BEGIN
		UPDATE dbo.exec_plan_stats_to_track
			SET [enabled] = 1
			WHERE database_id = @dbid AND [schema_id] = @schid AND [object_id] = @objid AND query_hash IS NULL
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_PlanStatistics_Capture]',10,1) WITH NOWAIT;
if object_id('dbo.usp_PlanStatistics_Capture') is null exec('create procedure [dbo].[usp_PlanStatistics_Capture] as select getdate() DT')
GO
  
alter procedure [dbo].[usp_PlanStatistics_Capture]
(
	@Debug tinyint = 0
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	collect query statistics on tracked plans. This is designed to be run from a scheduled job. 
*	Inputs:		None
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. Change logic for determining duplicate query stats from cursor to set based logic
*	2. Consider permanent temp tables in permanent database (would work if only one copy running at a time from that database)
*	3. expose query number of parameters
*	4. Change usp_PlanStatistics_Capture 5.C.i to use SET logic instead of cursor
*	5. For cancelled executions (which are not added to sys.dm_exec_query_stats) see sproc usp_PlanResults_Capture which should also run
*
*	Returns:	None
*	Prerequisite: usp_PlanStatistic_Add_Track called with valid parameters to identify a plan to track
*				
*	History:	
*
*	3/20/2017 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	3/20/2017			Mike Zawadzki			Created
*	12/6/2017			Mike Zawadzki			Changed debug logic as noted in version notes of 1.1.0044
*	6/15/2018			Mike Zawadzki			Fixed bug with total_rows and last_rows columns with SQL Server 2008
*
*********************************************************************************************************************/
	exec dbo.usp_UpdateVersionStatics
	DECLARE @runtime datetime
	DECLARE @statement_start_offset int
	DECLARE @plan_handle binary(64)
	DECLARE @last_execution_time datetime
	DECLARE @dbname sysname
	DECLARE @schname sysname
	DECLARE @objname sysname
	DECLARE @plan_handle_filter binary(8)
	DECLARE @lastrowcount int
	DECLARE @query_plan xml
	DECLARE @query_plan2 nvarchar(max)
	DECLARE @param_list nvarchar(max)
	DECLARE @pos1 int
	DECLARE @pos2 int
	DECLARE @plan_gen_num bigint
	DECLARE @hexstring varchar(18)
	DECLARE @search_string nvarchar(100)
	DECLARE @query_hash binary(8)
	DECLARE @query_plan_hash binary(8)
	DECLARE @id int
	DECLARE @rowcount int
	DECLARE @dt datetime
	DECLARE @ms int
	DECLARE @cursorcount int
	DECLARE @cursorcount2 int

	SET @runtime = GETDATE()

	CREATE TABLE #changedobjects
	(
		dbname sysname NOT NULL,
		schname sysname NOT NULL,
		objname sysname NOT NULL
	)

	CREATE TABLE #trackedplangens
	(
		plan_handle varbinary(64) NOT NULL,
		plan_generation_num bigint NOT NULL,
	)
			
	CREATE TABLE #exec_plan_stats_tracked
	(
		statement_start_offset int NOT NULL,
		plan_handle varbinary(64) NOT NULL,
		query_hash binary(8) NOT NULL,
		query_plan_hash binary(8) NOT NULL,
		plan_generation_num bigint NOT NULL,
		creation_time datetime NOT NULL,
		last_execution_time datetime NOT NULL,
		execution_count bigint NULL,
		total_worker_time bigint NULL,
		last_worker_time bigint NULL,
		min_worker_time bigint NULL,
		max_worker_time bigint NULL,
		total_elapsed_time bigint NULL,
		last_elapsed_time bigint NULL,
		min_elapsed_time bigint NULL,
		max_elapsed_time bigint NULL,
		total_rows bigint NULL,
		last_rows bigint NULL,
		skip_row tinyint NOT NULL
	)

	CREATE TABLE #plans_to_capture
	(
		statement_start_offset int NOT NULL,
		plan_handle varbinary(64) NOT NULL,
		query_hash binary(8) NOT NULL,
		query_plan_hash binary(8) NOT NULL,
	)

	--1.A. check for object_id value change on non-adhoc query stats monitored
	SET @dt = GETDATE()
	INSERT #changedobjects
		SELECT [database_name], [schema_name], [object_name] 
			FROM dbo.exec_plan_stats_to_track w
			WHERE [object_id] IS NOT NULL 
				AND [enabled] = 1 
				AND [object_id] != object_id('[' + [database_name] + '].['+ [schema_name] + '].[' + [object_name] + ']','P')
	SET @rowcount = @@ROWCOUNT
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '1.A:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END
	
	--1.B.
	IF @rowcount > 0
	BEGIN
		SET @dt = GETDATE()
		SET @cursorcount = 0
		DECLARE changed_stats_cur CURSOR FOR
			SELECT * FROM  #changedobjects
		OPEN changed_stats_cur
		FETCH NEXT FROM changed_stats_cur INTO @dbname, @schname, @objname
		
		WHILE @@FETCH_STATUS != -1
		BEGIN
			EXEC dbo.usp_PlanStatistic_Update_Track @dbname, @schname, @objname
			SET @cursorcount = @cursorcount + 1
			FETCH NEXT FROM changed_stats_cur INTO @dbname, @schname, @objname
		END
		DEALLOCATE changed_stats_cur

		IF @Debug > 0
		BEGIN
			SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
			PRINT '1.B:cc=' + LTRIM(STR(@cursorcount)) + ', ms=' + LTRIM(STR(@ms))
		END
	END

	--2.A. get highest current plan_generation_num value for tracked plans
	SET @dt = GETDATE()
	INSERT #trackedplangens
		SELECT plan_handle, MAX(plan_generation_num)
			FROM dbo.exec_plan_params_tracked
			GROUP BY plan_handle
	SET @rowcount = @@ROWCOUNT
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '2.A:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END

	--3.A. --capture non-adhoc query_stats
	SET @dt = GETDATE()
	IF @@MICROSOFTVERSION < 171050560 --10.50.1600
	BEGIN
		INSERT #exec_plan_stats_tracked
			EXEC('SELECT qs.statement_start_offset, qs.plan_handle, qs.query_hash, qs.query_plan_hash, qs.plan_generation_num, qs.creation_time, qs.last_execution_time, qs.execution_count, 
					qs.total_worker_time, qs.last_worker_time, qs.min_worker_time, qs.max_worker_time, 
					qs.total_elapsed_time, qs.last_elapsed_time, qs.min_elapsed_time, qs.max_elapsed_time, 
					NULL, NULL, 0
				FROM sys.dm_exec_query_stats qs
					INNER JOIN [dbo].[exec_plan_stats_to_track] pst
						ON SUBSTRING(qs.plan_handle,1,8) = pst.plan_handle_filter
							AND pst.[object_id] IS NOT NULL
							AND pst.[enabled] = 1')
		SET @rowcount = @@ROWCOUNT
	END
	ELSE
	BEGIN
		INSERT #exec_plan_stats_tracked
			EXEC('SELECT qs.statement_start_offset, qs.plan_handle, qs.query_hash, qs.query_plan_hash, qs.plan_generation_num, qs.creation_time, qs.last_execution_time, qs.execution_count, 
					qs.total_worker_time, qs.last_worker_time, qs.min_worker_time, qs.max_worker_time, 
					qs.total_elapsed_time, qs.last_elapsed_time, qs.min_elapsed_time, qs.max_elapsed_time, 
					qs.total_rows, qs.last_rows, 0
				FROM sys.dm_exec_query_stats qs
					INNER JOIN [dbo].[exec_plan_stats_to_track] pst
						ON SUBSTRING(qs.plan_handle,1,8) = pst.plan_handle_filter
							AND pst.[object_id] IS NOT NULL
							AND pst.[enabled] = 1')
		SET @rowcount = @@ROWCOUNT
	END


	
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '3.A:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END

	--3.B. eliminate query_stats that have not changed
	SET @dt = GETDATE()
	SET @cursorcount = 0
	SET @rowcount = 0
	DECLARE plan_stats_cur CURSOR FOR
		SELECT statement_start_offset, plan_handle, last_execution_time FROM #exec_plan_stats_tracked
	OPEN plan_stats_cur
	FETCH NEXT FROM plan_stats_cur INTO @statement_start_offset, @plan_handle, @last_execution_time
	WHILE @@FETCH_STATUS != -1
	BEGIN
		IF EXISTS (SELECT 1 FROM dbo.exec_plan_stats_tracked WHERE statement_start_offset = @statement_start_offset AND plan_handle = @plan_handle AND last_execution_time = @last_execution_time)
		BEGIN
			SET @cursorcount = @cursorcount + 1
			UPDATE #exec_plan_stats_tracked 
				SET skip_row = 1
				WHERE statement_start_offset = @statement_start_offset AND plan_handle = @plan_handle AND last_execution_time = @last_execution_time
			SET @rowcount = @@ROWCOUNT + @rowcount
		END
		FETCH NEXT FROM plan_stats_cur INTO @statement_start_offset, @plan_handle, @last_execution_time
	END
	DEALLOCATE plan_stats_cur

	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '3.B:rc=' + LTRIM(STR(@rowcount)) + ', cc=' + LTRIM(STR(@cursorcount)) + ', ms=' + LTRIM(STR(@ms))
	END

	--3.C. INSERT updated query stats
	SET @dt = GETDATE()
	INSERT dbo.exec_plan_stats_tracked
		SELECT @runtime, statement_start_offset, plan_handle, query_hash, query_plan_hash, plan_generation_num, creation_time, last_execution_time, execution_count, 
				total_worker_time, last_worker_time, min_worker_time, max_worker_time, 
				total_elapsed_time, last_elapsed_time, min_elapsed_time, max_elapsed_time, total_rows, last_rows
			FROM #exec_plan_stats_tracked
			WHERE skip_row = 0
	SET @rowcount = @@ROWCOUNT
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '3.C:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END

/*
1. can't just check if any rows in #trackedplangens as we could add plans to track later
2. can't just use #exec_plan_stats_tracked as is as multiple statements in same plan might have different plan_generation_num values
*/
	--2.B.
	SET @dt = GETDATE()
	UPDATE #exec_plan_stats_tracked SET skip_row = 0
	SET @rowcount = @@ROWCOUNT
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '2.B:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END

	--2.C.
	SET @dt = GETDATE()
	UPDATE tps 
		SET skip_row = 1
		FROM #exec_plan_stats_tracked tps
		WHERE plan_generation_num IN 
		(
			SELECT MAX(plan_generation_num) 
				FROM #exec_plan_stats_tracked tps2
				WHERE tps.plan_handle = tps2.plan_handle
		)
	SET @rowcount = @@ROWCOUNT
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '2.C:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END

	--2.D. get latest for existing plans known
	SET @dt = GETDATE()
	INSERT dbo.exec_plan_params_tracked (runtime, plan_handle, plan_generation_num)
		SELECT @runtime, tps.plan_handle, tps.plan_generation_num
			FROM #exec_plan_stats_tracked tps
				INNER JOIN #trackedplangens tpg
					ON tps.plan_handle = tpg.plan_handle
					AND tps.plan_generation_num > tpg.plan_generation_num
					AND tps.skip_row = 1
	SET @rowcount = @@ROWCOUNT
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '2.D:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END
	SET @lastrowcount = @rowcount

	--2.E. get latest for new/changed plans
	SET @dt = GETDATE()
	INSERT dbo.exec_plan_params_tracked (runtime, plan_handle, plan_generation_num)
		SELECT DISTINCT @runtime, tps.plan_handle, tps.plan_generation_num
			FROM #exec_plan_stats_tracked tps
			WHERE plan_handle NOT IN 
			(
				SELECT DISTINCT plan_handle FROM #trackedplangens
			)
			AND tps.skip_row = 1
	SET @rowcount = @@ROWCOUNT
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '2.E:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END
	SET @lastrowcount = @rowcount + @lastrowcount

	--2.F.
	IF @lastrowcount > 0
	BEGIN
		SET @dt = GETDATE()
		SET @cursorcount = 0
		SET @rowcount = 0
		--get query_plan
		DECLARE param_cursor CURSOR FOR
			SELECT plan_handle, plan_generation_num
				FROM dbo.exec_plan_params_tracked
				WHERE runtime = @runtime
		OPEN param_cursor
		FETCH NEXT FROM param_cursor INTO @plan_handle, @plan_gen_num
		WHILE @@FETCH_STATUS != -1
		BEGIN
			SELECT @query_plan = query_plan FROM sys.dm_exec_query_plan(@plan_handle)
			SET @query_plan2 = CONVERT(nvarchar(max), @query_plan)
			SET @pos1 = CHARINDEX(N'<ParameterList>', @query_plan2)
			WHILE @pos1 > 0
			BEGIN
				SET @pos2 = CHARINDEX(N'</ParameterList>',@query_plan2, @pos1)

				IF @pos2 > 0
				BEGIN
					SET @param_list = ISNULL(@param_list,'') + SUBSTRING(@query_plan2, @pos1 + 15, @pos2 - @pos1 - 15)
					SET @pos1 = CHARINDEX(N'<ParameterList>', @query_plan2, @pos2 + 16 )
				END
				ELSE
				BEGIN
					SET @pos1 = 0
				END
			END

			IF @pos2 > 0
			BEGIN
				--<ColumnReference Column="@x" ParameterCompiledValue="(1)"/><ColumnReference Column="@x" ParameterCompiledValue="(2)"/>
				SET @param_list = REPLACE(REPLACE(REPLACE(@param_list,N'"/><ColumnReference Column="',N';'), N'" ParameterCompiledValue="', N'='), N'<ColumnReference Column="', N'')
				SET @param_list = SUBSTRING(@param_list, 1, LEN(@param_list) - 3) --remove "/> from end of string
				UPDATE dbo.exec_plan_params_tracked
					SET query_parameters = @param_list
					WHERE plan_handle = @plan_handle
						AND plan_generation_num = @plan_gen_num
						and runtime = @runtime
				SET @rowcount = @@ROWCOUNT + @rowcount
				SET @cursorcount = @cursorcount + 1
			END

			FETCH NEXT FROM param_cursor INTO @plan_handle, @plan_gen_num
		END
		DEALLOCATE param_cursor

		IF @Debug > 0
		BEGIN
			SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
			PRINT '2.F:rc=' + LTRIM(STR(@rowcount)) + ', cc=' + LTRIM(STR(@cursorcount)) + ', ms=' + LTRIM(STR(@ms))
		END
	END

	TRUNCATE TABLE #exec_plan_stats_tracked

	--4.A. capture adhoc query_stats
	SET @dt = GETDATE()
	IF @@MICROSOFTVERSION < 171050560 --10.50.1600
	BEGIN
		INSERT #exec_plan_stats_tracked
			EXEC('SELECT qstats.statement_start_offset, qstats.plan_handle, qstats.query_hash, qstats.query_plan_hash, qstats.plan_generation_num, qstats.creation_time, qstats.last_execution_time, qstats.execution_count, 
					qstats.total_worker_time, qstats.last_worker_time, qstats.min_worker_time, qstats.max_worker_time, 
					qstats.total_elapsed_time, qstats.last_elapsed_time, qstats.min_elapsed_time, qstats.max_elapsed_time, 
					qstats.total_rows, qstats.last_rows, 0
				FROM 
				(
					SELECT qs.statement_start_offset, qs.plan_handle, qs.query_hash, qs.query_plan_hash, qs.plan_generation_num, qs.creation_time, qs.last_execution_time, qs.execution_count, 
							qs.total_worker_time, qs.last_worker_time, qs.min_worker_time, qs.max_worker_time, 
							qs.total_elapsed_time, qs.last_elapsed_time, qs.min_elapsed_time, qs.max_elapsed_time,
							NULL AS [total_rows], NULL AS [last_rows], pst.adhoc_string
						FROM sys.dm_exec_query_stats qs
							INNER JOIN [dbo].[exec_plan_stats_to_track] pst
								ON SUBSTRING(qs.plan_handle,1,4) = pst.plan_handle_filter
									AND pst.[object_id] IS NULL
									AND qs.query_hash = pst.query_hash
									AND pst.[enabled] = 1
				) qstats
				OUTER APPLY sys.dm_exec_sql_text (qstats.plan_handle) AS sqltext
				WHERE sqltext.[text] LIKE qstats.adhoc_string')
		SET @rowcount = @@ROWCOUNT
	END
	ELSE
	BEGIN
		INSERT #exec_plan_stats_tracked
			EXEC('SELECT qstats.statement_start_offset, qstats.plan_handle, qstats.query_hash, qstats.query_plan_hash, qstats.plan_generation_num, qstats.creation_time, qstats.last_execution_time, qstats.execution_count, 
					qstats.total_worker_time, qstats.last_worker_time, qstats.min_worker_time, qstats.max_worker_time, 
					qstats.total_elapsed_time, qstats.last_elapsed_time, qstats.min_elapsed_time, qstats.max_elapsed_time, 
					qstats.total_rows, qstats.last_rows, 0
				FROM 
				(
					SELECT qs.statement_start_offset, qs.plan_handle, qs.query_hash, qs.query_plan_hash, qs.plan_generation_num, qs.creation_time, qs.last_execution_time, qs.execution_count, 
							qs.total_worker_time, qs.last_worker_time, qs.min_worker_time, qs.max_worker_time, 
							qs.total_elapsed_time, qs.last_elapsed_time, qs.min_elapsed_time, qs.max_elapsed_time,
							qs.total_rows, qs.last_rows, pst.adhoc_string
						FROM sys.dm_exec_query_stats qs
							INNER JOIN [dbo].[exec_plan_stats_to_track] pst
								ON SUBSTRING(qs.plan_handle,1,4) = pst.plan_handle_filter
									AND pst.[object_id] IS NULL
									AND qs.query_hash = pst.query_hash
									AND pst.[enabled] = 1
				) qstats
				OUTER APPLY sys.dm_exec_sql_text (qstats.plan_handle) AS sqltext
				WHERE sqltext.[text] LIKE qstats.adhoc_string')
		SET @rowcount = @@ROWCOUNT
	END

	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '4.A:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END

	--4.B. eliminate query_stats that have not changed
	SET @dt = GETDATE()
	SET @cursorcount = 0
	SET @rowcount = 0
	DECLARE plan_stats_cur2 CURSOR FOR
		SELECT statement_start_offset, plan_handle, last_execution_time FROM #exec_plan_stats_tracked
	OPEN plan_stats_cur2
	FETCH NEXT FROM plan_stats_cur2 INTO @statement_start_offset, @plan_handle, @last_execution_time
	WHILE @@FETCH_STATUS != -1
	BEGIN
		IF EXISTS (SELECT 1 FROM dbo.exec_plan_stats_tracked WHERE statement_start_offset = @statement_start_offset AND plan_handle = @plan_handle AND last_execution_time = @last_execution_time)
		BEGIN
			UPDATE #exec_plan_stats_tracked 
				SET skip_row = 1
				WHERE statement_start_offset = @statement_start_offset AND plan_handle = @plan_handle AND last_execution_time = @last_execution_time
			SET @rowcount = @@ROWCOUNT + @rowcount
			SET @cursorcount = @cursorcount + 1
		END
		FETCH NEXT FROM plan_stats_cur2 INTO @statement_start_offset, @plan_handle, @last_execution_time
	END
	DEALLOCATE plan_stats_cur2
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '4.B:rc=' + LTRIM(STR(@rowcount)) + ', cc=' + LTRIM(STR(@cursorcount)) + ', ms=' + LTRIM(STR(@ms))
	END

	--4.C. INSERT updated query stats
	SET @dt = GETDATE()
	INSERT dbo.exec_plan_stats_tracked
		SELECT @runtime, statement_start_offset, plan_handle, query_hash, query_plan_hash, plan_generation_num, creation_time, last_execution_time, execution_count, 
				total_worker_time, last_worker_time, min_worker_time, max_worker_time, 
				total_elapsed_time, last_elapsed_time, min_elapsed_time, max_elapsed_time, total_rows, last_rows
			FROM #exec_plan_stats_tracked
			WHERE skip_row = 0
	SET @rowcount = @@ROWCOUNT
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '4.C:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END

	--5.A. capture new execution plans
	SET @plan_handle_filter = 0x0500 
		+ substring(convert(binary(2), DB_ID()),2,1) 
		+ substring(convert(binary(2), DB_ID()),1,1) 
		+ substring(convert(binary(4), @@PROCID),4,1) 
		+ substring(convert(binary(4), @@PROCID),3,1) 
		+ substring(convert(binary(4), @@PROCID),2,1) 
		+ substring(convert(binary(4), @@PROCID),1,1)

	--5.B.
	SET @dt = GETDATE()
	INSERT #plans_to_capture
		SELECT DISTINCT statement_start_offset, plan_handle, query_hash, query_plan_hash
			FROM dbo.exec_plan_stats_tracked tps
			WHERE runtime = @runtime
				AND SUBSTRING(plan_handle,1,8) != @plan_handle_filter --exclude THIS procedure from plan_capture
				AND NOT EXISTS
				(
					SELECT 1 
						FROM dbo.exec_plan_hashes_tracked h
							INNER JOIN dbo.exec_plan_tracked tp
								ON h.exec_plan_tracked_ID = tp.exec_plan_tracked_ID
						WHERE h.statement_start_offset = tps.statement_start_offset
							AND h.query_plan_hash = tps.query_plan_hash
							AND tp.plan_handle = tps.plan_handle
				)
	SET @rowcount = @@ROWCOUNT
	IF @Debug > 0
	BEGIN
		SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
		PRINT '5.B:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
	END

	--5.C.
	IF @rowcount > 0
	BEGIN
		--FUTURE Enhancement: change to SET logic with CROSS APPLY?

		--5.C.i. cursor over distinct plan_handles
		SET @dt = GETDATE()
		SET @rowcount = 0
		SET @cursorcount = 0
		SET @cursorcount2 = 0
		DECLARE plan_handle_cur CURSOR FOR
			SELECT DISTINCT plan_handle from #plans_to_capture
		OPEN plan_handle_cur
		FETCH NEXT FROM plan_handle_cur INTO @plan_handle
		WHILE @@FETCH_STATUS != -1
		BEGIN
			SELECT @query_plan = query_plan FROM sys.dm_exec_query_plan(@plan_handle)

			IF @query_plan IS NOT NULL
			BEGIN
				SET @query_plan2 = CONVERT(nvarchar(max), @query_plan)

				SET @id = NULL

				--5.C.ii cursor over #plans_to_capture
				DECLARE hash_cur CURSOR FOR
					SELECT statement_start_offset, query_hash, query_plan_hash
						FROM #plans_to_capture
						WHERE plan_handle = @plan_handle
				OPEN hash_cur
				FETCH NEXT FROM hash_cur INTO @statement_start_offset, @query_hash, @query_plan_hash
				WHILE @@FETCH_STATUS != -1
				BEGIN
					EXEC [dbo].[sp_hexadecimaltruncleadingzeros] @query_hash, @hexstring output
					SET @search_string = N'QueryHash="' + @hexstring + N'" QueryPlanHash="'

					EXEC [dbo].[sp_hexadecimaltruncleadingzeros] @query_plan_hash, @hexstring output

					SET @search_string = @search_string + @hexstring + N'"'

					IF @search_string IS NOT NULL
					BEGIN
						--5.C.iii. Check to see if statement's qh and qph are in current plan
						IF CHARINDEX(@search_string, @query_plan2) > 0
						BEGIN
							IF @id IS NULL
							BEGIN
								INSERT dbo.exec_plan_tracked (runtime, plan_handle, len_query_plan, query_plan) VALUES (@runtime, @plan_handle, ISNULL(DATALENGTH(@query_plan),0), @query_plan)
								SET @id = @@IDENTITY
							END
							
							INSERT dbo.exec_plan_hashes_tracked VALUES (@id, @statement_start_offset, @query_hash, @query_plan_hash)
							SET @rowcount = @rowcount + 1
						END 
					END
					SET @cursorcount2 = @cursorcount2 + 1
					FETCH NEXT FROM hash_cur INTO @statement_start_offset, @query_hash, @query_plan_hash
				END
				DEALLOCATE hash_cur
			END
			SET @cursorcount = @cursorcount + 1
			FETCH NEXT FROM plan_handle_cur INTO @plan_handle
		END
		DEALLOCATE plan_handle_cur
		IF @Debug > 0
		BEGIN
			SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
			PRINT '5.C.i:cc=' + LTRIM(STR(@cursorcount)) + ', ms=' + LTRIM(STR(@ms))
			PRINT '5.C.ii:cc=' + LTRIM(STR(@cursorcount2))
			PRINT '5.C.iii:cc=' + LTRIM(STR(@rowcount))
		END
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_snapshot_dm_db_index_usage_stats]',10,1) WITH NOWAIT;
if object_id('dbo.usp_snapshot_dm_db_index_usage_stats') is null exec('create procedure [dbo].[usp_snapshot_dm_db_index_usage_stats] as select getdate() DT')
GO
  
alter procedure dbo.usp_snapshot_dm_db_index_usage_stats
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Run usp_persist_dm_db_index_usage_stats to get latest index usage data then save old data and truncate 
*				table to allow for comparison of before and after index changes are made.
*
*	Inputs:	None
*
*	ASSIGN VARIABLES
*
*	Notes:	
*	1. This should be run BEFORE making any index changes so that you can compare old to new performance of indexes
*		in the process of index analysis. This is important as index_id values are not unique over time and can be 
*		re-used and possibly causing flawed analysis.
*	2. The naming convention of the table containg "old data" will be IndexUsageStats_YYYYMMDDHHMMSS
*
*	Future Enhancements:
*	1. Change implementation to rename existing table, drop indexes and constraints and create new table for new data 
*		due to performance reasons.

*	Current Known Bugs:
*	
*	Returns:	New IndexUsageStats table is created and old is renamed
*	Prerequisite: usp_persist_dm_db_index_usage_stats
*				
*	History:	
*
*	6/8/2017 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/8/2017			Mike Zawadzki			Created
*	
*********************************************************************************************************************/


	DECLARE @name sysname
	DECLARE @cmd nvarchar(4000)
	EXEC [dbo].[usp_persist_dm_db_index_usage_stats]
	SET @name = 'IndexUsageStats_' + REPLACE(REPLACE(REPLACE(CONVERT(varchar(19),GETDATE(),121),' ',''),':',''),'-','')

	SET @cmd = 'SELECT * INTO dbo.[' + @name + '] FROM dbo.IndexUsageStats;
TRUNCATE TABLE dbo.IndexUsageStats;'

	EXEC (@cmd)
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_Statistic_Add_Track]',10,1) WITH NOWAIT;
if object_id('dbo.usp_Statistic_Add_Track') is null exec('create procedure [dbo].[usp_Statistic_Add_Track] as select getdate() DT')
GO
  
alter procedure [dbo].[usp_Statistic_Add_Track]
(
	@dbname sysname,
	@schname sysname,
	@objname sysname,
	@statname sysname = NULL
)
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Enable tracking of statistics changes
*	Inputs:		
*
*	@dbname - required database name 
*	@schname - required schema name
*	@objname - required object name
*	@statname - optional statistic name. Note if statistic is ommitted then all statistics of that object will be inserted in table
*
*
*	ASSIGN VARIABLES
*
*	Notes:	propagate data into dbo.statistics_to_track table and enable scheduled job to capture data.
*
*	Returns:	Errors when object requested to tracked does not exist
*	Prerequisite: None
*				
*	History:	
*
*	3/20/2017 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	3/20/2017			Mike Zawadzki			Created
*	
*
*********************************************************************************************************************/

	DECLARE @dbid smallint
	DECLARE @schid int
	DECLARE @objid int
	DECLARE @statid int
	DECLARE @cmd nvarchar(4000)

	--strip extra delimiter characters
	SET @dbname = REPLACE(REPLACE(@dbname, N'[', N''), N']', N'')
	SET @schname = REPLACE(REPLACE(@schname, N'[', N''), N']', N'')
	SET @objname = REPLACE(REPLACE(@objname, N'[', N''), N']', N'')
	SET @statname = REPLACE(REPLACE(@statname, N'[', N''), N']', N'')

	--check if DB exists
	SET @dbid = DB_ID(@dbname)
	IF @dbid IS NULL
	BEGIN
		RAISERROR('usp_Statistic_Add_Track: invalid @dbname parameter',16,1)
		RETURN
	END

	--check if SCH exists
	SET @cmd = N'SELECT @p = schema_id from [' + @dbname + '].sys.schemas WHERE name = ''' + @schname + ''''
	EXEC sp_executesql @cmd, N'@p int output', @schid output
	IF @schid IS NULL
	BEGIN
		RAISERROR('usp_Statistic_Add_Track: invalid @schname parameter',16,2)
		RETURN
	END

	--check if OBJ exists
	SET @cmd = N'SELECT @p = object_id from [' + @dbname + '].sys.objects WHERE name = ''' + @objname + ''' and schema_id = ' + LTRIM(STR(@schid))
	--print @cmd
	EXEC sp_executesql @cmd, N'@p int output', @objid output
	IF @objid IS NULL
	BEGIN
		RAISERROR('usp_Statistic_Add_Track: invalid @objname parameter',16,3)
		RETURN
	END
	
	--check if STAT exists
	IF @statname = ''
	BEGIN
		SET @statname = NULL
	END

	IF @statname IS NOT NULL
	BEGIN
		SET @cmd = N'SELECT @p = stats_id from [' + @dbname + '].sys.stats WHERE name = ''' + @statname + ''' and object_id = ' + LTRIM(STR(@objid))
		--print @cmd
		EXEC sp_executesql @cmd, N'@p int output', @statid output

		IF @statid IS NULL
		BEGIN
			RAISERROR('usp_Statistic_Add_Track: invalid @statname parameter',16,4)
			RETURN
		END
	END

	--following line for debugging
	--select @dbid, @schid, @objid, @statid

	--insert into table
	IF @statid IS NULL
	BEGIN
		IF NOT EXISTS (SELECT 1 FROM dbo.statistics_to_track WHERE database_id = @dbid AND [object_id] = @objid)
		BEGIN
			INSERT dbo.statistics_to_track VALUES (@dbid, @schid, @objid, @statid, @dbname, @schname, @objname, @statname, 1, GETDATE())
		END
	END
	ELSE
	BEGIN
		IF NOT EXISTS (SELECT 1 FROM dbo.statistics_to_track WHERE database_id = @dbid AND [object_id] = @objid AND [stats_id] = @statid)
		BEGIN
			INSERT dbo.statistics_to_track VALUES (@dbid, @schid, @objid, NULL, @dbname, @schname, @objname, NULL, 1, GETDATE())
		END
	END

	--update job to be enabled
	EXEC msdb.dbo.sp_update_job @job_name=N'FD - Monitor Statistics', @enabled=1
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_Statistic_Get]',10,1) WITH NOWAIT;
if object_id('dbo.usp_Statistic_Get') is null exec('create procedure [dbo].[usp_Statistic_Get] as select getdate() DT')
GO
  
alter procedure [dbo].[usp_Statistic_Get]
(
	@name nvarchar(1000),
	@stat sysname
)
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Run DBCC SHOW_STATISICS so that its output can be stored in a table
*	Inputs:		
*
*	@name - required 3 part object name
*	@stat - required statistic name*
*
*	ASSIGN VARIABLES
*
*	Notes:	this is not designed to be run manually.
*
*	Returns:	DBCC SHOW_STATISTICS result set
*	Prerequisite: None
*				
*	History:	
*
*	3/20/2017 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	3/20/2017			Mike Zawadzki			Created
*	
*
*********************************************************************************************************************/

	DBCC SHOW_STATISTICS (@name, @stat) WITH STATS_STREAM
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_Statistics_Capture]',10,1) WITH NOWAIT;
if object_id('dbo.usp_Statistics_Capture') is null exec('create procedure [dbo].[usp_Statistics_Capture] as select getdate() DT')
GO
  
alter procedure [dbo].[usp_Statistics_Capture] 
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	Captures statistics changes
*	Inputs:		
*
*	ASSIGN VARIABLES
*
*	Notes:	check for new or updated statistics on tracked tables/statistics. This is designed to be run from a scheduled job.
*
*	Returns:	N/A
*	Prerequisite: usp_Statistic_Add_Track be called first with a valid object name
*				
*	History:	
*
*	3/20/2017 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	3/20/2017			Mike Zawadzki			Created
*	
*
*********************************************************************************************************************/

	DECLARE @cmd nvarchar(4000)
	DECLARE @runtime datetime
	DECLARE @dbname sysname
	DECLARE @dbid smallint
	DECLARE @schid int
	DECLARE @schname sysname
	DECLARE @objid int
	DECLARE @objname sysname
	DECLARE @statid int
	DECLARE @stats_date datetime
	DECLARE @statname sysname
	DECLARE @stats_stream varbinary(max)
	DECLARE @rows bigint
	DECLARE @data_pages bigint
	DECLARE @three_part_name nvarchar(1000)
	DECLARE @rowmods bigint

	CREATE TABLE #mods
	(
		id int NOT NULL,
		indid int NOT NULL,
		dpages bigint NULL,
		rowcnt bigint NULL,
		rowmodctr bigint NULL,
		skip_row tinyint NOT NULL
	)

	CREATE TABLE #stats
	(
		stats_id int,
		[stats_date] datetime,
		[name] sysname
	)

	CREATE TABLE #statblob
	(
		[Stats_Stream] image,
		[Rows] bigint,
		[Data Pages] bigint
	)

	SET @runtime = GETDATE()

	SET TEXTSIZE 100000 -- eliminate truncation when run as job

	--collect sizes/modifications
	DECLARE stat_db_cur CURSOR FOR 
		SELECT distinct database_id, [database_name]  
			FROM dbo.statistics_to_track 
			WHERE [enabled] = 1

	OPEN stat_db_cur
	FETCH NEXT FROM stat_db_cur INTO @dbid, @dbname
	WHILE @@FETCH_STATUS != -1
	BEGIN
		SET @cmd = N'INSERT #mods
			SELECT id, indid, dpages, rowcnt, rowmodctr, 0
				FROM [' + @dbname + N'].sys.sysindexes si
					INNER JOIN dbo.statistics_to_track st
						ON si.id = st.object_id
						AND st.[enabled] = 1
						AND st.database_id = ' + LTRIM(STR(@dbid))
		--PRINT @cmd
		EXEC (@cmd)

		--eliminate mods that have not changed
		DECLARE stat_mod_cur CURSOR FOR
			SELECT id, indid, rowcnt, rowmodctr FROM #mods
		OPEN stat_mod_cur
		FETCH NEXT FROM stat_mod_cur INTO @objid, @statid, @rows, @rowmods
		WHILE @@FETCH_STATUS != -1
		BEGIN
			IF EXISTS 
			(
				SELECT 1 FROM dbo.statistics_tracked_size
					WHERE database_id = @dbid AND [object_id] = @objid AND stats_id = @statid AND rowcnt = @rows AND rowmodctr = @rowmods
					AND runtime = 
					(
						SELECT max(runtime) FROM dbo.statistics_tracked_size
							WHERE database_id = @dbid AND [object_id] = @objid AND stats_id = @statid
					)
			)
			BEGIN
				UPDATE #mods
					SET skip_row = 1
					WHERE id = @objid AND indid = @statid
			END
			FETCH NEXT FROM stat_mod_cur INTO  @objid, @statid, @rows, @rowmods
		END
		DEALLOCATE stat_mod_cur

		--INSERT updated query stats
		INSERT dbo.statistics_tracked_size
			SELECT @runtime, @dbid, id, indid, dpages, rowcnt, rowmodctr
				FROM #mods
				WHERE skip_row = 0

		TRUNCATE TABLE #mods

		FETCH NEXT FROM stat_db_cur INTO @dbid, @dbname
	END
	DEALLOCATE stat_db_cur

	--collect statistics
	DECLARE stat_cur CURSOR FOR 
		SELECT [database_name], database_id, [object_id], [object_name], [schema_name]  
			FROM dbo.statistics_to_track
			WHERE stats_id IS NULL 
				AND [enabled] = 1

	OPEN stat_cur
	FETCH NEXT FROM stat_cur INTO @dbname, @dbid, @objid, @objname, @schname

	WHILE @@FETCH_STATUS != -1
	BEGIN
		SET @cmd = 'USE [' + @dbname + ']; INSERT #stats SELECT stats_id, stats_date(object_id, stats_id), name FROM sys.stats WHERE object_id = ' + LTRIM(STR(@objid))
		--PRINT @cmd
		EXEC (@cmd)

		--if stats are different or new collect and insert stats
		DECLARE temp_stat_cur CURSOR FOR SELECT * FROM #stats
		OPEN temp_stat_cur
		FETCH NEXT FROM temp_stat_cur INTO @statid, @stats_date, @statname
	
		WHILE @@FETCH_STATUS != -1
		BEGIN
			--following code for debugging
			--select @runtime, @statid, @stats_date
			IF NOT EXISTS 
			(	
				SELECT 1 FROM dbo.statistics_tracked ts1
				WHERE ts1.database_id = @dbid AND ts1.[object_id] = @objid and ts1.stats_id = @statid and ISNULL(ts1.[stats_date],'1900-01-01') = ISNULL(@stats_date,'1900-01-01')
				AND ts1.runtime = 
				(
					SELECT MAX(runtime) FROM dbo.statistics_tracked ts2
					WHERE ts2.database_id = @dbid AND ts2.[object_id] = @objid and ts2.stats_id = @statid
				)
			)
			BEGIN
				INSERT dbo.statistics_tracked (runtime, database_id, [object_id], stats_id, [stats_date], stats_name) VALUES (@runtime, @dbid, @objid, @statid, @stats_date, @statname)

				IF @stats_date IS NOT NULL
				BEGIN
					SET @three_part_name = N'[' + @dbname + N'].[' + @schname + N'].[' + @objname + N']'
					INSERT #statblob EXEC dbo.usp_Statistic_Get @three_part_name, @statname
					SELECT TOP 1 @stats_stream = [Stats_Stream], @rows = [Rows], @data_pages = [Data Pages] from #statblob
					UPDATE dbo.statistics_tracked 
						SET row_count = @rows,
							page_count = @data_pages,
							[stats_stream] = @stats_stream
						WHERE runtime = @runtime AND database_id = @dbid AND [object_id] = @objid AND stats_id = @statid AND [stats_date] = @stats_date
					TRUNCATE TABLE #statblob
				END
			END

			FETCH NEXT FROM temp_stat_cur INTO @statid, @stats_date, @statname
		END

		DEALLOCATE temp_stat_cur

		TRUNCATE TABLE #stats
		FETCH NEXT FROM stat_cur INTO @dbname, @dbid, @objid, @objname, @schname
	END

	DEALLOCATE stat_cur
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[usp_UpdateVersionStatics]',10,1) WITH NOWAIT;
if object_id('dbo.usp_UpdateVersionStatics') is null exec('create procedure [dbo].[usp_UpdateVersionStatics] as select getdate() DT')
GO
  alter procedure dbo.usp_UpdateVersionStatics
WITH ENCRYPTION
as
declare @SQL nvarchar(max)

if not exists (select * from Licensing.fn_ValidateLicense())
begin
	alter database FDDBA set single_user with rollback immediate

	set @SQL = (select 'alter table ' + quotename(s.[name]) + '.' + quotename(t.[name]) + ' drop constraint ' + quotename(k.[name]) + ';'
					from sys.foreign_keys k
						inner join sys.tables t on t.[object_id] = k.parent_object_id
						inner join sys.schemas s on s.[schema_id] = t.[schema_id]
					for xml path('')
				)
	if @SQL is not null
		exec(@SQL);

	;with obj as
			(select 'drop ' + case type_desc
									when 'SQL_INLINE_TABLE_VALUED_FUNCTION' then 'function'
									when 'SQL_SCALAR_FUNCTION' then 'function'
									when 'SQL_TABLE_VALUED_FUNCTION' then 'function'
									when 'SQL_STORED_PROCEDURE' then 'procedure'
									when 'USER_TABLE' then 'table'
									when 'VIEW' then 'view'
								end + ' ' + s.name + '.' + o.name cmd
				from sys.objects o
					inner join sys.schemas s on o.[schema_id] = s.[schema_id]
				where is_ms_shipped = 0
					and type_desc not in ('DEFAULT_CONSTRAINT', 'FOREIGN_KEY_CONSTRAINT', 'CHECK_CONSTRAINT', 'PRIMARY_KEY_CONSTRAINT', 'SQL_TRIGGER')
				union all
				select 'drop type ' + s.name + '.' + t.name
				from sys.table_types t
					inner join sys.schemas s on t.[schema_id] = s.[schema_id]
				union all
				select 'drop schema ' + name
				from sys.schemas
				where principal_id = 1
					and [schema_id] > 4
			)
	select @SQL = (select cmd + ';'
					from obj
					for xml path('')
					)
	exec(@SQL)

	set @SQL =
		(select 'exec msdb..sp_delete_job @job_name = ''' + j.name + ''';'
			from msdb..sysjobs j
				inner join msdb..syscategories c on c.category_id = j.category_id
			where c.name IN(N'Fortified Data - Maintenance',N'Fortified Data - Monitor')
			for xml path('')
		)
	exec(@SQL)
end

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [Infra].[usp_GetRegistryValue]',10,1) WITH NOWAIT;
if object_id('Infra.usp_GetRegistryValue') is null exec('create procedure [Infra].[usp_GetRegistryValue] as select getdate() DT')
GO
  alter procedure Infra.usp_GetRegistryValue
	@KeyName nvarchar(256),
	@ValueName nvarchar(256),
	@Value nvarchar(4000) output
WITH ENCRYPTION
as
set nocount on
declare @InstanceName nvarchar(256),
		@InstancePath nvarchar(256),
		@Key nvarchar(256)
select @InstanceName = isnull(cast(serverproperty('InstanceName') as nvarchar(128)), 'MSSQLSERVER')

EXEC master.dbo.xp_regread @rootkey = N'HKEY_LOCAL_MACHINE',
							@key = N'SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL',
							@value_name = @InstanceName,
							@value = @InstancePath output

set @Key = N'SOFTWARE\Microsoft\Microsoft SQL Server\' + @InstancePath + '\' + @KeyName

EXEC master.dbo.xp_regread @rootkey = N'HKEY_LOCAL_MACHINE',
							@key = @Key,
							@value_name = @ValueName,
							@value = @Value output

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [mon].[pDiskSpace_Insert]',10,1) WITH NOWAIT;
if object_id('mon.pDiskSpace_Insert') is null exec('create procedure [mon].[pDiskSpace_Insert] as select getdate() DT')
GO
  


/*********************************************************************************************************************
*	Written By:	Fortified Dataagre
*	Purpose: 	Insert Disk Space Information into table for historical purposes
*	Inputs:		None
*	Returns:	Errors
*	Prerequisite: This procedure uses xp_cmdshell and calls wmi to get information about all the drives. If xp_cmdshell is 
*	not enabled it WILL ENABLE IT and then disable it when it is done. It will return a result set of space information
*	Notes:		This job is a copy of the pGetDiskSpace that inserts into a table instead of returning info to the caller.		
*		
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	3/9/2018			Keith Buck				Created
*
*
*
*********************************************************************************************************************/
ALTER PROCEDURE mon.pDiskSpace_Insert
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
SET ARITHIGNORE ON

DECLARE @vSQL						NVARCHAR(1000);
DECLARE @tDrvLetter					TABLE (Drive VARCHAR(500));
DECLARE @vMsg						VARCHAR(1000);
DECLARE @vCurrentRuntime			DATETIME 
DECLARE @STRLine					VARCHAR(max);
DECLARE @Drive						VARCHAR(500);
DECLARE @TotalSize					REAL;
DECLARE @Freesize					REAL;
DECLARE @VolumeName					VARCHAR(64);
DECLARE @cmdshellEnabled			BIT

EXEC dbo.usp_UpdateVersionStatics
SET @vCurrentRuntime = getdate()
SELECT @cmdshellEnabled = cast(value_in_use as bit) FROM sys.configurations Where name = 'xp_cmdshell'

IF @cmdshellEnabled = 0
BEGIN
       RAISERROR('xp_cmdshell is NOT enabled, will enable it for the report and then turn it off when completed.',10,1) WITH NOWAIT;
       EXEC sp_configure 'xp_cmdshell',1;
       RECONFIGURE
END


DECLARE @tDrvInfo TABLE(
       Drive VARCHAR(500) null,
       [MB free] DECIMAL(20,2),
       [MB TotalSize] DECIMAL(20,2),
       [Volume Name] VARCHAR(64),
       [Pct Free] DECIMAL(20,2)
       );

INSERT INTO @tDrvLetter
EXEC xp_cmdshell 'wmic volume where drivetype="3" get caption, freespace, capacity, label';

DELETE FROM @tDrvLetter
WHERE Drive IS NULL OR len(Drive) < 4 OR Drive LIKE '%Capacity%' OR Drive LIKE  '%\\%\Volume%';


WHILE EXISTS(SELECT 1 FROM @tDrvLetter)
BEGIN
       SET ROWCOUNT 1;
       SELECT @STRLine = Drive FROM @tDrvLetter;

       -- Get TotalSize
       SET @TotalSize= CAST(LEFT(@STRLine,CHARINDEX(' ',@STRLine)) AS REAL)/1024/1024;
       --SELECT @TotalSize

       -- Remove Total Size
       SET @STRLine = REPLACE(@STRLine, LEFT(@STRLine,CHARINDEX(' ',@STRLine)),'');
       -- Get Drive

       SET @Drive = LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine)));
       --SELECT @Drive

       SET @STRLine = RTRIM(LTRIM(REPLACE(LTRIM(@STRLine), LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))),'')));

       SET @Freesize = CAST(LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))) as REAL)/1024/1024;
       --SELECT @Freesize/1024/1024

       SET @STRLine = RTRIM(LTRIM(REPLACE(LTRIM(@STRLine), LEFT(LTRIM(@STRLine),CHARINDEX(' ',LTRIM(@STRLine))),'')));
       SET @VolumeName = @STRLine;
       -- 

       INSERT INTO @tDrvInfo SELECT @Drive, @Freesize, @TotalSize, @VolumeName,@Freesize/@TotalSize*100;

       DELETE FROM @tDrvLetter;
END

SET ROWCOUNT 0

-- POPULATE TEMP TABLE WITH LOGICAL DISKS
-- This is FIX/Workaround for Windows 2003 bug that WMIC doesn't return volume name that is over X number of charactors.
SET @vSQL ='wmic /FailFast:ON logicaldisk where (drivetype ="3" and volumename!="RECOVERY" AND volumename!="System Reserved") get deviceid,volumename  /Format:csv'

DECLARE @toutput1 TABLE (Col1 VARCHAR(2048));
INSERT INTO @toutput1
EXEC master..xp_cmdshell @vSQL;
DELETE @toutput1 where ltrim(Col1) is null or len(Col1) = 1 or Col1 like 'Node,DeviceID,VolumeName%';

DECLARE @tlogicaldisk TABLE (DeviceID VARCHAR(128),VolumeName VARCHAR(256));
DECLARE @NodeName VARCHAR(128);
SET @NodeName = (SELECT TOP 1 LEFT(Col1, CHARINDEX(',',Col1)) FROM @toutput1);

-- Clean up server name
UPDATE @toutput1 SET Col1 = REPLACE(Col1, @NodeName, '');

INSERT INTO @tlogicaldisk
SELECT LEFT(Col1, CHARINDEX(',',Col1)-2),  SUBSTRING(Col1, CHARINDEX(',',Col1)+1, LEN(Col1))
FROM @toutput1;


UPDATE dr
SET dr.[Volume Name] = ld.VolumeName
       FROM @tDrvInfo dr RIGHT OUTER JOIN @tlogicaldisk ld ON left(dr.Drive,1) = ld.DeviceID
WHERE LEN([Volume Name]) = 1

INSERT INTO mon.DiskSpace(InstanceName, CreatedOn, Drive, TotalSize_mb, Free_mb) 
SELECT 
	@@servername,
	@vCurrentRuntime,
	CASE	WHEN LEN(Drive) = 3 THEN LEFT(Drive,1)
    ELSE Drive
    END, 
    ISNULL([MB TotalSize],0),
    ISNULL([MB free],0)
FROM 
	@tDrvInfo
ORDER BY 1;

IF @cmdshellEnabled = 0
BEGIN
        If EXISTS(SELECT 1 FROM SYS.configurations Where name = 'xp_cmdshell' AND value_in_use = CAST(1 AS sql_variant))
        BEGIN
                RAISERROR('Disabling xp_cmdshell .',10,1) WITH NOWAIT;
                EXEC sp_configure 'xp_cmdshell',0;
                RECONFIGURE
        END
END
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [mon].[pExecRequestes_Purge]',10,1) WITH NOWAIT;
if object_id('mon.pExecRequestes_Purge') is null exec('create procedure [mon].[pExecRequestes_Purge] as select getdate() DT')
GO
  
alter procedure mon.pExecRequestes_Purge
(
	@days					int = -14,
	@batchsize				int = 1000,
	@debug					bit = 1
)
WITH ENCRYPTION
AS
SET NOCOUNT ON
exec dbo.usp_UpdateVersionStatics
declare @recsaffected			int
declare @mindate				datetime
declare @start					datetime
declare @end					datetime
declare @msg					nvarchar(1000)
declare @errMsg					nvarchar(2048)
declare @errorCount				int 

SET @errorCount = 0
If @days > 0 
	set @days = @days * -1

set @mindate = DATEADD(day,@days,getdate())

set @recsaffected = 1
While @recsaffected > 0
Begin
	Begin try
		set @recsaffected = 0
		set @start = SYSDATETIME()
		Begin Tran
		delete 
			top (@batchsize) 
		  from	
			mon.ExecRequests
		 Where
			CreatedOn < @mindate

		set @recsaffected = @@ROWCOUNT
		Commit

		If @debug = 1
		begin
			set @end = SYSDATETIME()
			set @msg = N'Deleted ' + cast(@recsaffected as nvarchar(20)) + N' records from mon.ExecRequests table in ' + 
					cast(DATEDIFF(ms,@start, @end) as nvarchar(20)) + N' milliseconds (' +
					cast(DATEDIFF(second,@start, @end) as nvarchar(20)) + N' seconds).'
			RAISERROR(@msg, 10,1) with nowait;
		end

	End Try
	Begin Catch
		--get the error information and print it out, we are not going to stop the process we will continue on
		Select @errMsg = N' Error number ' + cast(ERROR_NUMBER() as nvarchar(20)) + N' occurred on line ' + cast(ERROR_LINE() as nvarchar(10)) + N', with message: ' +
			substring(ERROR_MESSAGE(),1,1975) 
		
		RAISERROR(@errMsg, 15,1) with nowait;
		--Transaction is not committable and must be rolled back
		If (XACT_STATE()) = -1
		begin
			Set @msg = 	N'The transaction is in an uncommittable state. Rolling back transaction with ' +
				cast(@recsaffected as nvarchar(20)) + N' records.'
			RAISERROR(@msg, 10,1) with nowait;
			ROLLBACK TRANSACTION;
		end
		-- Transaction is committable, so just do it!
		Else If (XACT_STATE()) = 1
		begin
			Set @msg = 	N'The transaction is in a committable state. Committing transaction.'
			RAISERROR(@msg, 10,1) with nowait;
			COMMIT TRANSACTION;   
		end
		set @errorCount = @errorCount + 1
		If @errorCount >= 3
			break;
	End Catch
End



GO


IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[mon].[pExecRequests_Insert]') AND type in (N'P', N'PC'))
	EXECUTE sp_executesql N'CREATE PROCEDURE [mon].[pExecRequests_Insert] AS SELECT GETDATE()'
GO

IF (select VerDec from #FDVER) >= 11
BEGIN
EXECUTE sp_executesql N'
ALTER PROCEDURE [mon].[pExecRequests_Insert]
WITH ENCRYPTION
AS
IF NOT EXISTS(select * from Licensing.fn_ValidateLicense()) RETURN;
DECLARE		@msg	VARCHAR(2048)
BEGIN TRY
	INSERT INTO [mon].[ExecRequests]
	(CreatedOn, session_id, RunTimeMinutes, RunDuration, DatabaseName, blocking_session_id, [status], open_transaction_count, [host_name], login_name
		, [program_name], wait_type, wait_resource, wait_time, start_time, totallogical_reads, TotalLogicalReads2, totalWrites, totalCPU, writes_in_tempdb
		, parallelquery, statement_text, blocking_text, sql_text, transaction_id, percent_complete, estimated_completion_time, scheduler_id, plan_handle
		, granted_query_memory, ExecutionPlan, statement_text_xml, sql_text_xml, last_request_start_time, last_request_end_time	)
	SELECT
			getdate(),
			x.session_id,
			CAST(DATEDIFF(mi, x.start_time, GETDATE()) AS BIGINT) ''Run Time min'',
			RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 86400 AS VARCHAR),2) + '':'' +
				RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 3600 AS VARCHAR),2) + '':'' +
				RIGHT(''0'' + CAST(( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 60) % 60 AS VARCHAR),2) + '':'' +
				RIGHT(''0'' + CAST(DATEDIFF(SECOND, x.start_time,  GETDATE()) % 60 AS VARCHAR),2) as ''RunTime DD:HH:MM:SS"'',
			DatabaseName,
			COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
			status,
			x.open_transaction_count,
			x.host_name,
			x.login_name,
			x.program_name,
			x.wait_type,
			x.wait_resource,
			x.wait_time,
			x.start_time,
			x.totallogical_reads ,
			FDDBA.[dbo].[fFormatIntReadable]( x.totallogical_reads) AS Reads ,
			x.totalWrites,
			x.totalCPU,
			x.writes_in_tempdb,
			parallelquery,
			(
				SELECT          
					substring(text, (statement_start_offset/2)+1
						, ((case statement_end_offset
								when -1 then datalength(text)
								else statement_end_offset
							end - statement_start_offset)/2) + 1)
				FROM sys.dm_exec_sql_text(x.sql_handle)
			) AS statement_text,
			(
				SELECT
					p.text
				FROM
				(
					SELECT
						MIN(sql_handle) AS sql_handle
					FROM sys.dm_exec_requests r2
					WHERE
						r2.session_id = x.blocking_session_id
				) AS r_blocking
				CROSS APPLY
				(
					SELECT
						text AS [text()]
					FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
				) p (text)
			) AS blocking_text,
			(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(x.sql_handle)
			) AS sql_text,
			transaction_id,
			percent_complete,
			estimated_completion_time,
			scheduler_id,
			plan_handle,
			x.granted_query_memory
			, (SELECT query_plan 
			FROM sys.dm_exec_query_plan (plan_handle)) execution_plan,
					(
				SELECT          
					substring(text, (statement_start_offset/2)+1
						, ((case statement_end_offset
								when -1 then datalength(text)
								else statement_end_offset
							end - statement_start_offset)/2) + 1)
				FROM sys.dm_exec_sql_text(x.sql_handle)
				FOR XML PATH(''''), TYPE
			) AS statement_text_xml,
				(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(x.sql_handle)
				FOR XML PATH(''''), TYPE
			) AS sql_text_xml
			,x.last_request_start_time
			,x.last_request_end_time
			
		FROM
		(
			SELECT
				s.session_id,
				DB_NAME(s.database_id) AS DatabaseName,
				s.status,
				s.host_name,
				s.login_name,
				r.start_time,
				s.open_transaction_count,
				r.sql_handle,
				wait_type,
				wait_resource,
				CAST(wait_time AS BIGINT) AS wait_time,
				statement_start_offset,
				statement_end_offset,
				r.blocking_session_id,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				count(*) AS parallelquery,
				SUM(CAST(r.logical_reads AS BIGINT)) AS totallogical_reads ,
				SUM(CAST(r.writes AS BIGINT)) AS totalWrites,
				SUM(CAST(r.cpu_time AS BIGINT)) AS totalCPU,
				SUM(CAST(tsu.user_objects_alloc_page_count + tsu.internal_objects_alloc_page_count AS BIGINT)) AS writes_in_tempdb,
				plan_handle,
				CAST(granted_query_memory AS BIGINT) AS granted_query_memory,
				program_name,
				s.last_request_start_time,
				s.last_request_end_time
			FROM 
				sys.dm_exec_sessions s
				LEFT JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
				LEFT JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id and r.request_id = tsu.request_id
			WHERE (s.status IN (''running'', ''runnable'', ''suspended'',''rollback'') or s.open_transaction_count > 0)
			AND s.session_id != @@spid
			GROUP BY
				s.session_id,
				s.database_id,
				s.status,
				s.host_name,
				s.login_name,
				r.start_time,
				r.sql_handle,
				wait_type,
				s.open_transaction_count,
				wait_resource,
				wait_time,
				statement_start_offset,
				statement_end_offset,
				r.blocking_session_id,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				last_request_start_time,
				plan_handle,
				granted_query_memory,
				program_name,
				s.last_request_end_time
											) x
	ORDER BY 1,2
END TRY
BEGIN CATCH
	SET @msg = ''Error occurred during first attempt to insert data into mon.pExecRequests_Insert. Error msg is: '' + ERROR_MESSAGE()
	RAISERROR(@msg,10,1) WITH NOWAIT;
	BEGIN TRY
		INSERT INTO [mon].[ExecRequests]
		(CreatedOn, session_id, RunTimeMinutes, RunDuration, DatabaseName, blocking_session_id, [status], open_transaction_count, [host_name], login_name
			, [program_name], wait_type, wait_resource, wait_time, start_time, totallogical_reads, TotalLogicalReads2, totalWrites, totalCPU, writes_in_tempdb
			, parallelquery, statement_text, blocking_text, sql_text, transaction_id, percent_complete, estimated_completion_time, scheduler_id, plan_handle
			, granted_query_memory, last_request_start_time, last_request_end_time
			)
		SELECT
				getdate(),
				x.session_id,
				CAST(DATEDIFF(mi, x.start_time, GETDATE()) AS BIGINT) ''Run Time min'',
				RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 86400 AS VARCHAR),2) + '':'' +
					RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 3600 AS VARCHAR),2) + '':'' +
					RIGHT(''0'' + CAST(( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 60) % 60 AS VARCHAR),2) + '':'' +
					RIGHT(''0'' + CAST(DATEDIFF(SECOND, x.start_time,  GETDATE()) % 60 AS VARCHAR),2) as ''RunTime DD:HH:MM:SS"'',
				DatabaseName,
				COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
				status,
				x.open_transaction_count,
				x.host_name,
				x.login_name,
				x.program_name,
				x.wait_type,
				x.wait_resource,
				x.wait_time,
				x.start_time,
				x.totallogical_reads ,
				FDDBA.[dbo].[fFormatIntReadable]( x.totallogical_reads) AS Reads ,
				x.totalWrites,
				x.totalCPU,
				x.writes_in_tempdb,
				parallelquery,
				(
					SELECT          
						substring(text, (statement_start_offset/2)+1
							, ((case statement_end_offset
									when -1 then datalength(text)
									else statement_end_offset
								end - statement_start_offset)/2) + 1)
					FROM sys.dm_exec_sql_text(x.sql_handle)
				) AS statement_text,
				(
					SELECT
						p.text
					FROM
					(
						SELECT
							MIN(sql_handle) AS sql_handle
						FROM sys.dm_exec_requests r2
						WHERE
							r2.session_id = x.blocking_session_id
					) AS r_blocking
					CROSS APPLY
					(
						SELECT
							text AS [text()]
						FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
					) p (text)
				) AS blocking_text,
				(
					SELECT
						text AS [text()]
					FROM sys.dm_exec_sql_text(x.sql_handle)
				) AS sql_text,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				plan_handle,
				x.granted_query_memory
				,x.last_request_start_time
				,x.last_request_end_time
			
			FROM
			(
				SELECT
					s.session_id,
					DB_NAME(s.database_id) AS DatabaseName,
					s.status,
					s.host_name,
					s.login_name,
					r.start_time,
					s.open_transaction_count,
					r.sql_handle,
					wait_type,
					wait_resource,
					CAST(wait_time AS BIGINT) AS wait_time,
					statement_start_offset,
					statement_end_offset,
					r.blocking_session_id,
					transaction_id,
					percent_complete,
					estimated_completion_time,
					scheduler_id,
					count(*) AS parallelquery,
					SUM(CAST(r.logical_reads AS BIGINT)) AS totallogical_reads ,
					SUM(CAST(r.writes AS BIGINT)) AS totalWrites,
					SUM(CAST(r.cpu_time AS BIGINT)) AS totalCPU,
					SUM(CAST(tsu.user_objects_alloc_page_count + tsu.internal_objects_alloc_page_count AS BIGINT)) AS writes_in_tempdb,
					plan_handle,
					CAST(granted_query_memory AS BIGINT) AS granted_query_memory,
					program_name,
					s.last_request_start_time,
					s.last_request_end_time
				FROM 
					sys.dm_exec_sessions s
					LEFT JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
					LEFT JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id and r.request_id = tsu.request_id
				WHERE (s.status IN (''running'', ''runnable'', ''suspended'',''rollback'') or s.open_transaction_count > 0)
				AND s.session_id != @@spid
				GROUP BY
					s.session_id,
					s.database_id,
					s.status,
					s.host_name,
					s.login_name,
					r.start_time,
					r.sql_handle,
					wait_type,
					s.open_transaction_count,
					wait_resource,
					wait_time,
					statement_start_offset,
					statement_end_offset,
					r.blocking_session_id,
					transaction_id,
					percent_complete,
					estimated_completion_time,
					scheduler_id,
					last_request_start_time,
					plan_handle,
					granted_query_memory,
					program_name,
					s.last_request_end_time
												) x
		ORDER BY 1,2
	END TRY
	BEGIN CATCH
		SET @msg = ''Error occurred during FINA attempt to insert data into mon.pExecRequests_Insert. Error msg is: '' + ERROR_MESSAGE()
		RAISERROR(@msg,10,1) WITH NOWAIT;
	END CATCH
END CATCH'
END
ELSE
BEGIN
EXECUTE sp_executesql N'
ALTER PROCEDURE [mon].[pExecRequests_Insert]
--WITH ENCRYPTION
AS
DECLARE		@msg	VARCHAR(2048)
BEGIN TRY
	INSERT INTO [mon].[ExecRequests]
	(CreatedOn, session_id, RunTimeMinutes, RunDuration, DatabaseName, blocking_session_id, [status], open_transaction_count, [host_name], login_name
		, [program_name], wait_type, wait_resource, wait_time, start_time, totallogical_reads, TotalLogicalReads2, totalWrites, totalCPU, writes_in_tempdb
		, parallelquery, statement_text, blocking_text, sql_text, transaction_id, percent_complete, estimated_completion_time, scheduler_id, plan_handle
		, granted_query_memory, ExecutionPlan, statement_text_xml, sql_text_xml, last_request_start_time, last_request_end_time	)
	SELECT
			getdate(),
			x.session_id,
			CAST(DATEDIFF(mi, x.start_time, GETDATE()) AS BIGINT) ''Run Time min'',
			RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 86400 AS VARCHAR),2) + '':'' +
				RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 3600 AS VARCHAR),2) + '':'' +
				RIGHT(''0'' + CAST(( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 60) % 60 AS VARCHAR),2) + '':'' +
				RIGHT(''0'' + CAST(DATEDIFF(SECOND, x.start_time,  GETDATE()) % 60 AS VARCHAR),2) as ''RunTime DD:HH:MM:SS"'',
			DatabaseName,
			COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
			status,
			x.open_transaction_count,
			x.host_name,
			x.login_name,
			x.program_name,
			x.wait_type,
			x.wait_resource,
			x.wait_time,
			x.start_time,
			x.totallogical_reads ,
			FDDBA.[dbo].[fFormatIntReadable]( x.totallogical_reads) AS Reads ,
			x.totalWrites,
			x.totalCPU,
			x.writes_in_tempdb,
			parallelquery,
			(
				SELECT          
					substring(text, (statement_start_offset/2)+1
						, ((case statement_end_offset
								when -1 then datalength(text)
								else statement_end_offset
							end - statement_start_offset)/2) + 1)
				FROM sys.dm_exec_sql_text(x.sql_handle)
			) AS statement_text,
			(
				SELECT
					p.text
				FROM
				(
					SELECT
						MIN(sql_handle) AS sql_handle
					FROM sys.dm_exec_requests r2
					WHERE
						r2.session_id = x.blocking_session_id
				) AS r_blocking
				CROSS APPLY
				(
					SELECT
						text AS [text()]
					FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
				) p (text)
			) AS blocking_text,
			(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(x.sql_handle)
			) AS sql_text,
			transaction_id,
			percent_complete,
			estimated_completion_time,
			scheduler_id,
			plan_handle,
			x.granted_query_memory
			, (SELECT query_plan 
			FROM sys.dm_exec_query_plan (plan_handle)) execution_plan,
					(
				SELECT          
					substring(text, (statement_start_offset/2)+1
						, ((case statement_end_offset
								when -1 then datalength(text)
								else statement_end_offset
							end - statement_start_offset)/2) + 1)
				FROM sys.dm_exec_sql_text(x.sql_handle)
				FOR XML PATH(''''), TYPE
			) AS statement_text_xml,
				(
				SELECT
					text AS [text()]
				FROM sys.dm_exec_sql_text(x.sql_handle)
				FOR XML PATH(''''), TYPE
			) AS sql_text_xml
			,x.last_request_start_time
			,x.last_request_end_time
			
		FROM
		(
			SELECT
				s.session_id,
				DB_NAME(r.database_id) AS DatabaseName,
				s.status,
				s.host_name,
				s.login_name,
				r.start_time,
				NULL AS open_transaction_count,
				r.sql_handle,
				wait_type,
				wait_resource,
				CAST(wait_time AS BIGINT) AS wait_time,
				statement_start_offset,
				statement_end_offset,
				r.blocking_session_id,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				count(*) AS parallelquery,
				SUM(CAST(r.logical_reads AS BIGINT)) AS totallogical_reads ,
				SUM(CAST(r.writes AS BIGINT)) AS totalWrites,
				SUM(CAST(r.cpu_time AS BIGINT)) AS totalCPU,
				SUM(CAST(tsu.user_objects_alloc_page_count + tsu.internal_objects_alloc_page_count AS BIGINT)) AS writes_in_tempdb,
				plan_handle,
				CAST(granted_query_memory AS BIGINT) AS granted_query_memory,
				program_name,
				s.last_request_start_time,
				s.last_request_end_time
			FROM 
				sys.dm_exec_sessions s
				LEFT JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
				LEFT JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id and r.request_id = tsu.request_id
			WHERE s.status IN (''running'', ''runnable'', ''suspended'',''rollback'') 
			AND s.session_id != @@spid
			GROUP BY
				s.session_id,
				r.database_id,
				s.status,
				s.host_name,
				s.login_name,
				r.start_time,
				r.sql_handle,
				wait_type,
				wait_resource,
				wait_time,
				statement_start_offset,
				statement_end_offset,
				r.blocking_session_id,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				last_request_start_time,
				plan_handle,
				granted_query_memory,
				program_name,
				s.last_request_end_time
											) x
	ORDER BY 1,2
END TRY
BEGIN CATCH
	SET @msg = ''Error occurred during first attempt to insert data into mon.pExecRequests_Insert. Error msg is: '' + ERROR_MESSAGE()
	RAISERROR(@msg,10,1) WITH NOWAIT;
	BEGIN TRY
		INSERT INTO [mon].[ExecRequests]
		(CreatedOn, session_id, RunTimeMinutes, RunDuration, DatabaseName, blocking_session_id, [status], open_transaction_count, [host_name], login_name
			, [program_name], wait_type, wait_resource, wait_time, start_time, totallogical_reads, TotalLogicalReads2, totalWrites, totalCPU, writes_in_tempdb
			, parallelquery, statement_text, blocking_text, sql_text, transaction_id, percent_complete, estimated_completion_time, scheduler_id, plan_handle
			, granted_query_memory, last_request_start_time, last_request_end_time
			)
		SELECT
				getdate(),
				x.session_id,
				CAST(DATEDIFF(mi, x.start_time, GETDATE()) AS BIGINT) ''Run Time min'',
				RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 86400 AS VARCHAR),2) + '':'' +
					RIGHT(''0'' + CAST( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 3600 AS VARCHAR),2) + '':'' +
					RIGHT(''0'' + CAST(( DATEDIFF(SECOND,x.start_time,  GETDATE()) / 60) % 60 AS VARCHAR),2) + '':'' +
					RIGHT(''0'' + CAST(DATEDIFF(SECOND, x.start_time,  GETDATE()) % 60 AS VARCHAR),2) as ''RunTime DD:HH:MM:SS"'',
				DatabaseName,
				COALESCE(x.blocking_session_id, 0) AS blocking_session_id,
				status,
				x.open_transaction_count,
				x.host_name,
				x.login_name,
				x.program_name,
				x.wait_type,
				x.wait_resource,
				x.wait_time,
				x.start_time,
				x.totallogical_reads ,
				FDDBA.[dbo].[fFormatIntReadable]( x.totallogical_reads) AS Reads ,
				x.totalWrites,
				x.totalCPU,
				x.writes_in_tempdb,
				parallelquery,
				(
					SELECT          
						substring(text, (statement_start_offset/2)+1
							, ((case statement_end_offset
									when -1 then datalength(text)
									else statement_end_offset
								end - statement_start_offset)/2) + 1)
					FROM sys.dm_exec_sql_text(x.sql_handle)
				) AS statement_text,
				(
					SELECT
						p.text
					FROM
					(
						SELECT
							MIN(sql_handle) AS sql_handle
						FROM sys.dm_exec_requests r2
						WHERE
							r2.session_id = x.blocking_session_id
					) AS r_blocking
					CROSS APPLY
					(
						SELECT
							text AS [text()]
						FROM sys.dm_exec_sql_text(r_blocking.sql_handle)
					) p (text)
				) AS blocking_text,
				(
					SELECT
						text AS [text()]
					FROM sys.dm_exec_sql_text(x.sql_handle)
				) AS sql_text,
				transaction_id,
				percent_complete,
				estimated_completion_time,
				scheduler_id,
				plan_handle,
				x.granted_query_memory
				,x.last_request_start_time
				,x.last_request_end_time
			
			FROM
			(
				SELECT
					s.session_id,
					DB_NAME(r.database_id) AS DatabaseName,
					s.status,
					s.host_name,
					s.login_name,
					r.start_time,
					NULL AS open_transaction_count,
					r.sql_handle,
					wait_type,
					wait_resource,
					CAST(wait_time AS BIGINT) AS wait_time,
					statement_start_offset,
					statement_end_offset,
					r.blocking_session_id,
					transaction_id,
					percent_complete,
					estimated_completion_time,
					scheduler_id,
					count(*) AS parallelquery,
					SUM(CAST(r.logical_reads AS BIGINT)) AS totallogical_reads ,
					SUM(CAST(r.writes AS BIGINT)) AS totalWrites,
					SUM(CAST(r.cpu_time AS BIGINT)) AS totalCPU,
					SUM(CAST(tsu.user_objects_alloc_page_count + tsu.internal_objects_alloc_page_count AS BIGINT)) AS writes_in_tempdb,
					plan_handle,
					CAST(granted_query_memory AS BIGINT) AS granted_query_memory,
					program_name,
					s.last_request_start_time,
					s.last_request_end_time
				FROM 
					sys.dm_exec_sessions s
					LEFT JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
					LEFT JOIN sys.dm_db_task_space_usage tsu ON s.session_id = tsu.session_id and r.request_id = tsu.request_id
				WHERE s.status IN (''running'', ''runnable'', ''suspended'',''rollback'') 
				AND s.session_id != @@spid
				GROUP BY
					s.session_id,
					r.database_id,
					s.status,
					s.host_name,
					s.login_name,
					r.start_time,
					r.sql_handle,
					wait_type,
					wait_resource,
					wait_time,
					statement_start_offset,
					statement_end_offset,
					r.blocking_session_id,
					transaction_id,
					percent_complete,
					estimated_completion_time,
					scheduler_id,
					last_request_start_time,
					plan_handle,
					granted_query_memory,
					program_name,
					s.last_request_end_time
												) x
		ORDER BY 1,2
	END TRY
	BEGIN CATCH
		SET @msg = ''Error occurred during FINA attempt to insert data into mon.pExecRequests_Insert. Error msg is: '' + ERROR_MESSAGE()
		RAISERROR(@msg,10,1) WITH NOWAIT;
	END CATCH
END CATCH'
END
GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [mon].[pProcess_Schedulers_Insert]',10,1) WITH NOWAIT;
if object_id('mon.pProcess_Schedulers_Insert') is null exec('create procedure [mon].[pProcess_Schedulers_Insert] as select getdate() DT')
GO
  

/*********************************************************************************************************************
*	Written By:	Ben DeBow
*	Purpose: 	Track active process data
*	Inputs:		
*
*	ASSIGN VARIABLES
*
*	Notes:	This procedure stores off the active sessions that are running.
*
*	Returns:	Errors
*	Prerequisite: 
*				
*	History:	
*
*	6/15/2010 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	6/15/2010			Ben DeBow				Created
*	7/30/2018			Keith Buck				Added to FDDBA and include change to underly table name
*
*********************************************************************************************************************/
alter procedure mon.pProcess_Schedulers_Insert
WITH ENCRYPTION
AS

SET NOCOUNT ON
SET ANSI_WARNINGS OFF
exec dbo.usp_UpdateVersionStatics
DECLARE @ErrorMessage		NVARCHAR(4000)
DECLARE @ErrorSeverity		INT
DECLARE @ErrorState			INT
DECLARE @rowcount			INT

BEGIN TRY

INSERT mon.[Process_Schedulers]( 
	[scheduler_id]
	,[current_tasks_count]
	,[runnable_tasks_count]
	,[work_queue_count]
	,[pending_disk_io_count]
	,[current_workers_count]
	,[active_workers_count]
	,[context_switches_count]
	,[preemptive_switches_count]
	,[status]
	,[load_factor]
	,CreatedOn)
--	PENDING PROCESSES ON THE SCHEDULERS WAITING TO BE EXECUTED
SELECT 
	scheduler_id
	, current_tasks_count
	, runnable_tasks_count
	, work_queue_count
	, pending_disk_io_count
	, current_workers_count
	, active_workers_count
	, context_switches_count
	, preemptive_switches_count
	, status
	, load_factor
	, getdate()
 FROM 
	sys.dm_os_schedulers
WHERE 
	scheduler_id < 255
	AND runnable_tasks_count > 0
ORDER BY 
	scheduler_id 


END TRY

BEGIN CATCH

    SELECT @ErrorMessage = ERROR_MESSAGE()
    , @ErrorSeverity = ERROR_SEVERITY()
    , @ErrorState = ERROR_STATE()

    SELECT ERROR_NUMBER() AS ErrorNumber
    , ERROR_SEVERITY() AS ErrorSeverity
    , ERROR_STATE() AS ErrorState
    , ERROR_PROCEDURE() AS ErrorProcedure
    , ERROR_LINE() AS ErrorLine
    , ERROR_MESSAGE() AS ErrorMessage
    
    RAISERROR (@ErrorMessage,
           @ErrorSeverity,
           @ErrorState)

END CATCH


GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [mon].[usp_PlanResults_Capture]',10,1) WITH NOWAIT;
if object_id('mon.usp_PlanResults_Capture') is null exec('create procedure [mon].[usp_PlanResults_Capture] as select getdate() DT')
GO
  
alter procedure [mon].[usp_PlanResults_Capture]
(
	@seconds smallint = 10,
	@Debug tinyint = 0
)
WITH ENCRYPTION
AS
BEGIN
/*********************************************************************************************************************
*	Written By:	Mike Zawadzki
*	Purpose: 	collect sys.dm_exec_requests on tracked plans. This is designed to be run from a scheduled job. 
*	Inputs:		
*		@seconds - interval to run check, min = 1 and max = 600
*		@debug - print out debug informat about execution
*
*	ASSIGN VARIABLES
*
*	Notes:	
*		1. will not capture data about nested sprocs that are not also monitored currently
*		2. designed to run from a scheduled job and continue to run until next run interval minus 10 seconds
*		3. determines time to run from job schedule or 600 seconds if not from job
*
*	Future Enhancements
*		1. consider capturing of sys.dm_exec_request_wait_stats for 2016 and later
*		2. consider capturing all session activity if all rows collected have max_ecid value of 0 to look for scheduler starvation
*		3. per sproc/adhoc query monitor threshold in seconds (i.e. sproc A every min and sproc B every 10 sec)
*
*	Returns:	None
*	Prerequisite: usp_PlanStatistic_Add_Track called with valid parameters to identify a plan to track
*				
*	History:	
*
*	4/30/2018 - Created
*
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	4/30/2018			Mike Zawadzki			Created
*	6/8/2018			Mike Zawadzki			FDDBA integration updates
*	6/11/2018			Mike Zawadzki			Add context_info column from sys.dm_exec_requests for extra tracking capabilities. See zd 54615 for details.
*	6/12/2018			Mike Zawadzki			Add @seconds parameter and time scaling
*
*********************************************************************************************************************/
	exec dbo.usp_UpdateVersionStatics
	DECLARE @run_time datetime
	DECLARE @dt datetime
	DECLARE @rowcount int = 0
	DECLARE @rowcount2 int = 0
	DECLARE @ms int
	DECLARE @cursorcount int
	DECLARE @dbname sysname
	DECLARE @schname sysname
	DECLARE @objname sysname
	DECLARE @count smallint = 0
	DECLARE @maxseconds int
	DECLARE @jobid binary(16)
	DECLARE @scheduleid int
	DECLARE @jobstr varchar(20) = 'JobStep (Job 0x'
	DECLARE @lenjobstr int = LEN(@jobstr)

	CREATE TABLE #changedobjects
	(
		dbname sysname NOT NULL,
		schname sysname NOT NULL,
		objname sysname NOT NULL
	)

	SELECT @jobid = CONVERT(binary(16),SUBSTRING([program_name], CHARINDEX(@jobstr, [program_name]) + @lenjobstr, 32), 2) FROM sys.dm_exec_sessions WHERE session_id = @@SPID
	IF @jobid IS NOT NULL
	BEGIN
		SELECT @scheduleid = schedule_id FROM msdb.dbo.sysjobschedules WHERE job_id = @jobid
		IF @scheduleid IS NOT NULL
		BEGIN
			SELECT @maxseconds = (CASE WHEN freq_subday_type = 2 THEN 1
					WHEN freq_subday_type = 4 THEN 60
					WHEN freq_subday_type = 8 THEN 3600
					ELSE 0 END * freq_subday_interval) - @seconds + 1
				FROM msdb.dbo.sysschedules WHERE schedule_id = @scheduleid
		END
	END
	IF @maxseconds IS NULL
	BEGIN
		SET @maxseconds = 600
	END

	WHILE @count < @maxseconds
	BEGIN
		IF @count % 60 = 0
		BEGIN
			--1.A. check for object_id value change on non-adhoc query stats monitored
			SET @dt = GETDATE()
			INSERT #changedobjects
				SELECT [database_name], [schema_name], [object_name] 
					FROM dbo.exec_plan_stats_to_track w
					WHERE [object_id] IS NOT NULL 
						AND [enabled] = 1 
						AND [object_id] != object_id('[' + [database_name] + '].['+ [schema_name] + '].[' + [object_name] + ']','P')
			SET @rowcount = @@ROWCOUNT
			IF @Debug > 0
			BEGIN
				SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
				PRINT '1.A:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
			END
	
			--1.B.
			IF @rowcount > 0
			BEGIN
				SET @dt = GETDATE()
				SET @cursorcount = 0
				DECLARE changed_stats_cur CURSOR FOR
					SELECT * FROM  #changedobjects
				OPEN changed_stats_cur
				FETCH NEXT FROM changed_stats_cur INTO @dbname, @schname, @objname
		
				WHILE @@FETCH_STATUS != -1
				BEGIN
					EXEC dbo.usp_PlanStatistic_Update_Track @dbname, @schname, @objname
					SET @cursorcount = @cursorcount + 1
					FETCH NEXT FROM changed_stats_cur INTO @dbname, @schname, @objname
				END
				DEALLOCATE changed_stats_cur

				IF @Debug > 0
				BEGIN
					SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
					PRINT '1.B:cc=' + LTRIM(STR(@cursorcount)) + ', ms=' + LTRIM(STR(@ms))
				END
			END
		END

		IF @count % @seconds = 0
		BEGIN
			--2. --capture non-adhoc query_stats
			SET @dt = GETDATE()
			SET @run_time = @dt
			INSERT mon.exec_plan_requests
				SELECT @run_time, session_id, request_id, start_time, [status], command, statement_start_offset, statement_end_offset, 
						r.database_id, blocking_session_id, wait_type, wait_time, wait_resource, granted_query_memory, 
						transaction_id, open_transaction_count, transaction_isolation_level, [lock_timeout], [deadlock_priority],
						scheduler_id, cpu_time, reads, writes, logical_reads, row_count, --task_address, 
						group_id, nest_level, 
						(SELECT MAX(exec_context_id) FROM sys.dm_os_tasks t WHERE t.session_id = r.session_id and t.request_id = r.request_id)  as [current_max_ecid],
						percent_complete, estimated_completion_time, r.query_hash, query_plan_hash, plan_handle, [sql_handle], [context_info]
						--statement_sql_handle, --2014
						--dop, --2016
						--parallel_worker_count --2016
					FROM sys.dm_exec_requests r
						INNER JOIN [dbo].[exec_plan_stats_to_track] pst
							ON SUBSTRING(r.plan_handle,1,8) = pst.plan_handle_filter
								AND pst.[object_id] IS NOT NULL
								AND pst.[enabled] = 1
			SET @rowcount = @@ROWCOUNT
			IF @Debug > 0
			BEGIN
				SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
				PRINT '2:rc=' + LTRIM(STR(@rowcount)) + ', ms=' + LTRIM(STR(@ms))
			END

			--3. capture adhoc query_stats
			SET @dt = GETDATE()
			INSERT mon.exec_plan_requests
				SELECT @run_time, session_id, request_id, start_time, [status], command, statement_start_offset, statement_end_offset, 
						r.database_id, blocking_session_id, wait_type, wait_time, wait_resource, granted_query_memory, 
						transaction_id, open_transaction_count, transaction_isolation_level, [lock_timeout], [deadlock_priority],
						scheduler_id, cpu_time, reads, writes, logical_reads, row_count, --task_address, 
						group_id, nest_level, 
						(SELECT MAX(exec_context_id) FROM sys.dm_os_tasks t WHERE t.session_id = r.session_id and t.request_id = r.request_id)  as [current_max_ecid],
						percent_complete, estimated_completion_time, r.query_hash, query_plan_hash, plan_handle, [sql_handle], [context_info]
						--statement_sql_handle, --2014
						--dop, --2016
						--parallel_worker_count --2016
					FROM sys.dm_exec_requests r
						INNER JOIN [dbo].[exec_plan_stats_to_track] pst
							ON SUBSTRING(r.plan_handle,1,4) = pst.plan_handle_filter
								AND pst.[object_id] IS NULL
								AND r.query_hash = pst.query_hash
								AND pst.[enabled] = 1

			SET @rowcount2 = @@ROWCOUNT
			IF @Debug > 0
			BEGIN
				SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
				PRINT '3:rc=' + LTRIM(STR(@rowcount2)) + ', ms=' + LTRIM(STR(@ms))
			END

			--4. capture waiting tasks
			IF @rowcount + @rowcount2 > 0
			BEGIN
				SET @dt = GETDATE()
				INSERT mon.exec_plan_waiting_tasks
					SELECT @run_time, t.session_id, t.exec_context_id, waiting_task_address, wait_duration_ms, t.wait_type, t.blocking_session_id, blocking_exec_context_id, resource_description
						FROM sys.dm_os_waiting_tasks t
							INNER JOIN mon.exec_plan_requests r
								ON t.session_id = r.session_id
								AND r.run_time = @run_time
								AND r.current_max_ecid > 0

				SET @rowcount2 = @@ROWCOUNT
				IF @Debug > 0
				BEGIN
					SET @ms = DATEDIFF(MILLISECOND, @dt, GETDATE())
					PRINT '4:rc=' + LTRIM(STR(@rowcount2)) + ', ms=' + LTRIM(STR(@ms))
				END
			END
		END
				
		SET @count = @count + 1
		IF @count < @maxseconds
		BEGIN
			WAITFOR DELAY '00:00:01'
		END
	END
END

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [Monitoring].[usp_CollectDeadlocks]',10,1) WITH NOWAIT;
if object_id('Monitoring.usp_CollectDeadlocks') is null exec('create procedure [Monitoring].[usp_CollectDeadlocks] as select getdate() DT')
GO
  alter procedure Monitoring.usp_CollectDeadlocks
	@OPS_ID smallint
WITH ENCRYPTION
as
set transaction isolation level read uncommitted
set nocount on
declare @XETargetFile nvarchar(max),
		@LastFileName varchar(1000),
		@LastOffset bigint,
		@OPL_ID int,
		@ErrorMessage nvarchar(4000),
		@RowCount bigint,
		@AttemptCount tinyint = 0,
		@Success bit = 0

if not exists (select * from Licensing.fn_ValidateLicense()) return

if object_id('tempdb..#Deadlocks') is not null
	drop table #Deadlocks

select @LastFileName = cast(Info1 as varchar(1000)),
	@LastOffset = cast(Info2 as bigint)
from OpsControl.fn_GetLastLogRecord(@OPS_ID, default, default, 1, default, default)

exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID output,
									@OPS_ID = @OPS_ID

select @XETargetFile = x.value('(EventFileTarget/File/@name)[1]', 'varchar(1000)')
from sys.dm_xe_session_targets t
	inner join sys.dm_xe_sessions s on t.event_session_address = s.address
	cross apply (select CAST(target_data as xml) x) e
where s.name = 'system_health'
	and target_name = 'event_file'

if @XETargetFile like '%system_health%.xel'
begin
	select @XETargetFile = left(@XETargetFile, len(@XETargetFile) - charindex('\', reverse(@XETargetFile), 1)) + '\system_health*.xel'

	while @AttemptCount < 2
			and @Success = 0
	begin
		set @AttemptCount += 1
		begin try
			select [file_name] FName, file_offset Offset,
				dateadd(hour, -DATEDIFF(hour, getdate(), getutcdate()), ed.value('(event/@timestamp)[1]', 'datetime')) EventDate,
				cast(b.query('.') as nvarchar(max)) DeadLockGraph
			into #Deadlocks
			from sys.fn_xe_file_target_read_file(@XETargetFile, null, @LastFileName, @LastOffset) e
				cross apply (select cast(event_data as xml) ed) x
				cross apply ed.nodes('event/data/value/deadlock') a(b)

			select top 1 @LastFileName = FName, @LastOffset = Offset
			from #Deadlocks
			order by EventDate desc

			begin transaction
			insert into Monitoring.Deadlocks(DLK_DateTime, DLK_Graph)
			select EventDate, DeadLockGraph
			from #Deadlocks
			where EventDate > (select max(DLK_DateTime)
								from Monitoring.Deadlocks)
				or @AttemptCount = 1
			set @RowCount = @@ROWCOUNT

			exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
												@Info1 = @LastFileName,
												@Info2 = @LastOffset,
												@Info3 = @RowCount,
												@Finalize = 1

			commit transaction

			set @Success = 1
		end try
		begin catch
			if @@TRANCOUNT > 0
				rollback transaction
			set @ErrorMessage = ERROR_MESSAGE()

			if @ErrorMessage like 'The offset % is invalid for log file "%".%'
					and @AttemptCount < 2
			begin
				select @LastFileName = null,
					@LastOffset = null,
					@ErrorMessage = null

				drop table #Deadlocks
			end
			else
				exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
													@ErrorMessage = @ErrorMessage,
													@Finalize = 1
		end catch
	end
end
else
	exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
									@ErrorMessage = 'No system_health file target found',
									@Finalize = 1

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [Monitoring].[usp_ParseDeadlocks]',10,1) WITH NOWAIT;
if object_id('Monitoring.usp_ParseDeadlocks') is null exec('create procedure [Monitoring].[usp_ParseDeadlocks] as select getdate() DT')
GO
  alter procedure Monitoring.usp_ParseDeadlocks
	@OPS_ID smallint = 4
WITH ENCRYPTION
as
set nocount on
set transaction isolation level read uncommitted
declare @LastID int,
		@ToID int,
		@OPL_ID int,
		@ErrorMessage nvarchar(4000)

if not exists (select * from Licensing.fn_ValidateLicense()) return

select @LastID = cast(Info1 as varchar(1000))
from OpsControl.fn_GetLastLogRecord(@OPS_ID, default, default, 1, default, default)

set @LastID = isnull(@LastID, 0)

select @ToID = max(DLK_ID)
from Monitoring.Deadlocks

exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID output,
									@OPS_ID = @OPS_ID

begin try
	begin transaction

	;with Victims as
			(select DLK_ID, v.value('@id', 'varchar(23)') ProcessID
				from Monitoring.Deadlocks
					cross apply DLK_Graph.nodes('/deadlock/victim-list/victimProcess') t(v)
				where DLK_ID between @LastID + 1 and @ToID
			)
		, Processes as
			(select DLK_ID
				, replace(p.value('@id', 'varchar(23)'), 'process', '') ProcessID
				, p.value('@spid', 'int') SPID
				, p.value('@sbid', 'int') SBID
				, p.value('@ecid', 'int') ECID
				, p.value('@taskpriority', 'smallint') TaskPriority
				, p.value('@logused', 'bigint') LogUsed
				, p.value('@waitresource', 'varchar(1000)') WaitResource
				, p.value('@waittime', 'int') WaitTime
				, p.value('@ownerId', 'bigint') OwnerID
				, p.value('@transactionname', 'nvarchar(128)') TransactionName
				, p.value('@lasttranstarted', 'datetime') LastTranStarted
				, p.value('@XDES', 'varchar(100)') XDES
				, p.value('@lockMode', 'nvarchar(60)') LockMode
				, p.value('@schedulerid', 'smallint') SchedulerID
				, p.value('@kpid', 'bigint') KPID
				, p.value('@status', 'varchar(20)') [Status]
				, p.value('@priority', 'smallint') [Priority]
				, p.value('@trancount', 'tinyint') TranCount
				, p.value('@lastbatchstarted', 'datetime') LastBatchStarted
				, p.value('@lastbatchcompleted', 'datetime') LastBatchCompleted
				, p.value('@lastattention', 'datetime') LastAttention
				, p.value('@clientapp', 'nvarchar(128)') ClientApp
				, p.value('@hostname', 'nvarchar(128)') HostName
				, p.value('@hostpid', 'bigint') HostPID
				, p.value('@loginname', 'nvarchar(128)') LoginName
				, p.value('@isolationlevel', 'nvarchar(60)') IsolationLevel
				, p.value('@xactid', 'bigint') XactID
				, p.value('@currentdb', 'int') DatabaseID
				, db_name(p.value('@currentdb', 'int')) DatabaseName
				, p.value('@lockTimeout', 'bigint') LockTimeout
				, p.value('@clientoption1', 'int') ClientOption1
				, p.value('@clientoption2', 'int') ClientOption2
				, p.value('inputbuf[1]', 'nvarchar(max)') InputBuffer
			from Monitoring.Deadlocks
				cross apply DLK_Graph.nodes('/deadlock/process-list/process') t(p)
			where DLK_ID between @LastID + 1 and @ToID
			)
	insert into Monitoring.DeadlockProcesses(DLP_DLK_ID, DLP_ProcessID, DLP_SPID, DLP_SBID, DLP_ECID, DLP_TaskPriority, DLP_LogUsed, DLP_WaitResource, DLP_WaitTime, DLP_OwnerID, DLP_TransactionName,
												DLP_LastTranStarted, DLP_XDES, DLP_LockMode, DLP_SchedulerID, DLP_KPID, DLP_Status, DLP_Priority, DLP_TranCount, DLP_LastBatchStarted, DLP_LastBatchCompleted,
												DLP_LastAttention, DLP_ClientApp, DLP_HostName, DLP_HostPID, DLP_LoginName, DLP_IsolationLevel, DLP_XactID, DLP_DatabaseID, DLP_DatabaseName, DLP_LockTimeout,
												DLP_ClientOption1, DLP_ClientOption2, DLP_InputBuffer, DLP_IsVictim, DLP_ObjectName)
	select p.DLK_ID, p.ProcessID, SPID, SBID, ECID, TaskPriority, LogUsed, WaitResource, WaitTime, OwnerID, TransactionName, LastTranStarted, XDES, LockMode, SchedulerID, KPID, [Status], [Priority], TranCount,
		LastBatchStarted, LastBatchCompleted, LastAttention, ClientApp, HostName, HostPID, LoginName, IsolationLevel, XactID, DatabaseID, DatabaseName, LockTimeout, ClientOption1, ClientOption2, InputBuffer,
		case when v.ProcessID is null then 0 else 1 end IsVictim, ObjectName
	from Processes p
		left join Victims v on v.DLK_ID = p.DLK_ID
								and v.ProcessID = p.ProcessID
		outer apply Monitoring.fn_DeadlockParseObjectNameFromInputBuffer(InputBuffer)

	;with Input as
			(select DLK_ID
					, upper(replace(cast(r.query('fn:local-name(.)') AS varchar(100)), 'lock', '')) ResourceType
					, replace(r.value('@id', 'varchar(20)'), 'lock', '') ResourceID
					, r.value('@dbid', 'int') DatabaseID
					, r.value('@mode', 'nvarchar(60)') Mode
					, r.value('@subresource', 'varchar(30)') SubResource
					, r.value('@objid', 'int') ObjectID
					, r.value('@objectname', 'nvarchar(386)') ObjectName
					, r.value('@lockPartition', 'varchar(25)') LockPartition
					, r.value('@fileid', 'int') FileID
					, r.value('@pageid', 'int') PageID
					, r.value('@ASsociatedObjectId', 'bigint') ASsociatedObjectId
					, r.value('@hobtid', 'bigint') HOBT
					, r.value('@indexname', 'nvarchar(128)') IndexName
					, r.value('@databasePrincipalId', 'int') DatabasePrincipalID
					, r.value('@hash', 'varchar(100)') [Hash]
					, case when cast(r.query('fn:local-name(.)') AS varchar(100)) = 'metadatalock' then r.query('.') else null end MetadataLockInfo
				from Monitoring.Deadlocks
					cross apply DLK_Graph.nodes('/deadlock/resource-list/child::node()') t(r)
				where DLK_ID between @LastID + 1 and @ToID
			)
	insert into Monitoring.DeadlockResources(DLR_DLK_ID, DLR_DRT_ID, DLR_ResourceID, DLR_DatabaseID, DLR_Mode, DLR_SubResource, DLR_ObjectID, DLR_ObjectName, DLR_LockPartition, DLR_FileID, DLR_PageID,
											DLR_ASsociatedObjectId, DLR_HOBT, DLR_IndexName, DLR_DatabasePrincipalID, DLR_Hash, DLR_MetadataLockInfo)
	select DLK_ID, DRT_ID, ResourceID, DatabaseID, Mode, SubResource, ObjectID, ObjectName, LockPartition, FileID, PageID, ASsociatedObjectId, HOBT, IndexName, DatabasePrincipalID, [Hash], MetadataLockInfo
	from Input
		inner join Monitoring.DeadlockResourceTypes on DRT_Name = ResourceType

	;with Input as
			(select DLK_ID
					, replace(p.value('@id', 'varchar(23)'), 'process', '') ProcessID
					, f.value('@procname', 'nvarchar(386)') ProcName
					, f.value('@line', 'int') Line
					, f.value('@stmtstart', 'bigint') StmtStart
					, f.value('@stmtend', 'bigint') StmtEnd
					, convert(varbinary(64), f.value('@sqlhandle', 'varchar(76)'), 1) SQLHandle
				from Monitoring.Deadlocks
					cross apply DLK_Graph.nodes('/deadlock/process-list/process') t(p)
					cross apply p.nodes('executionStack/frame') t1(f)
				where DLK_ID between @LastID + 1 and @ToID
			)
	insert into Monitoring.DeadlockFrames(DRF_DLK_ID, DRF_DLP_ID, DRF_ProcName, DRF_Line, DRF_StmtStart, DRF_StmtEnd, DRF_SQLHandle)
	select DLK_ID, DLP_ID, ProcName, Line, StmtStart, StmtEnd, SQLHandle
	from Input
		inner join Monitoring.DeadlockProcesses on DLP_DLK_ID = DLK_ID
													and DLP_ProcessID = ProcessID

	;with Input as
			(select DLK_ID, DLK_Graph
				from Monitoring.Deadlocks
				where DLK_ID between @LastID + 1 and @ToID
			)
		, Input1 as
			(select DLK_ID
					, 1 IsOwner
					, replace(o.value('@id', 'varchar(23)'), 'process', '') ProcessID
					, replace(r.value('@id', 'varchar(20)'), 'lock', '') ResourceID
					, o.value('@mode', 'nvarchar(60)') Mode
					, cast(null as nvarchar(60)) RequestType
				from Input
					cross apply DLK_Graph.nodes('/deadlock/resource-list//owner-list/owner') t(o)
					cross apply o.nodes('../..') t1(r)
				union all
				select DLK_ID
					, 0 IsOwner
					, replace(w.value('@id', 'varchar(23)'), 'process', '') ProcessID
					, replace(r.value('@id', 'varchar(20)'), 'lock', '') ResourceID
					, w.value('@mode', 'nvarchar(60)') Mode
					, w.value('@requestType', 'nvarchar(60)') RequestType
				from Input
					cross apply DLK_Graph.nodes('/deadlock/resource-list//waiter-list/waiter') t(w)
					cross apply w.nodes('../..') t1(r)
			)
	insert into Monitoring.DeadlockProcessResources(DPR_DLK_ID, DPR_DLP_ID, DPR_DLR_ID, DPR_IsOwner, DPR_Mode, DPR_RequestType)
	select DLK_ID, DLP_ID, DLR_ID, IsOwner, Mode, RequestType
	from Input1
		inner join Monitoring.DeadlockProcesses on DLP_DLK_ID = DLK_ID
													and DLP_ProcessID = ProcessID
		inner join Monitoring.DeadlockResources on DLR_DLK_ID = DLK_ID
													and DLR_ResourceID = ResourceID

	exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
										@Info1 = @ToID,
										@Finalize = 1
	commit transaction
end try
begin catch
	if @@TRANCOUNT > 0
		rollback transaction
	set @ErrorMessage = ERROR_MESSAGE()

	exec OpsControl.usp_LogOperation @OPL_ID = @OPL_ID,
										@ErrorMessage = @ErrorMessage,
										@Finalize = 1
end catch

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [OpsControl].[usp_LogOperation]',10,1) WITH NOWAIT;
if object_id('OpsControl.usp_LogOperation') is null exec('create procedure [OpsControl].[usp_LogOperation] as select getdate() DT')
GO
  alter procedure OpsControl.usp_LogOperation
	@OPL_ID int output,
	@OPS_ID smallint = null,
	@Identifier1 int = null,
	@Identifier2 int = null,
	@Info1 sql_variant = null,
	@Info2 sql_variant = null,
	@Info3 sql_variant = null,
	@ErrorMessage nvarchar(4000) = null,
	@Finalize bit = 0
WITH ENCRYPTION
as
set nocount on
declare @EndDateTime datetime2(3)

if not exists (select * from Licensing.fn_ValidateLicense()) return

if @Finalize = 1
	set @EndDateTime = sysdatetime()

if @OPL_ID is null
begin
	insert into OpsControl.OperationLog(OPL_OPS_ID, OPL_Identifier1, OPL_Identifier2, OPL_EndDateTime, OPL_Info1, OPL_Info2, OPL_Info3, OPL_ErrorMessage)
	values(@OPS_ID, @Identifier1, @Identifier2, @EndDateTime, @Info1, @Info2, @Info3, @ErrorMessage)

	set @OPL_ID = scope_identity()
end
else
	update OpsControl.OperationLog
	set OPL_EndDateTime = @EndDateTime,
		OPL_Info1 = @Info1,
		OPL_Info2 = @Info2,
		OPL_Info3 = @Info3,
		OPL_ErrorMessage = @ErrorMessage
	where OPL_ID = @OPL_ID

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [OpsControl].[usp_RunOperations]',10,1) WITH NOWAIT;
if object_id('OpsControl.usp_RunOperations') is null exec('create procedure [OpsControl].[usp_RunOperations] as select getdate() DT')
GO
  alter procedure OpsControl.usp_RunOperations
WITH ENCRYPTION
as
declare @Script nvarchar(max)

if not exists (select * from Licensing.fn_ValidateLicense()) return

declare cOperations cursor static forward_only for
	select replace(OPS_Script, '%OPS_ID%', cast(OPS_ID as nvarchar(10)))
	from OpsControl.Operations
		outer apply (select EndDateTime
						from OpsControl.fn_GetLastLogRecord(OPS_ID, default, default, default, default, default)) m
	where OPS_IsActive = 1
		and (EndDateTime is null
			or datediff(minute, EndDateTime, sysdatetime()) >= OPS_MinutesInterval
			)

open cOperations
fetch next from cOperations into @Script
while @@FETCH_STATUS = 0
begin
	exec(@Script)
	fetch next from cOperations into @Script
end
close cOperations
deallocate cOperations

GO


RAISERROR('	CREATING OR ALTERING PROCEDURE [perf].[pCPU_Insert]',10,1) WITH NOWAIT;
if object_id('perf.pCPU_Insert') is null exec('create procedure [perf].[pCPU_Insert] as select getdate() DT')
GO
  
/*********************************************************************************************************************
*	[perf].[pCPU_Insert]
*
*	Purpose: Inserts CPU information into the perf.cpu table
*
*	Inputs:	None
*
*	Notes:	
*		
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	2/7/2017			Keith Buck				Initial Creation
*	2/16/2018			Keith Buck				Insert into cpu columns which are tinyint could be less than 0 which 
*												causes an arthimetic overflow. Added a case to make anything negative 0.
*   4/15/2019			Keith Buck				Added a try catch including outputing the parameter used in the query to ease in trouble shooting. Not going to 
*												throw or raise the error back as we don't want a failure of this proc to cause a job failure.
*
*  For more scripts and sample code, check out 
*    http://www.FORTIFIEDATA.com
*
*  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
*  PARTICULAR PURPOSE.	
*********************************************************************************************************************/
ALTER PROCEDURE perf.pCPU_Insert
WITH ENCRYPTION
AS
SET NOCOUNT ON
exec dbo.usp_UpdateVersionStatics
DECLARE @ts_now				BIGINT 
DECLARE @lastcreated		DATETIME
DECLARE @msg				VARCHAR(2048)

SELECT @lastcreated = ISNULL(MAX(CreatedOn),'1/1/1900') FROM perf.CPU WHERE InstanceName = @@SERVERNAME
SET @lastcreated = DATEADD(SECOND,3,@lastcreated) 


SELECT @ts_now = cpu_ticks/(cpu_ticks/ms_ticks)FROM sys.dm_os_sys_info; 
--ADDED CASE STATEMENTS ON PROCESSOR VALUE INSERTS AS THEY ARE INTEGERS AND CAN BE NEGATIVE
--HOWEVER THEY ARE BEING INSERTED INTO TINYINT COLUMNS (TO SAVE SPACE) THAT CANNOT TAKE NEGATIVE NUMBER
BEGIN TRY
	INSERT INTO perf.CPU (InstanceName,  CreatedOn, SQLCpu, OtherCpu )
	SELECT 
			@@SERVERNAME, 
			DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()),
			CASE WHEN SQLProcessUtilization < 0 THEN 0 ELSE SQLProcessUtilization END,
				CASE WHEN 100 - SystemIdle - SQLProcessUtilization < 0 THEN 0
				ELSE 100 - SystemIdle - SQLProcessUtilization  END 
	FROM ( 
			SELECT record.value('(./Record/@id)[1]', 'int') AS record_id, 
				record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') 
				AS [SystemIdle], 
				record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 
				'int') 
				AS [SQLProcessUtilization], [timestamp] 
			FROM ( 
				SELECT [timestamp], CONVERT(xml, record) AS [record] 
				FROM sys.dm_os_ring_buffers 
				WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
				AND record LIKE N'%<SystemHealth>%') AS x 
			) AS y 
	WHERE
		DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) > @lastcreated
		--ADDED THIS LINE AS A WAY TO AVOID THE DUPLICATE ERROR 		
		AND DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) NOT IN(SELECT top 256 CreatedOn from perf.CPU ORDER BY CreatedOn  DESC)
	ORDER BY 
			DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) OPTION (RECOMPILE);
END TRY
BEGIN CATCH --just going to handle the erorr and move on, this proc should not cause an error in the job
	SET @msg = 'Error occurred In Proc pCPU_Insert, param @lastcreated value: ' + CONVERT(VARCHAR(30),@lastcreated,121) + '. Error msg is: ' + ERROR_MESSAGE()
	RAISERROR(@msg,10,1) WITH NOWAIT;
END CATCH

GO


truncate table dbo.WaitStatType
INSERT INTO dbo.WaitStatType(Name) select DISTINCT wait_type FROM sys.dm_os_wait_stats ;
--UPDATE THE CanIgnore COLUMN
UPDATE dbo.WaitStatType
	SET CanIgnore = 1
WHERE Name in	(N'CLR_SEMAPHORE',N'LAZYWRITER_SLEEP',N'RESOURCE_QUEUE',N'SLEEP_TASK',
N'SLEEP_SYSTEMTASK',N'SQLTRACE_BUFFER_FLUSH',N'WAITFOR',N'LOGMGR_QUEUE',N'CHECKPOINT_QUEUE',
N'REQUEST_FOR_DEADLOCK_SEARCH',N'XE_TIMER_EVENT',N'BROKER_TO_FLUSH',N'BROKER_TASK_STOP',N'CLR_MANUAL_EVENT',
N'CLR_AUTO_EVENT',N'DISPATCHER_QUEUE_SEMAPHORE',N'FT_IFTS_SCHEDULER_IDLE_WAIT',N'XE_DISPATCHER_WAIT',
N'XE_DISPATCHER_JOIN',N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP',N'ONDEMAND_TASK_QUEUE',N'BROKER_EVENTHANDLER',
N'SLEEP_BPOOL_FLUSH',N'DBMIRROR_EVENTS_QUEUE',N'DBMIRRORING_CMD',N'FT_IFTSHC_MUTEX')
GO


declare @Path nvarchar(4000)
exec Infra.usp_GetRegistryValue @KeyName = 'CPE',
								@ValueName = 'ErrorDumpDir',
								@Value = @Path output
merge Auditing.AuditSessions
using (values(1, Infra.fn_Slash(@Path) + 'FDAudit', 0)) s(SessionID, StoragePath, IsActive)
	on ASE_AUT_ID = SessionID
when not matched by target then insert(ASE_AUT_ID, ASE_StoragePath, ASE_IsActive)
								values(SessionID, StoragePath, IsActive);
GO


;with DefaultAuditEvents as
		(select *
		from (values('sqlserver.error_reported',
					'sqlserver.server_instance_name,sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.is_system,sqlserver.server_principal_name,sqlserver.session_id,sqlserver.session_server_principal_name,sqlserver.sql_text,sqlserver.username',
					'([package0].[equal_int64]([error_number],(15457)) or [package0].[equal_int64]([error_number],(5084))) and not [sqlserver].[like_i_sql_unicode_string]([message],N''%show advanced options%'')',
					'Server and database level configuration changes')
				, ('sqlserver.object_created',
					'sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.is_system,sqlserver.server_instance_name,sqlserver.server_principal_name,sqlserver.session_id,sqlserver.session_server_principal_name,sqlserver.sql_text,sqlserver.username',
					'[package0].[equal_uint64]([ddl_phase],(1)) AND [package0].[not_equal_uint64]([database_id],(2)) AND [sqlserver].[not_equal_i_sql_unicode_string]([object_name],N''telemetry_xevents'') AND [package0].[not_equal_uint64]([object_type],(21587)) AND [package0].[not_equal_uint64]([object_type],(16964)) AND [sqlserver].[not_equal_i_sql_unicode_string]([sqlserver].[client_app_name],N''SQLServerCEIP'')',
					null)
				, ('sqlserver.object_altered',
					'sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.is_system,sqlserver.server_instance_name,sqlserver.server_principal_name,sqlserver.session_id,sqlserver.session_server_principal_name,sqlserver.sql_text,sqlserver.username',
					'[package0].[equal_uint64]([ddl_phase],(1)) AND [package0].[not_equal_uint64]([database_id],(2)) AND [sqlserver].[not_equal_i_sql_unicode_string]([object_name],N''telemetry_xevents'') AND [package0].[not_equal_uint64]([object_type],(21587)) AND [package0].[not_equal_uint64]([object_type],(16964)) AND [sqlserver].[not_equal_i_sql_unicode_string]([sqlserver].[client_app_name],N''SQLServerCEIP'')',
					null)
				, ('sqlserver.object_deleted',
					'sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.is_system,sqlserver.server_instance_name,sqlserver.server_principal_name,sqlserver.session_id,sqlserver.session_server_principal_name,sqlserver.sql_text,sqlserver.username',
					'[package0].[equal_uint64]([ddl_phase],(1)) AND [package0].[not_equal_uint64]([database_id],(2)) AND [sqlserver].[not_equal_i_sql_unicode_string]([object_name],N''telemetry_xevents'') AND [package0].[not_equal_uint64]([object_type],(21587)) AND [package0].[not_equal_uint64]([object_type],(16964)) AND [sqlserver].[not_equal_i_sql_unicode_string]([sqlserver].[client_app_name],N''SQLServerCEIP'')',
					null)
				,('APPLICATION_ROLE_CHANGE_PASSWORD_GROUP', null, null, null)
				,('AUDIT_CHANGE_GROUP', null, null, null)
				,('DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP', null, null, null)
				,('DATABASE_OBJECT_PERMISSION_CHANGE_GROUP', null, null, null)
				,('DATABASE_OWNERSHIP_CHANGE_GROUP', null, null, null)
				,('DATABASE_PERMISSION_CHANGE_GROUP', null, null, null)
				,('DATABASE_PRINCIPAL_CHANGE_GROUP', null, null, null)
				,('DATABASE_ROLE_MEMBER_CHANGE_GROUP', null, null, null)
				,('LOGIN_CHANGE_PASSWORD_GROUP', null, null, null)
				,('SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP', null, null, null)
				,('SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP', null, null, null)
				,('SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP', null, null, null)
				,('SERVER_OBJECT_PERMISSION_CHANGE_GROUP', null, null, null)
				,('SERVER_PERMISSION_CHANGE_GROUP', null, null, null)
				,('SERVER_PRINCIPAL_CHANGE_GROUP', null, null, null)
				,('SERVER_ROLE_MEMBER_CHANGE_GROUP', null, null, null)
			) e(EventType, EventDetails, EventFilter, EventDescription)
		)
merge Auditing.AuditTemplateEvents
using (select AET_ID, EventDescription, EventDetails, EventFilter
		from DefaultAuditEvents
			inner join Auditing.EventTypes on AET_Name = EventType) s
	on ATE_AUT_ID = 1
		and ATE_AET_ID = AET_ID
		and (ATE_Description = EventDescription
				or (ATE_Description is null
						and EventDescription is null
					)
			)
when matched and ATE_AddedColumns <> EventDetails
				or ATE_Filter <> EventFilter
	then update set ATE_AddedColumns = EventDetails,
							ATE_Filter = EventFilter
when not matched by target then insert(ATE_AUT_ID, ATE_AET_ID, ATE_Description, ATE_AddedColumns, ATE_Filter, ATE_IsActive)
								values(1, AET_ID, EventDescription, EventDetails, EventFilter, 1);
GO


merge Auditing.AuditTemplates
using (values(1, 'FD_Default_Audit')
	) s(AuditID, AuditName)
	on AUT_ID = AuditID
when not matched by target then insert(AUT_ID, AUT_Name)
								values(AuditID, AuditName);
GO


merge Auditing.AuditTrailValueTypes
using (values(1, 'Event Type'),
				(2, 'Server Instance Name'),
				(3, 'Object Type'),
				(4, 'Database Name'),
				(5, 'Server Login name'),
				(6, 'Session Login name'),
				(7, 'Username'),
				(8, 'Host Name'),
				(9, 'Application Name')) s(TypeID, TypeName)
	on AVT_ID = TypeID
when not matched by target then insert(AVT_ID, AVT_Name)
								values(TypeID, TypeName);
GO


merge Auditing.EventSourceTypes
using (values(1, 'Extended Events'),
			(2, 'Server Audit')
		) s(TypeID, TypeName)
	on AES_ID = TypeID
when not matched by target then insert(AES_ID, AES_Name)
								values(TypeID, TypeName);
GO


merge Auditing.EventTypes
using (values(1, 1, 'sqlserver.error_reported'),
				(2, 1, 'sqlserver.object_altered'),
				(3, 1, 'sqlserver.object_created'),
				(4, 1, 'sqlserver.object_deleted'),
				(5, 2, 'DATABASE_ROLE_MEMBER_CHANGE_GROUP'),
				(6, 2, 'SERVER_ROLE_MEMBER_CHANGE_GROUP'),
				(7, 2, 'AUDIT_CHANGE_GROUP'),
				(8, 2, 'DATABASE_PERMISSION_CHANGE_GROUP'),
				(9, 2, 'DATABASE_OBJECT_PERMISSION_CHANGE_GROUP'),
				(10, 2, 'SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP'),
				(11, 2, 'SERVER_OBJECT_PERMISSION_CHANGE_GROUP'),
				(12, 2, 'SERVER_PERMISSION_CHANGE_GROUP'),
				(13, 2, 'DATABASE_PRINCIPAL_CHANGE_GROUP'),
				(14, 2, 'SERVER_PRINCIPAL_CHANGE_GROUP'),
				(15, 2, 'APPLICATION_ROLE_CHANGE_PASSWORD_GROUP'),
				(16, 2, 'LOGIN_CHANGE_PASSWORD_GROUP'),
				(17, 2, 'DATABASE_OWNERSHIP_CHANGE_GROUP'),
				(18, 2, 'DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP'),
				(19, 2, 'SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP'),
				(20, 2, 'SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP')
		) s(EventID, EventSource, EventName)
	on AET_ID = EventID
when not matched by target then insert(AET_ID, AET_AES_ID, AET_Name)
								values(EventID, EventSource, EventName);
GO


merge dbo.BackupReportExclusion d
using (values(N'model', 1, 1)) s(DatabaseName, ExcludeLog, ExcludeDiff)
	on s.DatabaseName = d.DatabaseName
when not matched by target then insert(DatabaseName, ExcludeLog, ExcludeDiff)
								values(s.DatabaseName, s.ExcludeLog, s.ExcludeDiff);


BEGIN TRAN
INSERT dbo.config_fddba2_history 
	SELECT * FROM dbo.config_fddba2 WHERE ISDATE(domain) = 1
DELETE dbo.config_fddba2 WHERE ISDATE(domain) = 1
COMMIT TRAN
GO
CREATE TABLE #temp (sprocline nvarchar(4000))

DECLARE @utcdt datetime
DECLARE @ldt datetime
DECLARE @dbdt datetime
DECLARE @version varchar(20)
DECLARE @upgrade_count int
DECLARE @offset_minutes int 
DECLARE @minutes int 
DECLARE @name varchar(50)
DECLARE @domain varchar(100)
SELECT @ldt = ldt, @utcdt = utcdt FROM #fddba_script_time
SELECT TOP 1 @version = a FROM #fddba_version
SELECT @dbdt = create_date FROM sys.databases WHERE database_id = DB_ID()

IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2_history WHERE [name] = 'fddba\setup')
BEGIN
	IF @version IS NULL
	BEGIN
		--initial install
		SET @name = 'fddba\setup'
	END
	ELSE
	BEGIN
		IF NOT EXISTS (SELECT 1 FROM dbo.config_fddba2_history WHERE [name] = 'fddba setup')
			AND NOT EXISTS(SELECT 1 FROM dbo.config_fddba2_history WHERE [name] LIKE 'fddba\upgrade\%' AND [value] = @version)
		BEGIN
			--original install was before version 1.1.0040 so just insert the prior value as the initial setup
			INSERT dbo.config_fddba2_history ([name], [domain], [value]) VALUES ('fddba\setup', CONVERT(varchar(23), @dbdt, 126), @version)
			SET @upgrade_count = 1
		END
		ELSE
		BEGIN
			--change old "fddba setup" to "fddba\upgrade\<number>"
			SET @upgrade_count = 1
			DECLARE fddba_setup_cur CURSOR FOR
				SELECT [domain] FROM dbo.config_fddba2_history WHERE [name] = 'fddba setup' ORDER BY CreatedOn
			OPEN fddba_setup_cur
			FETCH NEXT FROM fddba_setup_cur INTO @domain

			WHILE @@FETCH_STATUS != -1
			BEGIN
				UPDATE dbo.config_fddba2_history
					SET [name] = 'fddba\upgrade\' + LTRIM(STR(@upgrade_count))
					WHERE [name] = 'fddba setup' and [domain] = @domain
					
				SET @upgrade_count = @upgrade_count + 1
				FETCH NEXT FROM fddba_setup_cur INTO @domain
			END

			DEALLOCATE fddba_setup_cur
		END
	END
END

IF @name IS NULL
BEGIN
	--upgrade
	SET @domain = NULL
	SELECT @domain = MAX([domain]) FROM dbo.config_fddba2_history WHERE [name] LIKE 'fddba\upgrade\%'
	--do not need to check if @domain is null as if so then @name will be null and is handled below
	SELECT @name = [name] FROM dbo.config_fddba2_history WHERE [name] LIKE 'fddba\upgrade\%' AND [domain] = @domain
	IF @name IS NOT NULL
		SET @upgrade_count = CONVERT(int, SUBSTRING(@name, 15, LEN(@name))) + 1
	ELSE
		SET @upgrade_count = 1

	SET @name = 'fddba\upgrade\' + LTRIM(STR(@upgrade_count))
END

EXEC FDDBA.dbo.FDDBA_Get_Version @version OUTPUT
IF @version IS NULL
	SET @version = 'UNKNOWN-2'
--insert current 
INSERT dbo.config_fddba2_history ([name], [domain], [value]) VALUES (@name, CONVERT(varchar(23), @utcdt, 126), ISNULL(@version, 'ver: (null)'))
INSERT dbo.config_fddba2_history ([name], [domain], [value]) VALUES ('SQL Version', CONVERT(varchar(23), @utcdt, 126), CONVERT(varchar(20),SERVERPROPERTY('ProductVersion')) + ' ' + CONVERT(varchar(100),SERVERPROPERTY('Edition')))

IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2_history WHERE [name] = 'fddba\setup')
BEGIN
	INSERT dbo.config_fddba2_history ([name], [domain], [value]) VALUES ('fddba\setup', CONVERT(varchar(23), @dbdt, 126), 'UNKNOWN')
END
GO

--Check to see if missing data and parsing should be performed
DECLARE @dt datetime
DECLARE @version varchar(20)
SELECT @dt = utcdt FROM #fddba_script_time
SELECT TOP 1 @version = a FROM #fddba_version
DECLARE @row_state bigint = 0
IF NOT EXISTS (SELECT 1 FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'profile_name' and [domain] = 'fddba\pStartUpCheck')
BEGIN
	SET @row_state = @row_state + 1
END
IF NOT EXISTS (SELECT 1 FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'recipients' and [domain] = 'fddba\pStartUpCheck')
BEGIN
	SET @row_state = @row_state + 2
END
IF NOT EXISTS (SELECT 1 FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'file_attachments' and [domain] = 'fddba\pStartUpCheck')
BEGIN
	SET @row_state = @row_state + 4
END
IF NOT EXISTS (SELECT 1 FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'IncludeSpaceReport' and [domain] = 'fddba\pStartUpCheck')
BEGIN
	SET @row_state = @row_state + 8
END
IF NOT EXISTS (SELECT 1 FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'FreeSpaceWarningPercent' and [domain] = 'fddba\pStartUpCheck')
BEGIN
	SET @row_state = @row_state + 16
END
IF EXISTS (SELECT 1 FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'parameters' and [domain] = 'fddba\dbmail')
BEGIN
	SET @row_state = @row_state & 0xF8
END
IF EXISTS (SELECT 1 FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'parameters' and [domain] = 'fddba\pStartUpCheck4')
BEGIN
	SET @row_state = @row_state & 0xE7
END

--PRINT 'RS=' +  STR(@row_state)
IF @row_state > 0
BEGIN
	--parse data
	DECLARE @parse_state bigint = 0
	DECLARE @sproc varchar(50)
	DECLARE @msg varchar(100)

	DECLARE @profile nvarchar(4000)
	DECLARE @recip nvarchar(4000)
	DECLARE @file_attach nvarchar(4000)
	DECLARE @incspacerpt nvarchar(4000)
	DECLARE @freespacewarnprcnt nvarchar(4000)
	DECLARE @sql nvarchar(4000)
	
	IF OBJECT_ID('dbo.config_fddba','U') IS NOT NULL
	BEGIN
		--PRINT 'attempt to pull old data from old config table'
		IF EXISTS (SELECT 1 FROM dbo.config_fddba) 
		BEGIN
			IF EXISTS (SELECT 1 FROM sys.columns WHERE [object_id] = OBJECT_ID('dbo.config_fddba','U') AND name = 'includespacereport')
			BEGIN
				SET @parse_state = 1
				SET @sql = '
				SELECT TOP 1 @p1 = dbmail_profile,
						@p2 = dbmail_recipients,
						@p3 = dbmail_attachment,
						@p4 = includespacereport,
						@p5 = freespacewarningpercent
					FROM dbo.config_fddba'
				EXEC sp_executesql @sql, N'@p1 nvarchar(4000) OUTPUT, @p2 nvarchar(4000) OUTPUT, @p3 nvarchar(4000) OUTPUT, @p4 nvarchar(4000) OUTPUT, @p5 nvarchar(4000) OUTPUT',
					@p1 = @profile OUTPUT, @p2 = @recip OUTPUT, @p3 = @file_attach OUTPUT, @p4 = @incspacerpt OUTPUT, @p5 = @freespacewarnprcnt OUTPUT
			END
			ELSE
			BEGIN
				SET @parse_state = 2
				SET @sql = '
				SELECT TOP 1 @p1 = dbmail_profile,
						@p2 = dbmail_recipients,
						@p3 = dbmail_attachment
					FROM dbo.config_fddba'
				EXEC sp_executesql @sql, N'@p1 nvarchar(4000) OUTPUT, @p2 nvarchar(4000) OUTPUT, @p3 nvarchar(4000) OUTPUT',
					@p1 = @profile OUTPUT, @p2 = @recip OUTPUT, @p3 = @file_attach OUTPUT
			END
		END
	END

	IF EXISTS (SELECT 1 FROM master.sys.objects WHERE object_id = OBJECT_ID(N'[master].[dbo].[pStartUpCheck]') AND [type] in (N'P', N'PC'))
		OR EXISTS (SELECT 1 FROM master.sys.objects WHERE object_id = OBJECT_ID(N'[master].[dbo].[pStatUpCheck]') AND [type] in (N'P', N'PC'))
	BEGIN
		--PRINT 'attempt to pull old data from prior sproc'
		DECLARE @rowcount int
		IF EXISTS (SELECT 1 FROM master.sys.objects WHERE object_id = OBJECT_ID(N'[master].[dbo].[pStartUpCheck]') AND [type] in (N'P', N'PC'))
		BEGIN
			INSERT #temp EXEC ('USE [master]; EXEC sp_helptext ''dbo.pStartUpCheck''')
			SET @rowcount = @@ROWCOUNT
			SET @sproc = 'pStartUpCheck'
		END
		ELSE
		BEGIN
			INSERT #temp EXEC ('USE [master]; EXEC sp_helptext ''dbo.pStatUpCheck''')
			SET @rowcount = @@ROWCOUNT
			SET @sproc = 'pStatUpCheck'
		END

		DECLARE @p0 int
		DECLARE @p1 int
		DECLARE @p2 int

		IF @@ROWCOUNT > 0
		--IF @rowcount > 0
		BEGIN
			DECLARE @tempprofile nvarchar(4000)
			DECLARE @temprecip nvarchar(4000)
			DECLARE @tempfile_attach nvarchar(4000)
			DECLARE @tempincspacerpt nvarchar(4000)
			DECLARE @tempfreespacewarnprcnt nvarchar(4000)

			SELECT TOP 1 @tempprofile = sprocline FROM #temp WHERE sprocline like '%@profile_name%'
			SELECT TOP 1 @temprecip = sprocline FROM #temp WHERE sprocline like '%@recipients%'
			SELECT TOP 1 @tempfile_attach = sprocline FROM #temp WHERE sprocline like '%@file_attachments%'
			SELECT TOP 1 @tempincspacerpt = sprocline from #temp WHERE sprocline LIKE '%@IncludeSpaceReport%'
			SELECT TOP 1 @tempfreespacewarnprcnt = sprocline from #temp WHERE sprocline LIKE '%@FreeSpaceWarningPercent%'


			IF @profile IS NULL
			BEGIN
				SET @p0 = CHARINDEX('''', @tempprofile)
				IF @p0 > 0
				BEGIN
					SET @p0 = @p0 + 1
					SET @p1 = CHARINDEX('''', @tempprofile, @p0)
					IF @p1 > @p0 --@p1 > 0 is implied here
					BEGIN
						SET @parse_state = @parse_state + 4
						SET @profile = SUBSTRING(@tempprofile, @p0, @p1 - @p0)
					END
				END
			END
		
			IF @recip IS NULL
			BEGIN
				SET @p0 = CHARINDEX('''', @temprecip)
				IF @p0 > 0
				BEGIN
					SET @p0 = @p0 + 1
					SET @p1 = CHARINDEX('''', @temprecip, @p0)
					IF @p1 > @p0 --@p1 > 0 is implied here
					BEGIN
						SET @parse_state = @parse_state + 8
						SET @recip = SUBSTRING(@temprecip, @p0, @p1 - @p0)
					END
				END
			END
		
			IF @file_attach IS NULL
			BEGIN
				SET @p0 = CHARINDEX('''', @tempfile_attach)
				IF @p0 > 0
				BEGIN
					SET @p0 = @p0 + 1
					SET @p1 = CHARINDEX('''', @tempfile_attach, @p0)
					IF @p1 > @p0 --@p1 > 0 is implied here
					BEGIN
						SET @parse_state = @parse_state + 16
						SET @file_attach = SUBSTRING(@tempfile_attach, @p0, @p1 - @p0)
					END
				END
			END

			IF @incspacerpt IS NULL
			BEGIN
				SET @p0 = CHARINDEX('@IncludeSpaceReport', @tempincspacerpt)
				IF @p0 > 0
				BEGIN
					SET @p1 = CHARINDEX('=', @tempincspacerpt, @p0)
					IF @p1 > 0
					BEGIN
						SET @p1 = @p1 + 1
						SET @p2 = CHARINDEX(',', @tempincspacerpt, @p1)
						IF @p2 > @p1 --@p2 > 0 is implied here
						BEGIN
							SET @parse_state = @parse_state + 32
							SET @incspacerpt = SUBSTRING(@tempincspacerpt, @p1, @p2 - @p1)

							IF ISNUMERIC(@incspacerpt) = 0
							BEGIN
								SET @incspacerpt = NULL
							END
							ELSE
							BEGIN
								IF CONVERT(bigint, @incspacerpt) NOT IN (0,1)
								BEGIN
									SET @parse_state = @parse_state + 64
									SET @incspacerpt = NULL
								END
							END
						END
					END
				END
			END

			IF @freespacewarnprcnt IS NULL
			BEGIN
				SET @p0 = CHARINDEX('@FreeSpaceWarningPercent', @tempfreespacewarnprcnt)
				IF @p0 > 0
				BEGIN
					SET @p1 = CHARINDEX('=', @tempfreespacewarnprcnt, @p0)
					IF @p1 > 0
					BEGIN
						SET @parse_state = @parse_state + 128
						SET @p1 = @p1 + 1
						SET @p2 = LEN(@tempfreespacewarnprcnt)
						SET @freespacewarnprcnt = LTRIM(RTRIM(REPLACE(REPLACE(SUBSTRING(@tempfreespacewarnprcnt, @p1, @p2), CHAR(10), ''), CHAR(13), '')))

						IF ISNUMERIC(@freespacewarnprcnt) = 0
						BEGIN
							SET @freespacewarnprcnt = NULL
						END
						ELSE
						BEGIN
							IF CONVERT(bigint, @freespacewarnprcnt) NOT BETWEEN 0 AND 100
							BEGIN
								SET @parse_state = @parse_state + 256
								SET @freespacewarnprcnt = NULL
							END
						END
					END
				END
			END
		END
		ELSE
		BEGIN
			SET @msg = 'WARNING: NO ROWS FROM [' + ISNULL(@sproc, '(null)') + '] procedure!!'
			RAISERROR (@msg,11,1) WITH NOWAIT
		END
	END

	IF @profile IS NULL OR @recip IS NULL OR @file_attach IS NULL OR @incspacerpt IS NULL OR @freespacewarnprcnt IS NULL
	BEGIN
		--PRINT 'use sample data'
		SET @parse_state = @parse_state + 512
		RAISERROR ('Inserting sample values please confirm following values are correct and if not update them:',10,1)

		IF @profile IS NULL
		BEGIN
			SET @parse_state = @parse_state + 1024
			SET @profile = 'Agent Mail'
		END
		IF @recip IS NULL
		BEGIN
			SET @parse_state = @parse_state + 2048
			SET @recip = 'support@fortifieddata.com'
		END
		IF @file_attach IS NULL
		BEGIN
			SET @parse_state = @parse_state + 4096
			SET @file_attach = '\\REPLACESERVER\REPLACESHARE\fdlogo.png'
		END
		IF @incspacerpt IS NULL
		BEGIN
			SET @parse_state = @parse_state + 8192
			SET @incspacerpt = '1'
		END
		IF @freespacewarnprcnt IS NULL
		BEGIN
			SET @parse_state = @parse_state + 16384
			SET @freespacewarnprcnt ='10'
		END
	END

	IF @parse_state > 0
	BEGIN
		SET @msg = 'Data inserted into dbo.config_fddba2 (State=' + LTRIM(STR(ISNULL(@parse_state, -1))) + ')'
		RAISERROR (@msg,10,1)

		IF @parse_state NOT IN (1, 188) --188 is sum of correct parsing from startup proc
		BEGIN
			RAISERROR ('WARNING: Please check following values due to unexpected parsing!!!',10,1)
		END
		
		IF @row_state & 1 = 1 AND @profile IS NOT NULL
		BEGIN
			INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES ('profile_name', 'fddba\pStartUpCheck', @profile)
		END

		IF @row_state & 2 = 2 AND @recip IS NOT NULL
		BEGIN
			INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES ('recipients', 'fddba\pStartUpCheck', @recip)
		END

		IF @row_state & 4 = 4 AND @file_attach IS NOT NULL
		BEGIN
			INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES ('file_attachments', 'fddba\pStartUpCheck', @file_attach)
		END
		
		IF @row_state & 8 = 8 AND @incspacerpt IS NOT NULL
		BEGIN
			INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES ('IncludeSpaceReport', 'fddba\pStartUpCheck', @incspacerpt)
		END
		
		IF @row_state & 16 = 16 AND @freespacewarnprcnt IS NOT NULL
		BEGIN
			INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES ('FreeSpaceWarningPercent', 'fddba\pStartUpCheck', @freespacewarnprcnt)
		END

		INSERT dbo.config_fddba2_history ([name], [domain], [value]) VALUES ('fddba pStartUpCheck parsing', CONVERT(varchar(23), @dt, 126), 'rs: ' + LTRIM(STR(ISNULL(@row_state,-1))) + ', ps: ' + LTRIM(STR(ISNULL(@parse_state,-1))) + ', ' + ISNULL(@version,'ver: (null)'))
	END
END
--PRINT 'PS=' +  STR(@parse_state)
GO

--setup suggested trace flags (comma separated list (with trailing comma), using valuebig in XML format for ease of use to document reasons)
--UPDATED 3/8/2019 to check version and remove 1117,1118 for 2017 and greater
IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = 'trace_flags_suggested' AND [domain] = 'fddba\pMigrateTraceFlags')
BEGIN
	
	IF (select VerDec from #FDVER) >= 14
	BEGIN
		INSERT dbo.config_fddba2 ([name], [domain], [value], [comment]) 
			VALUES ('trace_flags_suggested','fddba\pMigrateTraceFlags','1204=1,1222=1,3226=1,4199=1,',
			'<CONFIG><1117>When a file in the filegroup meets the autogrow threshold, all files in the filegroup grow. Note: Starting with SQL Server 2016 this behavior is controlled by the AUTOGROW_SINGLE_FILE and AUTOGROW_ALL_FILES option of ALTER DATABASE, and trace flag 1117 has no effect.</1117><1118>MSKB328551</1118><1204>Write deadlocks to errorlog</1204><1222>Write deadlocks to errorlog</1222><3226>Suppress successful backup messages</3226><4199>Enable Query Optimizer changes</4199></CONFIG>')
	END
	ELSE
	BEGIN
		INSERT dbo.config_fddba2 ([name], [domain], [value], [comment]) 
			VALUES ('trace_flags_suggested','fddba\pMigrateTraceFlags','1117=1,1118=1,1204=1,1222=1,3226=1,4199=1,',
			'<CONFIG><1117>When a file in the filegroup meets the autogrow threshold, all files in the filegroup grow. Note: Starting with SQL Server 2016 this behavior is controlled by the AUTOGROW_SINGLE_FILE and AUTOGROW_ALL_FILES option of ALTER DATABASE, and trace flag 1117 has no effect.</1117><1118>MSKB328551</1118><1204>Write deadlocks to errorlog</1204><1222>Write deadlocks to errorlog</1222><3226>Suppress successful backup messages</3226><4199>Enable Query Optimizer changes</4199></CONFIG>')
	END
END
--ELSE
--BEGIN
--	IF (select VerDec from #FDVER) >= 14
--	BEGIN
--		UPDATE dbo.config_fddba2
--			SET [value] = '1204=1,1222=1,3226=1,4199=1,',
--				[valuebig] = NULL,
--				[comment] = '<CONFIG><1117>When a file in the filegroup meets the autogrow threshold, all files in the filegroup grow. Note: Starting with SQL Server 2016 this behavior is controlled by the AUTOGROW_SINGLE_FILE and AUTOGROW_ALL_FILES option of ALTER DATABASE, and trace flag 1117 has no effect.</1117><1118>MSKB328551</1118><1204>Write deadlocks to errorlog</1204><1222>Write deadlocks to errorlog</1222><3226>Suppress successful backup messages</3226><4199>Enable Query Optimizer changes</4199></CONFIG>'
--			WHERE [name] = 'trace_flags_suggested' AND [domain] = 'fddba\pMigrateTraceFlags'
--	END
--	ELSE
--	BEGIN
--		UPDATE dbo.config_fddba2
--			SET [value] = '1117=1,1118=1,1204=1,1222=1,3226=1,4199=1,',
--				[valuebig] = NULL,
--				[comment] = '<CONFIG><1117>When a file in the filegroup meets the autogrow threshold, all files in the filegroup grow. Note: Starting with SQL Server 2016 this behavior is controlled by the AUTOGROW_SINGLE_FILE and AUTOGROW_ALL_FILES option of ALTER DATABASE, and trace flag 1117 has no effect.</1117><1118>MSKB328551</1118><1204>Write deadlocks to errorlog</1204><1222>Write deadlocks to errorlog</1222><3226>Suppress successful backup messages</3226><4199>Enable Query Optimizer changes</4199></CONFIG>'
--			WHERE [name] = 'trace_flags_suggested' AND [domain] = 'fddba\pMigrateTraceFlags'
--	END
--END
GO

--setup default XE trace for deadlocks
IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = 'FD_deadlock_capture' AND [domain] = 'fddba\pXE_trace_enable')
BEGIN
	INSERT dbo.config_fddba2 ([name], [domain], [value]) 
		VALUES ('FD_deadlock_capture', 'fddba\pXE_trace_enable', 
			'<CONFIG><EVENT>sqlserver.xml_deadlock_report</EVENT><WITH>EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS, MAX_DISPATCH_LATENCY=30 SECONDS, MEMORY_PARTITION_MODE=PER_CPU, TRACK_CAUSALITY=OFF, STARTUP_STATE=ON</WITH></CONFIG>')
END
GO

--setup ring buffer collector
IF NOT EXISTS(SELECT 1 FROM dbo.config_fddba2 WHERE [name] = 'ring_buffer_capture' AND [domain] = 'fddba\ringbuffer\collect')
BEGIN
	INSERT dbo.config_fddba2 ([name], [domain], [value]) VALUES ('ring_buffer_capture','fddba\ringbuffer\collect','cpu=1,connectivity=1,security_error=1,')
END
GO

DROP TABLE #temp
GO

--report values
IF NOT EXISTS (SELECT 1 FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'parameters' and [domain] = 'fddba\pStartUpCheck4')
BEGIN
	DECLARE @rc int
	SELECT @rc = COUNT(*) FROM dbo.config_fddba2 WHERE [domain] = 'fddba\pStartUpCheck'
	IF @rc > 0
	BEGIN
		IF @rc != 5
		BEGIN
			RAISERROR ('WARNING: dbo.config_fddba2 is missing rows!! Please investigate',11,1) WITH NOWAIT
		END
		SELECT LEFT([domain],30) as [domain],[name],ISNULL([value],'(null)') as [value] FROM dbo.config_fddba2
		RAISERROR ('',10,1) WITH NOWAIT
	END
	ELSE
	BEGIN
		RAISERROR ('WARNING: dbo.config_fddba2 has no rows!! Please investigate',11,1) WITH NOWAIT
	END
END
GO


IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id IS NULL AND message_text = 'Error: %, Severity: %, State: %.')
	INSERT dbo.deadlock_message_blacklist VALUES (NULL,'Error: %, Severity: %, State: %.')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 3014 AND message_text = 'BACKUP DATABASE successfully processed %')
	INSERT dbo.deadlock_message_blacklist VALUES (3014,'BACKUP DATABASE successfully processed %')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 3014 AND message_text = 'BACKUP LOG successfully processed %')
	INSERT dbo.deadlock_message_blacklist VALUES (3014,'BACKUP LOG successfully processed %')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 4628)
	INSERT dbo.deadlock_message_blacklist VALUES (4628,'The ALL permission is deprecated and maintained only for compatibility%')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 15457)
	INSERT dbo.deadlock_message_blacklist VALUES (15457,'Configuration option ''%')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 17137)
	INSERT dbo.deadlock_message_blacklist VALUES (17137,'Starting up database ''%')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 17177)
	INSERT dbo.deadlock_message_blacklist VALUES (17177,'This instance of SQL Server has been using a process ID of%')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 17573)
	INSERT dbo.deadlock_message_blacklist VALUES (17573,'CHECKDB for database ''%')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 17890)
	INSERT dbo.deadlock_message_blacklist VALUES (17890,'A significant part of sql server process memory has been paged out%')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 18264)
	INSERT dbo.deadlock_message_blacklist VALUES (18264,'Database backed up. Database: %')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 18265)
	INSERT dbo.deadlock_message_blacklist VALUES (18265,'Log was backed up. Database: %')

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 18455)
	INSERT dbo.deadlock_message_blacklist VALUES (18455,'Login succeeded for user %') --18453-18455

IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_message_blacklist WHERE message_id = 18456)
	INSERT dbo.deadlock_message_blacklist VALUES (18456,'Login failed for user %') --18401,18451,18456,18461,18464,18465,18466,18470,18486,18487,18488,40697
GO


IF NOT EXISTS(SELECT 1 FROM dbo.deadlock_parse_strings)
BEGIN
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (0, 1, 'spid')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (0, 2, 's')

	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (1, 1, 'KEY')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (1, 2, 'PAGE')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (1, 3, 'RID')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (1, 4, 'OBJECT')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (1, 5, 'EXCHPIPE')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (1, 6, 'EXCHPORT')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (1, 7, 'METADATA')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (1, 8, 'APPLICATION')

	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 1, 'deadlock victim=process')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 2, 'process id=process', 10)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 3, 'frame procname=', 11)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 4, 'keylock hobtid=', 12)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 5, 'pagelock fileid=', 13)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 6, 'owner id=process', 14)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 7, 'waiter id=process', 14)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 8, 'exchangeEvent id=Pipe', 15)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 9, 'exchangeEvent id=Port', 15)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 10, 'objectlock lockPartition=', 16)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 11, 'ridlock fileid=', 17)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 12, 'Proc [Database Id = ', 18)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 13, 'inputbuf')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 14, 'deadlock-list') --string to ignore for adhoc inputbuffer parsing
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 15, 'process-list') --string to ignore for adhoc inputbuffer parsing
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 16, 'executionStack') --string to ignore for adhoc inputbuffer parsing
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 17, 'resource-list') --string to ignore for adhoc inputbuffer parsing
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 18, 'owner-list') --string to ignore for adhoc inputbuffer parsing
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 19, 'waiter-list') --string to ignore for adhoc inputbuffer parsing
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 20, 'metadatalock subresource=', 19)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 21, 'Deadlock encountered ....') --full string: Deadlock encountered .... Printing deadlock information
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (2, 22, 'Node:')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 23, 'Port: 0x', 20)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 24, 'ResType:', 21)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 25, 'SPID: ', 22)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 26, 'Input Buf: ', 23)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 27, 'applicationlock hash=', 24)

	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 2, 'taskpriority=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 3, 'logused=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (10, 4, 'waitresource=', 50)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 5, 'waittime=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 6, 'ownerId=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 7, 'transactionname=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 8, 'lasttranstarted=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 9, 'XDES=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 10, 'lockMode=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 11, 'schedulerid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 12, 'kpid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 13, 'status=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 14, 'spid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 15, 'sbid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 16, 'ecid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 17, 'priority=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 18, 'trancount=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 19, 'lastbatchstarted=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 20, 'lastbatchcompleted=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 21, 'lastattention=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 22, 'clientapp=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 23, 'hostname=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 24, 'hostpid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 25, 'loginname=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (10, 26, 'isolationlevel=', 51)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 27, 'xactid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 28, 'currentdb=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 29, 'lockTimeout=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 30, 'clientoption1=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (10, 31, 'clientoption2=')

	--frame
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (11, 2,'line=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (11, 3,'stmtstart=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (11, 4,'stmtend=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (11, 5,'sqlhandle=')


	--keylock hobtid=72057605412618240 dbid=5 objectname=WinSNAP.sync.OpSumm indexname=Idx_OpSumm_AuditDate id=lock44623b6100 mode=S associatedObjectId=72057605412618240
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (12, 2, 'dbid=' )
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (12, 3, 'objectname=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (12, 4, 'indexname=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (12, 5, 'id=lock' )
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (12, 6, 'mode=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (12, 7, 'associatedObjectId=')

	--pagelock fileid=1 pageid=4539159 dbid=5 subresource=FULL objectname=WinSNAP.sync.Customers id=lock3a43e1e200 mode=IX associatedObjectId=72057605409931264
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (13, 2, 'pageid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (13, 3, 'dbid=' )
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (13, 4, 'subresource=' )
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (13, 5, 'objectname=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (13, 6, 'id=lock' )
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (13, 7, 'mode=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (13, 8, 'associatedObjectId=')

	--waiterowner
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (14, 2, 'mode=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (14, 3, 'requestType=')

	--exchangeEvent
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (15, 2, 'WaitType=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (15, 3, 'nodeId=' )

	--objectlock lockPartition=15 objid=46939717 subresource=FULL dbid=5 objectname=unknown id=lock3a7d0e4080 mode=Sch-M associatedObjectId=46939717
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (16, 2, 'objid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (16, 3, 'subresource=' )
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (16, 4, 'dbid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (16, 5, 'objectname=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (16, 6, 'id=lock')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (16, 7, 'mode=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (16, 8, 'associatedObjectId=')

	--INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (2, 11, 'ridlock fileid=', 17)
	--ridlock fileid=3 pageid=368 dbid=2 objectname=tempdb.dbo.x id=lock25af929c100 mode=X associatedObjectId=1945555045335236608
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (17, 2, 'pageid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (17, 3, 'dbid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (17, 4, 'objectname=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (17, 5, 'id=lock')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (17, 6, 'mode=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (17, 7, 'associatedObjectId=')

	--Proc [Database Id = 5 Object Id = 839990547]
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (18, 2, ' Object Id = ')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (18, 3, ']')

	--metadatalock subresource=SCHEMA classid=schema_id = 25 dbid=14 lockPartition=0 id=lock92e71bd180 mode=Sch-S
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (19, 2, ' classid=schema_id = ')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (19, 3, 'dbid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (19, 4, 'lockPartition=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (19, 5, 'id=lock')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (19, 6, 'mode=')

	--Port: 0x00000093EDEBC8D0  Xid Slot: 7, Wait Slot: 3, Task: 0x000000A9EC447468, (Producer), Exchange Wait Type: e_waitPipeNewRow, Merging: 1
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (20, 2, '  Xid Slot: ')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (20, 3, ', Wait Slot: ')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (20, 4, ', Task: 0x')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (20, 5, ', (')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (20, 6, '), Exchange Wait Type: ')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (20, 7, ', Merging: ')

	--ResType:ExchangeId Stype:"AND" SPID:146 BatchID:0 ECID:16 TaskProxy:(0x000000982AE29BF0) Value:0xec447468 Cost:(20/0)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (21, 2, ' Stype:')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (21, 3, ' SPID:')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (21, 4, ' BatchID:')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (21, 5, ' ECID:')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (21, 6, ' TaskProxy:(0x')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (21, 7, ') Value:0x')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (21, 8, ' Cost:(')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (21, 9, ')')

	--SPID: 146 ECID: 16 Statement Type: SELECT INTO Line #: 77
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (22, 2, ' ECID: ')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (22, 3, ' Statement Type: ')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (22, 4, ' Line #: ')

	--Input Buf: No Event: 
	--Input Buf: Language Event: EXEC rsk.spUpdatePositionRiskModelData @startDate="2016-12-15"
	--Input Buf: RPC Event: Proc [Database Id = 22 Object Id = 197627797]
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (23, 2, ' Event:')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (23, 3, ' Proc [Database Id = ')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (23, 4, ' Object Id = ')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (23, 5, ']')

	--2017-12-27 10:09:33.360 spid22s         applicationlock hash=MyAppLock6731eaf3 databasePrincipalId=0 dbid=2 id=lock1871c8c4180 mode=X
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (24, 2, ' databasePrincipalId=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (24, 3, ' dbid=')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (24, 4, ' id=lock')
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (24, 5, ' mode=')


	--waitresource types
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 2, 'DATABASE:', 100)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 3, 'FILE:', 101)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 4, 'INDEX:', 102)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 5, 'OBJECT:', 103)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 6, 'PAGE:', 104)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 7, 'KEY:', 105)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 8, 'EXTENT:', 106) --?
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 9, 'RID:', 107) --?
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 10, 'APPLICATION:', 108) --?
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr, childstype) VALUES (50, 11, 'METADATA:', 109) --?

	--waitresource type strings
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (100, 2, '?') --DATABASE
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (101, 2, '?') --FILE
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (102, 2, '?') --INDEX
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (103, 2, ':') --OBJECT
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (103, 3, ':') --OBJECT
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (104, 2, ':') --PAGE
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (104, 3, ':') --PAGE
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (105, 2, ':') --KEY
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (105, 3, '(') --KEY
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (105, 4, ')') --KEY
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (106, 2, '?') --EXTENT
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (107, 2, ':') --RID
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (107, 3, ':') --RID
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (107, 4, ':') --RID

	--waitresource=APPLICATION: 2:0:[MyAppLock]:(6731eaf3)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (108, 2, ':') --APPLICATION
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (108, 3, ':[') --APPLICATION
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (108, 4, ']:(') --APPLICATION
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (108, 5, ')') --APPLICATION

	--waitresource=METADATA: database_id = 14 SCHEMA(schema_id = 25)
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (109, 1, 'database_id = ') --METADATA
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (109, 2, 'SCHEMA(schema_id = ') --METADATA
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (109, 3, ')') --METADATA

	--isolation level strings
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (51, 2, '(') 
	INSERT dbo.deadlock_parse_strings (stype, typeid, mystr) VALUES (51, 3, ')')

	UPDATE dbo.deadlock_parse_strings SET mylen = LEN(mystr)
END
GO


DECLARE @dt DATETIME, @sysstartdt DATETIME
SET @dt = GETDATE()
select @sysstartdt = create_date from sys.databases where name = 'tempdb'
	
INSERT INTO dbo.WaitStatistics (WaitStatTypeId, WaitingTaksCount, WaitTime_ms, MaxWaitTime_ms, SignalWaitTime_ms, CaptureDate, SystemStartDate)
SELECT wst.Id , ws.waiting_tasks_count, ws.wait_time_ms, ws.max_wait_time_ms, ws.signal_wait_time_ms,@dt, @sysstartdt 
    FROM sys.dm_os_wait_stats ws INNER JOIN dbo.WaitStatType  wst on 
			ws.wait_type = wst.Name
GO


truncate table dbo.WaitStats_Benign
INSERT [dbo].[WaitStats_Benign] ([WaitStatTypeName], [Comment], [ExcludeGroup]) 
	VALUES (N'BROKER_EVENTHANDLER', NULL, NULL)
	,(N'BROKER_RECEIVE_WAITFOR', NULL, NULL)
	,(N'BROKER_TASK_STOP', NULL, NULL)
	,(N'BROKER_TO_FLUSH', NULL, NULL)
	,(N'BROKER_TRANSMITTER', NULL, NULL)
	,(N'CHECKPOINT_QUEUE', NULL, NULL)
	,(N'CHKPT', NULL, NULL)
	,(N'CXCONSUMER', NULL, NULL)
	,(N'CLR_AUTO_EVENT', NULL, NULL)
	,(N'CLR_MANUAL_EVENT', NULL, NULL)
	,(N'CLR_SEMAPHORE', NULL, NULL)
	,(N'DBMIRROR_DBM_EVENT', N'Maybe comment out if you have mirroring issues', N'Mirroring')
	,(N'DBMIRROR_EVENTS_QUEUE', N'Maybe comment out if you have mirroring issues', N'Mirroring')
	,(N'DBMIRROR_WORKER_QUEUE', N'Maybe comment out if you have mirroring issues', N'Mirroring')
	,(N'DBMIRRORING_CMD', N'Maybe comment out if you have mirroring issues', N'Mirroring')
	,(N'DIRTY_PAGE_POLL', NULL, NULL)
	,(N'DISPATCHER_QUEUE_SEMAPHORE', NULL, NULL)
	,(N'EXECSYNC', NULL, NULL)
	,(N'FSAGENT', NULL, NULL)
	,(N'FT_IFTS_SCHEDULER_IDLE_WAIT', NULL, NULL)
	,(N'FT_IFTSHC_MUTEX', NULL, NULL)
	,(N'HADR_CLUSAPI_CALL', N'Maybe comment out if you have Availability Group', N'Availability Group')
	,(N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'Maybe comment out if you have Availability Group', N'Availability Group')
	,(N'HADR_LOGCAPTURE_WAIT', N'Maybe comment out if you have Availability Group', N'Availability Group')
	,(N'HADR_NOTIFICATION_DEQUEUE', N'Maybe comment out if you have Availability Group', N'Availability Group')
	,(N'HADR_TIMER_TASK', N'Maybe comment out if you have Availability Group', N'Availability Group')
	,(N'HADR_WORK_QUEUE', N'Maybe comment out if you have Availability Group', N'Availability Group')
	,(N'KSOURCE_WAKEUP', NULL, NULL)
	,(N'LAZYWRITER_SLEEP', NULL, NULL)
	,(N'LOGMGR_QUEUE', NULL, NULL)
	,(N'MEMORY_ALLOCATION_EXT', NULL, NULL)
	,(N'ONDEMAND_TASK_QUEUE', NULL, NULL)
	,(N'PARALLEL_REDO_DRAIN_WORKER', NULL, NULL)
	,(N'PARALLEL_REDO_LOG_CACHE', NULL, NULL)
	,(N'PARALLEL_REDO_TRAN_LIST', NULL, NULL)
	,(N'PARALLEL_REDO_WORKER_SYNC', NULL, NULL)
	,(N'PARALLEL_REDO_WORKER_WAIT_WORK', NULL, NULL)
	,(N'PREEMPTIVE_OS_FLUSHFILEBUFFERS', NULL, NULL)
	,(N'PREEMPTIVE_XE_GETTARGETSTATE', NULL, NULL)
	,(N'PWAIT_ALL_COMPONENTS_INITIALIZED', NULL, NULL)
	,(N'PWAIT_DIRECTLOGCONSUMER_GETNEXT', NULL, NULL)
	,(N'QDS_ASYNC_QUEUE', NULL, NULL)
	,(N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', NULL, NULL)
	,(N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP', NULL, NULL)
	,(N'QDS_SHUTDOWN_QUEUE', NULL, NULL)
	,(N'REDO_THREAD_PENDING_WORK', NULL, NULL)
	,(N'REQUEST_FOR_DEADLOCK_SEARCH', NULL, NULL)
	,(N'RESOURCE_QUEUE', NULL, NULL)
	,(N'SERVER_IDLE_CHECK', NULL, NULL)
	,(N'SLEEP_BPOOL_FLUSH', NULL, NULL)
	,(N'SLEEP_DBSTARTUP', NULL, NULL)
	,(N'SLEEP_DCOMSTARTUP', NULL, NULL)
	,(N'SLEEP_MASTERDBREADY', NULL, NULL)
	,(N'SLEEP_MASTERMDREADY', NULL, NULL)
	,(N'SLEEP_MASTERUPGRADED', NULL, NULL)
	,(N'SLEEP_MSDBSTARTUP', NULL, NULL)
	,(N'SLEEP_SYSTEMTASK', NULL, NULL)
	,(N'SLEEP_TASK', NULL, NULL)
	,(N'SLEEP_TEMPDBSTARTUP', NULL, NULL)
	,(N'SNI_HTTP_ACCEPT', NULL, NULL)
	,(N'SOS_WORK_DISPATCHER', NULL, NULL)
	,(N'SP_SERVER_DIAGNOSTICS_SLEEP', NULL, NULL)
	,(N'SQLTRACE_BUFFER_FLUSH', NULL, NULL)
	,(N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', NULL, NULL)
	,(N'SQLTRACE_WAIT_ENTRIES', NULL, NULL)
	,(N'TRACEWRITE', NULL, NULL)
	,(N'VDI_CLIENT_OTHER', NULL, NULL)
	,(N'WAIT_FOR_RESULTS', NULL, NULL)
	,(N'WAIT_XTP_CKPT_CLOSE', NULL, NULL)
	,(N'WAIT_XTP_HOST_WAIT', NULL, NULL)
	,(N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', NULL, NULL)
	,(N'WAIT_XTP_RECOVERY', NULL, NULL)
	,(N'WAITFOR', NULL, NULL)
	,(N'WAITFOR_TASKSHUTDOWN', NULL, NULL)
	,(N'XE_DISPATCHER_JOIN', NULL, NULL)
	,(N'XE_DISPATCHER_WAIT', NULL, NULL)
	,(N'XE_TIMER_EVENT', NULL, NULL)
	,(N'HADR_ARCONTROLLER_NOTIFICATIONS_SUBSCRIBER_LIST',NULL,NULL);
GO


--LICENSING KEY INSERT OR UPDATE MUST BE DONE FOR EACH VERSION
merge Licensing.LicensingKey d
using (values(GETDATE(), 0x4D5546675655735568656C4C4B426461444463764D4171414C5672776648724167426D7453424753)) s(DT, LicenceKey)
	on 1 = 1
when matched then update set LCK_InsertDate = DT,
							LCK_Key = LicenceKey
when not matched by target then insert(LCK_InsertDate, LCK_Key)
									values(DT, LicenceKey);
GO


merge into Monitoring.DeadlockResourceTypes
using (values(1, 'APPLICATION'),
			(2, 'KEY'),
			(3, 'METADATA'),
			(4, 'OBJECT'),
			(5, 'PAGE'),
			(6, 'RID')) s(TypeID, TypeName)
	on DRT_ID = TypeID
when not matched by target then insert(DRT_ID, DRT_Name)
								values(TypeID, TypeName);
GO


merge OpsControl.Operations
using (values(1, 'Deadlock collection', 90, 'exec Monitoring.usp_CollectDeadlocks @OPS_ID = %OPS_ID%',
					'<Description>
						<Information>
							<Info ID="1" Value="Last file name" />
							<Info ID="2" Value="Last file offset" />
							<Info ID="3" Value="Deadlocks found" />
						</Information>
					</Description>', 1),
			(2, 'Audit validation', 10, 'exec Auditing.usp_ValidateConfiguration @OPS_ID = %OPS_ID%',
					'<Description>
						<Identification>
							<Identifier ID="1" Value="ASE_ID" />
							<Identifier ID="2" Value="AES_ID" />
						</Identification>
					</Description>', 1),
			(3, 'Audit collection', 10, 'exec Auditing.usp_ReadLogs @OPS_ID = %OPS_ID%',
					'<Description>
						<Identification>
							<Identifier ID="1" Value="ASE_ID" />
							<Identifier ID="2" Value="AES_ID" />
						</Identification>
						<Information>
							<Info ID="1" Value="Last file name" />
							<Info ID="2" Value="Last file offset" />
							<Info ID="3" Value="Audit found" />
						</Information>
					</Description>', 1),
			(4, 'Parse deadlocks', 10, 'exec Monitoring.usp_ParseDeadlocks @OPS_ID = %OPS_ID%',
					'<Description>
						<Information>
							<Info ID="1" Value="Last DLK_ID" />
						</Information>
					</Description>', 1)

		) s(OpID, OpName, MinutesInterval, Script, DynColDescription, IsActive)
	on OPS_ID = OpID
when matched then update set OPS_Name = OpName,
							OPS_MinutesInterval = MinutesInterval,
							OPS_Script = Script,
							OPS_DynamicColumnsDescription = DynColDescription,
							OPS_IsActive = IsActive
when not matched by target then insert (OPS_ID, OPS_Name, OPS_MinutesInterval, OPS_Script, OPS_DynamicColumnsDescription, OPS_IsActive)
								values(OpID, OpName, MinutesInterval, Script, DynColDescription, IsActive)
when not matched by source then delete;
GO


if not exists (select * from ConfigurationHistory)
	EXEC dbo.ConfigurationHistory_insert
GO


--RAISERROR ('	EXECUTING dbo.pMigrateTraceFlags',10,1) WITH NOWAIT
--EXEC [dbo].[pMigrateTraceFlags]
GO


RAISERROR ('	EXECUTING dbo.startupcheck_fddba_convert_0_to_4',10,1) WITH NOWAIT;
EXEC [dbo].[startupcheck_fddba_convert_0_to_4] 'fddba\pStartUpCheck', 'fddba\dbmail', 'fddba\pStartUpCheck4'
GO


select LicensingExpirationDate
from Licensing.fn_ValidateLicense()
GO


/****************************************************************************************************
											JOBS
Please ensure that all variable declarations are done at the begining here. Do not use GO statements
in anything within the job section unless it is the last statement in the section.
****************************************************************************************************/
USE [msdb]
GO
DECLARE @enabled			BIT
DECLARE @ReturnCode			INT
DECLARE @startdateint		INT
DECLARE @jobId				BINARY(16)
DECLARE @minutes			INT 
DECLARE @sname				NVARCHAR(100)

SET @minutes = 10


SELECT @startdateint =  CAST(CONVERT(VARCHAR(30),GETDATE(),112) AS INT) 


/********************************************************************************************************
		JOB - FD - Backup Validation
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Backup Validation' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Backup Validation''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Backup Validation'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Backup Validation'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Backup Validation')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Backup Validation', @delete_unused_schedule=1
	
	BEGIN TRANSACTION
		SELECT @ReturnCode = 0
		SET @jobId = NULL
		
		IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Maintenance' AND category_class=1)
		BEGIN
			EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Maintenance'
			IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback15
		END

		EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Backup Validation', 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Fortified Data', 
		@category_name=N'Fortified Data - Maintenance', 
		@owner_login_name=N'sa', 
		@job_id = @jobId OUTPUT
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback15

		IF (select VerDec from #FDVER) < 11
		BEGIN
			IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
				EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute Procedure Local Databases', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'EXECUTE [dbo].[BackupException] 
GO', 
			@database_name=N'FDDBA', 
			@output_file_name=N'$(ESCAPE_SQUOTE(SQLDIR))\Log\Backup_Validation_$(ESCAPE_SQUOTE(STEPID))_$(ESCAPE_SQUOTE(STRTDT))_$(ESCAPE_SQUOTE(STRTTM)).txt', 
			@flags=4
			IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback15
		END
		ELSE
		BEGIN

			IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
				EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute Procedure Local Databases', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'EXECUTE [dbo].[BackupException] 
GO', 
			@database_name=N'FDDBA', 
			@output_file_name=N'$(ESCAPE_SQUOTE(SQLDIR))\LOG\Backup_Validation_$(ESCAPE_SQUOTE(STEPID))_$(ESCAPE_SQUOTE(STRTDT))_$(ESCAPE_SQUOTE(STRTTM)).txt', 
			@flags=4
			IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback15
		END


		IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 2)
			EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute Procedure Availability Groups', 
		@step_id=2, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'--CHECK IF THIS IS A PRIMARY FOR ANY AG, IF SO THEN RUN
	IF EXISTS(SELECT 
		1
	 FROM
		sys.databases d
		INNER JOIN sys.dm_hadr_database_replica_states drs on d.group_database_id = drs.group_database_id AND d.replica_id = drs.replica_id
		INNER JOIN sys.availability_groups ag on drs.group_id = ag.group_id
		INNER JOIN sys.dm_hadr_availability_group_states agstate on ag.group_id = agstate.group_id
	WHERE 
		d.replica_id IS NOT NULL
		AND agstate.primary_replica = @@SERVERNAME)
	BEGIN
		PRINT ''Executing AG check, this instance conatains a primary AG''
		EXECUTE FDDBA.[dbo].[BackupException_AG] 
	END  
	ELSE
	BEGIN
		PRINT ''This instance does NOT conatain a primary AG so report will not run.''
	END
	GO', 
		@database_name=N'FDDBA', 
		@output_file_name=N'$(ESCAPE_SQUOTE(SQLDIR))\LOG\Backup_Validation_$(ESCAPE_SQUOTE(STEPID))_$(ESCAPE_SQUOTE(STRTDT))_$(ESCAPE_SQUOTE(STRTTM)).txt', 
		@flags=4
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback15
		EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback15


		EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Daily 7 AM', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=1, 
		@freq_subday_interval=0, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=@startdateint, 
		@active_end_date=99991231, 
		@active_start_time=70000, 
		@active_end_time=235959
		
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback15
		EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback15
		COMMIT TRANSACTION
		GOTO EndSave15
		QuitWithRollback15:
			IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
		EndSave15:
END


/********************************************************************************************************
		JOB - FD - Capture Perfmon Data
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Capture Perfmon Data' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Capture Perfmon Data''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Capture Perfmon Data'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Capture Perfmon Data'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Capture Perfmon Data')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Capture Perfmon Data', @delete_unused_schedule=1
	


	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 

	
	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2

	END
	
	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Capture Perfmon Data', 
			@enabled=1, 
			@notify_level_eventlog=0, 
			@notify_level_email=0, 
			@notify_level_netsend=0, 
			@notify_level_page=0, 
			@delete_level=0, 
			@description=N'Captures performance data every X duration for many critical SQL counters', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2

	IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'PERFMON_COUNTERS', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=3, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'exec dbo.[pPerformanceMonitor]', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2
	
	IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 2)
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Processor Utilization', 
			@step_id=2, 
			@cmdexec_success_code=0, 
			@on_success_action=3, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'execute perf.pCPU_Insert', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2
	
	IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 3)
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Check Scheduler Pressure', 
		@step_id=3, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXEC mon.pProcess_Schedulers_Insert', 
		@database_name=N'FDDBA', 
		@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2
	
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2
	

	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Every 5 minutes', 
			@enabled=1, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=4, 
			@freq_subday_interval=5, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=0, 
			@active_start_date=20180206, 
			@active_end_date=99991231, 
			@active_start_time=0, 
			@active_end_time=235959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2
	COMMIT TRANSACTION
	GOTO EndSave2
	QuitWithRollback2:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave2:

END


/********************************************************************************************************
		JOB - FD - ExecRequest Load
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - ExecRequest Load' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - ExecRequest Load''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - ExecRequest Load'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - ExecRequest Load'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - ExecRequest Load')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - ExecRequest Load', @delete_unused_schedule=1
	
	BEGIN TRANSACTION
		SELECT @ReturnCode = 0
		SET @jobId = NULL

	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback13
	END

	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - ExecRequest Load', 
		@enabled=@enabled, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Insert executing requests into FDDBA.mon.ExecRequests', 
		@category_name=N'Fortified Data - Monitor', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback13
	
	IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute Procedure', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'exec mon.pExecRequests_Insert', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback13
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback13
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Every 10 seconds', 
			@enabled=0, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=2, 
			@freq_subday_interval=10, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=0, 
			@active_start_date=@startdateint, 
			@active_end_date=99991231, 
			@active_start_time=80000, 
			@active_end_time=195959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback13
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback13
	COMMIT TRANSACTION
	GOTO EndSave13
	QuitWithRollback13:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
		RAISERROR('Rolled Back Transaction 13',15,1)WITH NOWAIT;
	EndSave13:
END


/********************************************************************************************************
		JOB - FD - ExecRequestes Purge
********************************************************************************************************/
	IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - ExecRequestes Purge' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - ExecRequestes Purge''',10,1) WITH NOWAIT;
	ELSE
	BEGIN
		RAISERROR ('Creating Job  ''FD - ExecRequestes Purge'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
		SET @enabled = NULL 
		SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - ExecRequestes Purge'
		
		IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - ExecRequestes Purge')
			EXEC msdb.dbo.sp_delete_job @job_name=N'FD - ExecRequestes Purge', @delete_unused_schedule=1
		
		BEGIN TRANSACTION
		SELECT @ReturnCode = 0
		SET @jobId = NULL

		IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
		BEGIN
			EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
			IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback14
		END

		EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - ExecRequestes Purge', 
			@enabled=@enabled, 
			@notify_level_eventlog=0, 
			@notify_level_email=0, 
			@notify_level_netsend=0, 
			@notify_level_page=0, 
			@delete_level=0, 
			@description=N'Clean up for table mon.ExecRequests', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback14

		IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
		EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute Procedure', 
				@step_id=1, 
				@cmdexec_success_code=0, 
				@on_success_action=1, 
				@on_success_step_id=0, 
				@on_fail_action=2, 
				@on_fail_step_id=0, 
				@retry_attempts=0, 
				@retry_interval=0, 
				@os_run_priority=0, @subsystem=N'TSQL', 
				@command=N'[mon].[pExecRequestes_Purge] @days = 2, @batchsize = 1000', 
				@database_name=N'FDDBA', 
				@flags=0
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback14
		EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback14
		EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Daily', 
				@enabled=0, 
				@freq_type=4, 
				@freq_interval=1, 
				@freq_subday_type=1, 
				@freq_subday_interval=0, 
				@freq_relative_interval=0, 
				@freq_recurrence_factor=0, 
				@active_start_date=@startdateint, 
				@active_end_date=99991231, 
				@active_start_time=50700, 
				@active_end_time=235959
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback14
		EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback14
		COMMIT TRANSACTION
		GOTO EndSave14
		QuitWithRollback14:
			IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
			RAISERROR('Rolled Back Transaction 14',15,1)WITH NOWAIT;
		EndSave14:
	END


/********************************************************************************************************
		JOB - FD - Gather Configuration Settings
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Gather Configuration Settings' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Gather Configuration Settings''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Gather Configuration Settings'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Gather Configuration Settings'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Gather Configuration Settings')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Gather Configuration Settings', @delete_unused_schedule=1
	


	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 

	
	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback6

	END

	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Gather Configuration Settings', 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Gathers SQL Server configuration Information', 
		@category_name=N'Fortified Data - Monitor', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback6
	
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Gather Data', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXECUTE dbo.ConfigurationHistory_insert', 
		@database_name=N'FDDBA', 
		@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback6
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback6
	
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback6
	COMMIT TRANSACTION
	GOTO EndSave6
	QuitWithRollback6:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave6:
END
---------------------------------------------------------------------------------

--THIS JOB WILL ALWAYS BE CREATED AND ENABLED
RAISERROR ('Creating Job  ''FD - Process_Monitor - Capture Active Running Processes'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
SET @enabled = 1 

IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Process_Monitor - Capture Active Running Processes')
	EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Process_Monitor - Capture Active Running Processes', @delete_unused_schedule=1
	
BEGIN TRANSACTION
SELECT @ReturnCode = 0
SET @jobId = NULL 

	
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
BEGIN
	EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback7
END


	
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Process_Monitor - Capture Active Running Processes', 
		@enabled=@enabled, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Captures active running processes and enters the data into FD.dbo.Process_Monitor.', 
		@category_name=N'Fortified Data - Monitor', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback7
	
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Process_Monitor', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'exec dbo.usp_Load_Process_Monitor_Adhoc', 
		@database_name=N'FDDBA', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback7
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback7
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback7
COMMIT TRANSACTION
GOTO EndSave7
QuitWithRollback7:
	IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave7:

DECLARE @perf_condition nvarchar(200)
IF NOT EXISTS(select TOP 1 1 from dbo.sysalerts WHERE name=N'Blocking')
BEGIN
	IF @@SERVERNAME IS NOT NULL
	BEGIN
		IF CHARINDEX(N'\', @@SERVERNAME) = 0
		BEGIN
			SET @perf_condition = N'SQLServer:General Statistics|Processes blocked||>|5'
		END
		ELSE
		BEGIN
			SET @perf_condition = N'MSSQL$' + SUBSTRING(@@SERVERNAME, CHARINDEX(N'\', @@SERVERNAME) + 1, LEN(@@SERVERNAME)) + N':General Statistics|Processes blocked||>|5'
		END

		EXEC msdb.dbo.sp_add_alert @name=N'Blocking', 
			@message_id=0, 
			@severity=0, 
			@enabled=1, 
			@delay_between_responses=120, 
			@include_event_description_in=0, 
			@performance_condition=@perf_condition, 
			@job_name=N'FD - Process_Monitor - Capture Active Running Processes';
	END
END


/********************************************************************************************************
		JOB - FD - Gather Database Size Information
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Gather Database Size Information' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Gather Database Size Information''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Gather Database Size Information'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Gather Database Size Information' 
	
	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Gather Database Size Information')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Gather Database Size Information', @delete_unused_schedule=1
	


	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	set @jobId = null

	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	END
	select @jobId = job_id from msdb.dbo.sysjobs where (name = N'FD - Gather Database Size Information')
	if (@jobId is NULL)
	BEGIN
		EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Gather Database Size Information', 
			@enabled=1, 
			@notify_level_eventlog=0, 
			@notify_level_email=0, 
			@notify_level_netsend=0, 
			@notify_level_page=0, 
			@delete_level=0, 
			@description=N'Gathers database size information.', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

		IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
		EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Get file data', 
				@step_id=1, 
				@cmdexec_success_code=0, 
				@on_success_action=4, 
				@on_success_step_id=2, 
				@on_fail_action=4, 
				@on_fail_step_id=2, 
				@retry_attempts=0, 
				@retry_interval=0, 
				@os_run_priority=0, @subsystem=N'TSQL', 
				@command=N'EXEC [dbo].[pDatabaseFileStorage_AddByDatabaseName]
				@databaseNameList	= ''FDDBA~TEST~ReportServer''
				,@delimiter		= ''~'' 
				,@allUserDatabases 	= 1', 
				@database_name=N'FDDBA', 
				@flags=0
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	 
		IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 2)
		EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Get Disk Data', 
				@step_id=2, 
				@cmdexec_success_code=0, 
				@on_success_action=4, 
				@on_success_step_id=4, 
				@on_fail_action=4, 
				@on_fail_step_id=4, 
				@retry_attempts=0, 
				@retry_interval=0, 
				@os_run_priority=0, @subsystem=N'TSQL', 
				@command=N'Exec mon.pDiskSpace_Insert', 
				@database_name=N'FDDBA', 
				@flags=0
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	 
		IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 3)
		EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Get object data', 
				@step_id=3, 
				@cmdexec_success_code=0, 
				@on_success_action=3, 
				@on_success_step_id=0, 
				@on_fail_action=3, 
				@on_fail_step_id=0, 
				@retry_attempts=0, 
				@retry_interval=0, 
				@os_run_priority=0, @subsystem=N'TSQL', 
				@command=N'EXEC [dbo].[pDatabaseObjectStorage_AddByDatabaseName]
				@databaseNameList	= ''FDDBA~TEST~ReportServer''
				,@delimiter		= ''~'' 
				,@allUserDatabases 	= 1

			', 
				@database_name=N'FDDBA', 
				@flags=0
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	 
		IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 4)
		EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Check for failure', 
				@step_id=4, 
				@cmdexec_success_code=0, 
				@on_success_action=1, 
				@on_success_step_id=0, 
				@on_fail_action=2, 
				@on_fail_step_id=0, 
				@retry_attempts=0, 
				@retry_interval=0, 
				@os_run_priority=0, @subsystem=N'TSQL', 
				@command=N'DECLARE @jobid		uniqueidentifier
		DECLARE @rundate	INT
		DECLARE @runtime	INT
		DECLARE @startdt	DATETIME
		DECLARE @msg		VARCHAR(2048)
		--GET THE JOB ID
		SELECT @jobid =  CONVERT(uniqueidentifier,$(ESCAPE_NONE(JOBID)))
		PRINT ''Job Id is: '' + ISNULL(CAST(@jobid as varchar(50)), ''nuLL'')
		--GET THE LATEST RUNTIME INFORMATION FROM ACTIVITY
		select 
			 @startdt = a.start_execution_date
			,@rundate =  CAST(convert(CHAR(8), a.start_execution_date,112) AS INT)
			,@runtime =  CAST(REPLACE(convert(char(8), a.start_execution_date,108),'':'','''') AS INT)
		 from
			sysjobactivity a
		Where
			a.job_id = @jobid
		--CHECK FOR ERRORS AND IF ANY OCCURRED RAISE AN ERROR TO FAIL THIS STEP
		IF EXISTS(
			SELECT 
				1
			 FROM
				sysjobhistory h
			 WHERE
				h.job_id = @jobid
				AND dbo.agent_datetime(h.run_date, h.run_time) >= @startdt
				AND run_status = 0 --failed
			)
		BEGIN
			PRINT ''Failure found, returning Error to job step''
			RAISERROR(''One or more job steps failed, please investigate'',11,1) WITH NOWAIT;
		END
		ELSE
			PRINT ''No step failures found :)''', 
				@database_name=N'msdb', 
				@flags=0

		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
		EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Daily', 
				@enabled=1, 
				@freq_type=4, 
				@freq_interval=1, 
				@freq_subday_type=1, 
				@freq_subday_interval=0, 
				@freq_relative_interval=0, 
				@freq_recurrence_factor=0, 
				@active_start_date= @startdateint, 
				@active_end_date=99991231, 
				@active_start_time=10010, 
				@active_end_time=235959
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
		EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	END
	COMMIT TRANSACTION
	GOTO EndSave
	QuitWithRollback:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave:

	EXEC msdb.dbo.sp_update_job @job_name=N'FD - Gather Database Size Information', @start_step_id=1
	
END


/********************************************************************************************************
		JOB - FD - Gather File IO Stats
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Gather File IO Stats' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Gather File IO Stats''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Gather File IO Stats'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Gather File IO Stats'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Gather File IO Stats')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Gather File IO Stats', @delete_unused_schedule=1
	

	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 

	
	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2

	END

	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Gather File IO Stats', 
		@enabled=@enabled, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Gathers file statistics for each database file', 
		@category_name=N'Fortified Data - Monitor', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback3

	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Run Procedure', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'Execute [dbo].[pFileStats_Gather]', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback3
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback3
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Hourly', 
			@enabled=1, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=8, 
			@freq_subday_interval=1, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=0, 
			@active_start_date=@startdateint, 
			@active_end_date=99991231, 
			@active_start_time=0, 
			@active_end_time=235959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback3
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback3
	COMMIT TRANSACTION
	GOTO EndSave3
	QuitWithRollback3:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave3:



END


/********************************************************************************************************
		JOB - FD - Gather Index Usage Stats
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Gather Index Usage Stats' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Gather Index Usage Stats''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Gather Index Usage Stats'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Gather Index Usage Stats'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Gather Index Usage Stats')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Gather Index Usage Stats', @delete_unused_schedule=1
	


	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 

	
	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback8
	END



	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Gather Index Usage Stats', 
			@enabled=1, 
			@notify_level_eventlog=0, 
			@notify_level_email=0, 
			@notify_level_netsend=0, 
			@notify_level_page=0, 
			@delete_level=0, 
			@description=N'No description available.', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback8


	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute procedure', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'EXEC dbo.usp_persist_dm_db_index_usage_stats', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback8
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback8
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Friday 6pm', 
			@enabled=1, 
			@freq_type=8, 
			@freq_interval=32, 
			@freq_subday_type=1, 
			@freq_subday_interval=0, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=1, 
			@active_start_date=@startdateint, 
			@active_end_date=99991231, 
			@active_start_time=180000, 
			@active_end_time=235959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback8
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback8
	COMMIT TRANSACTION
	GOTO EndSave8
	QuitWithRollback8:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave8:
END


/********************************************************************************************************
		JOB - FD - GatherWaitStatistics
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - GatherWaitStatistics' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - GatherWaitStatistics''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - GatherWaitStatistics'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - GatherWaitStatistics'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - GatherWaitStatistics')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - GatherWaitStatistics', @delete_unused_schedule=1
	

BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL


IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback11

END


EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - GatherWaitStatistics', 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Gathers SQL Server wait statistics', 
		@category_name=N'Fortified Data - Monitor', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback11


EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Gather', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=3, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXECUTE dbo.pWaitStatistics_Load ', 
		@database_name=N'FDDBA', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback11


EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Delete Old Records', 
		@step_id=2, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXECUTE dbo.pWaitStatistics_Delete', 
		@database_name=N'FDDBA', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback11
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback11

EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Every 5 Minutes', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=4, 
		@freq_subday_interval=5, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=1, 
		@active_start_date=@startdateint, 
		@active_end_date=99991231, 
		@active_start_time=0, 
		@active_end_time=235959

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback11
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback11
COMMIT TRANSACTION
GOTO EndSave11
QuitWithRollback11:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave11:
END


/********************************************************************************************************
		JOB - FD - Monitor Agent Job History Purge
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Monitor Agent Job History Purge' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Monitor Agent Job History Purge''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Monitor Agent Job History Purge'' if it does not exist.',10,1) WITH NOWAIT;	
	set @enabled = 1
	SET @jobId = NULL 
	SELECT TOP 1 @jobid = job_id FROM msdb.dbo.sysjobs WHERE name = 'FD - Monitor Agent Job History Purge'
	IF @jobid IS NULL
	BEGIN
		BEGIN TRANSACTION
		SELECT @ReturnCode = 0
		IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
		BEGIN
			EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
			IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback19
		END

		if (@jobId is NULL)
		BEGIN
			EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Monitor Agent Job History Purge', 
					@enabled=1, 
					@notify_level_eventlog=0, 
					@notify_level_email=0, 
					@notify_level_netsend=0, 
					@notify_level_page=0, 
					@delete_level=0, 
					@description=N'Executes a purge of the agent job history table.', 
					@category_name=N'Fortified Data - Monitor', 
					@owner_login_name=N'sa', @job_id = @jobId OUTPUT
			IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback19
		END
		
		IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
		EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute procedure', 
				@step_id=1, 
				@cmdexec_success_code=0, 
				@on_success_action=1, 
				@on_success_step_id=0, 
				@on_fail_action=2, 
				@on_fail_step_id=0, 
				@retry_attempts=0, 
				@retry_interval=0, 
				@os_run_priority=0, @subsystem=N'TSQL', 
				@command=N'EXEC [dbo].[pAgentJob_History_Purge]', 
				@database_name=N'FDDBA', 
				@flags=0
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback19
		EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback19
		EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback19
		COMMIT TRANSACTION
		GOTO EndSave19
		QuitWithRollback19:
			IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
		EndSave19:
	END
	ELSE
		RAISERROR('Job ''FD - Monitor Agent Job History Purge'' alread exists, not going to create it.',10,1) WITH NOWAIT;
END


/********************************************************************************************************
		JOB - FD - Monitor Agent Job History
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Monitor Agent Job History' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Monitor Agent Job History''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Monitor Agent Job History'' if it does not exist.',10,1) WITH NOWAIT;	
	set @enabled = 1
	SET @jobId = NULL 
	SELECT TOP 1 @jobid = job_id FROM msdb.dbo.sysjobs WHERE name = 'FD - Monitor Agent Job History'
	IF @jobid IS NULL
	BEGIN
		BEGIN TRANSACTION
		SELECT @ReturnCode = 0
		IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
		BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback20

		END
		if (@jobId is NULL)
		BEGIN
		EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Monitor Agent Job History', 
				@enabled=1, 
				@notify_level_eventlog=0, 
				@notify_level_email=0, 
				@notify_level_netsend=0, 
				@notify_level_page=0, 
				@delete_level=0, 
				@description=N'Monitors job history for jobs listed in the dbo.agentjob_monitor table.', 
				@category_name=N'Fortified Data - Monitor', 
				@owner_login_name=N'sa', @job_id = @jobId OUTPUT
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback20

		END
		
		IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
		EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute procedure', 
				@step_id=1, 
				@cmdexec_success_code=0, 
				@on_success_action=1, 
				@on_success_step_id=0, 
				@on_fail_action=2, 
				@on_fail_step_id=0, 
				@retry_attempts=0, 
				@retry_interval=0, 
				@os_run_priority=0, @subsystem=N'TSQL', 
				@command=N'EXEC [dbo].[pAgentJob_History_Capture]', 
				@database_name=N'FDDBA', 
				@flags=0
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback20
		EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback20
		EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'FD Monitor Agent Job History Every 10 Minutes', 
				@enabled=0, 
				@freq_type=4, 
				@freq_interval=1, 
				@freq_subday_type=4, 
				@freq_subday_interval=10, 
				@freq_relative_interval=0, 
				@freq_recurrence_factor=0, 
				@active_start_date=@startdateint, 
				@active_end_date=99991231, 
				@active_start_time=0, 
				@active_end_time=235959
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback20
		EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback20
		COMMIT TRANSACTION
		GOTO EndSave20
		QuitWithRollback20:
			IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
		EndSave20:
	END
	ELSE
		RAISERROR('Job ''FD - Monitor Agent Job History'' alread exists, not going to create it.',10,1) WITH NOWAIT;
END


/********************************************************************************************************
		JOB - FD - Monitor Plan Results
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Monitor Plan Results' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Monitor Plan Results''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Monitor Plan Results'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Monitor Plan Results'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Monitor Plan Results')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Monitor Plan Results', @delete_unused_schedule=1
	

	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 

	
	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback16
	END



	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Monitor Plan Results', 
			@enabled=0, 
			@notify_level_eventlog=0, 
			@notify_level_email=2, 
			@notify_level_netsend=2, 
			@notify_level_page=2, 
			@delete_level=0, 
			@description=N'No description available.', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback16

	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute procedure', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_fail_action=2, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'EXEC [mon].[usp_PlanResults_Capture]', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback16
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback16
	SET @sname = N'FD - Monitor Plan Results Every ' + LTRIM(STR(@minutes)) + N' Minutes'
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=@sname, 
			@enabled=1, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=4, 
			@freq_subday_interval=@minutes, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=1, 
			@active_start_date=@startdateint,
			@active_end_date=99991231, 
			@active_start_time=0, 
			@active_end_time=235959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback16
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback16
	COMMIT TRANSACTION
	GOTO EndSave16
	QuitWithRollback16:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave16:

END


/********************************************************************************************************
		JOB - FD - Monitor Plan Statistics
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Monitor Plan Statistics' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Monitor Plan Statistics''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Monitor Plan Statistics'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Monitor Plan Statistics'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Monitor Plan Statistics')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Monitor Plan Statistics', @delete_unused_schedule=1
	

	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 

	
	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback10
	END



	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Monitor Plan Statistics', 
			@enabled=0, 
			@notify_level_eventlog=0, 
			@notify_level_email=2, 
			@notify_level_netsend=2, 
			@notify_level_page=2, 
			@delete_level=0, 
			@description=N'No description available.', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback10

	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute procedure', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_fail_action=2, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'EXEC [dbo].[usp_PlanStatistics_Capture]', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback10
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback10
	SET @sname = N'FD - Monitor Plan Statistics Every ' + LTRIM(STR(@minutes)) + N' Minutes'
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=@sname, 
			@enabled=1, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=4, 
			@freq_subday_interval=@minutes, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=1, 
			@active_start_date=@startdateint,
			@active_end_date=99991231, 
			@active_start_time=0, 
			@active_end_time=235959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback10
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback10
	COMMIT TRANSACTION
	GOTO EndSave10
	QuitWithRollback10:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave10:

END


/********************************************************************************************************
		JOB - FD - Monitor Statistics
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Monitor Statistics' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Monitor Statistics''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Monitor Statistics'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Monitor Statistics'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Monitor Statistics')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Monitor Statistics', @delete_unused_schedule=1
	


	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 

	
	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback12
	END



	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Monitor Statistics', 
			@enabled=0, 
			@notify_level_eventlog=0, 
			@notify_level_email=2, 
			@notify_level_netsend=2, 
			@notify_level_page=2, 
			@delete_level=0, 
			@description=N'No description available.', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback12

	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute procedure', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_fail_action=2, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'EXEC [dbo].[pAgentJob_History_Capture]', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback12
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback12
	SET @sname = N'FD - Monitor Statistics Every ' + LTRIM(STR(@minutes)) + N' Minutes'
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=@sname, 
			@enabled=1, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=4, 
			@freq_subday_interval=@minutes, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=1, 
			@active_start_date=@startdateint,
			@active_end_date=99991231, 
			@active_start_time=0, 
			@active_end_time=235959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback12
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback12
	COMMIT TRANSACTION
	GOTO EndSave12
	QuitWithRollback12:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave12:
END


/********************************************************************************************************
		JOB - FD - Process_Monitor_Adhoc Purge
********************************************************************************************************/
RAISERROR ('Creating Job  ''FD - Process_Monitor_Adhoc Purge'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
set @enabled = 1
SET @jobId = NULL 
	
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Process_Monitor_Adhoc Purge')
	EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Process_Monitor_Adhoc Purge', @delete_unused_schedule=1

BEGIN TRANSACTION
SELECT @ReturnCode = 0

IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Maintenance' AND category_class=1)
BEGIN
	EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Maintenance'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback18
END


select @jobId = job_id from msdb.dbo.sysjobs where (name = N'FD - Process_Monitor_Adhoc Purge')
if (@jobId is NULL)
BEGIN
	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Process_Monitor_Adhoc Purge', 
			@enabled=1, 
			@notify_level_eventlog=0, 
			@notify_level_email=0, 
			@notify_level_netsend=0, 
			@notify_level_page=0, 
			@delete_level=0, 
			@description=N'Cleanup Job.', 
			@category_name=N'Fortified Data - Maintenance', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback18
END

IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute Procedure', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=1, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXECUTE [dbo].[Process_Monitor_Adhoc_Purge] 
   @days  = -90
  ,@batchsize = 5000
  ,@debug = 1', 
		@database_name=N'FDDBA', 
		@output_file_name=N'$(ESCAPE_SQUOTE(SQLDIR))\LOG\ProcessMonitorAdhoc_Purge_$(ESCAPE_SQUOTE(STEPID))_$(ESCAPE_SQUOTE(STRTDT))_$(ESCAPE_SQUOTE(STRTTM)).txt', 
		@flags=4
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback18
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback18
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Sunday 8:05  am', 
		@enabled=1, 
		@freq_type=8, 
		@freq_interval=1, 
		@freq_subday_type=1, 
		@freq_subday_interval=0, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=1, 
		@active_start_date=@startdateint, 
		@active_end_date=99991231, 
		@active_start_time=80500, 
		@active_end_time=235959
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback18
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback18
COMMIT TRANSACTION
GOTO EndSave18
QuitWithRollback18:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave18:


/********************************************************************************************************
		JOB - FD - Run Operations
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - Run Operations' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - Run Operations''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - Run Operations'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	set @enabled = null
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - Run Operations' 
	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - Run Operations')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - Run Operations', @delete_unused_schedule=1
	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 
	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback17
	END
	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - Run Operations', 
			@enabled=@enabled, 
			@notify_level_eventlog=0, 
			@notify_level_email=0, 
			@notify_level_netsend=0, 
			@notify_level_page=0, 
			@delete_level=0, 
			@description=N'Fortified Data', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback17
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Run', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'exec OpsControl.usp_RunOperations', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback17
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback17
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Schedule1', 
			@enabled=1, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=4, 
			@freq_subday_interval=1, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=0, 
			@active_start_date=@startdateint, 
			@active_end_date=99991231, 
			@active_start_time=0, 
			@active_end_time=235959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback17
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback17
	COMMIT TRANSACTION
	GOTO EndSave17
	QuitWithRollback17:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave17:
end


/********************************************************************************************************
		JOB - FD - WhoIsActive Load
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - WhoIsActive Load' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - WhoIsActive Load''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - WhoIsActive Load'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - WhoIsActive Load'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - WhoIsActive Load')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - WhoIsActive Load', @delete_unused_schedule=1
	

	BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 

	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback4
	END

	select @jobId = job_id from msdb.dbo.sysjobs where (name = N'FD - WhoIsActive Load')
	if (@jobId is NULL)
	BEGIN
	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - WhoIsActive Load', 
			@enabled=@enabled, 
			@notify_level_eventlog=0, 
			@notify_level_email=0, 
			@notify_level_netsend=0, 
			@notify_level_page=0, 
			@delete_level=0, 
			@description=N'No description available.', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback4

	END
	
	IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute Procedure', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'exec sp_WhoIsActive  @get_outer_command = 1, @destination_table = ''FDDBA.dbo.WhoIsActive''

	--remove information that is not needed
	Delete 
	  From
			[FDDBA].[dbo].[WhoIsActive]
	  where 
		[collection_time] > DATEADD(MINUTE,-1,getdate())
		And   cast(sql_text as varchar(max)) = ''<?query --
	sp_server_diagnostics
	--?>''', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback4
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback4
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Every 10 seconds', 
			@enabled=0, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=2, 
			@freq_subday_interval=10, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=0, 
			@active_start_date=@startdateint, 
			@active_end_date=99991231, 
			@active_start_time=80000, 
			@active_end_time=195959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback4
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback4
	COMMIT TRANSACTION
	GOTO EndSave4
	QuitWithRollback4:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave4:
END


/********************************************************************************************************
		JOB - FD - WhoIsActive Purge
********************************************************************************************************/
IF NOT EXISTS (SELECT 1 FROM #joblist WHERE JobName = N'FD - WhoIsActive Purge' AND Install = 1)
		RAISERROR ('	Not Creating Job  ''FD - WhoIsActive Purge''',10,1) WITH NOWAIT;
ELSE
BEGIN
	RAISERROR ('Creating Job  ''FD - WhoIsActive Purge'', will also be dropping any existing job and schedule.',10,1) WITH NOWAIT;
	SET @enabled = NULL 
	SELECT @enabled = IsEnabled FROM #joblist WHERE JobName = N'FD - WhoIsActive Purge'

	IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - WhoIsActive Purge')
		EXEC msdb.dbo.sp_delete_job @job_name=N'FD - WhoIsActive Purge', @delete_unused_schedule=1
	

	--BEGIN TRANSACTION
	SELECT @ReturnCode = 0
	SET @jobId = NULL 

	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
		IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback4
	END
END
IF NOT EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'FD - WhoIsActive Purge')
BEGIN
	BEGIN TRANSACTION

 
	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Fortified Data - Monitor' AND category_class=1)
	BEGIN
	EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Fortified Data - Monitor'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback5

	END

	select @jobId = job_id from msdb.dbo.sysjobs where (name = N'FD - WhoIsActive Purge')
	if (@jobId is NULL)
	BEGIN
	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'FD - WhoIsActive Purge', 
			@enabled=@enabled, 
			@notify_level_eventlog=0, 
			@notify_level_email=0, 
			@notify_level_netsend=0, 
			@notify_level_page=0, 
			@delete_level=0, 
			@description=N'No description available.', 
			@category_name=N'Fortified Data - Monitor', 
			@owner_login_name=N'sa', @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback5

	END

	IF NOT EXISTS (SELECT * FROM msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_id = 1)
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute Procedure', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'[dbo].[pWhoIsActive_Purge] @days = 2, @batchsize = 1000
	', 
			@database_name=N'FDDBA', 
			@flags=0
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback5
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback5
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Daily', 
			@enabled=0, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=1, 
			@freq_subday_interval=0, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=0, 
			@active_start_date=@startdateint, 
			@active_end_date=99991231, 
			@active_start_time=50700, 
			@active_end_time=235959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback5
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback5
	COMMIT TRANSACTION
	GOTO EndSave5
	QuitWithRollback5:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave5:
END


/*****************************************************************************************************
	AGENT ALERT - Blocking
	This alert depends on job 'FD - Process_Monitor - Capture Active Running Processes' so we must
	add it after the job is created.
*****************************************************************************************************/
USE msdb	
GO

DECLARE @jobid				UNIQUEIDENTIFIER
DECLARE @perfcondition		NVARCHAR(512)

SELECT TOP 1 @jobid = job_id FROM msdb.dbo.sysjobs WHERE name like '%Process_Monitor - Capture Active Running Processes%'

IF @jobid IS NOT NULL
BEGIN
	IF NOT EXISTS(SELECT TOP 1 1 FROM msdb.dbo.sysalerts WHERE name = 'Blocking' )
	BEGIN
		IF CHARINDEX('\', @@servername) > 0
		BEGIN 
			SET @perfcondition = N'MSSQL$' +  SUBSTRING(  @@SERVERNAME, CHARINDEX('\',@@SERVERNAME) +1,30) + N':General Statistics|Processes blocked||>|5'
		END
		ELSE
			SET @perfcondition = N'SQLServer:General Statistics|Processes blocked||>|5'
	END
END
ELSE
	RAISERROR('ERROR ERROR: Unable to find job ''Process_Monitor - Capture Active Running Processes'' therefore cannot add Alert for Blocking',10,1) WITH NOWAIT;

IF NOT EXISTS (SELECT name FROM msdb.dbo.sysalerts WHERE name = N'Blocking')
BEGIN
	RAISERROR('Alert [Blocking] does not exist, creating it',10,1) WITH NOWAIT;
	EXEC msdb.dbo.sp_add_alert @name=N'Blocking', 
			@message_id=0, 
			@severity=0, 
			@enabled=1, 
			@delay_between_responses=120, 
			@include_event_description_in=0, 
			@category_name=N'[Uncategorized]', 
			@performance_condition= @perfcondition, 
			@job_id= @jobid
END


use FDDBA
GO
declare @SQL nvarchar(max)

if exists (select *
			from (select cast(serverproperty('ProductVersion') as varchar(100)) Ver,
						cast(serverproperty(N'EngineEdition') as int) Edt,
						cast(serverproperty(N'ProductLevel') as varchar(100)) SP) s
				cross apply (select cast(parsename(Ver, 4) + '.' + parsename(Ver, 3) as decimal(10, 2)) Ver1) v
			where Ver1 >= 10
					and (Edt = 3
							or (Edt = 2
								and (Ver1 >= 14
									or (Ver1 = 13
										and SP >= 'SP1'
										)
									)
								)
						)
			)
begin
	set @SQL = (select 'alter '
							+ case when MaxIndexID = 0
									then 'table'
									else 'index all on'
								end
							+ ' ' + quotename(schema_name([schema_id])) + '.' + quotename(name) + ' rebuild with (data_compression=page);'
					from sys.tables t
						cross apply (select max(index_id) MaxIndexID
										from sys.indexes i
										where i.[object_id] = t.[object_id]) i
					where exists (select *
									from sys.partitions p
									where p.[object_id] = t.[object_id]
										and p.data_compression_desc = 'NONE')
					for xml path(''))

	if @SQL is not null
		exec(@SQL)
end
GO


USE master
GO


DECLARE @sql nvarchar(4000)
IF NOT EXISTS(select 1 from sys.configurations where name = 'scan for startup procs' AND value_in_use = CAST(1 AS sql_variant))
BEGIN
	RAISERROR ('	Scan for startup procs enabled',10,1) WITH NOWAIT;
	SET @sql = N'exec sp_configure ''show advanced'',1;
	reconfigure
	exec sp_configure ''scan for startup procs'', 1;
	reconfigure;'
	execute sp_executesql @sql
END
GO


/*
--old client specific version
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pStartUpCheck]') AND TYPE in (N'P', N'PC'))
BEGIN
	RAISERROR ('	CREATING STARTUP PROCEDURE master.dbo.pStartUpCheck',10,1) WITH NOWAIT;
	DECLARE @sql		NVARCHAR(max)

	SET @sql = 'CREATE PROCEDURE  [dbo].[pStartUpCheck]
AS
	SET NOCOUNT ON
	WAITFOR DELAY ''00:05:00''


	DECLARE @HTML VARCHAR(max)
	DECLARE @sub	NVARCHAR(255)
	set @sub = N''Validation Results for Server '' + @@servername
	EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @IncludeSpaceReport = 1 , @FreeSpaceWarningPercent = 10

	declare @output int

	EXEC @output = msdb.dbo.sp_send_dbmail
		@profile_name =  ''Agent Mail'',
		@recipients =''@fortifieddata.com'',
		@subject=@sub,
		@body =@HTML,
		@body_format =''HTML'',
		@file_attachments = ''\\FILESHARE\fdlogo.png''

	IF @output > 0
		EXEC @output = msdb.dbo.sp_send_dbmail
		@profile_name =  ''Agent Mail'',
		@recipients =''@fortifieddata.com'',
		@subject=@sub,
		@body =@HTML,
		@body_format =''HTML'''

	execute sp_executesql @sql

	IF NOT EXISTS(select 1 from sys.configurations where name = 'scan for startup procs' AND value_in_use = CAST(1 AS sql_variant))
	BEGIN

		SET @sql = 'exec sp_configure ''show advanced'',1;
		reconfigure
		exec sp_configure ''scan for startup procs'', 1;
		reconfigure;'
		execute sp_executesql @sql
	END
	EXECUTE sp_procoption N'[dbo].[pStartUpCheck]', 'startup', '1'
END
*/
GO

IF EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pStartUpCheck]') AND [type] in (N'P', N'PC'))
BEGIN
	RAISERROR ('DISABLING STARTUP PROCEDURE master.dbo.pStartUpCheck',10,1) WITH NOWAIT;
	EXECUTE sp_procoption N'[dbo].[pStartUpCheck]', 'startup', '0'
END
GO


/*
ALTER PROCEDURE  [dbo].[pStartUpCheck2]
AS
BEGIN
	SET NOCOUNT ON
	WAITFOR DELAY '00:05:00'

	DECLARE @HTML				VARCHAR(max)
	DECLARE @sub				NVARCHAR(255)
	DECLARE @output				int
	DECLARE @dbmail_profile		sysname
	DECLARE @dbmail_recipients	varchar(max)
	DECLARE @dbmail_attachment	nvarchar(max)
	DECLARE @inclspacerpt	bit
	DECLARE @freespacewarnprcnt	tinyint

	SELECT TOP 1 @dbmail_profile = dbmail_profile,
			@dbmail_recipients = dbmail_recipients,
			@dbmail_attachment = dbmail_attachment,
			@inclspacerpt = includespacereport,
			@freespacewarnprcnt = freespacewarningpercent
		FROM FDDBA.dbo.config_fddba

	--check dbmail profile name
	IF @dbmail_profile IS NULL
		OR NOT EXISTS (SELECT 1 FROM msdb.dbo.sysmail_profile WHERE [name] = @dbmail_profile)
	BEGIN
		--find public profile
		SELECT TOP 1 @dbmail_profile = p.[name] 
			FROM msdb.dbo.sysmail_profile p
				INNER JOIN msdb.dbo.sysmail_principalprofile pp
				ON p.profile_id = pp.profile_id
	END

	--check dbmail recipients
	IF @dbmail_recipients IS NULL
	BEGIN
		SET @dbmail_recipients = 'support@fortifieddata.com'
	END

	SET @sub = N'Validation Results for Server ' + @@servername
	
	IF @inclspacerpt IS NOT NULL AND @freespacewarnprcnt IS NOT NULL
	BEGIN
		EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @IncludeSpaceReport = @inclspacerpt, @FreeSpaceWarningPercent = @freespacewarnprcnt
	END
	ELSE
	BEGIN
		IF @inclspacerpt IS NOT NULL AND @freespacewarnprcnt IS NULL
		BEGIN
			EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @IncludeSpaceReport = @inclspacerpt
		END
		ELSE
		BEGIN
			IF @inclspacerpt IS NULL AND @freespacewarnprcnt IS NOT NULL
			BEGIN
				EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @FreeSpaceWarningPercent = @freespacewarnprcnt
			END
			ELSE --@inclspacerpt IS NULL AND @freespacewarnprcnt IS NULL
			BEGIN
				EXECUTE FDDBA.dbo.pStartUpValidation @HTML output
			END
		END
	END

	IF @dbmail_attachment IS NOT NULL
	BEGIN
		EXEC @output = msdb.dbo.sp_send_dbmail
			@profile_name =  @dbmail_profile,
			@recipients = @dbmail_recipients,
			@subject=@sub,
			@body =@HTML,
			@body_format ='HTML',
			@file_attachments = @dbmail_attachment

		IF @output > 0
		BEGIN
			EXEC @output = msdb.dbo.sp_send_dbmail
				@profile_name =  @dbmail_profile,
				@recipients =@dbmail_recipients,
				@subject=@sub,
				@body =@HTML,
				@body_format ='HTML'

			IF @output > 0
			BEGIN
				RAISERROR('config_fddba or dbmail not configured correctly',16,1) with LOG
			END
		END
	END
	ELSE
	BEGIN
		EXEC @output = msdb.dbo.sp_send_dbmail
			@profile_name =  @dbmail_profile,
			@recipients = @dbmail_recipients,
			@subject=@sub,
			@body =@HTML,
			@body_format ='HTML'

		IF @output > 0
		BEGIN
			RAISERROR('config_fddba or dbmail not configured correctly',16,2) with LOG
		END
	END
END
*/
GO

IF EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pStartUpCheck2]') AND [type] in (N'P', N'PC'))
BEGIN
	RAISERROR ('DISABLING STARTUP PROCEDURE master.dbo.pStartUpCheck2',10,1) WITH NOWAIT;
	EXECUTE sp_procoption N'[dbo].[pStartUpCheck2]', 'startup', '0'
END
GO


/*
ALTER PROCEDURE  [dbo].[pStartUpCheck3]
(
	@debug bit = 0,
	@recip_override varchar(100) = NULL
)
AS
BEGIN
	SET NOCOUNT ON
	IF @debug = 0
	BEGIN
		WAITFOR DELAY '00:05:00'
	END

	DECLARE @HTML				VARCHAR(max)
	DECLARE @sub				NVARCHAR(255)
	DECLARE @output				int
	DECLARE @dbmail_profile		sysname
	DECLARE @dbmail_recipients	varchar(max)
	DECLARE @dbmail_attachment	nvarchar(max)
	DECLARE @inclspacerpt	bit
	DECLARE @freespacewarnprcnt	tinyint

	SELECT TOP 1 @dbmail_profile = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'profile_name' and [domain] = 'fddba\pStartUpCheck'
	SELECT TOP 1 @dbmail_recipients = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'recipients' and [domain] = 'fddba\pStartUpCheck'
	SELECT TOP 1 @dbmail_attachment = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'file_attachments' and [domain] = 'fddba\pStartUpCheck'
	SELECT TOP 1 @inclspacerpt = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'IncludeSpaceReport' and [domain] = 'fddba\pStartUpCheck'
	SELECT TOP 1 @freespacewarnprcnt = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'FreeSpaceWarningPercent' and [domain] = 'fddba\pStartUpCheck'

	--check dbmail profile name
	IF @dbmail_profile IS NULL
		OR NOT EXISTS (SELECT 1 FROM msdb.dbo.sysmail_profile WHERE [name] = @dbmail_profile)
	BEGIN
		--find public profile
		SELECT TOP 1 @dbmail_profile = p.[name] 
			FROM msdb.dbo.sysmail_profile p
				INNER JOIN msdb.dbo.sysmail_principalprofile pp
				ON p.profile_id = pp.profile_id
	END

	--check dbmail recipients
	IF @dbmail_recipients IS NULL
	BEGIN
		RAISERROR(''pStartUpCheck3 has a NULL value for @dbmail_recipients, using the default value.'',15,1) WITH LOG;
		SET @dbmail_recipients = 'support@fortifieddata.com'
	END

	IF @recip_override IS NOT NULL
	BEGIN
		SET @dbmail_recipients = @recip_override
	END

	SET @sub = N'Validation Results for Server ' + @@servername
	
	IF @inclspacerpt IS NOT NULL AND @freespacewarnprcnt IS NOT NULL
	BEGIN
		EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @IncludeSpaceReport = @inclspacerpt, @FreeSpaceWarningPercent = @freespacewarnprcnt
	END
	ELSE
	BEGIN
		IF @inclspacerpt IS NOT NULL AND @freespacewarnprcnt IS NULL
		BEGIN
			EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @IncludeSpaceReport = @inclspacerpt
		END
		ELSE
		BEGIN
			IF @inclspacerpt IS NULL AND @freespacewarnprcnt IS NOT NULL
			BEGIN
				EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @FreeSpaceWarningPercent = @freespacewarnprcnt
			END
			ELSE --@inclspacerpt IS NULL AND @freespacewarnprcnt IS NULL
			BEGIN
				EXECUTE FDDBA.dbo.pStartUpValidation @HTML output
			END
		END
	END

	IF @dbmail_attachment IS NOT NULL
	BEGIN
		EXEC @output = msdb.dbo.sp_send_dbmail
			@profile_name =  @dbmail_profile,
			@recipients = @dbmail_recipients,
			@subject=@sub,
			@body =@HTML,
			@body_format ='HTML',
			@file_attachments = @dbmail_attachment

		IF @output > 0
		BEGIN
			EXEC @output = msdb.dbo.sp_send_dbmail
				@profile_name =  @dbmail_profile,
				@recipients =@dbmail_recipients,
				@subject=@sub,
				@body =@HTML,
				@body_format ='HTML'

			IF @output > 0
			BEGIN
				RAISERROR('config_fddba2 or dbmail not configured correctly',16,1) with LOG
			END
		END
	END
	ELSE
	BEGIN
		EXEC @output = msdb.dbo.sp_send_dbmail
			@profile_name =  @dbmail_profile,
			@recipients = @dbmail_recipients,
			@subject=@sub,
			@body =@HTML,
			@body_format ='HTML'

		IF @output > 0
		BEGIN
			RAISERROR('config_fddba2 or dbmail not configured correctly',16,2) with LOG
		END
	END
END
*/

IF EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pStartUpCheck3]') AND [type] in (N'P', N'PC'))
BEGIN
	RAISERROR ('DROPPING STARTUP PROCEDURE master.dbo.pStartUpCheck3',10,1) WITH NOWAIT;
	DROP PROCEDURE [dbo].[pStartUpCheck3]
END
GO


RAISERROR ('	CREATING OR ALTERING PROCEDURE dbo.pStartUpCheck4',10,1) WITH NOWAIT;
GO
IF EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pStatUpCheck]') AND [type] in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[pStatUpCheck]
GO
IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pStartUpCheck4]') AND [type] in (N'P', N'PC'))
BEGIN
	EXEC dbo.sp_executesql @statement = N'
		CREATE PROCEDURE [dbo].[pStartUpCheck4]		
		AS
		SET NOCOUNT ON
		SELECT GETDATE()	
		'

	DECLARE @sql		NVARCHAR(max)

	EXECUTE sp_procoption N'[dbo].[pStartUpCheck4]', 'startup', '1'
END
GO

/*********************************************************************************************************************
*
*	[dbo].[pStartUpCheck4]
*
*	Written By:	Keith Buck
*	Purpose: 	Perform service restart checks and send HTML email with results to hopefully allow ability to review a
*				SQL Server outage without having to connect to client environment
*
*	Inputs:	
*		@debug : OPTIONAL - whether wait 5 min delay before processing. This is designed to speed up testing.
*		@recip_override : OPTIONAL - used in conjunction with @debug so that testing does not raise a false positive. When
*			using this parameter send your personal email.
*
*	Notes:	
*	1. Actual checks are performed in pStartupValidation
*	2. This is a startup stored procedure that waits 5 minutes to report results
*	3. The values used for parameters have been abstracted into table config_fddba2 table
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	?					Keith Buck				Created by FORTIFIED DATA SERVICES
*	2017-04-07			Keith Buck				Added call to pStartupValidation
*	2017-04-19			Keith Buck				Corrected mispelled name
*	2017-09-29			Keith Buck				Added parameters for Disk space testing to call to pStartupValidation
*	2017-11-29			Mike Zawadzki			Removed hard coded values and instead use values from config_fddba table
*	2017-11-30			Mike Zawadzki			Changed to use values from config_fddba2 table
*	2017-12-16			Mike Zawadzki			Changed comments about error conditions
*	2018-03-20			Mike Zawadzki			Change values from config_fddba2 table and added check for @@SERVERNAME not
*													matching hostname
*	
*  For more scripts and sample code, check out 
*    http://www.FORTIFIEDDB.com
*
*  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
*  PARTICULAR PURPOSE.	
*
*********************************************************************************************************************/
ALTER PROCEDURE  [dbo].[pStartUpCheck4]
(
	@debug bit = 0,
	@recip_override varchar(100) = NULL
)
AS
BEGIN
	SET NOCOUNT ON
	IF @debug = 0
	BEGIN
		WAITFOR DELAY '00:05:00'
	END

	DECLARE @HTML				VARCHAR(max)
	DECLARE @sub				NVARCHAR(255)
	DECLARE @output				int
	DECLARE @dbmail_profile		sysname
	DECLARE @dbmail_recipients	varchar(max)
	DECLARE @dbmail_attachment	nvarchar(max)
	DECLARE @parameters			varchar(3950)
	DECLARE @name				varchar(3950)					
	DECLARE @value				varchar(3950)
	DECLARE @inclspacerpt	bit
	DECLARE @freespacewarnprcnt	tinyint
	DECLARE @hostname			NVARCHAR(256)
	DECLARE @fIsSFCI			bit
	DECLARE @sqlservername		NVARCHAR(256)

	SELECT TOP 1 @parameters = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'parameters' and [domain] = 'fddba\dbmail'

	DECLARE dbmail_param_cur CURSOR FOR
		SELECT a, b FROM FDDBA.dbo.fSplit2columns(@parameters, '=', ',')
	OPEN dbmail_param_cur
	FETCH NEXT FROM dbmail_param_cur INTO @name, @value
	WHILE @@FETCH_STATUS != -1
	BEGIN
		IF @name = 'profile_name'
			SET @dbmail_profile = @value

		IF @name = 'recipients_normal'
			SET @dbmail_recipients = @value

		IF @name = 'fd_file_attachment'
			SET @dbmail_attachment = @value

		FETCH NEXT FROM dbmail_param_cur INTO @name, @value
	END
	DEALLOCATE dbmail_param_cur

	IF @debug=1
	BEGIN
		PRINT '@dbmail_profile=' + ISNULL(@dbmail_profile,'null')
		PRINT '@dbmail_recipients=' + ISNULL(@dbmail_recipients,'null')
		PRINT '@dbmail_attachment=' + ISNULL(@dbmail_attachment,'null')
	END

	SELECT TOP 1 @parameters = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'parameters' and [domain] = 'fddba\pStartUpCheck4'

	DECLARE startupcheck_param_cur CURSOR FOR
		SELECT a, b FROM FDDBA.dbo.fSplit2columns(@parameters, '=', ',')
	OPEN startupcheck_param_cur
	FETCH NEXT FROM startupcheck_param_cur INTO @name, @value
	WHILE @@FETCH_STATUS != -1
	BEGIN
		IF @name = 'IncludeSpaceReport'
			SET @inclspacerpt = @value

		IF @name = 'FreeSpaceWarningPercent'
			SET @freespacewarnprcnt = @value

		FETCH NEXT FROM startupcheck_param_cur INTO @name, @value
	END
	DEALLOCATE startupcheck_param_cur

	IF @debug=1
	BEGIN
		PRINT '@inclspacerpt=' + ISNULL(CONVERT(varchar(4),@inclspacerpt),'null')
		PRINT '@freespacewarnprcnt=' + ISNULL(CONVERT(varchar(5),@freespacewarnprcnt),'null')
	END

	--check dbmail profile name
	IF @dbmail_profile IS NULL
		OR NOT EXISTS (SELECT 1 FROM msdb.dbo.sysmail_profile WHERE [name] = @dbmail_profile)
	BEGIN
		--find public profile
		SELECT TOP 1 @dbmail_profile = p.[name] 
			FROM msdb.dbo.sysmail_profile p
				INNER JOIN msdb.dbo.sysmail_principalprofile pp
				ON p.profile_id = pp.profile_id
	END

	--check dbmail recipients
	IF @dbmail_recipients IS NULL
	BEGIN
		SET @dbmail_recipients = 'support@fortifieddata.com'
		IF @debug = 1
			PRINT 'OVERRIDE 1:@dbmail_recipients=' + ISNULL(@dbmail_recipients,'null')
	END

	IF @recip_override IS NOT NULL
	BEGIN
		SET @dbmail_recipients = @recip_override
		IF @debug = 1
			PRINT 'OVERRIDE 2:@dbmail_recipients=' + ISNULL(@dbmail_recipients,'null')
	END

	SET @hostname = CONVERT(NVARCHAR(256),SERVERPROPERTY('ComputerNamePhysicalNetBIOS'))

	IF CHARINDEX('\',@@SERVERNAME) > 0
	BEGIN
		SET @sqlservername = SUBSTRING(@@SERVERNAME, 1, CHARINDEX('\',@@SERVERNAME) - 1)
	END
	ELSE
	BEGIN
		SET @sqlservername = @@SERVERNAME
	END

	SET @fIsSFCI = CONVERT(bit,SERVERPROPERTY('IsClustered'))

	IF @hostname IS NOT NULL AND @fIsSFCI IS NOT NULL
	BEGIN
		IF @fIsSFCI = 1
		BEGIN
			SET @sub = N'Validation Results for Server [' + ISNULL(@@SERVERNAME,'(null)') + '] running on cluster node [' + @hostname + ']'
		END
		ELSE
		BEGIN
			IF @hostname = @sqlservername
			BEGIN
				SET @sub = N'Validation Results for Server [' + @@SERVERNAME + ']'
			END
			ELSE
			BEGIN
				SET @sub = N'Validation Results for Server [' + ISNULL(@@SERVERNAME,'(null)') + '] - Warning hostname [' + @hostname + ']'
			END
		END
	END
	ELSE
	BEGIN
		SET @sub = N'Validation Results for Server [' + ISNULL(@@SERVERNAME,'(null)') + '] - Warning name could not be verified'
	END

	IF @inclspacerpt IS NOT NULL AND @freespacewarnprcnt IS NOT NULL
	BEGIN
		EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @IncludeSpaceReport = @inclspacerpt, @FreeSpaceWarningPercent = @freespacewarnprcnt
	END
	ELSE
	BEGIN
		IF @inclspacerpt IS NOT NULL AND @freespacewarnprcnt IS NULL
		BEGIN
			EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @IncludeSpaceReport = @inclspacerpt
		END
		ELSE
		BEGIN
			IF @inclspacerpt IS NULL AND @freespacewarnprcnt IS NOT NULL
			BEGIN
				EXECUTE FDDBA.dbo.pStartUpValidation @HTML output, @FreeSpaceWarningPercent = @freespacewarnprcnt
			END
			ELSE --@inclspacerpt IS NULL AND @freespacewarnprcnt IS NULL
			BEGIN
				EXECUTE FDDBA.dbo.pStartUpValidation @HTML output
			END
		END
	END

	IF @dbmail_attachment IS NOT NULL
	BEGIN
		EXEC @output = msdb.dbo.sp_send_dbmail
			@profile_name =  @dbmail_profile,
			@recipients = @dbmail_recipients,
			@subject=@sub,
			@body =@HTML,
			@body_format ='HTML',
			@file_attachments = @dbmail_attachment

		IF @output > 0
		BEGIN
			EXEC @output = msdb.dbo.sp_send_dbmail
				@profile_name =  @dbmail_profile,
				@recipients =@dbmail_recipients,
				@subject=@sub,
				@body =@HTML,
				@body_format ='HTML'

			IF @output > 0
			BEGIN
				RAISERROR('config_fddba2 or dbmail not configured correctly',16,1) with LOG
			END
		END
	END
	ELSE
	BEGIN
		EXEC @output = msdb.dbo.sp_send_dbmail
			@profile_name =  @dbmail_profile,
			@recipients = @dbmail_recipients,
			@subject=@sub,
			@body =@HTML,
			@body_format ='HTML'

		IF @output > 0
		BEGIN
			RAISERROR('config_fddba2 or dbmail not configured correctly',16,2) with LOG
		END
	END
END
GO


RAISERROR ('	CREATING OR ALTERING PROCEDURE dbo.usp_EnableTraceFlags3',10,1) WITH NOWAIT;
GO

IF EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[usp_EnableTraceFlags]') AND [type] in (N'P', N'PC'))
BEGIN
	RAISERROR ('DISABLING STARTUP PROCEDURE master.dbo.usp_EnableTraceFlags',10,1) WITH NOWAIT;
	EXECUTE sp_procoption N'[dbo].[usp_EnableTraceFlags]', 'startup', '0'
	--DO NOT DROP usp_EnableTraceFlags so that it can be used to change value in config_fddba2 for trace flags properly
	--it is possible that we could extract trace flags from prior sproc, but it would need to account for comments which is difficult so skipping for now
END
GO

IF EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[usp_EnableTraceFlags2]') AND [type] in (N'P', N'PC'))
BEGIN
	RAISERROR ('DROPPING STARTUP PROCEDURE master.dbo.usp_EnableTraceFlags2',10,1) WITH NOWAIT;
	EXECUTE sp_procoption N'[dbo].[usp_EnableTraceFlags2]', 'startup', '0'
	DROP PROCEDURE [dbo].[usp_EnableTraceFlags2]
END
GO

IF NOT EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[usp_EnableTraceFlags3]') AND [type] in (N'P', N'PC'))
BEGIN
	EXEC dbo.sp_executesql @statement = N'
		CREATE PROCEDURE [dbo].[usp_EnableTraceFlags3]		
		AS
		SET NOCOUNT ON
		SELECT GETDATE()	
		'

	EXECUTE sp_procoption N'[dbo].[usp_EnableTraceFlags3]', 'startup', '1'
END
GO

/*********************************************************************************************************************
*
*	[dbo].[usp_EnableTraceFlags3]
*
*	Purpose: Enables SQL Server trace flags on startup.
*
*	Inputs:	None
*
*	Notes:	
*		1. This procedure was migrated from Base Default SQL Configuration to allow for dynamic trace flags using config_fddba2 table
*		2. Using Startup Stored Procedure instead of Startup Parameters due to access denied on xp_instance_regwrite in some cases
*		3. This has been modified so that it will update trace flags to current setting (i.e. if trace flag 1204 was originally
*			enabled and then configuration was changed to be off then running this stored procedure would turn off trace flag 1204.0
*			This change made so that changing of trace flags can be easily be updated.
*		4. List of trace flags will be comma separated with a trailing comma (for ease of searching)
*
*	History:	
*	Last Update			Updated By				Notes
*	-------------------	--------------------	-----------------------
*	?					Ben DeBow				Created by FORTIFIED DATA SERVICES
*	2018-01-03			Mike Zawadzki			Changed to use values from config_fddba2 table
*	2018-01-05			Mike Zawadzki			Changed to use fSplit function instead of parsing
*
*  For more scripts and sample code, check out 
*    http://www.FORTIFIEDDB.com
*
*  THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF 
*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
*  PARTICULAR PURPOSE.	
*
*********************************************************************************************************************/
ALTER PROC [dbo].[usp_EnableTraceFlags3]
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @trace_flags_config varchar(3950)
	DECLARE @trace_flags_config_join varchar(3950)
	DECLARE @existing varchar(6)
	DECLARE @global tinyint
	DECLARE @suggested varchar(6)
	DECLARE @setting char(1)
	DECLARE @sql varchar(50)

	CREATE TABLE #trace_flags_existing
	(
		traceflag varchar(5) NOT NULL,
		[status] tinyint NOT NULL,
		[global] tinyint NOT NULL,
		[session] tinyint NOT NULL,
	)

	INSERT #trace_flags_existing EXEC ('dbcc tracestatus(-1)')

	SELECT TOP 1 @trace_flags_config = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'trace_flags' and [domain] = 'fddba\usp_EnableTraceFlags3'

	IF @trace_flags_config IS NOT NULL
	BEGIN
		SET @trace_flags_config_join = REPLACE(@trace_flags_config, '-', '')

		DECLARE tfconfig_cursor CURSOR FOR
			SELECT traceflag, [global], a, b
				FROM #trace_flags_existing e
					RIGHT OUTER JOIN FDDBA.dbo.fSplit2columns(@trace_flags_config_join, '=', ',') s
						ON e.traceflag = s.a

		OPEN tfconfig_cursor
		FETCH NEXT FROM tfconfig_cursor INTO @existing, @global, @suggested, @setting
		WHILE @@FETCH_STATUS != -1
		BEGIN
			SET @sql = NULL
			--disable trace flags running that are configured as disabled
			--@TODO=1 --check next condition
			IF @global = 1 AND @setting = 0
			--IF @global = 1 AND CHARINDEX('-' + @suggested + ',', @trace_flags_config) > 0
			BEGIN
				--@TODO=1 --remove next line
				PRINT @sql
				SET @sql = 'DBCC TRACEOFF(' + @suggested + ', -1)'
			END

			--enable trace flags not running that are configured as enabled
			IF @existing IS NULL AND @setting = 1
			BEGIN
				--@TODO=1 --remove next line
				PRINT @sql
				SET @sql = 'DBCC TRACEON(' + @suggested + ', -1)'
			END

			IF @sql IS NOT NULL
			BEGIN
				EXEC (@sql)
			END

			FETCH NEXT FROM tfconfig_cursor INTO @existing, @global, @suggested, @setting
		END
		DEALLOCATE tfconfig_cursor
	END
END
GO

RAISERROR ('	EXECUTING dbo.usp_EnableTraceFlags3',10,1) WITH NOWAIT;
EXEC [dbo].[usp_EnableTraceFlags3]
GO


